based on http://onebithq.com/pub/mplayer/dvdnav/20061104/mplayer-dvdnav-patch-with-MPlayer-1.0rc1.tar.gz
generated from vanilla MPlayer-1.0rc1 sources
while resolving conflicts of the patch with original mplayer sources.

after that I removed all parts which conflicted with geexbox mplayer
and moved them into 701_player-dvdnav-conflict.diff

diff -Nur MPlayer-1.0rc1.orig/cfg-common.h MPlayer-1.0rc1/cfg-common.h
--- MPlayer-1.0rc1.orig/cfg-common.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/cfg-common.h	2006-12-04 00:10:44.000000000 +0100
@@ -40,6 +40,24 @@
 #else
 	{"dvd", "MPlayer was compiled without libdvdread support.\n", CONF_TYPE_PRINT, CONF_NOCFG, 0, 0, NULL},
 #endif
+#ifdef USE_MPDVDNAV
+	{"mlang", &dvdmenu_lang, CONF_TYPE_STRING, 0, 0, 0, NULL},
+	{"dvdnav-menutype", &dvdnav_menutype, CONF_TYPE_INT, CONF_RANGE|CONF_GLOBAL, 0, 2, NULL},
+	{"dvdnav-color-spu", &dvdnav_color_spu, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-nocolor-spu", &dvdnav_color_spu, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+	{"dvdnav-force-menu", &dvdnav_force_menu, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-noforce-menu", &dvdnav_force_menu, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+	{"dvdnav-still-repeat", &dvdnav_still_repeat, CONF_TYPE_INT, CONF_RANGE|CONF_GLOBAL, 0, 10, NULL},
+//	{"dvdnav-skipintro", &dvdnav_skipintro, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+//	{"dvdnav-noskipintro", &dvdnav_skipintro, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+#ifdef USE_MPDVDNAV_TRACE
+	{"dvdnav-trace", &dvdnav_trace, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"dvdnav-notrace", &dvdnav_trace, CONF_TYPE_FLAG, 0, 1, 0, NULL},
+#else
+	{"dvdnav-trace", "MPlayer was compiled without dvdnav trace support.\n", CONF_TYPE_PRINT, CONF_NOCFG, 0, 0, NULL},
+	{"dvdnav-notrace", "MPlayer was compiled without dvdnav trace support.\n", CONF_TYPE_PRINT, CONF_NOCFG, 0, 0, NULL},
+#endif
+#endif
 	{"alang", &audio_lang, CONF_TYPE_STRING, 0, 0, 0, NULL},
 	{"slang", &dvdsub_lang, CONF_TYPE_STRING, 0, 0, 0, NULL},
 
diff -Nur MPlayer-1.0rc1.orig/configure MPlayer-1.0rc1/configure
--- MPlayer-1.0rc1.orig/configure	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/configure	2006-12-04 00:10:44.000000000 +0100
@@ -1635,6 +1635,7 @@
 _xmms=no
 _have_dvd=no
 _dvdnav=auto
+_dvdnav_trace=yes
 # theres's some known linking issues with darwin and dvdnav, so disable autodetection
 if darwin; then
   _dvdnav=no
@@ -1878,6 +1879,8 @@
   --disable-mpdvdkit)	_mpdvdkit=no	;;
   --enable-dvdnav)	_dvdnav=yes	;;
   --disable-dvdnav)	_dvdnav=no	;;
+  --enable-dvdnav-trace) 	_dvdnav_trace=yes	;;
+  --disable-dvdnav-trace)	_dvdnav_trace=no	;;
   --enable-xanim)	_xanim=yes	;;
   --disable-xanim)	_xanim=no	;;
   --enable-real)	_real=yes	;;
@@ -5145,37 +5148,59 @@
 echores "$_vcd"
 
 echocheck "DVD support (libdvdnav)"
+#if test "$_dvdnav" = auto ; then
+#  $_dvdnavconfig --version >> $TMPLOG 2>&1 || _dvdnav=no
+#fi
+#if test "$_dvdnav" = auto ; then
+#  cat > $TMPC <<EOF
+##include <dvdnav.h>
+#int main(void) { dvdnav_t *dvd=0; return 0; }
+#EOF
+#  _dvdnav=no
+#  _dvdnavdir=`$_dvdnavconfig --cflags`
+#  _dvdnavlibs=`$_dvdnavconfig --libs`
+#  _dvdnavvsn=`$_dvdnavconfig --version | sed "s/\.//g"`
+#  _used_css=
+#  _dvdnavmajor=`echo $_dvdnavvsn | cut -d. -f2`
+#  test "$_dvdnavmajor" -ge 2 -o "$_dvdnavvsn" -ge 0110 && \
+#       cc_check $_dvdnavdir $_dvdnavlibs $_used_css $_ld_dl $_ld_pthread && _dvdnav=yes
+#fi
+#if test "$_dvdnav" = yes ; then
+#  _largefiles=yes
+#  _def_dvdnav='#define USE_DVDNAV 1'
+#  _ld_dvdnav=`$_dvdnavconfig --libs`
+#  _dvdnav_version=`$_dvdnavconfig --version | sed "s/\.//g"`
+#  _def_dvdnav_version="#define DVDNAVVERSION $_dvdnav_version"
+#  _inc_extra="$_inc_extra `$_dvdnavconfig --cflags`"
+#  _inputmodules="dvdnav $_inputmodules"
+#  
+#  #disable mpdvdkit and dvdread checks: dvdread will be enabled using dvdnav's version of dvdread
+#  _mpdvdkit=no
+#  _dvdread=yes
+#else
+#  _def_dvdnav='#undef USE_DVDNAV'
+#  _noinputmodules="dvdnav $_noinputmodules"
+#fi
+#echores "$_dvdnav"
+echocheck "DVDNAV support"
 if test "$_dvdnav" = auto ; then
-  $_dvdnavconfig --version >> $TMPLOG 2>&1 || _dvdnav=no
-fi
-if test "$_dvdnav" = auto ; then
-  cat > $TMPC <<EOF
-#include <dvdnav.h>
-int main(void) { dvdnav_t *dvd=0; return 0; }
-EOF
-  _dvdnav=no
-  _dvdnavdir=`$_dvdnavconfig --cflags`
-  _dvdnavlibs=`$_dvdnavconfig --libs`
-  _dvdnavvsn=`$_dvdnavconfig --version | sed "s/\.//g"`
-  _used_css=
-  _dvdnavmajor=`echo $_dvdnavvsn | cut -d. -f2`
-  test "$_dvdnavmajor" -ge 2 -o "$_dvdnavvsn" -ge 0110 && \
-       cc_check $_dvdnavdir $_dvdnavlibs $_used_css $_ld_dl $_ld_pthread && _dvdnav=yes
+_dvdnav="yes"
 fi
 if test "$_dvdnav" = yes ; then
   _largefiles=yes
   _def_dvdnav='#define USE_DVDNAV 1'
-  _ld_dvdnav=`$_dvdnavconfig --libs`
-  _dvdnav_version=`$_dvdnavconfig --version | sed "s/\.//g"`
-  _def_dvdnav_version="#define DVDNAVVERSION $_dvdnav_version"
-  _inc_extra="$_inc_extra `$_dvdnavconfig --cflags`"
+  _def_mpdvdnav='#define USE_MPDVDNAV 1'
+if test "$_dvdnav_trace" = yes ; then
+  _def_mpdvdnav_trace='#define USE_MPDVDNAV_TRACE 1'
+  _inputmodules="dvdnav(dvdnav-trace) $_inputmodules"
+else
   _inputmodules="dvdnav $_inputmodules"
-  
-  #disable mpdvdkit and dvdread checks: dvdread will be enabled using dvdnav's version of dvdread
-  _mpdvdkit=no
-  _dvdread=yes
+fi
+  _dvdnav_version='0110'
+  _def_dvdnav_version="#define DVDNAVVERSION $_dvdnav_version"
+  _def_dvdnav_sversion="#define DVDNAVSVERSION \"0.1.10\""
+  echores "yes"
 else
-  _def_dvdnav='#undef USE_DVDNAV'
   _noinputmodules="dvdnav $_noinputmodules"
 fi
 echores "$_dvdnav"
@@ -7567,6 +7592,7 @@
 DVDREAD_LIB = $_ld_dvdread
 DVDKIT2 = $_mpdvdkit
 DVDNAV = $_dvdnav
+LIBMPDVDNAV = $_dvdnav
 DVDNAV_LIB = $_ld_dvdnav
 WIN32DLL = $_win32
 W32_DEP = $_dep_win32
@@ -7975,6 +8001,9 @@
 /* DVD navigation support using libdvdnav */
 $_def_dvdnav
 $_def_dvdnav_version
+$_def_dvdnav_sversion
+$_def_mpdvdnav
+$_def_mpdvdnav_trace
 
 /* Define this to enable MPEG 1/2 image postprocessing (requires a FAST CPU!) */
 #define MPEG12_POSTPROC 1
diff -Nur MPlayer-1.0rc1.orig/help/help_mp-en.h MPlayer-1.0rc1/help/help_mp-en.h
--- MPlayer-1.0rc1.orig/help/help_mp-en.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/help/help_mp-en.h	2006-12-04 00:10:44.000000000 +0100
@@ -24,6 +24,10 @@
 #ifdef USE_DVDREAD
 " dvd://<titleno>  play DVD title from device instead of plain file\n"
 " -alang/-slang    select DVD audio/subtitle language (by 2-char country code)\n"
+#ifdef USE_DVDNAV
+" -mlang           select DVD menu language (by 2-char country code)\n"
+" -dvdnav-menutype set DVD menu button type: 0: spu (default), 1: simple box, 2: spu & simple box\n"
+#endif
 #endif
 " -ss <position>   seek to given (seconds or hh:mm:ss) position\n"
 " -nosound         do not play sound\n"
@@ -1864,3 +1868,159 @@
 #define MSGTR_RADIO_DriverV4L2 "[radio] Using V4Lv2 radio interface.\n"
 #define MSGTR_RADIO_DriverV4L "[radio] Using V4Lv1 radio interface.\n"
 
+// mpdvdnav - gui
+#define MSGTR_MENU_DVDNAV "DVDNAV"
+#define MSGTR_MENU_PlayDVDNAV "Play DVDNAV..."
+#define MSGTR_MENU_MenuDVDNAV "Main DVD Menu"
+
+// mpdvdnav
+
+#define MSGTR_MPDVDNAV_StopEvent "DVDNAV Event: STOP!\n"
+#define MSGTR_MPDVDNAV_WaitEvent "DVDNAV Event: Wait\n"
+#define MSGTR_MPDVDNAV_StillFrameEvent "DVDNAV Event: Still frame\n"
+#define MSGTR_MPDVDNAV_VtsChangeEvent "DVDNAV Event: Vts change\n"
+#define MSGTR_MPDVDNAV_CellChangeEvent "DVDNAV Event: Cell change\n"
+#define MSGTR_MPDVDNAV_SpuClutChangeEvent "DVDNAV Event: Spu clut change\n"
+#define MSGTR_MPDVDNAV_HighlightEvent "DVDNAV Event: Highlight\n"
+#define MSGTR_MPDVDNAV_NavPacketEvent "DVDNAV Event: Nav packet\n"
+
+#define MSGTR_MPDVDNAV_StillFrameDecodeError "Still frame decode error\n"
+#define MSGTR_MPDVDNAV_StillSkip "Dvdnav still skip\n"
+#define MSGTR_MPDVDNAV_CellN "cellN      : %i\n"
+#define MSGTR_MPDVDNAV_PgN "pgN        : %d\n"
+#define MSGTR_MPDVDNAV_CellLength "cell_length: %d\n"
+#define MSGTR_MPDVDNAV_PgLength "pg_lenght  : %d\n"
+#define MSGTR_MPDVDNAV_PgcLength "pgc_lenght : %d\n"
+#define MSGTR_MPDVDNAV_CellStart "cell_start : %d\n"
+#define MSGTR_MPDVDNAV_PgStart "pg_start   : %d\n"
+#define MSGTR_MPDVDNAV_Title "DVDNAV new title: %i\n"
+#define MSGTR_MPDVDNAV_Part  "DVDNAV new part: %i\n"
+#define MSGTR_MPDVDNAV_Aspect43 "Aspect 4/3\n"
+#define MSGTR_MPDVDNAV_Aspect169 "Aspect 16/9\n"
+#define MSGTR_MPDVDNAV_AspectOther "Aspect ? (%i)\n"
+#define MSGTR_MPDVDNAV_AudioID "DVDNAV new audio ID: %i\n"
+#define MSGTR_MPDVDNAV_DvdSubID "DVDNAV new dvdsub ID: %i\n"
+#define MSGTR_MPDVDNAV_Len "DVDNAV len: %i\n"
+#define MSGTR_MPDVDNAV_ReadInStillActive "%s: got a stream_read while I should be asleep!\n"
+#define MSGTR_MPDVDNAV_ErrorGetNextBlock "Error getting next block from DVD (%s)\n"
+#define MSGTR_MPDVDNAV_ErrorStreamRead "DVDNAV stream read error: %s\n"
+#define MSGTR_MPDVDNAV_ErrorSeek "DVDNAV stream seek error: %s (%llx)\n"
+#define MSGTR_MPDVDNAV_ErrorNav "DVDNAV navigation error: %s\n"
+#define MSGTR_MPDVDNAV_NoColorSpu "Color SPU does not support this vo!\n"
+
+// ----------------------- libmpdvdnav error -----------------------
+// libmpdvdnav - dvdnav.c
+#define MSGTR_LIBMPDVDNAV_Err_ErrorInitialisingTheDVDVM "Error initialising the DVD VM."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorStartingTheVM "Error starting the VM / opening the DVD device."
+#define MSGTR_LIBMPDVDNAV_Err_PassedANullPointer "Passed a NULL pointer."
+#define MSGTR_LIBMPDVDNAV_Err_VirtualDVDMachineNotStarted "Virtual DVD machine not started."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorRestartingTheVM "Error restarting the VM."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket "Error reading NAV packet."
+#define MSGTR_LIBMPDVDNAV_Err_ExpectedNAVPacketButNoneFound "Expected NAV packet but none found."
+#define MSGTR_LIBMPDVDNAV_Err_UnknownDomainWhenChangingVTS "Unknown domain when changing VTS."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingNAVPacket "Error reading NAV packet."
+#define MSGTR_LIBMPDVDNAV_Err_AttemptingToReadWithoutOpeningFile "Attempting to read without opening file."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorReadingFromDVD "Error reading from DVD."
+#define MSGTR_LIBMPDVDNAV_Err_NoCurrentPGC "No current PGC."
+#define MSGTR_LIBMPDVDNAV_Err_PassedAnInvalidAngleNumber "Passed an invalid angle number."
+// libmpdvdnav - searching.c
+#define MSGTR_LIBMPDVDNAV_Err_CannotSeekInAStillFrame "Cannot seek in a still frame."
+#define MSGTR_LIBMPDVDNAV_Err_RequestToSeekBehindEnd "Request to seek behind end."
+#define MSGTR_LIBMPDVDNAV_Err_RequestToSeekBeforeStart "Request to seek before start."
+#define MSGTR_LIBMPDVDNAV_Err_IllegalSeekMode "Illegal seek mode."
+#define MSGTR_LIBMPDVDNAV_Err_ErrorWhenSeeking "Error when seeking."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToPreviousChapterFailed "Skip to previous chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToTopChapterFailed "Skip to top chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_SkipToNextChapterFailed "Skip to next chapter failed."
+#define MSGTR_LIBMPDVDNAV_Err_NoSuchMenuOrMenuNotReachable "No such menu or menu not reachable."
+#define MSGTR_LIBMPDVDNAV_Err_NewPositionNotYetDetermined "New position not yet determined."
+// libmpdvdnav - highlight.c
+#define MSGTR_LIBMPDVDNAV_Err_BadVMState "Bad VM state."
+// libmpdvdnav - settings.c
+#define MSGTR_LIBMPDVDNAV_Err_PassedIllegalLanguageCode "Passed illegal language code."
+
+// ----------------------- libmpdvdnav -----------------------------
+// libmpdvdnav - dvdnav.c
+#define MSGTR_LIBMPDVDNAV_Using "libdvdnav: Using dvdnav version %s from http://dvd.sf.net\n"
+#define MSGTR_LIBMPDVDNAV_Demux_error "libdvdnav: demux error! %02x %02x %02x (should be 0x000001) \n"
+#define MSGTR_LIBMPDVDNAV_ErrorOpeningVtsDomain "Error opening vtsN=%i, domain=%i.\n"
+// libmpdvdnav - highlight.c
+#define MSGTR_LIBMPDVDNAV_NoCurrentPGC "No current PGC.\n"
+#define MSGTR_LIBMPDVDNAV_NotInAMenu "Not in a menu.\n"
+#define MSGTR_LIBMPDVDNAV_ThisNAVHasAlreadyBeenLeft "This NAV has already been left.\n"
+#define MSGTR_LIBMPDVDNAV_ButtonDoesNotExist "Button does not exist.\n"
+#define MSGTR_LIBMPDVDNAV_TitleOutOfRange "Title out of range.\n"
+#define MSGTR_LIBMPDVDNAV_PartOutOfRange "Part out of range.\n"
+#define MSGTR_LIBMPDVDNAV_NotImplementedYet "Not implemented yet.\n"
+#define MSGTR_LIBMPDVDNAV_NotInATitleOrMenu "Not in a title or menu.\n"
+// libmpdvdnav - navigation.c
+#define MSGTR_LIBMPDVDNAV_PassedANullPointer "Passed a NULL pointer.\n"
+#define MSGTR_LIBMPDVDNAV_VirtualDVDMachineNotStarted "Virtual DVD machine not started.\n"
+#define MSGTR_LIBMPDVDNAV_BadVMState "Bad VM state.\n"
+#define MSGTR_LIBMPDVDNAV_PassedATitleNumberOutOfRange "Passed a title number out of range.\n"
+// libmpdvdnav - read_cache.c
+#define MSGTR_LIBMPDVDNAV_PreCacheDVDReadReallocHappened "pre_cache DVD read realloc happened\n"
+#define MSGTR_LIBMPDVDNAV_PreCacheDVDReadMalloc "pre_cache DVD read malloc %d blocks\n"
+#define MSGTR_LIBMPDVDNAV_PreCachingWasImpossible "pre_caching was impossible, no cache chunk available\n"
+#define MSGTR_LIBMPDVDNAV_ReadCacheSectorInfo "libdvdnav: sector=%d, start_sector=%d, last_sector=%d\n"
+#define MSGTR_LIBMPDVDNAV_ReadCacheReadAheadSize "libdvdnav: read_ahead_size=%d, size=%d\n"
+#define MSGTR_LIBMPDVDNAV_CacheMissOnSector "cache miss on sector %d\n"
+// libmpdvdnav - remap.c
+#define MSGTR_LIBMPDVDNAV_UnableToFindMapFile "libdvdnav: Unable to find map file '%s'\n"
+#define MSGTR_LIBMPDVDNAV_IgnoringMapLine "libdvdnav: Ignoring map line (%d): %s\n"
+#define MSGTR_LIBMPDVDNAV_RemapInfo "libdvdnav: %s: domain %d, title %d, program %d, start %lx, next %lx\n"
+#define MSGTR_LIBMPDVDNAV_RedirectedTo "libdvdnav: Redirected to %lx\n"
+// libmpdvdnav - searching.c
+#define MSGTR_LIBMPDVDNAV_UnknownDomainForSeeking "libdvdnav: Error: Unknown domain for seeking.\n"
+#define MSGTR_LIBMPDVDNAV_CouldNotLocateBlock "libdvdnav: Could not locate block\n"
+#define MSGTR_LIBMPDVDNAV_AdmapNotLocated "libdvdnav: admap not located\n"
+#define MSGTR_LIBMPDVDNAV_ErrorWhenSeeking "libdvdnav: Error when seeking\n"
+#define MSGTR_LIBMPDVDNAV_FIXMEImplementSeekingToLocation "libdvdnav: FIXME: Implement seeking to location %u\n"
+#define MSGTR_LIBMPDVDNAV_PreviousChapterFailed "libdvdnav: previous chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_TopChapterFailed "libdvdnav: top chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_NextChapterFailed "libdvdnav: next chapter failed.\n"
+#define MSGTR_LIBMPDVDNAV_SearchChapterFailed "libdvdnav: search chapter failed.\n"
+// libmpdvdnav - decoder.c
+#define MSGTR_LIBMPDVDNAV_BadCallToVMGetbits "libdvdnav: Bad call to vm_getbits. Parameter out of range\n"
+#define MSGTR_LIBMPDVDNAV_SuspectedRCERegionProtection "libdvdnav: Suspected RCE Region Protection!!!\n"
+#define MSGTR_LIBMPDVDNAV_EvalCompareInvalidComparisonCode "libdvdnav: eval_compare: Invalid comparison code\n"
+#define MSGTR_LIBMPDVDNAV_UnknownInstrution "libdvdnav: Unknown Instruction!\n"
+#define MSGTR_LIBMPDVDNAV_WarningUnknownComman "libdvdnav: WARNING: Unknown Command=%x\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCWarningUnknownBits "libdvdnav: decoder.c: [WARNING, unknown bits:"
+#define MSGTR_LIBMPDVDNAV_DecoderCButton "libdvdnav: %s (button %d)\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCButton2 "libdvdnav: %s %d (button %d)\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCVtsTitleMenu "libdvdnav: %s vts %d title %d menu %d\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCResumeCell "libdvdnav: %s resume cell %d\n"
+#define MSGTR_LIBMPDVDNAV_DecoderCResumeCell2 "libdvdnav: %s %d resume cell %d\n"
+// libmpdvdnav - vm.c
+#define MSGTR_LIBMPDVDNAV_VmCDVDTitle "libdvdnav: DVD Title: "
+#define MSGTR_LIBMPDVDNAV_VmCDVDSerialNumber "\nlibdvdnav: DVD Serial Number: "
+#define MSGTR_LIBMPDVDNAV_VmCDVDTitleAlternative "\nlibdvdnav: DVD Title (Alternative): "
+#define MSGTR_LIBMPDVDNAV_VmCCantReadNameBlock "libdvdnav: Can't read name block. Probably not a DVD-ROM device.\n"
+#define MSGTR_LIBMPDVDNAV_VmCCantSeekToBlock "libdvdnav: Can't seek to block %u\n"
+#define MSGTR_LIBMPDVDNAV_VmCNameOpenFailed "NAME OPEN FAILED\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoOpenVTSIFailed "libdvdnav: ifoOpenVTSI failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadVTSPTTSRPTFailed "libdvdnav: ifoRead_VTS_PTT_SRPT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadPGCITFailed "libdvdnav: ifoRead_PGCIT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadPGCIUTFailed "libdvdnav: ifoRead_PGCI_UT failed - CRASHING!!!\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadVOBUADMAPVtsiFailed "libdvdnav: ifoRead_VOBU_ADMAP vtsi failed - CRASHING\n"
+#define MSGTR_LIBMPDVDNAV_VmCIfoReadTITLEVOBUADMAPVtsiFailed "libdvdnav: ifoRead_TITLE_VOBU_ADMAP vtsi failed - CRASHING\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmFaildToOpenReadTheDVD "libdvdnav: vm: faild to open/read the DVD\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmFaildToReadVIDEOTSIFO "libdvdnav: vm: faild to read VIDEO_TS.IFO\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadFPPGCFailed "libdvdnav: vm: ifoRead_FP_PGC failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadTTSRPTFailed "libdvdnav: vm: ifoRead_TT_SRPT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadPGCIUTFailed "libdvdnav: vm: ifoRead_PGCI_UT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadPRLMAITFailed "libdvdnav: vm: ifoRead_PTL_MAIT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadVTSATRTFailed "libdvdnav: vm: ifoRead_VTS_ATRT failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCVmIfoReadVOBUADMAPVgmiFailed "libdvdnav: vm: ifoRead_VOBU_ADMAP vgmi failed\n"
+#define MSGTR_LIBMPDVDNAV_VmCDVDDiskReportsItselfWithRegionMask "libdvdnav: DVD disk reports itself with Region mask 0x%08x. Regions:"
+#define MSGTR_LIBMPDVDNAV_VmCChapterNotFound "libdvdnav: chapter NOT FOUND!\n"
+#define MSGTR_LIBMPDVDNAV_VmCInvalidAngleBlock "libdvdnav: Invalid angle block\n"
+#define MSGTR_LIBMPDVDNAV_VmCInvalidBlockMode "libdvdnav: Invalid? Cell block_mode (%d), block_type (%d)\n"
+#define MSGTR_LIBMPDVDNAV_VmCCellIsInBlockButDidNotEnter "libdvdnav: Cell is in block but did not enter at first cell!\n"
+#define MSGTR_LIBMPDVDNAV_VmCTryingToResumeWithoutAnyResume "libdvdnav: trying to resume without any resume info set\n"
+#define MSGTR_LIBMPDVDNAV_VmCRandomOrShuffleTitlesAreNotHandledYet "libdvdnav: RANDOM or SHUFFLE titles are NOT handled yet.\n"
+#define MSGTR_LIBMPDVDNAV_VmCGetPGCNFailed "libdvdnav: get_PGCN failed. Was trying to find pgcN in domain %d\n"
+#define MSGTR_LIBMPDVDNAV_VmCPgciUtHandleIsNULL "libdvdnav: *** pgci_ut handle is NULL ***\n"
+#define MSGTR_LIBMPDVDNAV_VmCLanguageNotFound "libdvdnav: Language '%c%c' not found, using '%c%c' instead\n"
+#define MSGTR_LIBMPDVDNAV_VmCMenuLanguagesAvailable "libdvdnav: Menu Languages available: "
diff -Nur MPlayer-1.0rc1.orig/input/input.c MPlayer-1.0rc1/input/input.c
--- MPlayer-1.0rc1.orig/input/input.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/input/input.c	2006-12-04 00:10:44.000000000 +0100
@@ -177,6 +177,7 @@
   
   { MP_CMD_SEEK_CHAPTER, "seek_chapter", 1, { {MP_CMD_ARG_INT,{0}}, {MP_CMD_ARG_INT,{0}}, {-1,{0}} } },
   { MP_CMD_SET_MOUSE_POS, "set_mouse_pos", 2, { {MP_CMD_ARG_INT,{0}}, {MP_CMD_ARG_INT,{0}}, {-1,{0}} } },
+  { MP_CMD_SET_MOUSE_BUTTON, "set_mouse_button", 1, { {MP_CMD_ARG_INT,{0}}, {-1,{0}} } },
   
   { 0, NULL, 0, {} }
 };
diff -Nur MPlayer-1.0rc1.orig/input/input.h MPlayer-1.0rc1/input/input.h
--- MPlayer-1.0rc1.orig/input/input.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/input/input.h	2006-12-04 00:10:44.000000000 +0100
@@ -90,6 +90,7 @@
 #define MP_CMD_RADIO_SET_CHANNEL 88
 #define MP_CMD_RADIO_SET_FREQ 89
 #define MP_CMD_SET_MOUSE_POS 90
+#define MP_CMD_SET_MOUSE_BUTTON 95
 
 #define MP_CMD_SET_OPTION 91
 
diff -Nur MPlayer-1.0rc1.orig/libmenu/menu.c MPlayer-1.0rc1/libmenu/menu.c
--- MPlayer-1.0rc1.orig/libmenu/menu.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmenu/menu.c	2006-12-04 00:10:44.000000000 +0100
@@ -20,6 +20,7 @@
 #include "m_option.h"
 #include "m_struct.h"
 #include "menu.h"
+#include "libvo/video_out.h"
 
 #include "input/input.h"
 #include "input/joystick.h"
@@ -268,7 +269,7 @@
 
 ///////////////////////////// Helpers ////////////////////////////////////
 
-typedef void (*draw_alpha_f)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+typedef void (*draw_alpha_f)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
 
 inline static draw_alpha_f get_draw_alpha(uint32_t fmt) {
   switch(fmt) {
@@ -406,7 +407,7 @@
   while (*txt) {
     int c=get_next_char(&txt);
     if ((font=vo_font->font[c])>=0 && (x + vo_font->width[c] <= mpi->w) && (y + vo_font->pic_a[font]->h <= mpi->h))
-      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h,
+      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h,DEST_PLANES_Y,
 		 vo_font->pic_b[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->w,
@@ -576,7 +577,7 @@
       if(font >= 0) {
  	int cs = (vo_font->pic_a[font]->h - vo_font->height) / 2;
 	if ((sx + vo_font->width[c] < xmax)  &&  (sy + vo_font->height < ymax) )
-	  draw_alpha(vo_font->width[c], vo_font->height,
+	  draw_alpha(vo_font->width[c], vo_font->height, DEST_PLANES_Y,
 		     vo_font->pic_b[font]->bmp+vo_font->start[c] +
 		     cs * vo_font->pic_a[font]->w,
 		     vo_font->pic_a[font]->bmp+vo_font->start[c] +
@@ -684,7 +685,7 @@
     char pic[stride*h],pic_alpha[stride*h];
     memset(pic,g,stride*h);
     memset(pic_alpha,alpha,stride*h);
-    draw_alpha(w,h,pic,pic_alpha,stride,
+    draw_alpha(w,h,DEST_PLANES_Y,pic,pic_alpha,stride,
                mpi->planes[0] + y * mpi->stride[0] + x * (mpi->bpp>>3),
                mpi->stride[0]);
   }
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/Makefile MPlayer-1.0rc1/libmpcodecs/Makefile
--- MPlayer-1.0rc1.orig/libmpcodecs/Makefile	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/Makefile	2006-12-04 00:10:44.000000000 +0100
@@ -77,6 +77,7 @@
 
 VIDEO_SRCS=dec_video.c \
            vd.c \
+           vd_videostill.c \
            $(VIDEO_SRCS_NAT) \
            $(VIDEO_SRCS_LIB) \
 
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/vd.c MPlayer-1.0rc1/libmpcodecs/vd.c
--- MPlayer-1.0rc1.orig/libmpcodecs/vd.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/vd.c	2006-12-04 00:10:44.000000000 +0100
@@ -144,10 +144,8 @@
         mp_msg(MSGT_DECVIDEO,MSGL_WARN, MSGTR_CodecDidNotSet);
     /* XXX: HACK, if sh->disp_* aren't set,
      * but we have w and h, set them :: atmos */
-    if(!sh->disp_w && w)
-        sh->disp_w=w;
-    if(!sh->disp_h && h)
-        sh->disp_h=h;
+    if(w) sh->disp_w=w;
+    if(h) sh->disp_h=h;
 
     if(!sh->disp_w || !sh->disp_h)
 	return 0;
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/vd.h MPlayer-1.0rc1/libmpcodecs/vd.h
--- MPlayer-1.0rc1.orig/libmpcodecs/vd.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/vd.h	2006-12-04 00:10:44.000000000 +0100
@@ -25,6 +25,8 @@
 #define VDCTRL_GET_EQUALIZER 7 /* get color options (brightness,contrast etc) */
 #define VDCTRL_RESYNC_STREAM 8 /* seeking */
 #define VDCTRL_QUERY_UNSEEN_FRAMES 9 /* current decoder lag */
+#define VDCTRL_RESET	10	/* reset mpeg2 codec */
+#define VDCTRL_STORED_IMAGE 11	/* mpeg2 codec support stored image */
 
 // callbacks:
 int mpcodecs_config_vo(sh_video_t *sh, int w, int h, unsigned int preferred_outfmt);
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/vd_libmpeg2.c MPlayer-1.0rc1/libmpcodecs/vd_libmpeg2.c
--- MPlayer-1.0rc1.orig/libmpcodecs/vd_libmpeg2.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/vd_libmpeg2.c	2006-12-04 00:10:44.000000000 +0100
@@ -51,6 +51,11 @@
 	    (*((int*)arg)) == IMGFMT_422P)
 	    return CONTROL_TRUE;
 	return CONTROL_FALSE;
+    case VDCTRL_RESET:
+	mpeg2_reset(mpeg2dec,(*((int*)arg)));
+	return CONTROL_TRUE;
+    case VDCTRL_STORED_IMAGE:
+	return CONTROL_TRUE;
     }
     
     return CONTROL_UNKNOWN;
@@ -138,6 +143,9 @@
     mpeg2dec->decoder.convert_id=NULL;
     
     if(len<=0) return NULL; // skipped null frame
+#ifdef USE_DVDNAV
+    sh->enable_mpeg2_reset=0;
+#endif
     
     // append extra 'end of frame' code:
     ((char*)data+len)[0]=0;
@@ -174,16 +182,39 @@
 	    ph = info->sequence->display_height * info->sequence->pixel_height;
 	    if(ph) sh->aspect = (float) pw / (float) ph;
 	    // video parameters inited/changed, (re)init libvo:
+#ifdef USE_DVDNAV
+	    sh->enable_mpeg2_reset=1;
+#endif
 	    if (info->sequence->width >> 1 == info->sequence->chroma_width &&
 		info->sequence->height >> 1 == info->sequence->chroma_height) {
+#ifdef USE_DVDNAV
+//printf("lock: %i w:%i (%i) h: %i (%i) fmt: %i (%i) \n",sh->config_lock,sh->config_w,info->sequence->picture_width,
+//    sh->config_h,info->sequence->picture_height,sh->config_outfmt,IMGFMT_YV12);
+		if (sh->config_lock && sh->config_w==info->sequence->picture_width &&
+		    sh->config_h ==info->sequence->picture_height && sh->config_outfmt == IMGFMT_YV12) break;
+#endif
 		if(!mpcodecs_config_vo(sh,
 				       info->sequence->picture_width,
 				       info->sequence->picture_height, IMGFMT_YV12)) return 0;
+#ifdef USE_DVDNAV
+		if(sh->config_lock) {sh->config_w=info->sequence->picture_width;
+		    sh->config_h=info->sequence->picture_height; sh->config_outfmt=IMGFMT_YV12;}
+#endif
 	    } else if (info->sequence->width >> 1 == info->sequence->chroma_width &&
 		info->sequence->height == info->sequence->chroma_height) {
+#ifdef USE_DVDNAV
+//printf("lock: %i w:%i (%i) h: %i (%i) fmt: %i (%i) \n",sh->config_lock,sh->config_w,info->sequence->picture_width,
+//    sh->config_h,info->sequence->picture_height,sh->config_outfmt,IMGFMT_422P);
+		if (sh->config_lock && sh->config_w==info->sequence->picture_width &&
+		    sh->config_h ==info->sequence->picture_height && sh->config_outfmt == IMGFMT_422P) break;
+#endif
 		if(!mpcodecs_config_vo(sh,
 				       info->sequence->picture_width,
 				       info->sequence->picture_height, IMGFMT_422P)) return 0;
+#ifdef USE_DVDNAV
+		if(sh->config_lock) {sh->config_w=info->sequence->picture_width;
+		    sh->config_h=info->sequence->picture_height; sh->config_outfmt=IMGFMT_422P;}
+#endif
 	    } else return 0;
 	    break;
 	case STATE_PICTURE:
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/vf.c MPlayer-1.0rc1/libmpcodecs/vf.c
--- MPlayer-1.0rc1.orig/libmpcodecs/vf.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/vf.c	2006-12-04 00:10:44.000000000 +0100
@@ -322,12 +322,9 @@
     if(mpi->width!=w2 || mpi->height!=h){
 //	printf("vf.c: MPI parameters changed!  %dx%d -> %dx%d   \n", mpi->width,mpi->height,w2,h);
 	if(mpi->flags&MP_IMGFLAG_ALLOCATED){
-	    if(mpi->width<w2 || mpi->height<h){
 		// need to re-allocate buffer memory:
 		free(mpi->planes[0]);
 		mpi->flags&=~MP_IMGFLAG_ALLOCATED;
-		mp_msg(MSGT_VFILTER,MSGL_V,"vf.c: have to REALLOCATE buffer memory :(\n");
-	    }
 //	} else {
 	} {
 	    mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;
diff -Nur MPlayer-1.0rc1.orig/libmpcodecs/vf_expand.c MPlayer-1.0rc1/libmpcodecs/vf_expand.c
--- MPlayer-1.0rc1.orig/libmpcodecs/vf_expand.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpcodecs/vf_expand.c	2006-12-04 00:10:44.000000000 +0100
@@ -82,7 +82,7 @@
     // TODO  clear left and right side of the image if needed
 }
 
-static void draw_func(int x0,int y0, int w,int h,unsigned char* src, unsigned char *srca, int stride){
+static void draw_func(int x0,int y0, int w,int h,int dp,unsigned char* src, unsigned char *srca, int stride){
     unsigned char* dst;
     if(!vo_osd_changed_flag && vf->dmpi->planes[0]==vf->priv->fb_ptr){
 	// ok, enough to update the area inside the video, leave the black bands
@@ -110,19 +110,19 @@
     switch(vf->dmpi->imgfmt){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_I420:
@@ -131,13 +131,13 @@
     case IMGFMT_IF09:
     case IMGFMT_Y800:
     case IMGFMT_Y8:
-	vo_draw_alpha_yv12(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_yv12(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_YUY2:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_UYVY:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst+1,vf->dmpi->stride[0]);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst+1,vf->dmpi->stride[0]);
 	break;
     }
 }
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demux_avi.c MPlayer-1.0rc1/libmpdemux/demux_avi.c
--- MPlayer-1.0rc1.orig/libmpdemux/demux_avi.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demux_avi.c	2006-12-04 00:10:44.000000000 +0100
@@ -817,7 +817,7 @@
       stream_t* s;
       demuxer_t  *od;
       s = new_ds_stream(demuxer->audio);
-      od = new_demuxer(s,DEMUXER_TYPE_OGG,-1,-2,-2,NULL);
+      od = new_demuxer(s,DEMUXER_TYPE_OGG,-1,-2,-2,NULL,0);
       if(!demux_ogg_open(od)) {
         mp_msg( MSGT_DEMUXER,MSGL_ERR,MSGTR_ErrorOpeningOGGDemuxer);
         free_stream(s);
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demuxer.c MPlayer-1.0rc1/libmpdemux/demuxer.c
--- MPlayer-1.0rc1.orig/libmpdemux/demuxer.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demuxer.c	2006-12-04 00:10:44.000000000 +0100
@@ -143,7 +143,7 @@
   ds->pos=0;
   ds->dpos=0;
   ds->pack_no=0;
-//---------------
+//----------------
   ds->packs=0;
   ds->bytes=0;
   ds->first=ds->last=ds->current=NULL;
@@ -178,7 +178,7 @@
 }
 
 
-demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename){
+demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename,int hideerrmess){
   demuxer_t *d=malloc(sizeof(demuxer_t));
   memset(d,0,sizeof(demuxer_t));
   d->stream=stream;
@@ -191,6 +191,7 @@
   d->video=new_demuxer_stream(d,v_id);
   d->sub=new_demuxer_stream(d,s_id);
   d->type=type;
+  d->hide_packs_err_mess=hideerrmess;
   if(type)
     if (!(d->desc = get_demuxer_desc_from_type(type)))
       mp_msg(MSGT_DEMUXER,MSGL_ERR,"BUG! Invalid demuxer type in new_demuxer(), big troubles ahead.");
@@ -249,6 +250,11 @@
           mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_VIDEO_ID=%d\n", vid);
     }
     ((sh_video_t *)demuxer->v_streams[id])->vid = vid;
+    ((sh_video_t*)demuxer->v_streams[id])->config_lock=0;
+    ((sh_video_t*)demuxer->v_streams[id])->config_w=0;
+    ((sh_video_t*)demuxer->v_streams[id])->config_h=0;
+    ((sh_video_t*)demuxer->v_streams[id])->config_outfmt=0;
+    ((sh_video_t*)demuxer->v_streams[id])->enable_mpeg2_reset=0;
     return demuxer->v_streams[id];
 }
 
@@ -372,13 +378,15 @@
       return 1; //ds->buffer_size;
     }
     if(demux->audio->packs>=MAX_PACKS || demux->audio->bytes>=MAX_PACK_BYTES){
+      if (!(demux->hide_packs_err_mess)) {
       mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_TooManyAudioInBuffer,demux->audio->packs,demux->audio->bytes);
-      mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);
+        mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI); }
       break;
     }
     if(demux->video->packs>=MAX_PACKS || demux->video->bytes>=MAX_PACK_BYTES){
+      if (!(demux->hide_packs_err_mess)) {
       mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_TooManyVideoInBuffer,demux->video->packs,demux->video->bytes);
-      mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);
+        mp_msg(MSGT_DEMUXER,MSGL_HINT,MSGTR_MaybeNI);}
       break;
     }
     if(!demux_fill_buffer(demux,ds)){
@@ -644,7 +652,7 @@
 
 static demuxer_t* demux_open_stream(stream_t *stream, int file_format,
                     int force, int audio_id, int video_id, int dvdsub_id,
-                    char* filename) {
+                    char* filename,int hideerrmess) {
 
 //int file_format=(*file_format_ptr);
 
@@ -661,7 +669,7 @@
 // If somebody requested a demuxer check it
 if (file_format) {
   if ((demuxer_desc = get_demuxer_desc_from_type(file_format))) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename,hideerrmess);
     if (demuxer_desc->check_file)
       fformat = demuxer_desc->check_file(demuxer);
     if (force || !demuxer_desc->check_file)
@@ -680,7 +688,7 @@
         // Format changed after check, recurse
         free_demuxer(demuxer);
         return demux_open_stream(stream, fformat, force,
-                 audio_id, video_id, dvdsub_id, filename);
+                 audio_id, video_id, dvdsub_id, filename,hideerrmess);
       }
     }
     // Check failed for forced demuxer, quit
@@ -692,7 +700,7 @@
 // Test demuxers with safe file checks
 for (i = 0; (demuxer_desc = demuxer_list[i]); i++) {
   if (demuxer_desc->safe_check) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename, hideerrmess);
     if ((fformat = demuxer_desc->check_file(demuxer)) != 0) {
       if (fformat == demuxer_desc->type) {
         demuxer_t *demux2 = demuxer;
@@ -708,7 +716,7 @@
         // Format changed after check, recurse
         free_demuxer(demuxer);
         demuxer=demux_open_stream(stream, fformat, force,
-                  audio_id, video_id, dvdsub_id, filename);
+                  audio_id, video_id, dvdsub_id, filename, hideerrmess);
         if(demuxer) return demuxer; // done!
         file_format = DEMUXER_TYPE_UNKNOWN;
       }
@@ -727,7 +735,7 @@
   if(file_format!=DEMUXER_TYPE_UNKNOWN){
     // we like recursion :)
     demuxer=demux_open_stream(stream, file_format, force,
-              audio_id, video_id, dvdsub_id, filename);
+              audio_id, video_id, dvdsub_id, filename, hideerrmess);
     if(demuxer) return demuxer; // done!
     file_format=DEMUXER_TYPE_UNKNOWN; // continue fuzzy guessing...
     mp_msg(MSGT_DEMUXER,MSGL_V,"demuxer: continue fuzzy content-based format guessing...\n");
@@ -737,7 +745,7 @@
 // Try detection for all other demuxers
 for (i = 0; (demuxer_desc = demuxer_list[i]); i++) {
   if (!demuxer_desc->safe_check && demuxer_desc->check_file) {
-    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename);
+    demuxer = new_demuxer(stream,demuxer_desc->type,audio_id,video_id,dvdsub_id,filename, hideerrmess);
     if ((fformat = demuxer_desc->check_file(demuxer)) != 0) {
       if (fformat == demuxer_desc->type) {
         demuxer_t *demux2 = demuxer;
@@ -753,7 +761,7 @@
         // Format changed after check, recurse
         free_demuxer(demuxer);
         demuxer=demux_open_stream(stream, fformat, force,
-                  audio_id, video_id, dvdsub_id, filename);
+                  audio_id, video_id, dvdsub_id, filename, hideerrmess);
         if(demuxer) return demuxer; // done!
         file_format = DEMUXER_TYPE_UNKNOWN;
       }
@@ -797,7 +805,7 @@
 extern float stream_cache_min_percent;
 extern float stream_cache_seek_min_percent;
 
-demuxer_t* demux_open(stream_t *vs,int file_format,int audio_id,int video_id,int dvdsub_id,char* filename){
+demuxer_t* demux_open(stream_t *vs,int file_format,int audio_id,int video_id,int dvdsub_id,char* filename,int hideerrmess){
   stream_t *as = NULL,*ss = NULL;
   demuxer_t *vd,*ad = NULL,*sd = NULL;
   int afmt =DEMUXER_TYPE_UNKNOWN,sfmt = DEMUXER_TYPE_UNKNOWN ;
@@ -840,7 +848,7 @@
 
   vd = demux_open_stream(vs, demuxer_type ? demuxer_type : file_format,
          demuxer_force, audio_stream ? -2 : audio_id, video_id,
-         sub_stream ? -2 : dvdsub_id, filename);
+         sub_stream ? -2 : dvdsub_id, filename, hideerrmess);
   if(!vd) {
     if(as) free_stream(as);
     if(ss) free_stream(ss);
@@ -848,7 +856,7 @@
   }
   if(as) {
     ad = demux_open_stream(as, audio_demuxer_type ? audio_demuxer_type : afmt,
-           audio_demuxer_force, audio_id, -2, -2, audio_stream);
+           audio_demuxer_force, audio_id, -2, -2, audio_stream, hideerrmess);
     if(!ad) {
       mp_msg(MSGT_DEMUXER,MSGL_WARN,MSGTR_OpeningAudioDemuxerFailed,audio_stream);
       free_stream(as);
@@ -858,7 +866,7 @@
   }
   if(ss) {
     sd = demux_open_stream(ss, sub_demuxer_type ? sub_demuxer_type : sfmt,
-           sub_demuxer_force, -2, -2, dvdsub_id, sub_stream);
+           sub_demuxer_force, -2, -2, dvdsub_id, sub_stream, hideerrmess);
     if(!sd) {
       mp_msg(MSGT_DEMUXER,MSGL_WARN,MSGTR_OpeningSubtitlesDemuxerFailed,sub_stream);
       free_stream(ss);
@@ -976,6 +984,11 @@
 
 int demux_control(demuxer_t *demuxer, int cmd, void *arg) {
 
+    switch (cmd) {
+      case DEMUXER_CTRL_SETHIDEPACKSERR:
+        demuxer->hide_packs_err_mess=*((int*)arg);
+        return DEMUXER_CTRL_OK;
+      }
     if (demuxer->desc->control)
       return demuxer->desc->control(demuxer,cmd,arg);
 
@@ -1133,3 +1146,16 @@
         return current;
     }
 }
+
+void demuxer_set_hidemess(demuxer_t *demuxer, int hideflg)
+{
+    demux_control(demuxer, DEMUXER_CTRL_SETHIDEPACKSERR,(void *)&hideflg);
+    return;
+}
+
+void demuxer_update_time_pts(demuxer_t *demuxer, float final_pts, off_t endpos) {
+demuxer->stream->start_pos=0;
+demuxer->stream->end_pos=endpos;
+demuxer->movi_end=endpos;
+demux_control(demuxer, DEMUXER_CTRL_SET_TIME_PTS,(void *)&final_pts);
+}
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demuxer.h MPlayer-1.0rc1/libmpdemux/demuxer.h
--- MPlayer-1.0rc1.orig/libmpdemux/demuxer.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demuxer.h	2006-12-04 00:10:44.000000000 +0100
@@ -78,6 +78,9 @@
 #define DEMUXER_CTRL_GET_PERCENT_POS 11
 #define DEMUXER_CTRL_SWITCH_AUDIO 12
 
+#define DEMUXER_CTRL_SETHIDEPACKSERR 13
+#define DEMUXER_CTRL_SET_TIME_PTS 14
+
 // Holds one packet/frame/whatever
 typedef struct demux_packet_st {
   int len;
@@ -194,6 +197,9 @@
   demux_stream_t *audio; // audio buffer/demuxer
   demux_stream_t *video; // video buffer/demuxer
   demux_stream_t *sub;   // dvd subtitle buffer/demuxer
+// --------------
+  int hide_packs_err_mess;
+// --------------
 
   // stream headers:
   void* a_streams[MAX_A_STREAMS]; // audio streams (sh_audio_t)
@@ -282,7 +288,7 @@
 }
 
 demux_stream_t* new_demuxer_stream(struct demuxer_st *demuxer,int id);
-demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename);
+demuxer_t* new_demuxer(stream_t *stream,int type,int a_id,int v_id,int s_id,char *filename,int hideerrmess);
 void free_demuxer_stream(demux_stream_t *ds);
 void free_demuxer(demuxer_t *demuxer);
 
@@ -346,7 +352,7 @@
   return a*10+b;
 }
 
-demuxer_t* demux_open(stream_t *stream,int file_format,int aid,int vid,int sid,char* filename);
+demuxer_t* demux_open(stream_t *stream,int file_format,int aid,int vid,int sid,char* filename,int hideerrmess);
 int demux_seek(demuxer_t *demuxer,float rel_seek_secs,float audio_delay,int flags);
 demuxer_t*  new_demuxers_demuxer(demuxer_t* vd, demuxer_t* ad, demuxer_t* sd);
 
@@ -392,3 +398,5 @@
 int demuxer_add_chapter(demuxer_t* demuxer, const char* name, uint64_t start, uint64_t end);
 int demuxer_seek_chapter(demuxer_t *demuxer, int chapter, int mode, float *seek_pts, int *num_chapters, char **chapter_name);
 
+void demuxer_set_hidemess(demuxer_t *demuxer, int hideflg);
+void demuxer_update_time_pts(demuxer_t *demuxer, float final_pts, off_t endpos);
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demux_mov.c MPlayer-1.0rc1/libmpdemux/demux_mov.c
--- MPlayer-1.0rc1.orig/libmpdemux/demux_mov.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demux_mov.c	2006-12-04 00:10:44.000000000 +0100
@@ -1929,7 +1929,7 @@
     
                 demuxer->video->id = t_no;
                 s = new_ds_stream(demuxer->video);
-                od = demux_open(s, DEMUXER_TYPE_MPEG_PS, -1, -1, -1, NULL);
+                od = demux_open(s, DEMUXER_TYPE_MPEG_PS, -1, -1, -1, NULL, 0);
                 if(od) return new_demuxers_demuxer(od, od, od);
                 demuxer->video->id = -2;	//new linked demuxer couldn't be allocated
                 break;
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demux_mpg.c MPlayer-1.0rc1/libmpdemux/demux_mpg.c
--- MPlayer-1.0rc1.orig/libmpdemux/demux_mpg.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demux_mpg.c	2006-12-04 00:10:44.000000000 +0100
@@ -758,6 +758,7 @@
 	  int i;
           if(sh_audio && !d_audio->eof && d_video->pts && d_audio->pts){
 	    float a_pts=d_audio->pts;
+	  if((float)sh_audio->i_bps==0.0f) break;
             a_pts+=(ds_tell_pts(d_audio)-sh_audio->a_in_buffer_len)/(float)sh_audio->i_bps;
 	    if(d_video->pts>a_pts){
 	      skip_audio_frame(sh_audio);  // sync audio
@@ -859,6 +860,23 @@
             *((int*)arg) = demuxer->audio->id;
             return DEMUXER_CTRL_OK;
 
+	case DEMUXER_CTRL_SET_TIME_PTS: {
+	      if (demuxer->movi_end==0)
+		{
+		mpg_d->final_pts = 0.0;
+		mpg_d->has_valid_timestamps = 0;
+		return DEMUXER_CTRL_OK;
+		}
+              mpg_d->final_pts=*((float *)arg);
+	      if (mpg_d->final_pts==0.0)
+		{
+		mpg_d->final_pts = 0.0;
+		mpg_d->has_valid_timestamps = 0;
+		return DEMUXER_CTRL_OK;
+		}
+	      mpg_d->has_valid_timestamps = 1;
+	      return DEMUXER_CTRL_OK;
+	      }
 	default:
 	    return DEMUXER_CTRL_NOTIMPL;
     }
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demux_ogg.c MPlayer-1.0rc1/libmpdemux/demux_ogg.c
--- MPlayer-1.0rc1.orig/libmpdemux/demux_ogg.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demux_ogg.c	2006-12-04 00:10:44.000000000 +0100
@@ -1382,7 +1382,7 @@
 
   // Create the ds_stream and the ogg demuxer
   s = new_ds_stream(demuxer->audio);
-  od = new_demuxer(s,DEMUXER_TYPE_OGG,0,-2,-2,NULL);
+  od = new_demuxer(s,DEMUXER_TYPE_OGG,0,-2,-2,NULL,0);
 
   /// Add the header packets in the ogg demuxer audio stream
   // Initial header
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/demux_rtp.cpp MPlayer-1.0rc1/libmpdemux/demux_rtp.cpp
--- MPlayer-1.0rc1.orig/libmpdemux/demux_rtp.cpp	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/demux_rtp.cpp	2006-12-04 00:10:44.000000000 +0100
@@ -241,7 +241,7 @@
   if (demux_is_multiplexed_rtp_stream(demuxer)) {
     stream_t* s = new_ds_stream(demuxer->video);
     demuxer_t* od = demux_open(s, DEMUXER_TYPE_UNKNOWN,
-			       audio_id, video_id, dvdsub_id, NULL);
+			       audio_id, video_id, dvdsub_id, NULL, 0, 0, 0);
     demuxer = new_demuxers_demuxer(od, od, od);
   }
 
diff -Nur MPlayer-1.0rc1.orig/libmpdemux/stheader.h MPlayer-1.0rc1/libmpdemux/stheader.h
--- MPlayer-1.0rc1.orig/libmpdemux/stheader.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libmpdemux/stheader.h	2006-12-04 00:10:44.000000000 +0100
@@ -88,6 +88,12 @@
   void* ImageDesc; // for quicktime codecs
   // codec-specific:
   void* context;   // codec-specific stuff (usually HANDLE or struct pointer)
+
+  int config_lock;
+  int config_w;
+  int config_h;
+  unsigned int config_outfmt;
+  int enable_mpeg2_reset;
 } sh_video_t;
 
 // demuxer.c:
diff -Nur MPlayer-1.0rc1.orig/libvo/osd.c MPlayer-1.0rc1/libvo/osd.c
--- MPlayer-1.0rc1.orig/libvo/osd.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/osd.c	2006-12-04 00:10:44.000000000 +0100
@@ -11,6 +11,7 @@
 #include <inttypes.h>
 #include "cpudetect.h"
 #include "mangle.h"
+#include "video_out.h"
 
 #if defined(ARCH_X86) || defined(ARCH_X86_64)
 #define CAN_COMPILE_X86_ASM
@@ -101,152 +102,152 @@
 
 #endif //CAN_COMPILE_X86_ASM
 
-void vo_draw_alpha_yv12(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_yv12(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #ifdef RUNTIME_CPUDETECT
 #ifdef CAN_COMPILE_X86_ASM
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //RUNTIME_CPUDETECT
 #ifdef HAVE_MMX2
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_3DNOW)
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_MMX)
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_yuy2(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_yuy2(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #ifdef RUNTIME_CPUDETECT
 #ifdef CAN_COMPILE_X86_ASM
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //RUNTIME_CPUDETECT
 #ifdef HAVE_MMX2
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_3DNOW)
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_MMX)
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_uyvy(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_uyvy(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #ifdef RUNTIME_CPUDETECT
 #ifdef CAN_COMPILE_X86_ASM
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //RUNTIME_CPUDETECT
 #ifdef HAVE_MMX2
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_3DNOW)
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_MMX)
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_rgb24(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb24(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #ifdef RUNTIME_CPUDETECT
 #ifdef CAN_COMPILE_X86_ASM
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //RUNTIME_CPUDETECT
 #ifdef HAVE_MMX2
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_3DNOW)
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_MMX)
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_rgb32(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb32(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #ifdef RUNTIME_CPUDETECT
 #ifdef CAN_COMPILE_X86_ASM
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //RUNTIME_CPUDETECT
 #ifdef HAVE_MMX2
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_3DNOW)
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined (HAVE_MMX)
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif defined(ARCH_X86) || defined(ARCH_X86_64)
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!RUNTIME_CPUDETECT
 }
@@ -297,8 +298,10 @@
 	}
 }
 
-void vo_draw_alpha_rgb15(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb15(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y :
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -327,10 +330,67 @@
         dstbase+=dststride;
     }
     return;
+  case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                g=(((g*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
 }
 
-void vo_draw_alpha_rgb16(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb16(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y :
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -358,5 +418,60 @@
         dstbase+=dststride;
     }
     return;
+  case DEST_PLANES_RB :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                g=(((g*srca[x])>>6)+src[x])>>2;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR :
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
 }
 
diff -Nur MPlayer-1.0rc1.orig/libvo/osd.h MPlayer-1.0rc1/libvo/osd.h
--- MPlayer-1.0rc1.orig/libvo/osd.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/osd.h	2006-12-04 00:10:44.000000000 +0100
@@ -7,13 +7,13 @@
 
 extern void vo_draw_alpha_init(void); // build tables
 
-extern void vo_draw_alpha_yv12(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_yuy2(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_uyvy(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb24(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb32(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb15(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
-extern void vo_draw_alpha_rgb16(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_yv12(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_yuy2(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_uyvy(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb24(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb32(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb15(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+extern void vo_draw_alpha_rgb16(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
 
 #endif
 
diff -Nur MPlayer-1.0rc1.orig/libvo/osd_template.c MPlayer-1.0rc1/libvo/osd_template.c
--- MPlayer-1.0rc1.orig/libvo/osd_template.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/osd_template.c	2006-12-04 00:10:44.000000000 +0100
@@ -27,7 +27,7 @@
 #define EMMS     "emms"
 #endif
 
-static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !defined(HAVE_MMX)
     w=w>>1;
@@ -97,7 +97,7 @@
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !defined(HAVE_MMX)
     w=w>>1;
@@ -169,7 +169,7 @@
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
   int y;
 #if defined(FAST_OSD)
   w=w>>1;
@@ -193,8 +193,10 @@
   }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y:
 #ifdef HAVE_MMX
     asm volatile(
         "pxor %%mm7, %%mm7\n\t"
@@ -299,13 +301,61 @@
 	asm volatile(EMMS:::"memory");
 #endif
     return;
+case DEST_PLANES_RB:
+  for(y=0;y<h;y++){
+       register unsigned char *dst = dstbase;
+       register int x;
+       for(x=0;x<w;x++){
+           if(srca[x]){
+  		dst[0]=((dst[0]*srca[x])>>8)+src[x];
+           }
+           dst+=3; // 24bpp
+       }
+       src+=srcstride;
+       srca+=srcstride;
+       dstbase+=dststride;
+  }
+  return;
+case DEST_PLANES_G:
+  for(y=0;y<h;y++){
+       register unsigned char *dst = dstbase;
+       register int x;
+       for(x=0;x<w;x++){
+       if(srca[x]){
+  		dst[1]=((dst[1]*srca[x])>>8)+src[x];
+           }
+           dst+=3; // 24bpp
+       }
+       src+=srcstride;
+       srca+=srcstride;
+       dstbase+=dststride;
+  }
+  return;
+case DEST_PLANES_BR:
+  for(y=0;y<h;y++){
+       register unsigned char *dst = dstbase;
+       register int x;
+       for(x=0;x<w;x++){
+           if(srca[x]){
+  		dst[2]=((dst[2]*srca[x])>>8)+src[x];
+           }
+           dst+=3; // 24bpp
+       }
+       src+=srcstride;
+       srca+=srcstride;
+       dstbase+=dststride;
+  }
+  return;
+  }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #ifdef WORDS_BIGENDIAN
     dstbase++;
 #endif
+switch (dp) {
+  case DEST_PLANES_Y:
 #ifdef HAVE_MMX
 #ifdef HAVE_3DNOW
     asm volatile(
@@ -464,4 +514,44 @@
 	asm volatile(EMMS:::"memory");
 #endif
     return;
+ case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+0]=(((dstbase[4*x+0]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+1]=(((dstbase[4*x+1]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+		dstbase[4*x+2]=(((dstbase[4*x+2]*srca[x])>>8)+src[x])&0xff;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+ }
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/sub.c MPlayer-1.0rc1/libvo/sub.c
--- MPlayer-1.0rc1.orig/libvo/sub.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/sub.c	2006-12-04 00:10:44.000000000 +0100
@@ -70,6 +70,14 @@
 int sub_bg_color=0; /* subtitles background color */
 int sub_bg_alpha=0;
 int sub_justify=0;
+uint16_t  dvdnav_sx=0;
+uint16_t  dvdnav_ex=0;
+uint16_t  dvdnav_sy=0;
+uint16_t  dvdnav_ey=0;
+int	  dvdnav_show=0;
+unsigned char dvdnav_image=0x7f;
+unsigned char dvdnav_alpha=0x7f;
+
 
 // return the real height of a char:
 static inline int get_height(int c,int h){
@@ -132,11 +140,12 @@
 }
 
 // renders the buffer
-inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
     if (obj->allocated > 0) {
 	draw_alpha(obj->bbox.x1,obj->bbox.y1,
 		   obj->bbox.x2-obj->bbox.x1,
 		   obj->bbox.y2-obj->bbox.y1,
+		   DEST_PLANES_Y,
 		   obj->bitmap_buffer,
 		   obj->alpha_buffer,
 		   obj->stride);
@@ -194,6 +203,48 @@
         }
 }
 
+#undef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#undef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+void dvdnav_box_area(int sx, int sy, int ex, int ey, int show, unsigned char image, unsigned char alpha)
+{
+  dvdnav_sx=min(sx,ex);
+  dvdnav_ex=max(sx,ex);
+  dvdnav_sy=min(sy,ey);
+  dvdnav_ey=max(sy,ey);
+  dvdnav_show=show;
+  dvdnav_image=image;
+  dvdnav_alpha=alpha;
+}
+
+
+inline static void vo_update_dvdnav(mp_osd_obj_t* obj,int dxs,int dys){
+
+unsigned char * bitmap_buffer;
+unsigned char * alpha_buffer;
+int len;
+int stride;
+
+if (dvdnav_show)
+    {
+    obj->bbox.x1=obj->x=dvdnav_sx;
+    obj->bbox.y1=obj->y=dvdnav_sy;
+    obj->bbox.x2=dvdnav_ex;
+    obj->bbox.y2=dvdnav_ey;
+    alloc_buf(obj);
+    len = obj->stride*(obj->bbox.y2-obj->bbox.y1);
+//printf("dvdnav box image: %x alpha: %x \n",dvdnav_image,dvdnav_alpha);
+    memset(obj->bitmap_buffer,dvdnav_image,len);
+    memset(obj->alpha_buffer,dvdnav_alpha,len);
+    obj->flags|=OSDFLAG_BBOX|OSDFLAG_VISIBLE|OSDFLAG_CHANGED;
+    }
+    else
+    obj->flags&=~OSDFLAG_VISIBLE;
+}
+
+
 int vo_osd_progbar_type=-1;
 int vo_osd_progbar_value=100;   // 0..256
 
@@ -739,7 +790,7 @@
   obj->flags |= OSDFLAG_BBOX;
 }
 
-inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, unsigned char* src, unsigned char* srca, int stride))
+inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, int dp, unsigned char* src, unsigned char* srca, int stride))
 {
   spudec_draw_scaled(vo_spudec, obj->dxs, obj->dys, draw_alpha);
 }
@@ -825,6 +876,10 @@
         int vis=obj->flags&OSDFLAG_VISIBLE;
 	obj->flags&=~OSDFLAG_BBOX;
 	switch(obj->type){
+	case OSDTYPE_DVDNAV:
+	    vo_update_dvdnav(obj,dxs,dys);
+	    obj->flags|=OSDFLAG_CHANGED;
+	    break;
 	case OSDTYPE_SUBTITLE:
 	    vo_update_text_sub(obj,dxs,dys);
 	    break;
@@ -892,6 +947,7 @@
     new_osd_obj(OSDTYPE_SUBTITLE);
     new_osd_obj(OSDTYPE_PROGBAR);
     new_osd_obj(OSDTYPE_SPU);
+    new_osd_obj(OSDTYPE_DVDNAV);
 #ifdef HAVE_FREETYPE
     force_load_font = 1;
 #endif
@@ -917,7 +973,7 @@
     }
 }
 
-void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
     mp_osd_obj_t* obj=vo_osd_list;
     vo_update_osd(dxs,dys);
     while(obj){
@@ -927,6 +983,7 @@
 	case OSDTYPE_SPU:
 	    vo_draw_spudec_sub(obj, draw_alpha); // FIXME
 	    break;
+	case OSDTYPE_DVDNAV:
 	case OSDTYPE_OSD:
 	case OSDTYPE_SUBTITLE:
 	case OSDTYPE_PROGBAR:
diff -Nur MPlayer-1.0rc1.orig/libvo/sub.h MPlayer-1.0rc1/libvo/sub.h
--- MPlayer-1.0rc1.orig/libvo/sub.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/sub.h	2006-12-04 00:10:44.000000000 +0100
@@ -10,6 +10,8 @@
 #define OSDTYPE_SUBTITLE 2
 #define OSDTYPE_PROGBAR 3
 #define OSDTYPE_SPU 4
+#define OSDTYPE_DVDNAV 5
+void dvdnav_box_area(int sx, int sy, int ex, int ey, int show, unsigned char image, unsigned char alpha);
 
 #define OSDFLAG_VISIBLE 1
 #define OSDFLAG_CHANGED 2
@@ -51,7 +53,7 @@
 #if 0
 
 // disable subtitles:
-static inline void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+static inline void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
 }
 
 #else
@@ -110,7 +112,7 @@
 //extern void vo_draw_text_osd(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
 //extern void vo_draw_text_progbar(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
 //extern void vo_draw_text_sub(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 extern void vo_remove_text(int dxs,int dys,void (*remove)(int x0,int y0, int w,int h));
 
 void vo_init_osd(void);
diff -Nur MPlayer-1.0rc1.orig/libvo/vesa_lvo.c MPlayer-1.0rc1/libvo/vesa_lvo.c
--- MPlayer-1.0rc1.orig/libvo/vesa_lvo.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vesa_lvo.c	2006-12-04 00:10:44.000000000 +0100
@@ -233,50 +233,51 @@
   }	
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t bespitch = /*(*/mga_vid_config.src_width;// + 15) & ~15;
     switch(mga_vid_config.format){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_IYUV:
     case IMGFMT_I420:
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
         break;
     case IMGFMT_YUY2:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
         break;
     case IMGFMT_UYVY:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
         break;
     default:
-        draw_alpha_null(x0,y0,w,h,src,srca,stride);
+        draw_alpha_null(x0,y0,w,h,dp,src,srca,stride);
     }
 }
 
diff -Nur MPlayer-1.0rc1.orig/libvo/video_out.h MPlayer-1.0rc1/libvo/video_out.h
--- MPlayer-1.0rc1.orig/libvo/video_out.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/video_out.h	2006-12-04 00:10:44.000000000 +0100
@@ -80,6 +80,11 @@
   int w,h;
 } mp_win_t;
 
+#define VOCTRL_YUVSPU_SUPPORT 28
+#define VOCTRL_RGBSPU_SUPPORT 29
+#define VOCTRL_BGRSPU_SUPPORT 30
+#define VOCTRL_YUYSPU_SUPPORT 31
+
 #define VO_TRUE		1
 #define VO_FALSE	0
 #define VO_ERROR	-1
@@ -92,6 +97,15 @@
 #define VOFLAG_FLIPPING		0x08
 #define VOFLAG_XOVERLAY_SUB_VO  0x10000
 
+// dest planes (draw_alpha)
+#define	DEST_PLANES_Y		0
+#define DEST_PLANES_U		1
+#define DEST_PLANES_V		2
+#define DEST_PLANES_RB		3
+#define DEST_PLANES_G		4
+#define DEST_PLANES_BR		5
+#define DEST_PLANES_YUYV	6
+
 typedef struct vo_info_s
 {
         /* driver name ("Matrox Millennium G200/G400" */
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_aa.c MPlayer-1.0rc1/libvo/vo_aa.c
--- MPlayer-1.0rc1.orig/libvo/vo_aa.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_aa.c	2006-12-04 00:10:44.000000000 +0100
@@ -531,7 +531,7 @@
 }
 
 #ifdef USE_OSD
-static void draw_alpha(int x,int y, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x,int y, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     int i,j;
     for (i = 0; i < h; i++) {
 	for (j = 0; j < w; j++) {
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_dfbmga.c MPlayer-1.0rc1/libvo/vo_dfbmga.c
--- MPlayer-1.0rc1.orig/libvo/vo_dfbmga.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_dfbmga.c	2006-12-04 00:10:44.000000000 +0100
@@ -926,7 +926,7 @@
 }
 
 static void
-vo_draw_alpha_alut44( int w, int h,
+vo_draw_alpha_alut44( int w, int h, int dp,
                     unsigned char* src,
                     unsigned char *srca,
                     int srcstride,
@@ -957,6 +957,7 @@
 static void
 draw_alpha( int x0, int y0,
             int w, int h,
+	    int dp,
             unsigned char *src,
 	    unsigned char *srca,
             int stride )
@@ -981,38 +982,47 @@
 
      switch (subframe_format) {
      case DSPF_ALUT44:
-          vo_draw_alpha_alut44( w, h, src, srca, stride,
+          vo_draw_alpha_alut44( w, h, dp, src, srca, stride,
                                 ((uint8_t *) dst) + pitch * y0 + x0,
                               pitch );
           break;
      case DSPF_RGB32:
      case DSPF_ARGB:
-	  vo_draw_alpha_rgb32( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb32( w, h, dp, src, srca, stride,
 			       (( uint8_t *) dst) + pitch * y0 + 4 * x0,
                                pitch );
 	  break;
      case DSPF_RGB24:
-	  vo_draw_alpha_rgb24( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb24( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 3 * x0,
                                pitch );
 	  break;
      case DSPF_RGB16:
-	  vo_draw_alpha_rgb16( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb16( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                                pitch );
 	  break;
      case DSPF_ARGB1555:
-	  vo_draw_alpha_rgb15( w, h, src, srca, stride,
+	  vo_draw_alpha_rgb15( w, h, dp, src, srca, stride,
 			       ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                                pitch );
 	  break;
      case DSPF_YUY2:
-	  vo_draw_alpha_yuy2( w, h, src, srca, stride,
+	switch (dp) {
+	    case DEST_PLANES_Y:
+	    vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + 2 * x0,
                               pitch );
 	  break;
+	    case DEST_PLANES_YUYV:
+	    vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + 2 * x0,
+                              pitch );
+	    break;
+	    }
+	  break;
      case DSPF_UYVY:
-	  vo_draw_alpha_yuy2( w, h, src, srca, stride,
+	  vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + 2 * x0 + 1,
                               pitch );
 	  break;
@@ -1022,10 +1032,34 @@
 #endif
      case DSPF_I420:
      case DSPF_YV12:
-	  vo_draw_alpha_yv12( w, h, src, srca, stride,
+	switch (dp) {
+	  case DEST_PLANES_Y:
+	    vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
 			      ((uint8_t *) dst) + pitch * y0 + x0,
                               pitch );
 	  break;
+	  case DEST_PLANES_U:
+	    if (subframe_format==DSPF_YV12)
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * in_height,
+                              pitch );
+		else
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * (in_height+in_height/2),
+                              pitch );
+	    break;
+	  case DEST_PLANES_V:
+	    if (subframe_format==DSPF_YV12)
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * (in_height+in_height/2),
+                              pitch );
+		else
+		vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+			      ((uint8_t *) dst) + pitch * y0 + x0 + pitch * in_height,
+                              pitch );
+	    break;
+	  }
+	  break;
      }
 
      subframe->Unlock( subframe );
@@ -1420,6 +1454,18 @@
 
                return get_equalizer( data, value );
           }
+    case VOCTRL_YUVSPU_SUPPORT:
+		if (subframe_format==DSPF_I420 || subframe_format==DSPF_YV12) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_YUYSPU_SUPPORT:
+		if (subframe_format==DSPF_YUY2) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_RGBSPU_SUPPORT:
+		if (subframe_format==DSPF_RGB32 || subframe_format==DSPF_ARGB || subframe_format==DSPF_RGB24 ||
+			subframe_format==DSPF_RGB16 || subframe_format==DSPF_ARGB1555) return VO_TRUE;
+		return VO_FALSE;
+    case VOCTRL_BGRSPU_SUPPORT:
+		return VO_FALSE;
      }
 
      return VO_NOTIMPL;
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_dga.c MPlayer-1.0rc1/libvo/vo_dga.c
--- MPlayer-1.0rc1.orig/libvo/vo_dga.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_dga.c	2006-12-04 00:10:44.000000000 +0100
@@ -227,7 +227,7 @@
 
 //---------------------------------------------------------
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride)
 {
 
@@ -243,19 +243,19 @@
     {
 
         case 32:
-            vo_draw_alpha_rgb32(w, h, src, srca, stride, d + 4 * offset,
+            vo_draw_alpha_rgb32(w, h, dp, src, srca, stride, d + 4 * offset,
                                 4 * buffer_stride);
             break;
         case 24:
-            vo_draw_alpha_rgb24(w, h, src, srca, stride, d + 3 * offset,
+            vo_draw_alpha_rgb24(w, h, dp, src, srca, stride, d + 3 * offset,
                                 3 * buffer_stride);
             break;
         case 15:
-            vo_draw_alpha_rgb15(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb15(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
         case 16:
-            vo_draw_alpha_rgb16(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb16(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
     }
@@ -981,6 +981,14 @@
             return get_image(data);
         case VOCTRL_QUERY_FORMAT:
             return query_format(*((uint32_t *) data));
+	case VOCTRL_YUVSPU_SUPPORT:
+	    return VO_FALSE;
+	case VOCTRL_RGBSPU_SUPPORT:
+	    return VO_FALSE;
+	case VOCTRL_BGRSPU_SUPPORT:
+	    if(HW_MODE.vdm_mplayer_depth==32 || HW_MODE.vdm_mplayer_depth==24 ||
+		HW_MODE.vdm_mplayer_depth==15 || HW_MODE.vdm_mplayer_depth==16) return VO_TRUE;
+	    return VO_FALSE;
     }
     return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_directfb2.c MPlayer-1.0rc1/libvo/vo_directfb2.c
--- MPlayer-1.0rc1.orig/libvo/vo_directfb2.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_directfb2.c	2006-12-04 00:10:44.000000000 +0100
@@ -1447,6 +1447,20 @@
     
 	return(directfb_get_video_eq(data, value));
       }
+    case VOCTRL_YUVSPU_SUPPORT:
+	if (pixel_format==DSPF_I420 || pixel_format==DSPF_YV12) return VO_TRUE;
+	return VO_FALSE;
+    case VOCTRL_RGBSPU_SUPPORT:
+	if (pixel_format==DSPF_RGB32 || pixel_format==DSPF_ARGB || pixel_format==DSPF_RGB24 ||
+		pixel_format==DSPF_RGB16) return VO_TRUE;
+#if DIRECTFBVERSION > 915
+	if (pixel_format==DSPF_ARGB1555) return VO_TRUE;
+#else
+	if (pixel_format==DSPF_RGB15) return VO_TRUE;
+#endif
+	return VO_FALSE;
+    case VOCTRL_BGRSPU_SUPPORT:
+	return VO_FALSE;
   };
   return VO_NOTIMPL;
 }
@@ -1460,7 +1474,7 @@
 
 // hopefully will be removed soon
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
         void *dst;
@@ -1479,35 +1493,51 @@
 	switch(pixel_format) {
                 case DSPF_RGB32:
                 case DSPF_ARGB:
-                        vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
+                        vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
                         break;
 
                 case DSPF_RGB24:
-                        vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
+                        vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
                         break;
 
                 case DSPF_RGB16:
-                        vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 #if DIRECTFBVERSION > DFB_VERSION(0,9,15)
                 case DSPF_ARGB1555:
 #else
                 case DSPF_RGB15:
 #endif
-                        vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb15(w,h,src,dp,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 
 		case DSPF_YUY2:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
+    			vo_draw_alpha_yuy2(w,h,src,dp,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
 		break;
 
         	case DSPF_UYVY:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
+    			vo_draw_alpha_yuy2(w,h,src,dp,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
 		break;
 
         	case DSPF_I420:
 		case DSPF_YV12:
-    			vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
+		  switch (dp) {
+		    case DEST_PLANES_Y:
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
+			break;
+		    case DEST_PLANES_U:
+			if (pixel_format==DSPF_YV12)
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/4 + pitch*y0 + 1*x0,pitch);
+			    else
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/2 + pitch*y0 + 1*x0,pitch);
+		        break;
+		    case DEST_PLANES_V:
+			if (pixel_format==DSPF_YV12)
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/2 + pitch*y0 + 1*x0,pitch);
+			    else
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*height/4 + pitch*y0 + 1*x0,pitch);
+		        break;
+		    }
 		break;
 		}
 
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_directx.c MPlayer-1.0rc1/libvo/vo_directx.c
--- MPlayer-1.0rc1.orig/libvo/vo_directx.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_directx.c	2006-12-04 00:10:44.000000000 +0100
@@ -86,7 +86,7 @@
 static RECT last_rect = {0xDEADC0DE, 0xDEADC0DE, 0xDEADC0DE, 0xDEADC0DE};
 
 extern void mplayer_put_key(int code);              //let mplayer handel the keyevents 
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 extern int vidmode;
 
 /*****************************************************************************
@@ -144,37 +144,62 @@
 
 LIBVO_EXTERN(directx)
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
+    uint8_t *d;
+    uint32_t uvstride=dstride/2;
     switch(image_format) {
     case IMGFMT_YV12 :
     case IMGFMT_I420 :
 	case IMGFMT_IYUV :
 	case IMGFMT_YVU9 :
-    	vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) image) + dstride*y0 + x0,dstride);
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + dstride*y0 + x0,dstride);
+		    break;
+		case DEST_PLANES_U:
+		    if(image_format == IMGFMT_YV12)
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*y0 + x0,uvstride);
+			else
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*(image_height/2) + uvstride*y0 + x0,uvstride);
+		    break;
+		case DEST_PLANES_V:
+		    if(image_format == IMGFMT_YV12)
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*(image_height/2) + uvstride*y0 + x0,uvstride);
+			else
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image) + image_height*dstride + uvstride*y0 + x0,uvstride);
+		    break;
+		}
 	break;
 	case IMGFMT_YUY2 :
-	    vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+		    break;
+		case DEST_PLANES_YUYV:
+		    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) image)+ dstride*y0 + 2*x0 ,dstride);
+		    break;
+		}
     break;
     case IMGFMT_UYVY :
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) image) + dstride*y0 + 2*x0 + 1,dstride);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) image) + dstride*y0 + 2*x0 + 1,dstride);
     break;
 	case IMGFMT_RGB15:	
     case IMGFMT_BGR15:
-		vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
+		vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
     break;
     case IMGFMT_RGB16:
 	case IMGFMT_BGR16:
-        vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+2*x0,dstride);
     break;
     case IMGFMT_RGB24:
 	case IMGFMT_BGR24:
-        vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
+        vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
     break;
     case IMGFMT_RGB32:
 	case IMGFMT_BGR32:
-        vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
+        vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) image)+dstride*y0+4*x0,dstride);
     break;
     }
 }
@@ -1583,6 +1608,25 @@
 		va_end(ap);
 		return color_ctrl_get(data, value);
 	}
+	case VOCTRL_YUVSPU_SUPPORT: {
+		if (image_format==IMGFMT_YV12 || image_format==IMGFMT_I420 ||
+		    image_format==IMGFMT_IYUV || image_format==IMGFMT_YVU9) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_YUYSPU_SUPPORT: {
+		if (image_format==IMGFMT_YUY2) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_RGBSPU_SUPPORT: {
+		if (image_format==IMGFMT_RGB15 || image_format==IMGFMT_RGB16 ||
+		    image_format==IMGFMT_RGB32) return VO_TRUE;
+		return VO_FALSE;
+	}
+	case VOCTRL_BGRSPU_SUPPORT: {
+		if (image_format==IMGFMT_BGR15 || image_format==IMGFMT_BGR16 ||
+		    image_format==IMGFMT_BGR32) return VO_TRUE;
+		return VO_FALSE;
+	}
     case VOCTRL_RESET:
         last_rect.left = 0xDEADC0DE;   // reset window position cache
         // fall-through intended
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_dxr3.c MPlayer-1.0rc1/libvo/vo_dxr3.c
--- MPlayer-1.0rc1.orig/libvo/vo_dxr3.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_dxr3.c	2006-12-04 00:10:44.000000000 +0100
@@ -677,7 +677,7 @@
 	return 0;
 }
 
-static void draw_alpha(int x, int y, int w, int h, unsigned char* src, unsigned char *srca, int srcstride)
+static void draw_alpha(int x, int y, int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride)
 {
 #ifdef SPU_SUPPORT
 	unsigned char *buf = &osdpicbuf[(y * osdpicbuf_w) + x];
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_fbdev2.c MPlayer-1.0rc1/libvo/vo_fbdev2.c
--- MPlayer-1.0rc1.orig/libvo/vo_fbdev2.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_fbdev2.c	2006-12-04 00:10:44.000000000 +0100
@@ -79,7 +79,7 @@
 static int fb_bpp;		// 32: 32  24: 24  16: 16  15: 15
 static size_t fb_size; // size of frame_buffer
 static int fb_line_len; // length of one line in bytes
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride, unsigned char *dst,
 		int dstride);
 
@@ -317,7 +317,7 @@
 	return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	unsigned char *dst;
@@ -330,7 +330,7 @@
 	dst = next_frame + (in_width * y0 + x0) * fb_pixel_size;
 	dstride = in_width * fb_pixel_size;
 #endif
-	(*draw_alpha_p)(w, h, src, srca, stride, dst, dstride);
+	(*draw_alpha_p)(w, h, dp, src, srca, stride, dst, dstride);
 }
 
 static void draw_osd(void)
@@ -403,6 +403,13 @@
   switch (request) {
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (fb_bpp == 32 || fb_bpp==24 || fb_bpp==16 || fb_bpp==15) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_fbdev.c MPlayer-1.0rc1/libvo/vo_fbdev.c
--- MPlayer-1.0rc1.orig/libvo/vo_fbdev.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_fbdev.c	2006-12-04 00:10:44.000000000 +0100
@@ -562,7 +562,7 @@
 static int fb_line_len;
 static int fb_xres;
 static int fb_yres;
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride, unsigned char *dst,
 		int dstride);
 
@@ -1053,14 +1053,14 @@
 	return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	unsigned char *dst;
 
 	dst = center + fb_line_len * y0 + fb_pixel_size * x0;
 
-	(*draw_alpha_p)(w, h, src, srca, stride, dst, fb_line_len);
+	(*draw_alpha_p)(w, h, dp, src, srca, stride, dst, fb_line_len);
 }
 
 static int draw_frame(uint8_t *src[]) { return 1; }
@@ -1174,6 +1174,13 @@
     return get_image(data);
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (fb_bpp == 32 || fb_bpp==24 || fb_bpp==16 || fb_bpp==15) return VO_TRUE;
+    return VO_FALSE;
   }
 
 #ifdef CONFIG_VIDIX
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_gl2.c MPlayer-1.0rc1/libvo/vo_gl2.c
--- MPlayer-1.0rc1.orig/libvo/vo_gl2.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_gl2.c	2006-12-04 00:10:44.000000000 +0100
@@ -83,7 +83,7 @@
 static int      use_glFinish;
 
 static void (*draw_alpha_fnc)
-                 (int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+                 (int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 
 /* The squares that are tiled to make up the game screen polygon */
@@ -572,23 +572,23 @@
   glLoadIdentity();
 }
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
 }
 
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
 }
 
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
 }
 
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 }
 
 #ifdef GL_WIN32
@@ -1139,6 +1139,13 @@
       return vo_x11_get_equalizer(data, value);
     }
 #endif
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (image_bpp==15 || image_bpp==16 || image_bpp==24 || image_bpp==32) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_macosx.m MPlayer-1.0rc1/libvo/vo_macosx.m
--- MPlayer-1.0rc1.orig/libvo/vo_macosx.m	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_macosx.m	2006-12-04 00:10:44.000000000 +0100
@@ -78,17 +78,17 @@
 LIBVO_EXTERN(macosx)
 
 extern void mplayer_put_key(int code);
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src, unsigned char *srca, int stride)
 {
 	switch (image_format)
 	{
 		case IMGFMT_RGB32:
-			vo_draw_alpha_rgb32(w,h,src,srca,stride,image_data+4*(y0*image_width+x0),4*image_width);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,image_data+4*(y0*image_width+x0),4*image_width);
 			break;
 		case IMGFMT_YUY2:
-			vo_draw_alpha_yuy2(w,h,src,srca,stride,image_data + (x0 + y0 * image_width) * 2,image_width*2);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,image_data + (x0 + y0 * image_width) * 2,image_width*2);
 			break;
 	}
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_quartz.c MPlayer-1.0rc1/libvo/vo_quartz.c
--- MPlayer-1.0rc1.orig/libvo/vo_quartz.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_quartz.c	2006-12-04 00:10:44.000000000 +0100
@@ -129,7 +129,7 @@
 #include "osdep/keycodes.h"
 
 extern void mplayer_put_key(int code);
-extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 
 //PROTOTYPE/////////////////////////////////////////////////////////////////
 static OSStatus KeyEventHandler(EventHandlerCallRef nextHandler, EventRef event, void *userData);
@@ -194,23 +194,23 @@
     }
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src, unsigned char *srca, int stride)
 {
 	switch (image_format)
 	{
 		case IMGFMT_RGB32:
-			vo_draw_alpha_rgb32(w,h,src,srca,stride,image_data+4*(y0*imgRect.right+x0),4*imgRect.right);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,image_data+4*(y0*imgRect.right+x0),4*imgRect.right);
 			break;
 		case IMGFMT_YV12:
 		case IMGFMT_IYUV:
 		case IMGFMT_I420:
-			vo_draw_alpha_yv12(w,h,src,srca,stride, ((char*)P) + P->componentInfoY.offset + x0 + y0 * imgRect.right, imgRect.right);
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride, ((char*)P) + P->componentInfoY.offset + x0 + y0 * imgRect.right, imgRect.right);
 			break;
 		case IMGFMT_UYVY:
-			vo_draw_alpha_uyvy(w,h,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
+			vo_draw_alpha_uyvy(w,h,dp,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
 			break;
 		case IMGFMT_YUY2:
-			vo_draw_alpha_yuy2(w,h,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((char*)P) + (x0 + y0 * imgRect.right) * 2,imgRect.right*2);
 			break;
 	}
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_sdl.c MPlayer-1.0rc1/libvo/vo_sdl.c
--- MPlayer-1.0rc1.orig/libvo/vo_sdl.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_sdl.c	2006-12-04 00:10:44.000000000 +0100
@@ -286,7 +286,7 @@
  *
  **/
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 	struct sdl_priv_s *priv = &sdl_priv;
 	
     if(priv->osd_has_changed) {
@@ -327,16 +327,43 @@
 		case IMGFMT_YV12:  
 		case IMGFMT_I420:
         	case IMGFMT_IYUV:
-            vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+		    switch (dp) {
+			case DEST_PLANES_Y :
+			    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			    break;
+			case DEST_PLANES_U :
+			    SDL_OVR_LOCK(-1)
+			    if (priv->format==IMGFMT_YV12)
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[1]))+priv->overlay->pitches[1]*y0+x0,priv->overlay->pitches[1]);
+				else
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[2]))+priv->overlay->pitches[2]*y0+x0,priv->overlay->pitches[2]);
+			    SDL_OVR_UNLOCK
+			    break;
+			case DEST_PLANES_V :
+			    SDL_OVR_LOCK(-1)
+			    if (priv->format==IMGFMT_YV12)
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[2]))+priv->overlay->pitches[2]*y0+x0,priv->overlay->pitches[2]);
+				else
+				vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) (priv->overlay->pixels[1]))+priv->overlay->pitches[1]*y0+x0,priv->overlay->pitches[1]);
+			    SDL_OVR_UNLOCK
+			    break;
+			}
 		break;
 		case IMGFMT_YUY2:
         	case IMGFMT_YVYU:
                 x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+		switch (dp) {
+		    case DEST_PLANES_Y :
+			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			break;
+		    case DEST_PLANES_YUYV :
+			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+			break;
+		    }
 		break;	
         	case IMGFMT_UYVY:
                 x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+    			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
 		break;
 
 		default:
@@ -345,19 +372,19 @@
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		}
         }
@@ -366,19 +393,19 @@
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		}
         }
@@ -1729,6 +1756,18 @@
 	mp_msg(MSGT_VO,MSGL_DBG2, "SDL: Set fullscreen mode\n"); }
     }
     return VO_TRUE;
+  case VOCTRL_YUVSPU_SUPPORT:
+    if (priv->format == IMGFMT_YV12 || priv->format == IMGFMT_I420 || priv->format==IMGFMT_IYUV) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_YUYSPU_SUPPORT:
+    if (priv->format==IMGFMT_YUY2) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    if (priv->mode == RGB) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (priv->mode == BGR) return VO_TRUE;
+    return VO_FALSE;
   }
 
   return VO_NOTIMPL;
diff -Nur MPlayer-1.0rc1.orig/libvo/vosub_vidix.c MPlayer-1.0rc1/libvo/vosub_vidix.c
--- MPlayer-1.0rc1.orig/libvo/vosub_vidix.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vosub_vidix.c	2006-12-04 00:10:44.000000000 +0100
@@ -283,7 +283,7 @@
   }	
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t apitch,bespitch;
     void *lvo_mem;
@@ -297,36 +297,57 @@
     case IMGFMT_IF09:
     case IMGFMT_Y8:
     case IMGFMT_Y800:
+	switch (dp) {
+	  case DEST_PLANES_Y:
 	bespitch = (vidix_play.src.w + apitch) & (~apitch);
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+           vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+	  break;
+	  case DEST_PLANES_U:
+	     lvo_mem = vidix_mem + vidix_play.offsets[next_frame] + vidix_play.offset.u;
+	     lvo_mem += dstrides.u*y0/2 + x0;
+	     vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem,dstrides.u/2);
+	  break;
+	  case DEST_PLANES_V:
+	     lvo_mem = vidix_mem + vidix_play.offsets[next_frame] + vidix_play.offset.v;
+	     lvo_mem += dstrides.v*y0/2 + x0;
+	     vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem,dstrides.v/2);
+	  break;
+	  }
         break;
     case IMGFMT_YUY2:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+	switch (dp) {
+	case DEST_PLANES_Y:
+          vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+	  break;
+	case DEST_PLANES_YUYV:
+           vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+	  break;
+	  }
         break;
     case IMGFMT_UYVY:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
         break;
     case IMGFMT_RGB32:
     case IMGFMT_BGR32:
 	bespitch = (vidix_play.src.w*4 + apitch) & (~apitch);
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
         break;
     case IMGFMT_RGB24:
     case IMGFMT_BGR24:
 	bespitch = (vidix_play.src.w*3 + apitch) & (~apitch);
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
         break;
     case IMGFMT_RGB16:
     case IMGFMT_BGR16:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     case IMGFMT_RGB15:
     case IMGFMT_BGR15:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     default:
 	return;
@@ -512,7 +533,7 @@
 	    next_frame = i;
 	    memset(vidix_mem + vidix_play.offsets[i], 0x80,
 		vidix_play.frame_size);
-	    draw_alpha(0, 0, image_width, image_height, tmp, tmpa, image_width);
+	    draw_alpha(0, 0, image_width, image_height, DEST_PLANES_Y, tmp, tmpa, image_width);
 	}
 	free(tmp);
 	free(tmpa);
@@ -700,6 +721,16 @@
 
     return VO_TRUE;
   }
+  case VOCTRL_YUVSPU_SUPPORT:
+    if((vidix_play.fourcc==IMGFMT_YV12 || vidix_play.fourcc==IMGFMT_YV12 || vidix_play.fourcc==IMGFMT_IYUV ||
+	vidix_play.fourcc==IMGFMT_I420 || vidix_play.fourcc==IMGFMT_YVU9 || vidix_play.fourcc==IMGFMT_IF09 ||
+	vidix_play.fourcc==IMGFMT_Y8 || vidix_play.fourcc==IMGFMT_Y800) &&
+	!(vidix_play.flags & VID_PLAY_INTERLEAVED_UV)) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_YUYSPU_SUPPORT:
+    if((vidix_play.fourcc==IMGFMT_YUY2) &&
+	!(vidix_play.flags & VID_PLAY_INTERLEAVED_UV)) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
   // WARNING: we drop extra parameters (...) here!
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_vesa.c MPlayer-1.0rc1/libvo/vo_vesa.c
--- MPlayer-1.0rc1.orig/libvo/vo_vesa.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_vesa.c	2006-12-04 00:10:44.000000000 +0100
@@ -46,6 +46,7 @@
 #include "vosub_vidix.h"
 #endif
 #include "mp_msg.h"
+#include "help_mp.h"
 
 #include "libswscale/swscale.h"
 #include "libmpcodecs/vf_scale.h"
@@ -107,7 +108,7 @@
 static unsigned video_mode; /* selected video mode for playback */
 static struct VesaModeInfoBlock video_mode_info;
 static int flip_trigger = 0;
-static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 /* multibuffering */
 uint8_t*  video_base; /* should be never changed */
@@ -295,7 +296,7 @@
 /* Please comment it out if you want have OSD within movie */
 /*#define OSD_OUTSIDE_MOVIE 1*/
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -305,10 +306,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
 }
 
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -318,10 +319,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
 }
 
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -331,10 +332,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
 }
 
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -344,15 +345,16 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
@@ -1100,6 +1102,14 @@
   switch (request) {
   case VOCTRL_QUERY_FORMAT:
     return query_format(*((uint32_t*)data));
+  case VOCTRL_YUVSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (dstFourcc == IMGFMT_BGR15 || dstFourcc == IMGFMT_BGR16 || dstFourcc == IMGFMT_BGR24 ||
+	    dstFourcc == IMGFMT_BGR32 || dstFourcc == IMGFMT_BGR16) return VO_TRUE;
+    return VO_FALSE;
   }
 
 #ifdef CONFIG_VIDIX
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_x11.c MPlayer-1.0rc1/libvo/vo_x11.c
--- MPlayer-1.0rc1.orig/libvo/vo_x11.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_x11.c	2006-12-04 00:10:44.000000000 +0100
@@ -61,7 +61,7 @@
 LIBVO_EXTERN(x11)
 /* private prototypes */
 static void Display_Image(XImage * myximage, unsigned char *ImageData);
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
@@ -106,39 +106,39 @@
 
 }
 
-static void draw_alpha_32(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_32(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb32(w, h, src, srca, stride,
+    vo_draw_alpha_rgb32(w, h, dp, src, srca, stride,
                         ImageData + 4 * (y0 * image_width + x0),
                         4 * image_width);
 }
 
-static void draw_alpha_24(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_24(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb24(w, h, src, srca, stride,
+    vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
                         ImageData + 3 * (y0 * image_width + x0),
                         3 * image_width);
 }
 
-static void draw_alpha_16(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_16(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb16(w, h, src, srca, stride,
+    vo_draw_alpha_rgb16(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_15(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_15(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb15(w, h, src, srca, stride,
+    vo_draw_alpha_rgb15(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
@@ -796,6 +796,14 @@
                 vo_x11_clearwindow(mDisplay, vo_window);
             }
             return VO_TRUE;
+        case VOCTRL_YUVSPU_SUPPORT:
+            return VO_FALSE;
+        case VOCTRL_RGBSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_BGRSPU_SUPPORT:
+	    if (out_format == IMGFMT_BGR15 || out_format == IMGFMT_BGR16 ||
+		out_format == IMGFMT_BGR24 || out_format == IMGFMT_BGR32) return VO_TRUE;
+	    return VO_FALSE;
     }
     return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_xv.c MPlayer-1.0rc1/libvo/vo_xv.c
--- MPlayer-1.0rc1.orig/libvo/vo_xv.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_xv.c	2006-12-04 00:10:44.000000000 +0100
@@ -92,47 +92,83 @@
 static uint32_t dwidth, dheight;
 static uint32_t max_width = 0, max_height = 0; // zero means: not set
 
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static int support_yuvspu = VO_FALSE;
+static int support_yuyspu = VO_FALSE;
+
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
-static void draw_alpha_yv12(int x0, int y0, int w, int h,
+static void draw_alpha_yv12(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+    switch (dp)  {
+	case DEST_PLANES_U:  {
+    x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[1] +
+                       xvimage[current_buf]->pitches[1] * y0 + x0,
+                       xvimage[current_buf]->pitches[1]);
+	  break; }
+	case DEST_PLANES_V:  {
+    x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[2] +
+                       xvimage[current_buf]->pitches[2] * y0 + x0,
+                       xvimage[current_buf]->pitches[2]);
+	  break; }
+	case DEST_PLANES_Y: {
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yv12(w, h, src, srca, stride,
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + x0,
                        xvimage[current_buf]->pitches[0]);
 }
+	}
 
-static void draw_alpha_yuy2(int x0, int y0, int w, int h,
+}
+
+static void draw_alpha_yuy2(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+  switch (dp) {
+    case DEST_PLANES_Y:
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
                        xvimage[current_buf]->pitches[0]);
+    break;
+    case DEST_PLANES_YUYV:
+    x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                       xvimage[current_buf]->data +
+                       xvimage[current_buf]->offsets[0] +
+                       xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
+                       xvimage[current_buf]->pitches[0]);
+    break;
+    }
 }
 
-static void draw_alpha_uyvy(int x0, int y0, int w, int h,
+static void draw_alpha_uyvy(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0 + 1,
                        xvimage[current_buf]->pitches[0]);
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
@@ -386,11 +422,13 @@
     {
         case IMGFMT_YV12:
         case IMGFMT_I420:
+	    support_yuvspu = VO_TRUE;
         case IMGFMT_IYUV:
             draw_alpha_fnc = draw_alpha_yv12;
             break;
         case IMGFMT_YUY2:
         case IMGFMT_YVYU:
+	    support_yuyspu = VO_TRUE;
             draw_alpha_fnc = draw_alpha_yuy2;
             break;
         case IMGFMT_UYVY:
@@ -1008,6 +1046,14 @@
         case VOCTRL_ONTOP:
             vo_x11_ontop();
             return VO_TRUE;
+        case VOCTRL_YUVSPU_SUPPORT:
+            return support_yuvspu;
+        case VOCTRL_RGBSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_BGRSPU_SUPPORT:
+	    return VO_FALSE;
+        case VOCTRL_YUYSPU_SUPPORT:
+            return support_yuyspu;
     }
     return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_xvmc.c MPlayer-1.0rc1/libvo/vo_xvmc.c
--- MPlayer-1.0rc1.orig/libvo/vo_xvmc.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_xvmc.c	2006-12-04 00:10:44.000000000 +0100
@@ -86,12 +86,12 @@
 static int free_element;
 
 
-static void (*draw_osd_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_osd_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void (*clear_osd_fnc)(int x0,int y0, int w,int h);
 static void (*init_osd_fnc)(void);
 
-static void   draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
-static void   draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void   clear_osd_subpic(int x0,int y0, int w,int h);
 static void   init_osd_yuv_pal(void);
 
@@ -881,7 +881,7 @@
    subpicture_alloc = 1;
 }
 
-static void draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 int ox,oy;
 int rez;
 
@@ -901,7 +901,7 @@
    }
 }
 
-static void draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 int ox,oy;
 int rez;
    if(  mp_msg_test(MSGT_VO,MSGL_DBG4) )
diff -Nur MPlayer-1.0rc1.orig/libvo/vo_yuv4mpeg.c MPlayer-1.0rc1/libvo/vo_yuv4mpeg.c
--- MPlayer-1.0rc1.orig/libvo/vo_yuv4mpeg.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/vo_yuv4mpeg.c	2006-12-04 00:10:44.000000000 +0100
@@ -179,25 +179,37 @@
 	}
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride) {
 	switch (using_format)
 	{
     	case IMGFMT_YV12:
-	    	vo_draw_alpha_yv12(w, h, src, srca, stride, 
+	    switch (dp) {
+		case DEST_PLANES_Y:
+		    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
 				       image + y0 * image_width + x0, image_width);
 			break;
+		case DEST_PLANES_U:
+		    if (image_u) vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+				image_u + y0 * image_width + x0, image_width);
+		    break;
+		case DEST_PLANES_V:
+		    if (image_v) vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+				image_v + y0 * image_width + x0, image_width);
+		    break;
+		}
+			break;
 		
 		case IMGFMT_BGR|24:
 		case IMGFMT_RGB|24:
 			if (config_interlace != Y4M_ILACE_BOTTOM_FIRST)
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width + x0) * 3, image_width * 3);
 			else
 			{
 				swap_fields (rgb_buffer, image_height, image_width * 3);
 
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width  + x0) * 3, image_width * 3);
 				
 				swap_fields (rgb_buffer, image_height, image_width * 3);
@@ -543,6 +555,15 @@
     return query_format(*((uint32_t*)data));
   case VOCTRL_DUPLICATE_FRAME:
     return write_last_frame();
+  case VOCTRL_YUVSPU_SUPPORT:
+    if (using_format==IMGFMT_YV12) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_RGBSPU_SUPPORT:
+    if (using_format==IMGFMT_RGB|24) return VO_TRUE;
+    return VO_FALSE;
+  case VOCTRL_BGRSPU_SUPPORT:
+    if (using_format==IMGFMT_BGR|24) return VO_TRUE;
+    return VO_FALSE;
   }
   return VO_NOTIMPL;
 }
diff -Nur MPlayer-1.0rc1.orig/libvo/x11_common.c MPlayer-1.0rc1/libvo/x11_common.c
--- MPlayer-1.0rc1.orig/libvo/x11_common.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/libvo/x11_common.c	2006-12-04 00:10:44.000000000 +0100
@@ -64,6 +64,9 @@
 #define WIN_LAYER_ABOVE_DOCK             10
 
 extern int enable_mouse_movements;
+#ifdef USE_DVDNAV
+extern int enable_dvdnav_mouse_movements;
+#endif
 int fs_layer = WIN_LAYER_ABOVE_DOCK;
 static int orig_layer = 0;
 static int old_gravity = NorthWestGravity;
@@ -1085,7 +1088,11 @@
                 }
                 break;
             case MotionNotify:
+#ifdef USE_DVDNAV
+                if(enable_mouse_movements || enable_dvdnav_mouse_movements)
+#else
                 if(enable_mouse_movements)
+#endif
                 {
                     char cmd_str[40];
                     sprintf(cmd_str,"set_mouse_pos %i %i",Event.xmotion.x, Event.xmotion.y);
@@ -1128,6 +1135,14 @@
                     mouse_waiting_hide = 1;
                     mouse_timer = GetTimerMS();
                 }
+#ifdef USE_DVDNAV
+                if(enable_dvdnav_mouse_movements)
+                {
+                    char cmd_str[40];
+                    sprintf(cmd_str,"set_mouse_button %i",Event.xbutton.button - 1);
+                    mp_input_queue_cmd(mp_input_parse_cmd(cmd_str));
+                }
+#endif
 #ifdef HAVE_NEW_GUI
                 // Ignor mouse button 1 - 3 under gui 
                 if (use_gui && (Event.xbutton.button >= 1)
diff -Nur MPlayer-1.0rc1.orig/Makefile MPlayer-1.0rc1/Makefile
--- MPlayer-1.0rc1.orig/Makefile	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/Makefile	2006-12-04 00:10:44.000000000 +0100
@@ -192,6 +192,9 @@
 ifeq ($(DVDKIT2),yes)
 PARTS += libmpdvdkit2
 endif
+ifeq ($(LIBMPDVDNAV),yes)
+PARTS += libmpdvdnav
+endif
 ifeq ($(GUI),yes)
 PARTS += Gui
 endif
@@ -265,6 +268,10 @@
 COMMON_DEPS += Gui/libgui.a
 GUI_LIBS = Gui/libgui.a $(GTK_LIBS)
 endif
+ifeq ($(LIBMPDVDNAV),yes)
+COMMON_DEPS += libmpdvdnav/libmpdvdnav.a
+COMMON_LIBS += libmpdvdnav/libmpdvdnav.a
+endif
 
 .SUFFIXES: .cc .c .o
 
@@ -281,6 +288,9 @@
 libmpdvdkit2/libmpdvdkit.a:
 	$(MAKE) -C libmpdvdkit2
 
+libmpdvdnav/libmpdvdnav.a:
+	$(MAKE) -C libmpdvdnav
+
 loader/libloader.a:
 	$(MAKE) -C loader
 
diff -Nur MPlayer-1.0rc1.orig/mencoder.c MPlayer-1.0rc1/mencoder.c
--- MPlayer-1.0rc1.orig/mencoder.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/mencoder.c	2006-12-04 00:10:44.000000000 +0100
@@ -62,6 +62,7 @@
 #include "libmpcodecs/mp_image.h"
 #include "libmpcodecs/dec_audio.h"
 #include "libmpcodecs/dec_video.h"
+#include "libmpcodecs/vd_videostill.h"
 #include "libmpcodecs/vf.h"
 
 // for MPEGLAYER3WAVEFORMAT:
@@ -503,7 +504,7 @@
 if (frameno_filename) {
   stream2=open_stream(frameno_filename,0,&i);
   if(stream2){
-    demuxer2=demux_open(stream2,DEMUXER_TYPE_AVI,-1,-1,-2,NULL);
+    demuxer2=demux_open(stream2,DEMUXER_TYPE_AVI,-1,-1,-2,NULL,0);
     if(demuxer2) mp_msg(MSGT_MENCODER, MSGL_INFO, MSGTR_UsingPass3ControlFile, frameno_filename);
     else mp_msg(MSGT_DEMUXER,MSGL_ERR,MSGTR_FormatNotRecognized);
   }
@@ -584,7 +585,7 @@
   if(demuxer2) audio_id=-2; /* do NOT read audio packets... */
 
   //demuxer=demux_open(stream,file_format,video_id,audio_id,dvdsub_id);
-  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename);
+  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,0);
   if(!demuxer){
     mp_msg(MSGT_DEMUXER, MSGL_FATAL, MSGTR_FormatNotRecognized);
     mp_msg(MSGT_DEMUXER, MSGL_FATAL, MSGTR_CannotOpenDemuxer);
diff -Nur MPlayer-1.0rc1.orig/mplayer.c MPlayer-1.0rc1/mplayer.c
--- MPlayer-1.0rc1.orig/mplayer.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/mplayer.c	2006-12-04 00:10:44.000000000 +0100
@@ -87,6 +87,9 @@
 int player_idle_mode=0;
 int quiet=0;
 int enable_mouse_movements=0;
+#ifdef USE_DVDNAV
+int enable_dvdnav_mouse_movements=0;
+#endif
 
 #ifdef WIN32
 char * proc_priority=NULL;
@@ -187,6 +190,9 @@
 
 #include "libmpcodecs/dec_audio.h"
 #include "libmpcodecs/dec_video.h"
+#ifdef USE_DVDNAV
+#include "libmpcodecs/vd_videostill.h"
+#endif
 #include "libmpcodecs/mp_image.h"
 #include "libmpcodecs/vf.h"
 #include "libmpcodecs/vd.h"
@@ -414,12 +420,23 @@
 edl_record_ptr edl_records = NULL; ///< EDL entries memory area
 edl_record_ptr next_edl_record = NULL; ///< only for traversing edl_records
 short user_muted = 0; ///< Stores whether user wanted muted mode.
+short sw_muted = 0; ///< Stores whether switch stream is currently is muted mode.
 short edl_muted  = 0; ///< Stores whether EDL is currently in muted mode.
 short edl_decision = 0; ///< 1 when an EDL operation has been made.
 FILE* edl_fd = NULL; ///< fd to write to when in -edlout mode.
 float begin_skip = MP_NOPTS_VALUE; ///< start time of the current skip while on edlout mode
 int use_filedir_conf;
 
+#ifdef USE_DVDNAV
+int dvdnav_wait = 0;
+int dvdnav_still = 0;
+int dvdnav_decodeok = 0;
+int dvdnav_seek_counter = 0;
+int dvdnav_menu_visible = 0;
+int dvdnav_color_spu_flg = -1;
+unsigned int dvdnav_activate_timer = 0;
+#endif
+
 static unsigned int inited_flags=0;
 #define INITED_VO 1
 #define INITED_AO 2
@@ -1769,7 +1786,7 @@
         return M_PROPERTY_NOT_IMPLEMENTED;
     }
 
-    if (edl_muted) return M_PROPERTY_DISABLED;
+    if (edl_muted || sw_muted) return M_PROPERTY_DISABLED;
     user_muted = 0;
 
     switch(action) {
@@ -1809,13 +1826,13 @@
         return 1;
     case M_PROPERTY_STEP_UP:
     case M_PROPERTY_STEP_DOWN:
-        if(edl_muted) return M_PROPERTY_DISABLED;
+        if(edl_muted || sw_muted) return M_PROPERTY_DISABLED;
         mixer_mute(&mixer);
         user_muted = mixer.muted;
         return 1;
     case M_PROPERTY_PRINT:
         if(!arg) return 0;
-        if(edl_muted) {
+        if(edl_muted || sw_muted) {
             *(char**)arg = strdup(MSGTR_EnabledEdl);
             return 1;
         }
@@ -2224,7 +2241,19 @@
 #ifdef USE_DVDREAD
         if (vo_spudec && dvdsub_id >= 0) {
             char lang[3];
-            int code = dvd_lang_from_sid(stream, dvdsub_id);
+	    int code;
+#ifdef USE_DVDNAV
+	    if(stream->type==STREAMTYPE_DVDNAV)
+	      {
+	      code = dvdsub_id;
+	      if (stream_control(demuxer->stream, STREAM_CTRL_LANG_FROM_SID, &code)!=
+	        STREAM_OK) code=0;
+//	      code = dvdnav_lang_from_sid((dvdnav_priv_t*)(stream->priv),
+//		    dvdsub_id);
+	      }
+	    else
+#endif
+            code = dvd_lang_from_sid(stream, dvdsub_id);
                 lang[0] = code >> 8;
                 lang[1] = code;
                 lang[2] = 0;
@@ -2303,6 +2332,12 @@
                 spudec_reset(vo_spudec);
             }
 #endif
+#ifdef USE_DVDNAV
+            if (vo_spudec && stream->type == STREAMTYPE_DVDNAV) {
+                d_dvdsub->id = dvdsub_id;
+                spudec_reset(vo_spudec);
+            }
+#endif
 #ifdef HAVE_OGGVORBIS
             if (demuxer->type == DEMUXER_TYPE_OGG)
                 d_dvdsub->id = demux_ogg_sub_id(demuxer, dvdsub_id);
@@ -2350,6 +2385,15 @@
         spudec_reset(vo_spudec);
     }
 #endif
+#ifdef USE_DVDNAV
+    if (vo_spudec && stream->type == STREAMTYPE_DVDNAV &&
+	    dvdsub_id < 0 && reset_spu)
+      {
+      dvdsub_id = -2;
+      d_dvdsub->id = dvdsub_id;
+      spudec_reset(vo_spudec);
+      }
+#endif
 
     return 1;
 }
@@ -3585,7 +3629,12 @@
 //============ Open DEMUXERS --- DETECT file type =======================
 current_module="demux_open";
 
-demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename);
+#ifdef USE_DVDNAV
+if (stream->type==STREAMTYPE_DVDNAV)
+  demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,1);
+  else
+#endif
+demuxer=demux_open(stream,file_format,audio_id,video_id,dvdsub_id,filename,0);
 
 // HACK to get MOV Reference Files working
 
@@ -3835,6 +3884,22 @@
 			    sh_video->disp_w, sh_video->disp_h);
 }
 #endif
+#ifdef USE_DVDNAV
+if (vo_spudec==NULL && stream->type==STREAMTYPE_DVDNAV) {
+    current_module="spudec_init_dvdnav";
+//  vo_spudec=spudec_new_scaled(
+//	dvdnav_stream_get_palette((dvdnav_priv_t*)(stream->priv)),
+//	sh_video->disp_w,
+//	sh_video->disp_h);
+  unsigned int palette=0;
+  stream_control(stream,STREAM_CTRL_GET_PALETTE,&palette);
+  vo_spudec=spudec_new_scaled(
+	palette,
+	sh_video->disp_w,
+	sh_video->disp_h);
+}
+if (dvdsub_id>=0 && stream->type==STREAMTYPE_DVDNAV) dvdnav_go_spu=2;
+#endif
 
 if ((vo_spudec == NULL) && (demuxer->type == DEMUXER_TYPE_MATROSKA) &&
     (d_dvdsub->sh != NULL) && (((sh_sub_t *)d_dvdsub->sh)->type == 'v')) {
@@ -3984,6 +4049,10 @@
     }
 }
 
+#ifdef USE_DVDNAV
+if(stream->type==STREAMTYPE_DVDNAV) enable_dvdnav_mouse_movements=1; else enable_dvdnav_mouse_movements=0;
+#endif
+
 vf_vo_data.vo = video_out;
 current_module="init_video_filters";
 {
@@ -4178,6 +4247,45 @@
 
 mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_StartPlaying);fflush(stdout);
 
+#ifdef USE_DVDNAV
+if (stream->type==STREAMTYPE_DVDNAV) {
+//  dvdnav_stream_fullstart((dvdnav_priv_t *)stream->priv);
+  stream_control(stream,STREAM_CTRL_FULL_START,NULL);  
+//  dvdnav_set_language(
+//	(dvdnav_priv_t *)stream->priv, dvdsub_lang, audio_lang, NULL);
+  stream_control(stream,STREAM_CTRL_SET_ALANG,&audio_lang);  
+  stream_control(stream,STREAM_CTRL_SET_SLANG,&dvdsub_lang);  
+//  stream_control(stream,STREAM_CTRL_SET_MLANG,NULL);  
+  clearsmpi(); /* clear correct still image */
+if(stream->type==STREAMTYPE_DVDNAV) {
+  current_module="dvdnav lang->id";
+  struct dvd_idfromlang_st dvd_idfromlang;
+  dvd_idfromlang.lang=audio_lang;
+  dvd_idfromlang.id=0;
+  if(audio_lang && audio_id==-1)
+//    audio_id=dvdnav_aid_from_lang((dvdnav_priv_t*)(stream->priv),audio_lang);
+ if (stream_control(stream,STREAM_CTRL_AID_FROM_LANG,&dvd_idfromlang)==STREAM_OK)
+   audio_id=dvd_idfromlang.id;
+  if (sh_audio && audio_id>=0) dvdnav_go_audio=1;
+  if(dvdsub_lang && dvdsub_id==-2) dvdsub_id=-1;
+
+  dvd_idfromlang.lang=dvdsub_lang;
+  dvd_idfromlang.id=0;
+  if(dvdsub_lang && dvdsub_id==-1)
+//    dvdsub_id=dvdnav_sid_from_lang((dvdnav_priv_t*)(stream->priv),dvdsub_lang);
+ if (stream_control(stream,STREAM_CTRL_SID_FROM_LANG,&dvd_idfromlang)==STREAM_OK)
+   dvdsub_id=dvd_idfromlang.id;
+  if (dvdsub_id>=0) dvdnav_go_spu=1;
+  global_sub_indices[SUB_SOURCE_DEMUX] = global_sub_size; // the global # of the first demux-specific sub.
+  int number_of_subs=0;
+//  global_sub_size += dvdnav_number_of_subs((dvdnav_priv_t*)(stream->priv));
+  if (stream_control(stream,STREAM_CTRL_NUMBER_OF_SUBS,&number_of_subs)==STREAM_OK)
+  global_sub_size += number_of_subs;
+  current_module=NULL;
+  }
+}
+#endif
+
 total_time_usage_start=GetTimer();
 audio_time_usage=0; video_time_usage=0; vout_time_usage=0;
 total_frame_cnt=0; drop_frame_cnt=0; // fix for multifile fps benchmark
@@ -4285,6 +4393,9 @@
   vo_pts=sh_video->timer*90000.0;
   vo_fps=sh_video->fps;
 
+#ifdef USE_DVDNAV
+if (stream->type==STREAMTYPE_DVDNAV && dvdnav_still) frame_time_remaining=0;
+#endif
   if(!frame_time_remaining){
     //--------------------  Decode a frame: -----------------------
     blit_frame = 0; // Don't blit if we hit EOF
@@ -4330,6 +4441,21 @@
 	// decode:
 	current_module="decode_video";
 //	printf("Decode! %p  %d  \n",start,in_size);
+#ifdef USE_DVDNAV
+	if (stream->type==STREAMTYPE_DVDNAV)
+	  {
+	  dvdnav_decodeok=0;
+	  blit_frame=decode_video_still(sh_video,start,in_size,drop_frame,
+		MP_NOPTS_VALUE,1);
+	  if (!blit_frame && in_size>0)
+	    {
+	    if (vd_mpeg2_reset(sh_video,0))
+	      blit_frame=decode_video_still(sh_video,start,in_size,drop_frame,
+		    MP_NOPTS_VALUE,1);
+	    }
+	  if (blit_frame && in_size>0) dvdnav_decodeok=1;
+	  } else
+#endif
 	blit_frame=decode_video(sh_video,start,in_size,drop_frame, sh_video->pts);
 	break;
     }
@@ -4751,7 +4877,7 @@
        edl_decision = 1;
      } else if( next_edl_record->action == EDL_MUTE ) {
        edl_muted = !edl_muted;
-       if ((user_muted | edl_muted) != mixer.muted) mixer_mute(&mixer);
+       if ((user_muted | edl_muted || sw_muted) != mixer.muted) mixer_mute(&mixer);
        mp_msg(MSGT_CPLAYER, MSGL_DBG4, "EDL_MUTE: [%f]\n", next_edl_record->start_sec );
      }
      next_edl_record=next_edl_record->next;
@@ -4759,6 +4885,530 @@
   }
  }
 
+#ifdef USE_DVDNAV
+current_module="dvdnav_event";
+if (stream->type==STREAMTYPE_DVDNAV)
+  {
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.stop)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_STOP,NULL)==STREAM_OK)
+    {
+    eof=1;
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_MPDVDNAV_StopEvent);
+    } else {
+  int nav_menu = 0;
+
+  if (demuxer->audio->sh && !sh_audio)	// Hot init audio
+    {
+    d_audio=demuxer->audio;
+    sh_audio=d_audio->sh;
+    sh_audio->ds=d_audio;
+
+    current_module="hot init_audio_codec";
+    if(!init_best_audio_codec(sh_audio,audio_codec_list,audio_fm_list))
+      sh_audio=d_audio->sh=NULL; // failed to init :(
+      else
+      inited_flags|=INITED_ACODEC;
+//================ SETUP AUDIO ==========================
+
+    if(sh_audio){
+    //const ao_info_t *info=audio_out->info;
+      current_module="hot af_preinit";
+      ao_data.samplerate=force_srate;
+      ao_data.channels=0;
+      ao_data.format=audio_output_format;
+#if 1
+      // first init to detect best values
+      if(!preinit_audio_filters(sh_audio,
+	    // input:
+            (int)(sh_audio->samplerate*playback_speed),
+	    sh_audio->channels, sh_audio->sample_format,
+	    // output:
+	    &ao_data.samplerate, &ao_data.channels, &ao_data.format)){
+          mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_AudioFilterChainPreinitError);
+          exit_player(MSGTR_Exit_error);
+      }
+#endif
+    current_module="hot ao2_init";
+      if(!(audio_out=init_best_audio_out(audio_driver_list,
+	  0, // plugin flag
+          ao_data.samplerate,
+	  ao_data.channels,
+      ao_data.format,0))){
+        // FAILED:
+	mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_CannotInitAO);
+        uninit_player(INITED_ACODEC); // close codec
+	sh_audio=d_audio->sh=NULL; // -> nosound
+      } else {
+	// SUCCESS:
+        inited_flags|=INITED_AO;
+	mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "AO: [%s] %dHz %dch %s (%d bytes per sample)\n",
+            audio_out->info->short_name,
+	    ao_data.samplerate,
+	    ao_data.channels,
+            af_fmt2str_short(ao_data.format),
+	    af_fmt2bits(ao_data.format)/8 );
+        mp_msg(MSGT_CPLAYER,MSGL_V,
+	    "AO: Description: %s\nAO: Author: %s\n",
+	    audio_out->info->name,
+	    audio_out->info->author);
+        if(strlen(audio_out->info->comment) > 0)
+	  mp_msg(MSGT_CPLAYER,MSGL_V,
+	    "AO: Comment: %s\n",
+	    audio_out->info->comment);
+        // init audio filters:
+#if 1
+        current_module="hot af_init";
+	if(!build_afilter_chain(sh_audio, &ao_data)) {
+          mp_msg(MSGT_CPLAYER,MSGL_ERR,MSGTR_NoMatchingFilter);
+	}
+#endif
+      }
+    mixer.audio_out = audio_out;
+    mixer.volstep = volstep;
+    }
+  }
+  if (!sh_audio)
+    {
+    demuxer->audio->id=-1;
+    }	// force hot add audio
+  if (dvdnav_seek_counter && vd_decode_mp_preserve())
+    dvdnav_seek_counter=1;
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.wait)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_STOP,NULL)==STREAM_OK)
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_WaitEvent);
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.still_frame)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_STILL,NULL)==STREAM_OK)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_StillFrameEvent);
+    ds_free_packs(demuxer->audio);
+    ds_free_packs(demuxer->video);
+//    if (dvdnav_decodeok) dvdnav_seek_counter=1;
+    dvdnav_still=1;				// still mode on
+    }
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.vts_change)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS,NULL)==STREAM_OK)
+    {
+    dvdnav_still=0;				// still mode off
+    dvdnav_activate_timer=0;			// clear activate timer
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_VtsChangeEvent);
+//    if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+    if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)==STREAM_OK)
+      {
+//      audio_id=((dvdnav_priv_t*)(stream->priv))->alang;		// set new audio id
+      int id=0;
+      if (stream_control(stream,STREAM_CTRL_GET_AUDIO_ID,&id)==STREAM_OK)
+        audio_id=id;
+//      if (((dvdnav_priv_t*)(stream->priv))->slang==128)
+      id=128;
+      if (stream_control(stream,STREAM_CTRL_GET_DVDSUB_ID,&id)!=STREAM_OK)
+        id=128;
+      if (id==128)
+        {
+	dvdsub_id=-2;
+	d_dvdsub->id = dvdsub_id;
+	} else {
+	dvdsub_id=id;
+	d_dvdsub->id = dvdsub_id;
+	}
+      }		// set new sub id
+    dvdnav_seek_counter=5;
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) guiGetEvent( guiSetStream,(char *)stream );
+#endif
+    }
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.cell_change)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_CELL,NULL)==STREAM_OK)
+    {
+    dvdnav_still=0;				// still mode off
+    dvdnav_activate_timer=0;			// clear activate timer
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_CellChangeEvent);
+
+//    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain))
+    if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK)
+      {
+//      if (((dvdnav_priv_t*)(stream->priv))->event.cell_really_change)
+      if (stream_control(stream,STREAM_CTRL_DVDNAV_REALLY_CHANGE,NULL)==STREAM_OK)
+        dvdnav_seek_counter=5;
+      } else {
+//      if (((dvdnav_priv_t*)(stream->priv))->lasttitle!=
+//	    ((dvdnav_priv_t*)(stream->priv))->title)
+      if (stream_control(stream,STREAM_CTRL_DVDNAV_IS_NEW_TITLE,NULL)!=STREAM_OK)
+	{
+	dvdnav_seek_counter=2;
+//	audio_id=((dvdnav_priv_t*)(stream->priv))->alang;		// set new audio id
+	int id=0;
+	if (stream_control(stream,STREAM_CTRL_GET_AUDIO_ID,&id)==STREAM_OK)
+	  audio_id=id;
+//	if (((dvdnav_priv_t*)(stream->priv))->slang==128)
+	id=128;
+	if (stream_control(stream,STREAM_CTRL_GET_DVDSUB_ID,&id)!=STREAM_OK)
+	  id=128;
+	if (id==128)
+	  {
+	  dvdsub_id=-2;
+	  d_dvdsub->id = dvdsub_id;
+	  } else {
+	  dvdsub_id=id;
+	  d_dvdsub->id = dvdsub_id;
+	  }
+	}		// set new sub id
+      }
+//    ((dvdnav_priv_t*)(stream->priv))->lasttitle=
+//	    ((dvdnav_priv_t*)(stream->priv))->title;
+//    ((dvdnav_priv_t*)(stream->priv))->lastpart=
+//	    ((dvdnav_priv_t*)(stream->priv))->part;
+//    ((dvdnav_priv_t*)(stream->priv))->old_vts_domain=
+//	    ((dvdnav_priv_t*)(stream->priv))->vts_domain;
+    stream_control(stream,STREAM_CTRL_DVDNAV_TITLESET,NULL);
+    nav_menu=1;
+#ifdef HAVE_NEW_GUI
+    if ( use_gui ) guiGetEvent( guiSetStream,(char *)stream );
+#endif
+    }
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.spu_clut_change)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_SPU_CLUT,NULL)==STREAM_OK)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_SpuClutChangeEvent);
+    if (vo_spudec) {
+//      spudec_update_palette(vo_spudec,
+//		((dvdnav_priv_t*)(stream->priv))->event.spu_clut);
+      spu_clut_t spu_clut;
+      if (stream_control(stream,STREAM_CTRL_GET_SPU_CLUT,&spu_clut)==STREAM_OK)
+        spudec_update_palette(vo_spudec,spu_clut);
+//      if(!((dvdnav_priv_t*)(stream->priv))->vts_domain &&
+      if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK &&
+		(dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+		dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	{
+	spu_palette_t spu_palette;
+	if (stream_control(stream,STREAM_CTRL_GET_SPU_PALETTE,&spu_palette)==STREAM_OK)
+	  spudec_dvdnav_palette(vo_spudec,spu_palette);
+	vo_osd_changed(OSDTYPE_SPU);
+	}
+//      if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+      if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)==STREAM_OK)
+        spudec_reset(vo_spudec);
+      }
+    nav_menu=1;
+    }
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.highlight)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_HIGHLIGHT,NULL)==STREAM_OK)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_V,MSGTR_MPDVDNAV_HighlightEvent);
+// dvdnav menu button update
+    nav_menu=1;
+    }
+//  if (((dvdnav_priv_t*)(stream->priv))->event.eventflag.nav_packet)
+  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_NAV_PACKET,NULL)==STREAM_OK)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_DBG2,MSGTR_MPDVDNAV_NavPacketEvent);
+//    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain)) nav_menu=1;
+    if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK)
+      nav_menu=1;
+    }
+//  ((dvdnav_priv_t*)(stream->priv))->lasttitle=
+//	    ((dvdnav_priv_t*)(stream->priv))->title;
+//  ((dvdnav_priv_t*)(stream->priv))->lastpart=
+//	    ((dvdnav_priv_t*)(stream->priv))->part;
+//  ((dvdnav_priv_t*)(stream->priv))->old_vts_domain=
+//	    ((dvdnav_priv_t*)(stream->priv))->vts_domain;
+    stream_control(stream,STREAM_CTRL_DVDNAV_TITLESET,NULL);
+  d_video->eof=0;
+  d_audio->eof=0;
+  stream->eof=0;
+  demuxer->stream->eof=0;
+  demuxer->audio->eof=0;
+  demuxer->video->eof=0;
+
+// dvdnav event clear
+//  dvdnav_event_clear((dvdnav_priv_t*)(stream->priv));
+  stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_CLEAR,NULL);
+  if (dvdnav_menu_visible && dvdnav_force_menu)
+    {
+    if (!vo_spudec || !spudec_visible(vo_spudec))
+      {
+//      dvdnav_highlight_event_t highlight;
+//      dvdnav_get_highlight((dvdnav_priv_t*)(stream->priv),&highlight,1);
+      mp_highlight_t highlight;
+      stream_control(stream,STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_SHOW,&highlight);
+      dvdnav_box_area(highlight.sx,highlight.sy,highlight.ex,highlight.ey,
+	    1,0x7f,0x7f); /* set box button area & on */
+      vo_osd_changed(OSDTYPE_DVDNAV);
+      } else {
+      dvdnav_box_area(0,0,0,0,0,0x00,0x00);
+      vo_osd_changed(OSDTYPE_DVDNAV);
+      dvdnav_menu_visible=0;
+      }
+    }
+  if (dvdnav_activate_timer)
+    {
+// reset activate? (>1 sec)
+    if (GetTimer() > dvdnav_activate_timer + 1000000) nav_menu=1;
+    }
+  if (nav_menu)
+    {
+    if (dvdnav_color_spu_flg==-1)
+      {
+      dvdnav_color_spu_flg=0;
+      if (dvdnav_color_spu && video_out)
+	{
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_YUVSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_YUV;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_YUYSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_YUY;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_RGBSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_RGB;
+	if (!dvdnav_color_spu_flg &&
+		video_out->control(VOCTRL_BGRSPU_SUPPORT,NULL)==VO_TRUE)
+	  dvdnav_color_spu_flg=DVDNAV_SPU_BGR;
+	if (!dvdnav_color_spu_flg)
+	  mp_msg(MSGT_CPLAYER,MSGL_INFO,MSGTR_MPDVDNAV_NoColorSpu);
+	}
+      }
+    dvdnav_menu_visible=0;
+//    if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain))
+    if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK)
+      {
+// vts0 - set menu button
+//      dvdnav_highlight_event_t highlight;
+//      dvdnav_get_highlight((dvdnav_priv_t*)(stream->priv),&highlight,1);	/* get spu botton area & palette */
+      mp_highlight_t highlight;
+      stream_control(stream,STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_SHOW,&highlight);
+      if (vo_spudec && (dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	{
+	int menu_sid = 0;
+	stream_control(stream,STREAM_CTRL_DVDNAV_GET_MENU_SID,&menu_sid);
+//	if(d_dvdsub->id!=((dvdnav_priv_t*)(stream->priv))->menu_sid)
+	if(d_dvdsub->id!=menu_sid)
+	  {
+//	  d_dvdsub->id=((dvdnav_priv_t*)(stream->priv))->menu_sid;
+	  d_dvdsub->id=menu_sid;
+	  spudec_reset(vo_spudec);
+	  }
+	spudec_dvdnav_mode(vo_spudec, 1, dvdnav_color_spu_flg);	/* spu menu button on */
+	spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+		highlight.ey,highlight.palette); /* set spu button area & palette */
+	vo_osd_changed(OSDTYPE_SPU);
+	}
+	if (dvdnav_menutype==DVDNAV_MENUTYPE_BOX ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX)
+	{
+	dvdnav_box_area(highlight.sx,highlight.sy,highlight.ex,highlight.ey,
+		1,0x7f,0x7f); /* set box button area & on */
+	vo_osd_changed(OSDTYPE_DVDNAV);
+	}
+      if (dvdnav_menutype==DVDNAV_MENUTYPE_SPU && highlight.buttonN)
+        dvdnav_menu_visible=1;
+      } else {
+// reset spu info
+      global_sub_size = 0;
+      int i;
+      for (i = 0; i < SUB_SOURCES; i++)
+        global_sub_indices[i] = -1;
+//        global_sub_quiet_osd_hack = 1;
+      global_sub_indices[SUB_SOURCE_DEMUX] = global_sub_size; // the global # of the first demux-specific sub.
+//      global_sub_size += dvdnav_number_of_subs((dvdnav_priv_t*)(stream->priv));
+      int number_of_subs=0;
+      if (stream_control(stream,STREAM_CTRL_NUMBER_OF_SUBS,&number_of_subs)==STREAM_OK)
+	global_sub_size += number_of_subs;
+      if (dvdnav_menutype==DVDNAV_MENUTYPE_BOX ||
+	dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX)
+	{
+	dvdnav_box_area(0,0,0,0,0,0x00,0x00);	/* nav box button off */
+	vo_osd_changed(OSDTYPE_DVDNAV);
+	}
+      spudec_dvdnav_mode(vo_spudec, 0, 0);	/* spu menu button off */
+      spudec_reset(vo_spudec);
+      }
+    }
+//  if (dvdnav_seek_counter && (!((dvdnav_priv_t*)(stream->priv))->stillok))
+//  if (dvdnav_seek_counter && 
+//    stream_control(stream,STREAM_CTRL_DVDNAV_STILLOK,NULL)!=STREAM_OK)
+  if (dvdnav_seek_counter && 
+    stream_control(stream,STREAM_CTRL_DVDNAV_STILLOK,NULL)!=STREAM_OK)
+    {
+    sw_muted=1;
+    if (sh_audio && sw_muted != mixer.muted) mixer_mute(&mixer);
+//    if (((dvdnav_priv_t*)(stream->priv))->aspect!=
+//	    ((dvdnav_priv_t*)(stream->priv))->lastaspect && sh_video)
+      int aspect=0;
+      if (stream_control(stream,STREAM_CTRL_CHANGE_ASPECT,NULL)==STREAM_OK && sh_video &&
+        stream_control(stream,STREAM_CTRL_GET_ASPECT,&aspect))
+      {
+//      switch (((dvdnav_priv_t*)(stream->priv))->aspect)		/* set current ascpet */
+      switch (aspect)		/* set current ascpet */
+        {
+	case 0 :	// 4:3
+	  {
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: set aspect 4:3\n");
+#endif
+	  movie_aspect = (float) 4 / 3;
+	  mpcodecs_config_vo (sh_video, sh_video->disp_w, sh_video->disp_h, 0);
+	  break;
+	  }
+        case 3 :	// FIXME: 16:9???
+	case 2 :	// 16:9
+	  {
+#ifdef USE_MPDVDNAV_TRACE
+        if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: set aspect 16:9\n");
+#endif
+	movie_aspect = (float) 16 / 9;
+	mpcodecs_config_vo (sh_video, sh_video->disp_w, sh_video->disp_h, 0);
+	break;
+	}
+      default:
+        {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: unknow aspect %i\n",
+//		((dvdnav_priv_t*)(stream->priv))->aspect);
+		aspect);
+#endif
+	break;
+	}
+      }
+//    ((dvdnav_priv_t*)(stream->priv))->lastaspect=
+//	    ((dvdnav_priv_t*)(stream->priv))->aspect;
+    stream_control(stream,STREAM_CTRL_SYNC_ASPECT,NULL);
+    }
+    if (sh_audio)
+      {
+//      audio_id=((dvdnav_priv_t*)(stream->priv))->alang;
+      int id=0;
+      if (stream_control(stream,STREAM_CTRL_GET_AUDIO_ID,&id)==STREAM_OK)
+        audio_id=id;
+      int v = demuxer_switch_audio(demuxer, audio_id);
+      } // switch audio channel
+    rel_seek_secs = 0.00;
+    abs_seek_pos = 0;
+    if(sh_video) sh_video->pts=0.0f;
+//    ((dvdnav_priv_t*)(stream->priv))->lockseek=1;
+    int lockseek=1;
+    stream_control(stream,STREAM_CTRL_DVDNAV_SET_LOCKSEEK,&lockseek);
+    if(demux_seek(demuxer,rel_seek_secs,0.0,abs_seek_pos))
+      {	// demuxer reset???
+      rel_seek_secs = 0.00;
+      abs_seek_pos = 0;
+      if(sh_video)
+	{
+	current_module="seek_video_reset";
+	resync_video_stream(sh_video);
+	if(vo_config_count) video_out->control(VOCTRL_RESET,NULL);
+	sh_video->pts=0.0f;
+	sh_video->num_frames=0;
+	sh_video->num_frames_decoded=0;
+	sh_video->timer=0.0f;
+	sh_video->stream_delay=0.0f;
+	frame_time_remaining=0;
+	audio_delay=0.0f;
+	sh_video->timer=0;
+	audio_delay += sh_video->stream_delay;
+	}
+      if(sh_audio)
+        {
+	audio_delay -= sh_audio->stream_delay;
+	sh_audio->delay=-audio_delay;
+	current_module="seek_audio_reset";
+	audio_out->reset();
+	resync_audio_stream(sh_audio);
+	} // stop audio, throwing away buffered data
+      if(vo_spudec) spudec_reset(vo_spudec);
+      }
+    current_module="demuxer_update_time_pts";
+//    if (((dvdnav_priv_t*)(stream->priv))->vts_domain)
+    if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)==STREAM_OK)
+      {
+      uint32_t tlen=0;
+      float final_pts=0.0;
+      if (stream_control(stream,STREAM_CTRL_GET_FINALPTS,&final_pts)==STREAM_OK &&
+        stream_control(stream,STREAM_CTRL_GET_TLEN,&tlen)==STREAM_OK)
+	demuxer_update_time_pts(demuxer,
+		final_pts,
+		tlen*2048);
+//      demuxer_update_time_pts(demuxer,
+//		((dvdnav_priv_t*)(stream->priv))->final_pts,
+//		((dvdnav_priv_t*)(stream->priv))->tlen*2048);
+      } else {
+      demuxer_update_time_pts(demuxer, 0.0, 0);
+      }
+//    ((dvdnav_priv_t*)(stream->priv))->lockseek=0;
+    lockseek=0;
+    stream_control(stream,STREAM_CTRL_DVDNAV_SET_LOCKSEEK,&lockseek);
+    }
+  if (dvdnav_seek_counter) dvdnav_seek_counter--; else sw_muted=0;
+#ifdef HAVE_NEW_GUI
+//  if (!(((dvdnav_priv_t*)(stream->priv))->vts_domain) && sh_video)
+//  if (stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK && sh_video)
+//    {
+//    dvdnav_window_orig_width=sh_video->disp_w;		/* set original video window size */
+//    dvdnav_window_orig_height=sh_video->disp_h;		/* required on calculate mouse position */
+//    dvdnav_mouse((dvdnav_priv_t*)(stream->priv));	/* process mouse positon: set menu button */
+//    stream_control(stream,STREAM_CTRL_DVDNAV_MOUSE,NULL);
+//    }
+#endif
+// play to new title
+  if (dvdnav_go_title>0)
+    {
+//    dvdnav_title_play((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+//	    dvdnav_go_title);
+    stream_control(stream,STREAM_CTRL_DVDNAV_TITLE_PLAY,&dvdnav_go_title);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+// play to new chapter
+  if (dvdnav_go_part>0)
+    {
+//    dvdnav_part_play((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+//	    ((dvdnav_priv_t*)(stream->priv))->title, dvdnav_go_part);
+    stream_control(stream,STREAM_CTRL_DVDNAV_PART_PLAY,&dvdnav_go_part);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+// go main DVD menu
+  if (dvdnav_go_menu>0)
+    {
+//    dvdnav_menu_call((dvdnav_t*)((dvdnav_priv_t*)(stream->priv))->dvdnav,
+//	    DVD_MENU_Root);
+    int menu_call = DVD_MENUCALL_Root;    
+    stream_control(stream,STREAM_CTRL_DVDNAV_MENUCALL,&menu_call);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_audio=
+	    dvdnav_go_spu=0;
+    }
+  if (dvdnav_go_menu_force)
+    {
+//    dvdnav_menu_force((dvdnav_priv_t*)(stream->priv));	/* go main menu with skip intro */
+    stream_control(stream,STREAM_CTRL_DVDNAV_MENUFORCE,NULL);
+    dvdnav_go_title=dvdnav_go_part=dvdnav_go_menu=dvdnav_go_menu_force=
+	    dvdnav_go_audio=dvdnav_go_spu=0;
+    }
+// switch audio channel
+  if (dvdnav_go_audio)
+    {
+    if (sh_audio) demuxer_switch_audio(demuxer, audio_id);
+    dvdnav_go_audio=0;
+    }
+// switch spu subtitle
+  if (dvdnav_go_spu)
+    {
+    d_dvdsub->id = dvdsub_id;
+    if (vo_spudec)
+      {
+      spudec_reset(vo_spudec);
+      dvdnav_go_spu--;
+      }
+    }
+  }
+}
+#endif
+
 //================= Keyboard events, SEEKing ====================
 
   current_module="key_events";
@@ -5529,14 +6179,54 @@
         break;
     }
 #ifdef USE_DVDNAV
-    case MP_CMD_DVDNAV: {
+//    case MP_CMD_DVDNAV: {
+//      int button = -1;
+//      if(stream->type != STREAMTYPE_DVDNAV) break;
+//
+//      if(mp_dvdnav_handle_input(stream, cmd->args[0].v.i, &button)) {
+//          uninit_player(INITED_ALL-(INITED_STREAM|INITED_INPUT|(fixed_vo ? INITED_VO : 0)));
+//          goto goto_enable_cache;
+//      } else if(button>0) set_osd_msg(OSD_MSG_TEXT, 1, osd_duration, "Selected button number %d", button);
+//      break;
+//    }
+    case MP_CMD_SET_MOUSE_BUTTON: {
       int button = -1;
+        button = cmd->args[0].v.i;
+#ifdef USE_DVDNAV
+	int action = MP_CMD_DVDNAV_SELECT;
+        if(stream->type == STREAMTYPE_DVDNAV && button == 0) {
+	  if (vo_spudec && (dvdnav_menutype==DVDNAV_MENUTYPE_SPU ||
+	    dvdnav_menutype==DVDNAV_MENUTYPE_SPU_BOX))
+	    {
+	    mp_highlight_t highlight;
+	    stream_control(stream,STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_ACTIVATE,&highlight);
+	    spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+		highlight.ey,highlight.palette); /* set spu button area & palette */
+	    vo_osd_changed(OSDTYPE_SPU);
+	    dvdnav_activate_timer=GetTimer();
+	    }
+	  stream_control(stream,STREAM_CTRL_DVDNAV_MENU_ACTION,&action);
+        }
+#endif
+        break;
+    }
+     case MP_CMD_DVDNAV: {
+//      dvdnav_priv_t * dvdnav_priv=(dvdnav_priv_t*)stream->priv;
+/* ignore these events if we're not in dvd_nav mode */
       if(stream->type != STREAMTYPE_DVDNAV) break;
-
-      if(mp_dvdnav_handle_input(stream, cmd->args[0].v.i, &button)) {
-          uninit_player(INITED_ALL-(INITED_STREAM|INITED_INPUT|(fixed_vo ? INITED_VO : 0)));
-          goto goto_enable_cache;
-      } else if(button>0) set_osd_msg(OSD_MSG_TEXT, 1, osd_duration, "Selected button number %d", button);
+      switch (cmd->args[0].v.i) {
+         case MP_CMD_DVDNAV_SELECT:
+        case MP_CMD_DVDNAV_UP:
+        case MP_CMD_DVDNAV_DOWN:
+        case MP_CMD_DVDNAV_LEFT:
+        case MP_CMD_DVDNAV_RIGHT:
+        case MP_CMD_DVDNAV_MENU:
+//	  dvdnav_menu_action(dvdnav_priv, cmd->args[0].v.i);
+	  stream_control(stream,STREAM_CTRL_DVDNAV_MENU_ACTION,&cmd->args[0].v.i);
+	  break;
+        default:
+//          mp_msg(MSGT_CPLAYER, MSGL_V, "Weird DVD Nav cmd %d\n",cmd->args[0].v.i);
+          break; }
       break;
     }
 #endif
@@ -5666,7 +6356,7 @@
     next_edl_record = next_edl_record->next;
 
 }
-if ((user_muted | edl_muted) != mixer.muted) mixer_mute(&mixer);
+if ((user_muted || edl_muted) != mixer.muted) mixer_mute(&mixer);
 
   rel_seek_secs=0;
   abs_seek_pos=0;
@@ -5674,6 +6364,7 @@
   current_module=NULL;
   loop_seek=0;
 }
+if (sh_audio && !user_muted && !edl_muted && !sw_muted && mixer.muted) mixer_mute(&mixer);
 
 #ifdef HAVE_NEW_GUI
       if(use_gui){
@@ -5771,6 +6462,15 @@
   }
   
   /* detect wether the sub has changed or not */
+#ifdef USE_DVDNAV
+ /* still image now process data, because next frame reseek: delete read spu packet */
+  if(stream->type==STREAMTYPE_DVDNAV)
+    {
+//    if(dvdnav_still || !((dvdnav_priv_t*)(stream->priv))->vts_domain)
+    if (dvdnav_still || stream_control(stream,STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN,NULL)!=STREAM_OK)
+	spudec_heartbeat(vo_spudec,90000*sh_video->timer);
+    }
+#endif
   if(spudec_changed(vo_spudec))
     vo_osd_changed(OSDTYPE_SPU);
   current_module=NULL;
diff -Nur MPlayer-1.0rc1.orig/spudec.c MPlayer-1.0rc1/spudec.c
--- MPlayer-1.0rc1.orig/spudec.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/spudec.c	2006-12-04 00:10:44.000000000 +0100
@@ -92,6 +92,52 @@
   int spu_changed;
   unsigned int forced_subs_only;     /* flag: 0=display all subtitle, !0 display only forced subtitles */
   unsigned int is_forced_sub;         /* true if current subtitle is a forced subtitle */
+
+  packet_t *last_packet;
+  unsigned int widthuv, heightuv, strideuv;
+  unsigned int start_coluv, end_coluv;
+  unsigned int start_rowuv, end_rowuv;
+  size_t image_sizeuv;
+  size_t scaled_image_sizeuv;
+  size_t image_sizeyuy;
+
+  unsigned int scaled_frame_widthuv, scaled_frame_heightuv;
+  unsigned int scaled_start_coluv, scaled_start_rowuv;
+  unsigned int scaled_widthuv, scaled_heightuv, scaled_strideuv;
+  unsigned char *scaled_imageu;
+  unsigned char *scaled_imagev;
+  unsigned char *scaled_aimageuv;
+
+  unsigned int hpalette[4];
+  unsigned int halpha[4];
+  unsigned int hcuspal[4];
+
+  unsigned char *imageu;		/* u value from yUv */
+  unsigned char *imagev;		/* v value from yuV*/
+  unsigned char *aimageuv;		/* alpha with uv*/
+  unsigned char *imageyuy;		/* yuy2 */
+  unsigned char *aimageyuy;		/* alpha with yuy2*/
+  unsigned int strideyuy;
+
+  int dvdnav_color_spu;		/* flag: 0 = grayscale SPU, 1 = YUV color SPU 2 = RGB 3 = BGR */
+
+  int dvdnav_menu;		/* flag: 0=normal subtitle, 1=dvdnav menu */
+  unsigned int dvdnav_sx;	/* dvdnav menu item box */
+  unsigned int dvdnav_ex;
+  unsigned int dvdnav_sy;
+  unsigned int dvdnav_ey;
+  unsigned int dvdnav_modify;	/* dvdnav menu item box is modify */
+  uint32_t     dvdnav_palette;	/* dvdnav menu button palette */
+  unsigned int dvdnav_x0;	/* dvdnav menu item draw_alpha coordinates */
+  unsigned int dvdnav_y0;
+  unsigned int dvdnav_w;
+  unsigned int dvdnav_h;
+  unsigned char *dvdnav_image;	/* dvdnav menu item image */
+  unsigned char *dvdnav_aimage;	/* dvdnav menu item alpha */
+  unsigned int dvdnav_stride;
+  unsigned int dvdnav_allocated;
+  unsigned int dvdnav_scalex;
+  unsigned int dvdnav_scaley;
 } spudec_handle_t;
 
 static void spudec_queue_packet(spudec_handle_t *this, packet_t *packet)
@@ -211,11 +257,132 @@
   } else {
     mp_msg(MSGT_SPUDEC, MSGL_FATAL, "Fatal: update_spu: malloc requested %d bytes\n", 2 * this->stride * this->height);
   }
+  unsigned char *imageu;
+  unsigned char *imagev;
+  switch (this->dvdnav_color_spu) {
+    case DVDNAV_SPU_YUV:
+    case DVDNAV_SPU_YUY:
+      for (fy = 0; fy < this->image_sizeuv && !this->aimageuv[fy]; fy++);
+      for (ly = this->strideuv * this->heightuv-1;
+        ly && !this->aimageuv[ly]; ly--);
+      first_y = fy / this->strideuv;
+      last_y = ly / this->strideuv;
+      this->start_rowuv += first_y;
+      // Some subtitles trigger this condition
+      if (last_y + 1 > first_y ) {
+	  this->heightuv = last_y - first_y +1;
+        } else {
+	  this->heightuv = 0;
+	  this->image_sizeuv = 0;
+	  return;
+        }
+      //  printf("new h %d new start %d (sz %d st %d)---\n\n", this->height, this->start_row, this->image_size, this->stride);
+      imageu = malloc(3 * this->strideuv * this->heightuv);
+      if(imageu){
+        this->image_sizeuv = this->strideuv * this->heightuv;
+        imagev = imageu + this->image_sizeuv;
+        aimage = imagev + this->image_sizeuv;
+        memcpy(imageu, this->imageu + this->strideuv * first_y,
+	    this->image_sizeuv);
+        memcpy(imagev, this->imagev + this->strideuv * first_y,
+	    this->image_sizeuv);
+        memcpy(aimage, this->aimageuv + this->strideuv * first_y,
+	    this->image_sizeuv);
+        free(this->imageu);
+        this->imageu = imageu;
+        this->imagev = imagev;
+        this->aimageuv = aimage;
+        } else {
+          mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+	    "Fatal: update_spu: malloc requested %d bytes\n",
+	    3 * this->strideuv * this->height);
+        }
+      break;
+    case DVDNAV_SPU_RGB:
+    case DVDNAV_SPU_BGR:
+      this->image_sizeuv = this->stride * this->height;
+      imageu = malloc(2 * this->stride * this->height);
+      if(imageu){
+        imagev = imageu + this->image_size;
+        memcpy(imageu, this->imageu + this->stride * first_y, this->image_size);
+        memcpy(imagev, this->imagev + this->stride * first_y, this->image_size);
+        free(this->imageu);
+        this->imageu = imageu;
+        this->imagev = imagev;
+        this->aimageuv = NULL;
+      } else {
+        mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+	    "Fatal: update_spu: malloc requested %d bytes\n",
+	    2 * this->stride * this->height);
+      }
+      break;
+    }
+}
+
+void spu_yuv_to_rgb(unsigned int y,unsigned int u,unsigned int v,
+    unsigned int *r,unsigned int *g,unsigned int *b)
+{
+int ty,tu,tv;
+int tr,tg,tb;
+ty=y;tv=u;tu=v;
+tr = (298*(ty-16)+408*(tv-128))/256;
+tg = (298*(ty-16)-100*(tu-128)-208*(tv-128))/256;
+tb = (298*(ty-16)+516*(tu-128))/256;
+if(tr>255) tr=255; if(tr<0) tr=0;
+if(tg>255) tg=255; if(tg<0) tg=0;
+if(tb>255) tb=255; if(tb<0) tb=0;
+*r=tr; *g=tg; *b=tb;
+return;
+}
+
+static void spudec_process_fill(spudec_handle_t *this, int x, int y, int len,
+    unsigned char color, unsigned char coloru, unsigned char colorv,
+    unsigned char alpha)
+{
+unsigned int corrx, corry, corrl;
+if (this->stride-x-len<0) return;
+if (len<0) return;
+switch (this->dvdnav_color_spu)
+  {
+  case DVDNAV_SPU_YUV:
+  case DVDNAV_SPU_YUY:
+    corry=y & 0x01;
+    corrx=x & 0x01;
+    corrl=len & 0x01;
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    memset(this->imageu + (y-corry)/2 * this->strideuv + (x+corrx)/2, coloru,
+	(len-corrl)/2);
+    memset(this->imagev + (y-corry)/2 * this->strideuv + (x+corrx)/2, colorv,
+	(len-corrl)/2);
+    memset(this->aimageuv + (y-corry)/2 * this->strideuv + (x+corrx)/2, alpha,
+	(len-corrl)/2);
+    break;
+  case DVDNAV_SPU_RGB:
+  case DVDNAV_SPU_BGR:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->imageu + y * this->stride + x, coloru, len);
+    memset(this->imagev + y * this->stride + x, colorv, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+  default:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+}
 }
 
 static void spudec_process_data(spudec_handle_t *this, packet_t *packet)
 {
   unsigned int cmap[4], alpha[4];
+  unsigned int thpalette[4], thalpha[4];
+  unsigned int hcmap[4], halpha[4];
+  unsigned int cmapu[4], cmapv[4];
+  unsigned int hcmapu[4], hcmapv[4];
+  unsigned int control_start;
+  unsigned int current_nibble[2];
+  unsigned int ty,tu,tv,tr,tg,tb;
+  int deinterlace_oddness;
   unsigned int i, x, y;
 
   this->scaled_frame_width = 0;
@@ -227,6 +394,18 @@
   this->height = packet->height;
   this->width = packet->width;
   this->stride = packet->stride;
+  this->strideuv = packet->stride;
+  control_start = packet->control_start;
+  current_nibble[0]=packet->current_nibble[0];
+  current_nibble[1]=packet->current_nibble[1];
+  deinterlace_oddness=packet->deinterlace_oddness;
+
+  this->start_coluv = packet->start_col/2;
+  this->end_coluv = packet->end_col/2;
+  this->start_rowuv = packet->start_row/2;
+  this->end_rowuv = packet->end_row/2;
+  this->heightuv = packet->height/2+1;
+  this->widthuv = packet->width/2+1;
   for (i = 0; i < 4; ++i) {
     alpha[i] = mkalpha(packet->alpha[i]);
     if (alpha[i] == 0)
@@ -242,7 +421,91 @@
 	cmap[i] = 256 - alpha[i];
     }
   }
-
+  if (this->dvdnav_menu)
+    for (i = 0; i < 4; ++i) {	/* use button palette */
+      thalpha[i]=(this->dvdnav_palette >> ((3-i)*4)) & 0x0f;
+      thpalette[i]=(this->dvdnav_palette >> (16+(3-i)*4)) & 0x0f;
+      halpha[i] = mkalpha(thalpha[i]);
+      hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);
+      if (alpha[i] == 0) {cmap[i] = 0; cmapu[i] = 0; cmapv[i] = 0;} else {
+        if (cmap[i] + alpha[i] > 255)
+	  cmap[i] = 256 - alpha[i];
+	  switch (this->dvdnav_color_spu) {
+	    case DVDNAV_SPU_YUV:
+	    case DVDNAV_SPU_YUY:
+	      cmap[i] = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_RGB:
+	      ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      cmap[i] = tr;
+	      cmapu[i] = tg;
+	      cmapv[i] = tb;
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_BGR:
+	      ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      cmap[i] = tb;
+	      cmapu[i] = tg;
+	      cmapv[i] = tr;
+	      cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	      cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	      cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+	      break;
+	    }
+	  }
+      if (halpha[i] == 0) {hcmap[i] = 0; hcmapu[i] = 0; hcmapv[i] = 0;} else {
+        if (hcmap[i] + halpha[i] > 255)
+	  hcmap[i] = 256 - halpha[i];
+	  switch (this->dvdnav_color_spu) {
+	    case DVDNAV_SPU_YUV:
+	    case DVDNAV_SPU_YUY:
+              hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+              hcmapu[i] = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+              hcmapv[i] = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_RGB:
+              ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      hcmap[i] = tr;
+	      hcmapu[i] = tg;
+	      hcmapv[i] = tb;
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    case DVDNAV_SPU_BGR:
+              ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+              tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+              tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	      spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	      hcmap[i] = tb;
+	      hcmapu[i] = tg;
+	      hcmapv[i] = tr;
+	      hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	      hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	      hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+	      break;
+	    }
+	}
+      }
   if (this->image_size < this->stride * this->height) {
     if (this->image != NULL) {
       free(this->image);
@@ -256,6 +519,57 @@
   }
   if (this->image == NULL)
     return;
+if(this->dvdnav_menu && this->dvdnav_color_spu)
+  {
+  if (this->imageyuy)
+    {
+    free(this->imageyuy);
+    this->imageyuy=NULL;
+    this->aimageyuy=NULL;
+    }
+  if (this->dvdnav_color_spu==DVDNAV_SPU_YUV ||
+	this->dvdnav_color_spu==DVDNAV_SPU_YUY)
+    {
+    if (this->image_sizeuv < this->strideuv * this->heightuv)
+      {
+      if (this->imageu != NULL)
+        {
+        free(this->imageu);
+        this->image_sizeuv = 0;
+        }
+      this->imageu = malloc(3 * this->strideuv * this->heightuv);
+      if (this->imageu)
+        {
+        this->image_sizeuv = this->strideuv * this->heightuv;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+	}
+      }
+    memset(this->imageu,0,3 * this->strideuv * this->heightuv);
+    } else {
+    if (this->image_sizeuv < this->stride * this->height)
+      {
+      if (this->imageu != NULL)
+	{
+	free(this->imageu);
+	this->image_sizeuv = 0;
+        }
+      this->imageu = malloc(2 * this->stride * this->height);
+      if (this->imageu)
+        {
+        this->image_sizeuv = this->stride * this->height;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+	}
+      }
+    memset(this->imageu,0,2 * this->stride * this->height);
+    }
+  if (this->imageu == NULL) return;
+  } else {
+  if (this->imageu) free(this->imageu);
+  this->imageu=NULL;
+  this->image_sizeuv=0;
+  }
 
   /* Kludge: draw_alpha needs width multiple of 8. */
   if (this->width < this->stride)
@@ -290,8 +604,86 @@
     if (len > this->width - x || len == 0)
       len = this->width - x;
     /* FIXME have to use palette and alpha map*/
+    if (this->dvdnav_menu)
+      {
+      if (this->start_row+y>=this->dvdnav_sy &&
+	    this->start_row+y<=this->dvdnav_ey)
+	{
+	if (this->start_col+x>=this->dvdnav_sx &&
+		this->start_col+x+len<=this->dvdnav_ex)
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	else if(this->start_col+x<this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_sx &&
+		this->start_col+x+len<=this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_sx-this->start_col-x,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_sx-this->start_col,
+		    y,
+		    len+this->start_col+x-this->dvdnav_sx,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  }
+	else if(this->start_col+x<this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_sx &&
+		this->start_col+x+len>this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_sx-this->start_col-x,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_sx-this->start_col,
+		    y,
+		    this->dvdnav_ex-this->dvdnav_sx,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_ex-this->start_col,
+		    y,
+		    x+len+this->start_col-this->dvdnav_ex,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  }
+	else if(this->start_col+x>=this->dvdnav_sx &&
+		this->start_col+x<this->dvdnav_ex &&
+		this->start_col+x+len>this->dvdnav_ex)
+	  {
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    this->dvdnav_ex-this->start_col-x,
+		    hcmap[color], hcmapu[color], hcmapv[color], halpha[color]);
+	  spudec_process_fill(this,
+		    this->dvdnav_ex-this->start_col,
+		    y,
+		    len+this->start_col+x-this->dvdnav_ex,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	  }
+	  else
+	  spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+	} else
+	spudec_process_fill(this,
+		    x,
+		    y,
+		    len,
+		    cmap[color], cmapu[color], cmapv[color], alpha[color]);
+      }
+      else
+      {
     memset(this->image + y * this->stride + x, cmap[color], len);
     memset(this->aimage + y * this->stride + x, alpha[color], len);
+      }
     x += len;
     if (x >= this->width) {
       next_line(packet);
@@ -299,7 +691,12 @@
       ++y;
     }
   }
+  packet->control_start = control_start;
+  packet->current_nibble[0]=current_nibble[0];
+  packet->current_nibble[1]=current_nibble[1];
+  packet->deinterlace_oddness=deinterlace_oddness;
   spudec_cut_image(this);
+//printf("spudec_process_data: w: %i h: %i end\n",this->height,this->width);
 }
 
 
@@ -584,6 +981,7 @@
   spu->now_pts = 0;
   spu->end_pts = 0;
   spu->packet_size = spu->packet_offset = 0;
+//  if (spu->last_packet) {printf("free4\n");spudec_free_packet(spu->last_packet); spu->last_packet=NULL;}
 }
 
 void spudec_heartbeat(void *this, unsigned int pts100)
@@ -591,6 +989,7 @@
   spudec_handle_t *spu = (spudec_handle_t*) this;
   spu->now_pts = pts100;
 
+  if(spu->queue_head) spu->queue_head->start_pts=0;
   while (spu->queue_head != NULL && pts100 >= spu->queue_head->start_pts) {
     packet_t *packet = spudec_dequeue_packet(spu);
     spu->start_pts = packet->start_pts;
@@ -598,17 +997,31 @@
     if (spu->auto_palette)
       compute_palette(spu, packet);
     spudec_process_data(spu, packet);
+    if (spu->dvdnav_menu)
+      {
+      if(spu->last_packet)
+	{
+	spudec_free_packet(spu->last_packet);
+	}
+      spu->last_packet=packet;
+      } else
     spudec_free_packet(packet);
     spu->spu_changed = 1;
   }
 }
 
+
 int spudec_visible(void *this){
     spudec_handle_t *spu = (spudec_handle_t *)this;
+    if(!spu) return 0;
+    if (spu->dvdnav_menu && spu->height > 0)
+      {
+      if(spu->height>0) spu->end_pts=UINT_MAX;
+      return 1;
+      }
     int ret=(spu->start_pts <= spu->now_pts &&
 	     spu->now_pts < spu->end_pts &&
 	     spu->height > 0);
-//    printf("spu visible: %d  \n",ret);
     return ret;
 }
 
@@ -620,12 +1033,90 @@
   }
 }
 
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
     spudec_handle_t *spu = (spudec_handle_t *)this;
     if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts && spu->image)
     {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+    if (spu->dvdnav_menu)
+      {	/* spu menu mode? */
+      switch (spu->dvdnav_color_spu)
+	{
+	case DVDNAV_SPU_YUV:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_U,
+		    spu->imageu,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_V,
+		    spu->imagev,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  break;
+	case DVDNAV_SPU_YUY:
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy) draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width*2,
+		    spu->height/2,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  break;
+	case DVDNAV_SPU_RGB:
+	case DVDNAV_SPU_BGR:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width, spu->height,
+		    DEST_PLANES_BR,
+		    spu->imagev,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_G,
+		    spu->imageu,
+		    spu->aimage,
+		    spu->stride);
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_RB,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  break;
+	default:
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	}
+      } else
+	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,DEST_PLANES_Y,
 		   spu->image, spu->aimage, spu->stride);
 	spu->spu_changed = 0;
     }
@@ -737,6 +1228,119 @@
   }
 }
 
+static void scale_image_uv(int x, int y, scale_pixel* table_x,
+	scale_pixel* table_y, spudec_handle_t * spu)
+{
+  int alpha[4];
+  int coloru[4];
+  int colorv[4];
+  unsigned int scale[4];
+  int base = table_y[y].position * spu->strideuv + table_x[x].position;
+  int scaled = y * spu->scaled_strideuv + x;
+  alpha[0] = canon_alpha(spu->aimageuv[base]);
+  alpha[1] = canon_alpha(spu->aimageuv[base + 1]);
+  alpha[2] = canon_alpha(spu->aimageuv[base + spu->strideuv]);
+  alpha[3] = canon_alpha(spu->aimageuv[base + spu->strideuv + 1]);
+  coloru[0] = spu->imageu[base];
+  coloru[1] = spu->imageu[base + 1];
+  coloru[2] = spu->imageu[base + spu->strideuv];
+  coloru[3] = spu->imageu[base + spu->strideuv + 1];
+  colorv[0] = spu->imagev[base];
+  colorv[1] = spu->imagev[base + 1];
+  colorv[2] = spu->imagev[base + spu->strideuv];
+  colorv[3] = spu->imagev[base + spu->strideuv + 1];
+// FIXME: color hack!!!
+//  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+//  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+//  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+//  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * 0x100;
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * 0x100;
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * 0x100;
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * 0x100;
+  spu->scaled_imageu[scaled] =
+	(coloru[0] * scale[0] +
+	coloru[1] * scale[1] +
+	coloru[2] * scale[2] +
+	coloru[3] * scale[3])>>24;
+  spu->scaled_imagev[scaled] =
+	(colorv[0] * scale[0] +
+	colorv[1] * scale[1] +
+	colorv[2] * scale[2] +
+	colorv[3] * scale[3])>>24;
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  spu->scaled_aimageuv[scaled] =
+	(scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
+  if (spu->scaled_aimageuv[scaled]){
+    spu->scaled_aimageuv[scaled] = 256 - spu->scaled_aimageuv[scaled];
+    if(spu->scaled_aimageuv[scaled] + spu->scaled_imageu[scaled] > 255)
+      spu->scaled_imageu[scaled] = 256 - spu->scaled_aimageuv[scaled];
+    if(spu->scaled_aimageuv[scaled] + spu->scaled_imagev[scaled] > 255)
+      spu->scaled_imagev[scaled] = 256 - spu->scaled_aimageuv[scaled];
+  }
+}
+
+static void scale_image_rgb(int x, int y, scale_pixel* table_x, scale_pixel* table_y, spudec_handle_t * spu)
+{
+  int alpha[4];
+  int colorr[4];
+  int colorg[4];
+  int colorb[4];
+  unsigned int scale[4];
+  int base = table_y[y].position * spu->stride + table_x[x].position;
+  int scaled = y * spu->scaled_stride + x;
+  alpha[0] = canon_alpha(spu->aimage[base]);
+  alpha[1] = canon_alpha(spu->aimage[base + 1]);
+  alpha[2] = canon_alpha(spu->aimage[base + spu->stride]);
+  alpha[3] = canon_alpha(spu->aimage[base + spu->stride + 1]);
+  colorr[0] = spu->image[base];
+  colorr[1] = spu->image[base + 1];
+  colorr[2] = spu->image[base + spu->stride];
+  colorr[3] = spu->image[base + spu->stride + 1];
+  colorg[0] = spu->imageu[base];
+  colorg[1] = spu->imageu[base + 1];
+  colorg[2] = spu->imageu[base + spu->stride];
+  colorg[3] = spu->imageu[base + spu->stride + 1];
+  colorb[0] = spu->imagev[base];
+  colorb[1] = spu->imagev[base + 1];
+  colorb[2] = spu->imagev[base + spu->stride];
+  colorb[3] = spu->imagev[base + spu->stride + 1];
+  scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
+  scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
+  scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
+  scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
+  spu->scaled_image[scaled] =
+	(colorr[0] * scale[0] +
+	colorr[1] * scale[1] +
+	colorr[2] * scale[2] +
+	colorr[3] * scale[3])>>24;
+  spu->scaled_imageu[scaled] =
+	(colorg[0] * scale[0] +
+	colorg[1] * scale[1] +
+	colorg[2] * scale[2] +
+	colorg[3] * scale[3])>>24;
+  spu->scaled_imagev[scaled] =
+	(colorb[0] * scale[0] +
+	colorb[1] * scale[1] +
+	colorb[2] * scale[2] +
+	colorb[3] * scale[3])>>24;
+  spu->scaled_aimage[scaled] =
+	(scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
+  if (spu->scaled_aimage[scaled]){
+    spu->scaled_aimage[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_image[scaled] > 255)
+      spu->scaled_image[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_imageu[scaled] > 255)
+      spu->scaled_imageu[scaled] = 256 - spu->scaled_aimage[scaled];
+    if(spu->scaled_aimage[scaled] + spu->scaled_imagev[scaled] > 255)
+      spu->scaled_imagev[scaled] = 256 - spu->scaled_aimage[scaled];
+  }
+}
+
+
 void sws_spu_image(unsigned char *d1, unsigned char *d2, int dw, int dh, int ds,
 	unsigned char *s1, unsigned char *s2, int sw, int sh, int ss)
 {
@@ -763,11 +1367,204 @@
 	sws_freeContext(ctx);
 }
 
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+void spudec_create_yuy(void *this, int spu_scaled)
+{
+spudec_handle_t *spu = this;
+unsigned char *dptr;
+unsigned char *daptr;
+unsigned char *sptry;
+unsigned char *sptru;
+unsigned char *sptrv;
+unsigned char *saptr;
+unsigned char *saptruv;
+int y,x;
+
+if (spu_scaled) {
+  spu->strideyuy=spu->scaled_stride*2;
+  spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+  memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+  spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->scaled_height;
+  for(y=0;y<spu->scaled_height;y++) {
+    dptr=spu->imageyuy+y*spu->strideyuy;
+    daptr=spu->aimageyuy+y*spu->strideyuy;
+    sptry=spu->scaled_image+y*spu->scaled_stride;
+    sptru=spu->scaled_imageu+y/2*spu->scaled_strideuv;
+    sptrv=spu->scaled_imagev+y/2*spu->scaled_strideuv;
+    saptr=spu->scaled_aimage+y*spu->scaled_stride;
+    saptruv=spu->scaled_aimageuv+y/2*spu->scaled_strideuv;
+    for(x=0;x<spu->scaled_widthuv-1;x++) {
+      *dptr++=*sptry++;
+      *dptr++=*sptrv++;
+      *dptr++=*sptry++;
+      *dptr++=*sptru++;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv++;
+      } }
+  } else {
+  spu->strideyuy=spu->stride*2;
+  spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+  memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+  spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->height;
+  for(y=0;y<spu->height;y++) {
+    dptr=spu->imageyuy+y*spu->strideyuy;
+    daptr=spu->aimageyuy+y*spu->strideyuy;
+    sptry=spu->image+y*spu->stride;
+    sptru=spu->imageu+y/2*spu->strideuv;
+    sptrv=spu->imagev+y/2*spu->strideuv;
+    saptr=spu->aimage+y*spu->stride;
+    saptruv=spu->aimageuv+y/2*spu->strideuv;
+    for(x=0;x<spu->widthuv-1;x++) {
+      *dptr++=*sptry++;
+      *dptr++=*sptrv++;
+      *dptr++=*sptry++;
+      *dptr++=*sptru++;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv;
+      *daptr++=*saptr++;
+      *daptr++=*saptruv++;
+      } }
+  }
+}
+
+void sws_spu_image_uv(unsigned char *du, unsigned char *dv, unsigned char *d2,
+	int dw, int dh, int ds, unsigned char *su, unsigned char *sv,
+	unsigned char *s2, int sw, int sh, int ss)
+{
+struct SwsContext *ctx;
+static SwsFilter filter;
+static int firsttime = 1;
+static float oldvar;
+int i;
+
+if (!firsttime && oldvar != spu_gaussvar) sws_freeVec(filter.lumH);
+if (firsttime)
+    {
+    filter.lumH = filter.lumV =
+	filter.chrH = filter.chrV = sws_getGaussianVec(spu_gaussvar, 3.0);
+    sws_normalizeVec(filter.lumH, 1.0);
+    firsttime = 0;
+    oldvar = spu_gaussvar;
+    }
+
+ctx=sws_getContext(sw, sh, IMGFMT_Y800, dw, dh, IMGFMT_Y800, SWS_GAUSS, &filter, NULL, NULL);
+sws_scale(ctx,&su,&ss,0,sh,&du,&ds);
+sws_scale(ctx,&sv,&ss,0,sh,&dv,&ds);
+for (i=ss*sh-1; i>=0; i--)
+  if (!s2[i]) s2[i] = 255; //else s2[i] = 1;
+sws_scale(ctx,&s2,&ss,0,sh,&d2,&ds);
+for (i=ds*dh-1; i>=0; i--)
+  if (d2[i]==0) d2[i] = 1;
+  else if (d2[i]==255) d2[i] = 0;
+sws_freeContext(ctx);
+}
+
+void sws_spu_image_rgb(unsigned char *dr, unsigned char *dg, unsigned char *db,
+	unsigned char *d2, int dw, int dh, int ds,
+	unsigned char *sr,unsigned char *sg,unsigned char *sb,
+	unsigned char *s2, int sw, int sh, int ss)
+{
+struct SwsContext *ctx;
+static SwsFilter filter;
+static int firsttime = 1;
+static float oldvar;
+int i;
+
+if (!firsttime && oldvar != spu_gaussvar) sws_freeVec(filter.lumH);
+if (firsttime)
+    {
+    filter.lumH = filter.lumV =
+	filter.chrH = filter.chrV = sws_getGaussianVec(spu_gaussvar, 3.0);
+    sws_normalizeVec(filter.lumH, 1.0);
+    firsttime = 0;
+    oldvar = spu_gaussvar;
+    }
+
+ctx=sws_getContext(sw, sh, IMGFMT_Y800, dw, dh, IMGFMT_Y800, SWS_GAUSS, &filter, NULL, NULL);
+sws_scale(ctx,&sr,&ss,0,sh,&dr,&ds);
+sws_scale(ctx,&sg,&ss,0,sh,&dg,&ds);
+sws_scale(ctx,&sb,&ss,0,sh,&db,&ds);
+for (i=ss*sh-1; i>=0; i--) if (!s2[i]) s2[i] = 255; //else s2[i] = 1;
+sws_scale(ctx,&s2,&ss,0,sh,&d2,&ds);
+for (i=ds*dh-1; i>=0; i--)
+    if (d2[i]==0) d2[i] = 1;
+    else if (d2[i]==255) d2[i] = 0;
+sws_freeContext(ctx);
+}
+
+#undef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#undef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+void spudec_dvdnav_mode(void *this, int mode, int cflg)
+{		/* set/clear spu menu mode */
+spudec_handle_t *spu = (spudec_handle_t *)this;
+if (!spu) return;
+spu->dvdnav_menu=mode;
+spu->dvdnav_color_spu=cflg;
+if (!spu->dvdnav_menu && spu->last_packet)
+  {
+  spudec_free_packet(spu->last_packet);
+  spu->last_packet=NULL;
+  }
+return;
+}
+
+void spudec_dvdnav_area(void *this, uint16_t sx, uint16_t sy, uint16_t ex,
+	uint16_t ey, uint32_t palette)
+{
+spudec_handle_t *spu = this;
+if (!spu) return;
+if (spu->dvdnav_sx==min(sx,ex) &&
+	spu->dvdnav_ex==max(sx,ex) &&
+	spu->dvdnav_sy==min(sy,ey) &&
+	spu->dvdnav_ey==max(sy,ey) &&
+	spu->dvdnav_palette==palette) return;
+spu->dvdnav_sx=min(sx,ex);		/* set spu button area, palette & on */
+spu->dvdnav_ex=max(sx,ex);
+spu->dvdnav_sy=min(sy,ey);
+spu->dvdnav_ey=max(sy,ey);
+spu->dvdnav_palette=palette;
+spu->dvdnav_modify=1;
+if (spu->dvdnav_menu && spu->last_packet)
+  {
+  if (spu->auto_palette)
+    compute_palette(spu, spu->last_packet);
+  spudec_process_data(spu, spu->last_packet);
+  }
+return;
+}
+
+void spudec_dvdnav_palette(void *this, uint32_t palette)
+{
+spudec_handle_t *spu = this;
+if (!spu) return;
+spu->dvdnav_palette=palette;		/* set spu button palette */
+return;
+}
+
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
   spudec_handle_t *spu = (spudec_handle_t *)me;
   scale_pixel *table_x;
   scale_pixel *table_y;
+  if (spu->dvdnav_menu) {
+    switch (spu->dvdnav_color_spu)
+      {
+      case DVDNAV_SPU_YUV:
+      case DVDNAV_SPU_YUY:
+        spudec_draw_scaled_yuv(me,dxs,dys,draw_alpha);
+	return;
+	break;
+      case DVDNAV_SPU_RGB:
+      case DVDNAV_SPU_BGR:
+        spudec_draw_scaled_rgb(me,dxs,dys,draw_alpha);
+	return;
+	break;
+      }
+    }
 
   if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
 
@@ -780,7 +1577,7 @@
 	|| (spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
       if (spu->image)
       {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,DEST_PLANES_Y,
 		   spu->image, spu->aimage, spu->stride);
 	spu->spu_changed = 0;
       }
@@ -1087,7 +1884,7 @@
 	  break;
 	}
 	draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
-		   spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+		    DEST_PLANES_Y,spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
 	spu->spu_changed = 0;
       }
     }
@@ -1099,78 +1896,1302 @@
   }
 }
 
-void spudec_update_palette(void * this, unsigned int *palette)
-{
-  spudec_handle_t *spu = (spudec_handle_t *) this;
-  if (spu && palette) {
-    memcpy(spu->global_palette, palette, sizeof(spu->global_palette));
-    if(spu->hw_spu)
-      spu->hw_spu->control(VOCTRL_SET_SPU_PALETTE,spu->global_palette);
-  }
-}
-
-void spudec_set_font_factor(void * this, double factor)
+void spudec_draw_scaled_yuv(void *me, unsigned int dxs, unsigned int dys,
+	void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
-  spudec_handle_t *spu = (spudec_handle_t *) this;
-  spu->font_start_level = (int)(0xF0-(0xE0*factor));
-}
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+  scale_pixel *table_x;
+  scale_pixel *table_y;
+  unsigned int scalex = 0;
+  unsigned int scaley = 0;
 
-void *spudec_new_scaled(unsigned int *palette, unsigned int frame_width, unsigned int frame_height)
-{
-  return spudec_new_scaled_vobsub(palette, NULL, 0, frame_width, frame_height);
-}
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
 
-/* get palette custom color, width, height from .idx file */
-void *spudec_new_scaled_vobsub(unsigned int *palette, unsigned int *cuspal, unsigned int custom, unsigned int frame_width, unsigned int frame_height)
+    // check if only forced subtitles are requested
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){
+	return;}
+
+    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 ||
+	    spu->orig_frame_height == 0 ||
+	    (spu->orig_frame_width == dxs && spu->orig_frame_height == dys)))
 {
-  spudec_handle_t *this = calloc(1, sizeof(spudec_handle_t));
-  if (this){
-    //(fprintf(stderr,"VobSub Custom Palette: %d,%d,%d,%d", this->cuspal[0], this->cuspal[1], this->cuspal[2],this->cuspal[3]);
-    this->packet = NULL;
-    this->image = NULL;
-    this->scaled_image = NULL;
-    /* XXX Although the video frame is some size, the SPU frame is
-       always maximum size i.e. 720 wide and 576 or 480 high */
-    this->orig_frame_width = 720;
-    this->orig_frame_height = (frame_height == 480 || frame_height == 240) ? 480 : 576;
-    this->custom = custom;
-    // set up palette:
-    this->auto_palette = 1;
-    if (palette){
-      memcpy(this->global_palette, palette, sizeof(this->global_palette));
-      this->auto_palette = 0;
-    }
-    this->custom = custom;
-    if (custom && cuspal) {
-      memcpy(this->cuspal, cuspal, sizeof(this->cuspal));
-      this->auto_palette = 0;
-    }
-    // forced subtitles default: show all subtitles
-    this->forced_subs_only=0;
-    this->is_forced_sub=0;
+      if (spu->image)
+	{
+	if (spu->dvdnav_color_spu==DVDNAV_SPU_YUY) {
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy) draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width*2,
+		    spu->heightuv*2,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  } else {
+	  draw_alpha(spu->start_col,
+		    spu->start_row,
+		    spu->width,
+		    spu->height,
+		    DEST_PLANES_Y,
+		    spu->image,
+		    spu->aimage,
+		    spu->stride);
+	  if(spu->dvdnav_color_spu && spu->imageu && spu->aimageuv)
+	    draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_U,
+		    spu->imageu,
+		    spu->aimageuv,
+		    spu->strideuv);
+	  if(spu->dvdnav_color_spu && spu->imagev && spu->aimageuv)
+	    draw_alpha(spu->start_coluv,
+		    spu->start_rowuv,
+		    spu->widthuv,
+		    spu->heightuv,
+		    DEST_PLANES_V,
+		    spu->imagev,
+		    spu->aimageuv,
+		    spu->strideuv);
   }
-  else
-    mp_msg(MSGT_SPUDEC,MSGL_FATAL, "FATAL: spudec_init: calloc");
-  return this;
+	spu->spu_changed = 0;
 }
+    } else {
+      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys)
+	{	/* Resizing is needed */
+	/* scaled_x = scalex * x / 0x100
+	   scaled_y = scaley * y / 0x100
+	   order of operations is important because of rounding. */
+	scalex = 0x100 * dxs / spu->orig_frame_width;
+	scaley = 0x100 * dys / spu->orig_frame_height;
 
-void *spudec_new(unsigned int *palette)
+	spu->scaled_start_col = spu->start_col * scalex / 0x100;
+	spu->scaled_start_row = spu->start_row * scaley / 0x100;
+	spu->scaled_width = spu->width * scalex / 0x100;
+	spu->scaled_height = spu->height * scaley / 0x100;
+	spu->scaled_start_coluv = spu->start_coluv * scalex / 0x100;
+	spu->scaled_start_rowuv = spu->start_rowuv * scaley / 0x100;
+	spu->scaled_widthuv = spu->widthuv * scalex / 0x100;
+	spu->scaled_heightuv = spu->heightuv * scaley / 0x100;
+	/* Kludge: draw_alpha needs width multiple of 8 */
+	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
+	spu->scaled_strideuv = (spu->scaled_widthuv + 7) & ~7;
+	if (spu->scaled_image_size < spu->scaled_stride *
+		(spu->scaled_height+2))
 {
-    return spudec_new_scaled(palette, 0, 0);
+	  if (spu->scaled_image)
+	    {
+	    free(spu->scaled_image);
+	    spu->scaled_image_size = 0;
 }
-
-void spudec_free(void *this)
+	  spu->scaled_image = malloc(2 * spu->scaled_stride *
+		(spu->scaled_height+2));
+	  if (spu->scaled_image)
+{
+	    memset(spu->scaled_image,0,
+		    2 * spu->scaled_stride * (spu->scaled_height+2));
+	    spu->scaled_image_size = spu->scaled_stride *
+		    (spu->scaled_height+2);
+	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+}
+	}
+	if (spu->scaled_image_sizeuv < spu->scaled_strideuv *
+		(spu->scaled_heightuv+2))
 {
-  spudec_handle_t *spu = (spudec_handle_t*)this;
-  if (spu) {
-    while (spu->queue_head)
-      spudec_free_packet(spudec_dequeue_packet(spu));
-    if (spu->packet)
-      free(spu->packet);
-    if (spu->scaled_image)
-	free(spu->scaled_image);
-    if (spu->image)
-      free(spu->image);
+	  if (spu->scaled_imageu)
+	    {
+	    free(spu->scaled_imageu);
+	    spu->scaled_image_sizeuv = 0;
+    }
+	  spu->scaled_imageu = malloc(3 * spu->scaled_strideuv *
+		(spu->scaled_height+2));
+	  if (spu->scaled_imageu)
+	    {
+	    memset(spu->scaled_imageu,0,3 * spu->scaled_strideuv *
+		    (spu->scaled_height+2));
+	    spu->scaled_image_sizeuv = spu->scaled_strideuv *
+		    (spu->scaled_heightuv+2);
+	    spu->scaled_imagev = spu->scaled_imageu +
+		    spu->scaled_image_sizeuv;
+	    spu->scaled_aimageuv = spu->scaled_imagev +
+		    spu->scaled_image_sizeuv;
+	    }
+	}
+	if (spu->scaled_image) {
+	  unsigned int x, y;
+	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
+	    goto nothing_to_do;
+	    }
+	  if (spu->scaled_widthuv <= 1 || spu->scaled_heightuv <= 1) {
+	    goto nothing_to_do;
+	    }
+	switch(spu_aamode&15)
+	  {
+	  case 4:
+	    sws_spu_image(spu->scaled_image, spu->scaled_aimage,
+		  spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+		  spu->image, spu->aimage, spu->width, spu->height, spu->stride);
+	    sws_spu_image_uv(spu->scaled_imageu, spu->scaled_imagev,
+		  spu->scaled_aimageuv, spu->scaled_widthuv,
+		  spu->scaled_heightuv, spu->scaled_strideuv,
+		  spu->imageu, spu->imagev, spu->aimageuv,
+		  spu->widthuv, spu->heightuv, spu->strideuv);
+	    break;
+	  case 3:
+	    table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
+	    table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+	    if (!table_x || !table_y)
+	      {
+	      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	      }
+	    scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
+	    scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
+	    for (y = 0; y < spu->scaled_height; y++)
+	      for (x = 0; x < spu->scaled_width; x++)
+		scale_image(x, y, table_x, table_y, spu);
+	    free(table_x);
+	    free(table_y);
+	    table_x = calloc(spu->scaled_widthuv, sizeof(scale_pixel));
+	    table_y = calloc(spu->scaled_heightuv, sizeof(scale_pixel));
+	    if (!table_x || !table_y) {
+	      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	      }
+	    scale_table(0, 0, spu->widthuv - 1, spu->scaled_widthuv - 1,
+		table_x);
+	    scale_table(0, 0, spu->heightuv - 1, spu->scaled_heightuv - 1,
+		table_y);
+	    for (y = 0; y < spu->scaled_heightuv; y++)
+	      for (x = 0; x < spu->scaled_widthuv; x++)
+		scale_image_uv(x, y, table_x, table_y, spu);
+	    free(table_x);
+	    free(table_y);
+	    break;
+	  case 0:
+	  /* no antialiasing */
+	  for (y = 0; y < spu->scaled_height; ++y)
+	    {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->stride * unscaled_y;
+	    int scaled_strides = spu->scaled_stride * y;
+	    for (x = 0; x < spu->scaled_width; ++x)
+	      {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_image[scaled_strides + x] =
+		    spu->image[strides + unscaled_x];
+	      spu->scaled_aimage[scaled_strides + x] =
+		    spu->aimage[strides + unscaled_x];
+	      }
+	    }
+	  for (y = 0; y < spu->scaled_heightuv; ++y)
+	    {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->strideuv * unscaled_y;
+	    int scaled_strides = spu->scaled_strideuv * y;
+	    for (x = 0; x < spu->scaled_widthuv; ++x)
+	      {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_imageu[scaled_strides + x] =
+		    spu->imageu[strides + unscaled_x];
+	      spu->scaled_imagev[scaled_strides + x] =
+		    spu->imagev[strides + unscaled_x];
+	      spu->scaled_aimageuv[scaled_strides + x] =
+		    spu->aimageuv[strides + unscaled_x];
+	      }
+	    }
+	    break;
+	  case 1:
+	  {
+	    /* Intermediate antialiasing. */
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const unsigned int unscaled_top =
+		    y * spu->orig_frame_height / dys;
+	      unsigned int unscaled_bottom =
+		    (y + 1) * spu->orig_frame_height / dys;
+	      if (unscaled_bottom >= spu->height)
+		unscaled_bottom = spu->height - 1;
+	      for (x = 0; x < spu->scaled_width; ++x)
+	        {
+		const unsigned int unscaled_left =
+			x * spu->orig_frame_width / dxs;
+		unsigned int unscaled_right =
+			(x + 1) * spu->orig_frame_width / dxs;
+		unsigned int color = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->width)
+		  unscaled_right = spu->width - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx)
+		    {
+		    base = walky * spu->stride + walkx;
+		    tmp = canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		    }
+		base = y * spu->scaled_stride + x;
+		spu->scaled_image[base] = alpha ? color / alpha : 0;
+		spu->scaled_aimage[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) *
+		  (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      const unsigned int unscaled_top = y *
+		    (spu->orig_frame_height/2) / (dys/2);
+	      unsigned int unscaled_bottom = (y + 1) *
+		    (spu->orig_frame_height/2) / (dys/2);
+	      if (unscaled_bottom >= spu->heightuv)
+		unscaled_bottom = spu->heightuv - 1;
+	      for (x = 0; x < spu->scaled_widthuv; ++x) {
+		const unsigned int unscaled_left = x *
+			(spu->orig_frame_width/2) / (dxs/2);
+		unsigned int unscaled_right = (x + 1) *
+			(spu->orig_frame_width/2) / (dxs/2);
+		unsigned int coloru = 0;
+		unsigned int colorv = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->widthuv)
+		  unscaled_right = spu->widthuv - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx)
+		    {
+		    base = walky * spu->strideuv + walkx;
+		    tmp = canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		    }
+		base = y * spu->scaled_strideuv + x;
+		spu->scaled_imageu[base] = alpha ? coloru / alpha : 0;
+		spu->scaled_imagev[base] = alpha ? colorv / alpha : 0;
+		spu->scaled_aimageuv[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) *
+		  (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimageuv[base]) {
+		  spu->scaled_aimageuv[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimageuv[base];
+		}
+	      }
+	    }
+	  }
+	  break;
+	  case 2:
+	  {
+	    /* Best antialiasing.  Very slow. */
+	    /* Any pixel (x, y) represents pixels from the original
+	       rectangular region comprised between the columns
+	       unscaled_y and unscaled_y + 0x100 / scaley and the rows
+	       unscaled_x and unscaled_x + 0x100 / scalex
+
+	       The original rectangular region that the scaled pixel
+	       represents is cut in 9 rectangular areas like this:
+
+	       +---+-----------------+---+
+	       | 1 |        2        | 3 |
+	       +---+-----------------+---+
+	       |   |                 |   |
+	       | 4 |        5        | 6 |
+	       |   |                 |   |
+	       +---+-----------------+---+
+	       | 7 |        8        | 9 |
+	       +---+-----------------+---+
+
+	       The width of the left column is at most one pixel and
+	       it is never null and its right column is at a pixel
+	       boundary.  The height of the top row is at most one
+	       pixel it is never null and its bottom row is at a
+	       pixel boundary. The width and height of region 5 are
+	       integral values.  The width of the right column is
+	       what remains and is less than one pixel.  The height
+	       of the bottom row is what remains and is less than
+	       one pixel.
+
+	       The row above 1, 2, 3 is unscaled_y.  The row between
+	       1, 2, 3 and 4, 5, 6 is top_low_row.  The row between 4,
+	       5, 6 and 7, 8, 9 is (unsigned int)unscaled_y_bottom.
+	       The row beneath 7, 8, 9 is unscaled_y_bottom.
+
+	       The column left of 1, 4, 7 is unscaled_x.  The column
+	       between 1, 4, 7 and 2, 5, 8 is left_right_column.  The
+	       column between 2, 5, 8 and 3, 6, 9 is (unsigned
+	       int)unscaled_x_right.  The column right of 3, 6, 9 is
+	       unscaled_x_right. */
+	    const double inv_scalex = (double) 0x100 / scalex;
+	    const double inv_scaley = (double) 0x100 / scaley;
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row = MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double color = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->stride * (unsigned int) unscaled_y;
+		tmp = left * top *
+		    canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		color += tmp * spu->image[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		    base = spu->stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    unsigned int walkx;
+		    base = spu->stride * walky;
+		    for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      alpha += tmp;
+		      color += tmp * spu->image[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->stride * walky +
+			    (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		    tmp = /* 1.0 * */ bottom *
+			canon_alpha(spu->aimage[base + walkx]);
+		    alpha += tmp;
+		    color += tmp * spu->image[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->stride * (unsigned int)
+			unscaled_y_bottom + (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  color += tmp * spu->image[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_stride * y + x;
+		spu->scaled_image[base] = alpha > 0 ? color / alpha : 0;
+		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row =
+			MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_widthuv; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double coloru = 0.0;
+		double colorv = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->strideuv * (unsigned int) unscaled_y;
+		tmp = left * top *
+		    canon_alpha(spu->aimageuv[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		coloru += tmp * spu->imageu[base + (unsigned int) unscaled_x];
+		colorv += tmp * spu->imagev[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx)
+		    {
+		    base = spu->strideuv * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->strideuv * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    unsigned int walkx;
+		    base = spu->strideuv * walky;
+		    for (walkx = left_right_column;
+			walkx < (unsigned int) unscaled_x_right;
+			++walkx)
+		    {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimageuv[base + walkx]);
+		      alpha += tmp;
+		      coloru += tmp * spu->imageu[base + walkx];
+		      colorv += tmp * spu->imagev[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			walky < (unsigned int) unscaled_y_bottom;
+			++walky)
+		    {
+		    base = spu->strideuv * walky +
+			    (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimageuv[base]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base];
+		    colorv += tmp * spu->imagev[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimageuv[base + walkx]);
+		    alpha += tmp;
+		    coloru += tmp * spu->imageu[base + walkx];
+		    colorv += tmp * spu->imagev[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->strideuv * (unsigned int) unscaled_y_bottom +
+			(unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimageuv[base]);
+		  alpha += tmp;
+		  coloru += tmp * spu->imageu[base];
+		  colorv += tmp * spu->imagev[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_strideuv * y + x;
+		spu->scaled_imageu[base] = alpha > 0 ? coloru / alpha : 0;
+		spu->scaled_imagev[base] = alpha > 0 ? colorv / alpha : 0;
+		spu->scaled_aimageuv[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimageuv[base]) {
+		  spu->scaled_aimageuv[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimageuv[base];
+		  if (spu->scaled_aimageuv[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimageuv[base];
+		}
+	      }
+	    }
+	  }
+	  }
+nothing_to_do:
+	  /* Kludge: draw_alpha needs width multiple of 8. */
+	  if (spu->scaled_width < spu->scaled_stride)
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      memset(spu->scaled_aimage + y * spu->scaled_stride +
+		    spu->scaled_width, 0,
+		    spu->scaled_stride - spu->scaled_width);
+	    }
+	  spu->scaled_frame_width = dxs;
+	  spu->scaled_frame_height = dys;
+	  if (spu->scaled_widthuv < spu->scaled_strideuv)
+	    for (y = 0; y < spu->scaled_heightuv; ++y) {
+	      memset(spu->scaled_aimageuv + y * spu->scaled_stride +
+		    spu->scaled_widthuv, 0,
+		    spu->scaled_strideuv - spu->scaled_widthuv);
+	    }
+	  spu->scaled_frame_widthuv = dxs/2;
+	  spu->scaled_frame_heightuv = dys/2;
+	}
+      }
+      if (spu->scaled_image){
+        switch (spu_alignment) {
+        case 0:
+          spu->scaled_start_row = dys*sub_pos/100;
+	  if (spu->scaled_start_row + spu->scaled_height > dys)
+	    spu->scaled_start_row = dys - spu->scaled_height;
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100;
+	  if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	    spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+	  break;
+	case 1:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  } else {
+	    if (spu->scaled_start_row + spu->scaled_height > dys)
+	      spu->scaled_start_row = dys - spu->scaled_height;
+	  }
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_rowuv < 0) spu->scaled_start_rowuv = 0;
+	  } else {
+	    if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	      spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+	  }
+	  break;
+        case 2:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+	  if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+          spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv;
+	  if (spu->scaled_start_rowuv < 0) spu->scaled_start_rowuv = 0;
+	  break;
+	}
+	if (spu->dvdnav_color_spu==DVDNAV_SPU_YUY) {
+	  if (!spu->imageyuy) spudec_create_yuy(spu,1);
+	  if (spu->imageyuy) draw_alpha(spu->scaled_start_col,
+		    spu->scaled_start_row,
+		    spu->scaled_width*2,
+		    spu->scaled_height,
+		    DEST_PLANES_YUYV,
+		    spu->imageyuy,
+		    spu->aimageyuy,
+		    spu->strideyuy);
+	  } else {
+	  draw_alpha(spu->scaled_start_col,
+		    spu->scaled_start_row,
+		    spu->scaled_width,
+		    spu->scaled_height,
+		    DEST_PLANES_Y,
+		    spu->scaled_image,
+		    spu->scaled_aimage,
+		    spu->scaled_stride);
+	  draw_alpha(spu->scaled_start_coluv,
+		    spu->scaled_start_rowuv,
+		    spu->scaled_widthuv,
+		    spu->scaled_heightuv,
+		    DEST_PLANES_U,
+		    spu->scaled_imageu,
+		    spu->scaled_aimageuv,
+		    spu->scaled_strideuv);
+	  draw_alpha(spu->scaled_start_coluv,
+		    spu->scaled_start_rowuv,
+		    spu->scaled_widthuv,
+		    spu->scaled_heightuv,
+		    DEST_PLANES_V,
+		    spu->scaled_imagev,
+		    spu->scaled_aimageuv,
+		    spu->scaled_strideuv);
+	  }
+	spu->spu_changed = 0;
+      }
+    }
+  }
+  else
+  {
+    mp_msg(MSGT_SPUDEC,MSGL_DBG2,
+	"SPU not displayed: start_pts=%d  end_pts=%d  now_pts=%d\n",
+        spu->start_pts, spu->end_pts, spu->now_pts);
+  }
+}
+
+void spudec_draw_scaled_rgb(void *me, unsigned int dxs, unsigned int dys,
+	void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
+{
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+  scale_pixel *table_x;
+  scale_pixel *table_y;
+  unsigned int scalex = 0;
+  unsigned int scaley = 0;
+
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
+
+    // check if only forced subtitles are requested
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){
+	return;
+    }
+
+    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 ||
+	spu->orig_frame_height == 0 ||
+	(spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
+      if (spu->image)
+      {
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_RB,
+		spu->image,
+		spu->aimage,
+		spu->stride);
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_G,
+		spu->imageu,
+		spu->aimage,
+		spu->stride);
+      draw_alpha(spu->start_col,
+		spu->start_row,
+		spu->width,
+		spu->height,
+		DEST_PLANES_BR,
+		spu->imagev,
+		spu->aimage,
+		spu->stride);
+      spu->spu_changed = 0;
+      }
+    }
+    else {
+      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys) {	/* Resizing is needed */
+	/* scaled_x = scalex * x / 0x100
+	   scaled_y = scaley * y / 0x100
+	   order of operations is important because of rounding. */
+	scalex = 0x100 * dxs / spu->orig_frame_width;
+	scaley = 0x100 * dys / spu->orig_frame_height;
+
+	spu->scaled_start_col = spu->start_col * scalex / 0x100;
+	spu->scaled_start_row = spu->start_row * scaley / 0x100;
+	spu->scaled_width = spu->width * scalex / 0x100;
+	spu->scaled_height = spu->height * scaley / 0x100;
+	/* Kludge: draw_alpha needs width multiple of 8 */
+	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
+	if (spu->scaled_image_size < spu->scaled_stride * spu->scaled_height) {
+	  if (spu->scaled_image) {
+	    free(spu->scaled_image);
+	  if (spu->scaled_imageu)
+	    free(spu->scaled_imageu);
+	    spu->scaled_image_size = 0;
+	  }
+	  spu->scaled_image = malloc(2 * spu->scaled_stride * spu->scaled_height);
+	  spu->scaled_imageu = malloc(3 * spu->scaled_stride * spu->scaled_height);
+	  if (spu->scaled_image) {
+	    spu->scaled_image_size = spu->scaled_stride * spu->scaled_height;
+	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+	  }
+	  if (spu->scaled_imageu) {
+	    spu->scaled_imagev = spu->scaled_imageu + spu->scaled_image_size;
+	  }
+	}
+	if (spu->scaled_image) {
+	  unsigned int x, y;
+	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
+	    goto nothing_to_do;
+	  }
+	  switch(spu_aamode&15) {
+	  case 4:
+	  sws_spu_image_rgb(spu->scaled_image,spu->scaled_imageu,
+		    spu->scaled_imagev, spu->scaled_aimage,
+		    spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+		    spu->image, spu->imageu, spu->imagev, spu->aimage,
+		    spu->width, spu->height, spu->stride);
+	  break;
+	  case 3:
+	  table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
+	  table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+	  if (!table_x || !table_y) {
+	    mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+		    "Fatal: spudec_draw_scaled: calloc failed\n");
+	  }
+	  scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
+	  scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
+	  for (y = 0; y < spu->scaled_height; y++)
+	    for (x = 0; x < spu->scaled_width; x++)
+	      scale_image_rgb(x, y, table_x, table_y, spu);
+	  free(table_x);
+	  free(table_y);
+	  break;
+	  case 0:
+	  /* no antialiasing */
+	  for (y = 0; y < spu->scaled_height; ++y) {
+	    int unscaled_y = y * 0x100 / scaley;
+	    int strides = spu->stride * unscaled_y;
+	    int scaled_strides = spu->scaled_stride * y;
+	    for (x = 0; x < spu->scaled_width; ++x) {
+	      int unscaled_x = x * 0x100 / scalex;
+	      spu->scaled_image[scaled_strides + x] =
+		    spu->image[strides + unscaled_x];
+	      spu->scaled_imageu[scaled_strides + x] =
+		    spu->imageu[strides + unscaled_x];
+	      spu->scaled_imagev[scaled_strides + x] =
+		    spu->imagev[strides + unscaled_x];
+	      spu->scaled_aimage[scaled_strides + x] =
+		    spu->aimage[strides + unscaled_x];
+	    }
+	  }
+	  break;
+	  case 1:
+	  {
+	    /* Intermediate antialiasing. */
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const unsigned int unscaled_top = y *
+			spu->orig_frame_height / dys;
+	      unsigned int unscaled_bottom = (y + 1) *
+			spu->orig_frame_height / dys;
+	      if (unscaled_bottom >= spu->height)
+		unscaled_bottom = spu->height - 1;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const unsigned int unscaled_left = x *
+			    spu->orig_frame_width / dxs;
+		unsigned int unscaled_right = (x + 1) *
+			    spu->orig_frame_width / dxs;
+		unsigned int colorr = 0;
+		unsigned int colorg = 0;
+		unsigned int colorb = 0;
+		unsigned int alpha = 0;
+		unsigned int walkx, walky;
+		unsigned int base, tmp;
+		if (unscaled_right >= spu->width)
+		  unscaled_right = spu->width - 1;
+		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx) {
+		    base = walky * spu->stride + walkx;
+		    tmp = canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		base = y * spu->scaled_stride + x;
+		spu->scaled_image[base] = alpha ? colorr / alpha : 0;
+		spu->scaled_imageu[base] = alpha ? colorg / alpha : 0;
+		spu->scaled_imagev[base] = alpha ? colorb / alpha : 0;
+		spu->scaled_aimage[base] =
+		  alpha * (1 + unscaled_bottom - unscaled_top) * (1 + unscaled_right - unscaled_left);
+		/* spu->scaled_aimage[base] =
+		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	  }
+	  break;
+	  case 2:
+	  {
+	    /* Best antialiasing.  Very slow. */
+	    /* Any pixel (x, y) represents pixels from the original
+	       rectangular region comprised between the columns
+	       unscaled_y and unscaled_y + 0x100 / scaley and the rows
+	       unscaled_x and unscaled_x + 0x100 / scalex
+
+	       The original rectangular region that the scaled pixel
+	       represents is cut in 9 rectangular areas like this:
+
+	       +---+-----------------+---+
+	       | 1 |        2        | 3 |
+	       +---+-----------------+---+
+	       |   |                 |   |
+	       | 4 |        5        | 6 |
+	       |   |                 |   |
+	       +---+-----------------+---+
+	       | 7 |        8        | 9 |
+	       +---+-----------------+---+
+
+	       The width of the left column is at most one pixel and
+	       it is never null and its right column is at a pixel
+	       boundary.  The height of the top row is at most one
+	       pixel it is never null and its bottom row is at a
+	       pixel boundary. The width and height of region 5 are
+	       integral values.  The width of the right column is
+	       what remains and is less than one pixel.  The height
+	       of the bottom row is what remains and is less than
+	       one pixel.
+
+	       The row above 1, 2, 3 is unscaled_y.  The row between
+	       1, 2, 3 and 4, 5, 6 is top_low_row.  The row between 4,
+	       5, 6 and 7, 8, 9 is (unsigned int)unscaled_y_bottom.
+	       The row beneath 7, 8, 9 is unscaled_y_bottom.
+
+	       The column left of 1, 4, 7 is unscaled_x.  The column
+	       between 1, 4, 7 and 2, 5, 8 is left_right_column.  The
+	       column between 2, 5, 8 and 3, 6, 9 is (unsigned
+	       int)unscaled_x_right.  The column right of 3, 6, 9 is
+	       unscaled_x_right. */
+	    const double inv_scalex = (double) 0x100 / scalex;
+	    const double inv_scaley = (double) 0x100 / scaley;
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      const double unscaled_y = y * inv_scaley;
+	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
+	      const unsigned int top_low_row =
+			MIN(unscaled_y_bottom, unscaled_y + 1.0);
+	      const double top = top_low_row - unscaled_y;
+	      const unsigned int height = unscaled_y_bottom > top_low_row
+		? (unsigned int) unscaled_y_bottom - top_low_row
+		: 0;
+	      const double bottom = unscaled_y_bottom > top_low_row
+		? unscaled_y_bottom - floor(unscaled_y_bottom)
+		: 0.0;
+	      for (x = 0; x < spu->scaled_width; ++x) {
+		const double unscaled_x = x * inv_scalex;
+		const double unscaled_x_right = unscaled_x + inv_scalex;
+		const unsigned int left_right_column =
+			MIN(unscaled_x_right, unscaled_x + 1.0);
+		const double left = left_right_column - unscaled_x;
+		const unsigned int width = unscaled_x_right > left_right_column
+		  ? (unsigned int) unscaled_x_right - left_right_column
+		  : 0;
+		const double right = unscaled_x_right > left_right_column
+		  ? unscaled_x_right - floor(unscaled_x_right)
+		  : 0.0;
+		double colorr = 0.0;
+		double colorg = 0.0;
+		double colorb = 0.0;
+		double alpha = 0.0;
+		double tmp;
+		unsigned int base;
+		/* Now use these informations to compute a good alpha,
+                   and lightness.  The sum is on each of the 9
+                   region's surface and alpha and lightness.
+
+		  transformed alpha = sum(surface * alpha) / sum(surface)
+		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
+		*/
+		/* 1: top left part */
+		base = spu->stride * (unsigned int) unscaled_y;
+		tmp = left * top * canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		alpha += tmp;
+		colorr += tmp * spu->image[base + (unsigned int) unscaled_x];
+		colorg += tmp * spu->imageu[base + (unsigned int) unscaled_x];
+		colorb += tmp * spu->imagev[base + (unsigned int) unscaled_x];
+		/* 2: top center part */
+		if (width > 0) {
+		  unsigned int walkx;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    base = spu->stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 3: top right part */
+		if (right > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y +
+			    (unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* 4: center left part */
+		if (height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			    walky < (unsigned int) unscaled_y_bottom;
+			    ++walky) {
+		    base = spu->stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 5: center part */
+		if (width > 0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+			    walky < (unsigned int) unscaled_y_bottom;
+			    ++walky) {
+		    unsigned int walkx;
+		    base = spu->stride * walky;
+		    for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      alpha += tmp;
+		      colorr += tmp * spu->image[base + walkx];
+		      colorg += tmp * spu->imageu[base + walkx];
+		      colorb += tmp * spu->imagev[base + walkx];
+		    }
+		  }
+		}
+		/* 6: center right part */
+		if (right > 0.0 && height > 0) {
+		  unsigned int walky;
+		  for (walky = top_low_row;
+				walky < (unsigned int) unscaled_y_bottom;
+				++walky) {
+		    base = spu->stride * walky + (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base];
+		    colorg += tmp * spu->imageu[base];
+		    colorb += tmp * spu->imagev[base];
+		  }
+		}
+		/* 7: bottom left part */
+		if (bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* 8: bottom center part */
+		if (width > 0 && bottom > 0.0) {
+		  unsigned int walkx;
+		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  for (walkx = left_right_column;
+			    walkx < (unsigned int) unscaled_x_right;
+			    ++walkx) {
+		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimage[base + walkx]);
+		    alpha += tmp;
+		    colorr += tmp * spu->image[base + walkx];
+		    colorg += tmp * spu->imageu[base + walkx];
+		    colorb += tmp * spu->imagev[base + walkx];
+		  }
+		}
+		/* 9: bottom right part */
+		if (right > 0.0 && bottom > 0.0) {
+		  base = spu->stride * (unsigned int) unscaled_y_bottom +
+			    (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  alpha += tmp;
+		  colorr += tmp * spu->image[base];
+		  colorg += tmp * spu->imageu[base];
+		  colorb += tmp * spu->imagev[base];
+		}
+		/* Finally mix these transparency and brightness information suitably */
+		base = spu->scaled_stride * y + x;
+		spu->scaled_image[base] = alpha > 0 ? colorr / alpha : 0;
+		spu->scaled_imageu[base] = alpha > 0 ? colorg / alpha : 0;
+		spu->scaled_imagev[base] = alpha > 0 ? colorb / alpha : 0;
+		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
+		if (spu->scaled_aimage[base]) {
+		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
+		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imageu[base] > 255)
+		    spu->scaled_imageu[base] = 256 - spu->scaled_aimage[base];
+		  if (spu->scaled_aimage[base] + spu->scaled_imagev[base] > 255)
+		    spu->scaled_imagev[base] = 256 - spu->scaled_aimage[base];
+		}
+	      }
+	    }
+	  }
+	  }
+nothing_to_do:
+	  /* Kludge: draw_alpha needs width multiple of 8. */
+	  if (spu->scaled_width < spu->scaled_stride)
+	    for (y = 0; y < spu->scaled_height; ++y) {
+	      memset(spu->scaled_aimage + y * spu->scaled_stride +
+			spu->scaled_width, 0,
+			spu->scaled_stride - spu->scaled_width);
+	    }
+	  spu->scaled_frame_width = dxs;
+	  spu->scaled_frame_height = dys;
+	}
+      }
+      if (spu->scaled_image){
+        switch (spu_alignment) {
+        case 0:
+          spu->scaled_start_row = dys*sub_pos/100;
+	  if (spu->scaled_start_row + spu->scaled_height > dys)
+	    spu->scaled_start_row = dys - spu->scaled_height;
+	  break;
+	case 1:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
+          if (sub_pos < 50) {
+	    if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  } else {
+	    if (spu->scaled_start_row + spu->scaled_height > dys)
+	      spu->scaled_start_row = dys - spu->scaled_height;
+	  }
+	  break;
+        case 2:
+          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+	  if (spu->scaled_start_row < 0) spu->scaled_start_row = 0;
+	  break;
+	}
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_RB,
+		spu->scaled_image,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_G,
+		spu->scaled_imageu,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	draw_alpha(spu->scaled_start_col,
+		spu->scaled_start_row,
+		spu->scaled_width,
+		spu->scaled_height,
+		DEST_PLANES_BR,
+		spu->scaled_imagev,
+		spu->scaled_aimage,
+		spu->scaled_stride);
+	spu->spu_changed = 0;
+      }
+    }
+  }
+  else
+  {
+    mp_msg(MSGT_SPUDEC,MSGL_DBG2,
+	"SPU not displayed: start_pts=%d  end_pts=%d  now_pts=%d\n",
+        spu->start_pts, spu->end_pts, spu->now_pts);
+  }
+}
+
+void spudec_update_palette(void * this, unsigned int *palette)
+{
+  spudec_handle_t *spu = (spudec_handle_t *) this;
+  if (spu && palette) {
+    memcpy(spu->global_palette, palette, sizeof(spu->global_palette));
+    if(spu->hw_spu)
+      spu->hw_spu->control(VOCTRL_SET_SPU_PALETTE,spu->global_palette);
+  }
+}
+
+void spudec_set_font_factor(void * this, double factor)
+{
+  spudec_handle_t *spu = (spudec_handle_t *) this;
+  spu->font_start_level = (int)(0xF0-(0xE0*factor));
+}
+
+void *spudec_new_scaled(unsigned int *palette, unsigned int frame_width, unsigned int frame_height)
+{
+  return spudec_new_scaled_vobsub(palette, NULL, 0, frame_width, frame_height);
+}
+
+/* get palette custom color, width, height from .idx file */
+void *spudec_new_scaled_vobsub(unsigned int *palette, unsigned int *cuspal, unsigned int custom, unsigned int frame_width, unsigned int frame_height)
+{
+  spudec_handle_t *this = calloc(1, sizeof(spudec_handle_t));
+  if (this){
+    //(fprintf(stderr,"VobSub Custom Palette: %d,%d,%d,%d", this->cuspal[0], this->cuspal[1], this->cuspal[2],this->cuspal[3]);
+    this->packet = NULL;
+    this->image = NULL;
+    this->scaled_image = NULL;
+    /* XXX Although the video frame is some size, the SPU frame is
+       always maximum size i.e. 720 wide and 576 or 480 high */
+    this->orig_frame_width = 720;
+    this->orig_frame_height = (frame_height == 480 || frame_height == 240) ? 480 : 576;
+    this->custom = custom;
+    // set up palette:
+    this->auto_palette = 1;
+    if (palette){
+      memcpy(this->global_palette, palette, sizeof(this->global_palette));
+      this->auto_palette = 0;
+    }
+    this->custom = custom;
+    if (custom && cuspal) {
+      memcpy(this->cuspal, cuspal, sizeof(this->cuspal));
+      this->auto_palette = 0;
+    }
+    // forced subtitles default: show all subtitles
+    this->forced_subs_only=0;
+    this->is_forced_sub=0;
+  }
+  else
+    mp_msg(MSGT_SPUDEC,MSGL_FATAL, "FATAL: spudec_init: calloc");
+  return this;
+}
+
+void *spudec_new(unsigned int *palette)
+{
+    return spudec_new_scaled(palette, 0, 0);
+}
+
+void spudec_free(void *this)
+{
+  spudec_handle_t *spu = (spudec_handle_t*)this;
+  if (spu) {
+    while (spu->queue_head)
+      spudec_free_packet(spudec_dequeue_packet(spu));
+    if (spu->packet)
+      free(spu->packet);
+    if (spu->scaled_image)
+	free(spu->scaled_image);
+    if (spu->image)
+      free(spu->image);
+    if (spu->dvdnav_image)
+      free(spu->dvdnav_image);
+    if (spu->dvdnav_aimage)
+      free(spu->dvdnav_aimage);
+
+    if (spu->imageu)
+      free(spu->imageu);
+    if (spu->imageyuy)
+      free(spu->imageyuy);
+    spu->imageyuy=NULL;
+    if (spu->scaled_imageu)
+	free(spu->scaled_imageu);
+
+    if (spu->last_packet) {spudec_free_packet(spu->last_packet); spu->last_packet=NULL;}
+    spu->dvdnav_allocated = 0;
     free(spu);
   }
 }
diff -Nur MPlayer-1.0rc1.orig/spudec.h MPlayer-1.0rc1/spudec.h
--- MPlayer-1.0rc1.orig/spudec.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/spudec.h	2006-12-04 00:10:44.000000000 +0100
@@ -5,8 +5,31 @@
 
 void spudec_heartbeat(void *this, unsigned int pts100);
 void spudec_assemble(void *this, unsigned char *packet, unsigned int len, unsigned int pts100);
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+#define DVDNAV_SPU_YUV	1
+#define DVDNAV_SPU_RGB	2
+#define DVDNAV_SPU_BGR	3
+#define DVDNAV_SPU_YUY	4
+
+void spu_yuv_to_rgb(unsigned int y,unsigned int u,unsigned int v,
+    unsigned int *r,unsigned int *g,unsigned int *b);
+void spudec_dvdnav_mode(void *this, int mode, int cflg);
+void spudec_dvdnav_area(void *this, uint16_t sx, uint16_t sy,
+    uint16_t ex, uint16_t ey, uint32_t palette);
+void spudec_dvdnav_palette(void *this, uint32_t palette);
+int spudec_dvdnav_menu_box(void *this, int scaled, unsigned int scalex,
+    unsigned int scaley);
+void spudec_new_scaled_yuv(unsigned int *palette, unsigned int frame_width,
+    unsigned int frame_height);
+void spudec_new_scaled_rgb(unsigned int *palette, unsigned int frame_width,
+    unsigned int frame_height);
+void spudec_draw_scaled_yuv(void *me, unsigned int dxs, unsigned int dys,
+    void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled_rgb(void *me, unsigned int dxs, unsigned int dys,
+    void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_create_yuy(void *this, int spu_scaled);
+
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void spudec_update_palette(void *this, unsigned int *palette);
 void *spudec_new_scaled(unsigned int *palette, unsigned int frame_width, unsigned int frame_height);
 void *spudec_new_scaled_vobsub(unsigned int *palette, unsigned int *cuspal, unsigned int custom, unsigned int frame_width, unsigned int frame_height);
@@ -18,7 +41,7 @@
 void spudec_set_hw_spu(void *this, vo_functions_t *hw_spu);
 int spudec_changed(void *this);
 void spudec_calc_bbox(void *me, unsigned int dxs, unsigned int dys, unsigned int* bbox);
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void spudec_set_forced_subs_only(void * const this, const unsigned int flag);
 #endif
 
diff -Nur MPlayer-1.0rc1.orig/stream/stream_dvdnav.c MPlayer-1.0rc1/stream/stream_dvdnav.c
--- MPlayer-1.0rc1.orig/stream/stream_dvdnav.c	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/stream/stream_dvdnav.c	2006-12-04 00:10:44.000000000 +0100
@@ -1,5 +1,7 @@
 #include "config.h"
 
+#if 0
+// original stream_dvdnav.c from MPlayer-1.0rc1
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
@@ -411,3 +413,1437 @@
   &stream_opts,
   1 // Urls are an option string
 };
+// end of original stream_dvdnav.c from MPlayer-1.0rc1
+#else
+
+#include "config.h"
+
+#ifdef USE_MPDVDNAV		// enable dvdnav support?
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include "mp_msg.h"
+#include "stream.h"
+#include "help_mp.h"
+#include "osdep/timer.h"
+#include "input/input.h"
+#include "stream.h"
+#include "stream_dvdnav.h"
+#include "libvo/video_out.h"
+#include "spudec.h"
+#include "m_option.h"
+#include "m_struct.h"
+#include "libmpdvdnav/dvdnav_internal.h"
+
+#define TRACE	// enable trace messages print, usage: -dvdnav-trace options
+//#define LOG_DEBUG
+
+int dvd_nav_skip_opening = 0;
+int dvd_nav_still = 0;
+int dvdnav_menutype = 0;
+int dvdnav_continue_play = 0;
+int dvdnav_go_title = 0;
+int dvdnav_go_part = 0;
+int dvdnav_go_menu = 0;
+int dvdnav_go_menu_force = 0;
+int dvdnav_go_audio = 0;
+int dvdnav_go_spu = 0;
+int dvdnav_trace = 0;
+int dvdnav_force_menu = 0;
+int dvdnav_skipintro = 0;
+int dvdnav_color_spu = 1;
+int dvdnav_still_repeat = DVDNAV_MAX_STILL_FRAME;
+char* dvdmenu_lang = NULL;
+
+extern char* dvd_device;
+extern int audio_id;
+extern int dvdsub_id;
+extern char* audio_lang;
+extern char* dvdsub_lang;
+
+#ifdef HAVE_NEW_GUI
+int	dvdnav_window_width=0;
+int	dvdnav_window_height=0;
+int	dvdnav_window_orig_width=0;
+int	dvdnav_window_orig_height=0;
+int	dvdnav_mouse_x=0;
+int	dvdnav_mouse_y=0;
+int	dvdnav_mouse_orig_x=0;
+int	dvdnav_mouse_orig_y=0;
+int	dvdnav_mouse_button=0;
+int	dvdnav_mouse_set=0;
+#endif
+
+off_t	eventnum=0;
+
+int cellxx=0;
+
+static struct stream_priv_s {
+  int track;
+  char* device;
+} stream_priv_dflts = {
+  1,
+  NULL
+};
+
+#define ST_OFF(f) M_ST_OFF(struct stream_priv_s,f)
+/// URL definition
+static m_option_t stream_opts_fields[] = {
+  { NULL, NULL, 0, 0, 0, 0,  NULL }
+};
+static struct m_struct_st stream_opts = {
+  "dvd",
+  sizeof(struct stream_priv_s),
+  &stream_priv_dflts,
+  stream_opts_fields
+};
+
+
+#ifndef _MSC_VER
+#include <sys/param.h>
+#include <sys/fcntl.h>
+#else
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 255
+#endif
+#endif /* _MSC_VER */
+
+int dvdnav_seek(dvdnav_priv_t * dvdnav_priv, off_t newpos,stream_t *s)
+{
+if (dvdnav_priv->lockseek) return 0;
+if (dvdnav_sector_search(dvdnav_priv->dvdnav, newpos, SEEK_SET)!=
+	DVDNAV_STATUS_OK) {
+  if (!newpos) mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	MSGTR_MPDVDNAV_ErrorSeek,dvdnav_err_to_string(dvdnav_priv->dvdnav),
+	newpos );
+  return 0;
+  }
+return 1;
+}
+
+static int seek(stream_t *s, off_t newpos)
+{
+off_t seekpos;
+
+mp_msg(MSGT_CPLAYER,MSGL_DBG2,"DVDNAV seek pos: %llx\n",newpos);
+dvdnav_priv_t* dvdnav_priv=s->priv;
+int domain_vts=dvdnav_priv->vts_domain;
+if(newpos!=s->pos) {
+  if (!domain_vts)
+    mp_msg(MSGT_CPLAYER,MSGL_V,"Cannot seek in DVDNAV streams yet!\n");
+    else {
+    seekpos=newpos/2048;
+    if (dvdnav_seek((dvdnav_priv_t*)s->priv,seekpos,s)) s->pos=newpos; }
+    }
+if (newpos==0) {
+  ((dvdnav_priv_t*)(s->priv))->stillcounter=0;
+  ((dvdnav_priv_t*)(s->priv))->waitcounter=0;
+  ((dvdnav_priv_t*)(s->priv))->lockstillcounter=0;}
+return 1;
+}
+
+unsigned int * dvdnav_stream_get_palette(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav->vm) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav->vm\n",
+	__FUNCTION__);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav->vm->state.pgc) {
+  mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"%s: NULL dvdnav_priv->dvdnav->vm->state.pgc\n",
+	__FUNCTION__);
+  return NULL;
+  }
+return dvdnav_priv->dvdnav->vm->state.pgc->palette;
+}
+
+int dvdnav_menu_action(dvdnav_priv_t * dvdnav_priv, int action)
+{
+pci_t* pnavpci;
+dsi_t* pnavdsi;
+uint32_t buttonN;
+pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+pnavdsi = dvdnav_get_current_nav_dsi( dvdnav_priv->dvdnav );
+dvdnav_status_t nav_status;
+if (!dvdnav_priv) return 0;
+switch (action) {
+  case MP_CMD_DVDNAV_UP:
+    nav_status = dvdnav_upper_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd up");
+#endif
+    break;
+  case MP_CMD_DVDNAV_DOWN:
+    nav_status = dvdnav_lower_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd down");
+#endif
+    break;
+  case MP_CMD_DVDNAV_LEFT:
+    nav_status = dvdnav_left_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd left");
+#endif
+    break;
+  case MP_CMD_DVDNAV_RIGHT:
+    nav_status = dvdnav_right_button_select(dvdnav_priv->dvdnav, pnavpci);
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav cmd right");
+#endif
+    break;
+  case MP_CMD_DVDNAV_MENU:
+    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+    dvdnav_priv->cell_timer=0;
+    dvdnav_priv->one_cell_timer=0;
+    dvdnav_priv->stillflg=0;
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: menu action: Menu Root\n");
+#endif
+    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 0);
+    nav_status = dvdnav_menu_call(dvdnav_priv->dvdnav,DVD_MENU_Root);
+    break;
+  case MP_CMD_DVDNAV_SELECT:
+    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+    dvdnav_priv->cell_timer=0;
+    dvdnav_priv->one_cell_timer=0;
+    dvdnav_priv->stillflg=0;
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: menu action: Menu Select\n");
+#endif
+    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 0);
+    nav_status = dvdnav_button_activate(dvdnav_priv->dvdnav, pnavpci);
+    break;
+  default:
+    return 0;
+  }
+if (nav_status == DVDNAV_STATUS_ERR) {mp_msg(MSGT_CPLAYER, MSGL_WARN,
+	MSGTR_MPDVDNAV_ErrorNav,
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+    return 0;}
+return 1;
+}
+
+int dvdnav_menu_force(dvdnav_priv_t * dvdnav_priv)
+{
+return 1;
+}
+
+void dvdnav_stream_fullstart(dvdnav_priv_t * dvdnav_priv)
+{
+if (dvdnav_priv && !dvdnav_priv->started) {
+//    dvdnav_stream_reset(dvdnav_priv);
+  dvdnav_priv->started=1; }
+dvdnav_event_clear(dvdnav_priv);
+dvdnav_priv->stillcounter=0;
+dvdnav_priv->waitcounter=0;
+dvdnav_priv->lockstillcounter=0;
+}
+
+int dvdnav_reallyeof(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) return 1;
+return dvdnav_priv->stopflg;
+}
+
+void dvdnav_set_language(dvdnav_priv_t *dvdnav_priv, char *alang,
+    char *slang, char *mlang)	/* set nav languages */
+{
+if (slang) {
+  if (dvdnav_spu_language_select(dvdnav_priv->dvdnav, slang ) !=
+      DVDNAV_STATUS_OK)	/* FIXME: don't work! */
+    mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting spu languages: %s\n",
+      dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+if (alang) {
+  if (dvdnav_audio_language_select(dvdnav_priv->dvdnav, alang ) !=
+      DVDNAV_STATUS_OK)	/* FIXME: don't work! */
+    mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting audio languages: %s\n",
+      dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+if (mlang) {
+  if (dvdnav_menu_language_select(dvdnav_priv->dvdnav, dvdmenu_lang ) !=
+    DVDNAV_STATUS_OK)
+  mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting menu languages: %s\n",
+    dvdnav_err_to_string(dvdnav_priv->dvdnav)); }
+return;
+}
+
+int dvdnav_lang_from_sid(dvdnav_priv_t *dvdnav_priv, int id)
+{
+if (!dvdnav_priv) return 0;
+if (id >= dvdnav_priv->nr_of_subtitles) return 0;
+return dvdnav_priv->subtitles[id].language;
+}
+
+int dvdnav_sid_from_lang(dvdnav_priv_t *dvdnav_priv, unsigned char* lang)
+{
+if (!dvdnav_priv) return 0;
+int code,i;
+while(lang && strlen(lang)>=2) {
+  code=lang[1]|(lang[0]<<8);
+  for(i=0;i<dvdnav_priv->nr_of_subtitles;i++) {
+    if(dvdnav_priv->subtitles[i].language==code) {
+      mp_msg(MSGT_OPEN,MSGL_V,MSGTR_DVDsubtitleChannel, i, lang[0],lang[1]);
+      return i;}
+    }
+  lang+=2; 
+  while (lang[0]==',' || lang[0]==' ') ++lang;
+  }
+mp_msg(MSGT_OPEN,MSGL_WARN,MSGTR_DVDnoMatchingSubtitle);
+return -1;
+}
+
+int dvdnav_aid_from_lang(dvdnav_priv_t *dvdnav_priv, unsigned char* lang)
+{
+if (!dvdnav_priv) return 0;
+int code,i;
+while(lang && strlen(lang)>=2) {
+  code=lang[1]|(lang[0]<<8);
+  for(i=0;i<dvdnav_priv->nr_of_channels;i++) {
+    if(dvdnav_priv->audio_streams[i].language==code) {
+      mp_msg(MSGT_OPEN,MSGL_V,MSGTR_DVDaudioChannel,
+	    dvdnav_priv->audio_streams[i].id, lang[0],lang[1]);
+      return dvdnav_priv->audio_streams[i].id;}
+    }
+  lang+=2; 
+  while (lang[0]==',' || lang[0]==' ') ++lang;
+  }
+mp_msg(MSGT_OPEN,MSGL_WARN,MSGTR_DVDnoMatchingAudio);
+return -1;
+}
+
+int dvdnav_number_of_subs(dvdnav_priv_t *dvdnav_priv)
+{
+if (!dvdnav_priv) return -1;
+return dvdnav_priv->nr_of_subtitles;
+}
+
+static void stream_dvdnav_close(stream_t *s)
+{
+free_dvdnav_stream((dvdnav_priv_t*)s->priv);
+}
+
+void dvdnav_event_clear(dvdnav_priv_t * dvdnav_priv)
+{
+memset(&(dvdnav_priv->event),0,sizeof(stream_dvdnav_event_t));
+return;
+}
+
+void dvdnav_get_highlight(dvdnav_priv_t *dvdnav_priv,
+    dvdnav_highlight_event_t *highlight_event,
+    int display_mode)
+{
+pci_t* pnavpci;
+int button_number = -1;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (!highlight_event) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav ))) return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &(highlight_event->buttonN));
+highlight_event->display=display_mode; /* show */
+if (highlight_event->display==2) b_mode=1;	/* activate */
+if (highlight_event->buttonN > 0 && pnavpci->hli.hl_gi.btn_ns > 0 &&
+	highlight_event->display) {
+    for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+        btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+        if(highlight_event->buttonN==button_number+1) {
+	    highlight_event->sx=min(btni->x_start,btni->x_end);
+	    highlight_event->ex=max(btni->x_start,btni->x_end);
+	    highlight_event->sy=min(btni->y_start,btni->y_end);
+	    highlight_event->ey=max(btni->y_start,btni->y_end);
+	    if (btni->btn_coln==0) highlight_event->palette=0;
+		else
+		highlight_event->palette=
+		    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+	    }
+	}
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+	"dvdnav: get highlight (%i:%i-%i:%i #%i)\n",
+	highlight_event->sx,
+	highlight_event->sy,
+	highlight_event->ex,
+	highlight_event->ey,
+	highlight_event->buttonN);
+#endif
+    } else {	/* hide button or none button */
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+	"dvdnav: get highlight hide\n");
+#endif
+    highlight_event->sx=0;
+    highlight_event->ex=0;
+    highlight_event->sy=0;
+    highlight_event->ey=0;
+    highlight_event->palette=0;
+    highlight_event->buttonN=0; }
+#ifdef USE_MPDVDNAV_TRACE
+    dvdnav_print_buttons(dvdnav_priv,"dvdnav_get_highlight");
+#endif
+return;
+}
+
+void dvdnav_get_button_palette(dvdnav_priv_t *dvdnav_priv,uint32_t *palette)	/* get button palette */
+{
+pci_t* pnavpci;
+int button_number;
+int buttonN;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (!palette) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+    for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+        btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+        if(buttonN==button_number+1) {					/* current button? */
+	    if (btni->btn_coln==0) *palette=0;
+		else *palette=
+		    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+	    }
+	}
+    }
+if (*palette==0)	/* if none current button? */
+    {
+    btni_t *btni = &(pnavpci->hli.btnit[0]);
+    if (btni->btn_coln==0) *palette=0;
+	else *palette=
+	    pnavpci->hli.btn_colit.btn_coli[btni->btn_coln-1][b_mode];
+    }
+return;
+}
+
+void dvdnav_print_buttons(dvdnav_priv_t *dvdnav_priv, char* txt)
+{
+#ifdef USE_MPDVDNAV_TRACE
+if( !mp_msg_test(MSGT_CPLAYER,MSGL_DBG2) ) return; 
+pci_t* pnavpci;
+int button_number;
+int buttonN;
+int b_mode = 0;
+if (!dvdnav_priv) return;
+if (!dvdnav_priv->dvdnav) return;
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: buttons number: %d (%s)\n",
+	pnavpci->hli.hl_gi.btn_ns,
+	txt);
+  for (button_number = 0; button_number < pnavpci->hli.hl_gi.btn_ns;
+	    button_number++) {
+    btni_t *btni = &(pnavpci->hli.btnit[button_number]);
+    if(buttonN==button_number+1) {					/* current button? */
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: *buttons: #%d (%d:%d,%d:%d)\n",
+	button_number,
+	btni->x_start,
+	btni->y_start,
+	btni->x_end,
+	btni->y_end);
+    } else {
+      if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav:  buttons: #%d (%d:%d,%d:%d)\n",
+	button_number,
+	btni->x_start,
+	btni->y_start,
+	btni->x_end,
+	btni->y_end);
+	}
+    }
+  } else {
+  if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	"dvdnav: buttons number: no buttons (%s)\n",
+	txt);
+  }
+#endif
+return;
+}
+
+
+#ifdef HAVE_NEW_GUI
+void dvdnav_mouse(dvdnav_priv_t * dvdnav_priv)
+{
+pci_t* pnavpci;
+if (dvdnav_mouse_set!=1) return;
+dvdnav_mouse_set=2;		// Lock mouse event
+if (NULL==(pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav )))
+  return;
+if (dvdnav_window_orig_width>0 &&
+    dvdnav_window_orig_height>0 &&
+    dvdnav_window_width>0 &&
+    dvdnav_window_height>0) {
+    // Calculate original mouse position (if scaled window)
+  dvdnav_mouse_orig_x=
+	dvdnav_mouse_x*dvdnav_window_orig_width/dvdnav_window_width;
+  dvdnav_mouse_orig_y=
+	dvdnav_mouse_y*dvdnav_window_orig_height/dvdnav_window_height;
+  } else {
+  dvdnav_mouse_orig_x=dvdnav_mouse_x;
+  dvdnav_mouse_orig_y=dvdnav_mouse_y; }
+if (pnavpci->hli.hl_gi.btn_ns) {	/* is buttons */
+    dvdnav_mouse_select(dvdnav_priv->dvdnav, pnavpci,
+	dvdnav_mouse_orig_x,
+	dvdnav_mouse_orig_y); /* mouse position select */
+#ifdef USE_MPDVDNAV_TRACE
+    if (dvdnav_mouse_button) dvdnav_print_buttons(dvdnav_priv,
+	"dvdnav_mouse");
+#endif
+  if (dvdnav_mouse_button) dvdnav_menu_action(dvdnav_priv,
+	MP_CMD_DVDNAV_SELECT); }	/* mouse button event */
+dvdnav_mouse_set=0;
+dvdnav_mouse_button=0;
+return;
+}
+#endif
+
+#define FIRST_AC3_AID 128
+#define FIRST_DTS_AID 136
+#define FIRST_MPG_AID 0
+#define FIRST_PCM_AID 160
+
+int dvdnav_stream_read(dvdnav_priv_t * dvdnav_priv, unsigned char *buf,
+    int *len,stream_dvdnav_event_t *event)
+{
+int eventid = DVDNAV_NOP;
+
+if (!len) return -1;
+*len=-1;
+if (!dvdnav_priv) return -1;
+if (!buf) return -1;
+if (dvdnav_priv->stopflg) return -1;
+
+if (dvd_nav_still) {
+  mp_msg(MSGT_CPLAYER,MSGL_DBG2,
+  MSGTR_MPDVDNAV_ReadInStillActive,
+  __FUNCTION__);
+  *len=0;
+  return -1;
+  }
+if (dvdnav_get_next_block(dvdnav_priv->dvdnav,buf,&eventid,len)!=
+    DVDNAV_STATUS_OK) {
+  mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	MSGTR_MPDVDNAV_ErrorGetNextBlock,
+	dvdnav_err_to_string(dvdnav_priv->dvdnav) );
+  *len=-1;
+  }
+  else if (eventid!=DVDNAV_BLOCK_OK) {
+    switch (eventid) {
+#if 0
+      case DVDNAV_NOP : {
+	event->eventflag.nop=1;
+	event->eventflag.isevent=1;
+	break; }
+#endif
+      case DVDNAV_STILL_FRAME: {
+	event->eventflag.still_frame=1;
+	event->eventflag.isevent=1;
+	dvdnav_priv->stillflg=1;
+	dvdnav_priv->stillok=0;
+	dvdnav_still_event_t *still_event = (dvdnav_still_event_t*)(buf);
+	event->still_length=still_event->length;
+	unsigned int end_time=0;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: still frame (%x)\n",
+	    event->still_length);
+#endif
+	if (still_event->length==0x01)		// FIXME: TIME HACK
+	  {
+	  pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	  end_time=(pnavpci->pci_gi.e_eltm.hour*3600+
+	    pnavpci->pci_gi.e_eltm.minute*60+
+	    pnavpci->pci_gi.e_eltm.second)*1000000;
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) {
+	    float et=end_time;
+	    et=et/1000000;
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		    "dvdnav: still wait time %8.3f sec (form pci_t) hack:(\n",
+		    et);
+	    }
+#endif
+	  }
+	if (event->still_length==0xff) {
+	  if (dvdnav_priv->stillcounter<dvdnav_still_repeat)
+	    dvdnav_still_back(dvdnav_priv->dvdnav);
+	    else
+	    dvdnav_priv->stillok=1;
+	  } else {
+	  if (end_time==0) end_time=still_event->length*1000000;
+	  if (!dvdnav_priv->cell_timer) {
+	    dvdnav_priv->cell_timer = GetTimer();
+	    dvdnav_priv->one_cell_timer = dvdnav_priv->cell_timer;
+	    }
+	  unsigned int now = GetTimer();
+#ifdef USE_MPDVDNAV_TRACE
+	  if (dvdnav_trace) {
+	    float pt=now-dvdnav_priv->cell_timer;
+	    pt=pt/1000000;
+	    float et=end_time;
+	    et=et/1000000;
+	    mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: remains time %8.3f sec\n",
+		et-pt);
+	    }
+#endif
+	  if (now-dvdnav_priv->cell_timer<end_time) {	// cell play time end?
+	    dvdnav_button_select_auto_action( dvdnav_priv->dvdnav, 1);
+	  if (dvdnav_priv->stillcounter<dvdnav_still_repeat)
+	    dvdnav_still_back(dvdnav_priv->dvdnav);
+	    else
+	    dvdnav_priv->stillok=1; // don't let dvdnav stall on this image
+	  } else {
+	  dvdnav_still_skip(dvdnav_priv->dvdnav);
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;}
+	  }
+	break; }
+      case DVDNAV_SPU_STREAM_CHANGE : {
+	event->eventflag.spu_stream_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_spu_stream_change_event_t *spu_stream_change_event =
+	    (dvdnav_spu_stream_change_event_t*)(buf);
+	event->spu_physical_wide=
+	    spu_stream_change_event->physical_wide;
+	event->spu_physical_letterbox=
+	    spu_stream_change_event->physical_letterbox;
+	event->spu_physical_pan_scan=
+	    spu_stream_change_event->physical_pan_scan;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: spu stream change\n");
+#endif
+	break; }
+      case DVDNAV_AUDIO_STREAM_CHANGE : {
+	event->eventflag.audio_stream_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_audio_stream_change_event_t *audio_stream_change_event =
+	    (dvdnav_audio_stream_change_event_t*)(buf);
+	event->audio_physical=
+	    audio_stream_change_event->physical;
+	event->audio_logical=
+	    audio_stream_change_event->logical;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: audio stream change\n");
+#endif
+	break; }
+      case DVDNAV_VTS_CHANGE : {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: vts change\n");
+#endif
+	event->eventflag.vts_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_vts_change_event_t *vts_change_event =
+	    (dvdnav_vts_change_event_t*)(buf);
+	event->vts_old_vtsN=vts_change_event->old_vtsN;
+	event->vts_old_domain=vts_change_event->old_domain;
+	event->vts_new_vtsN=vts_change_event->new_vtsN;
+	event->vts_new_domain=vts_change_event->new_domain;
+	dvdnav_get_position(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->tpos),
+	    &(dvdnav_priv->tlen));
+	if (!dvdnav_priv->vts_domain)
+	  dvdnav_priv->cell_timer=GetTimer();
+	  else
+	  dvdnav_priv->cell_timer=0;
+	event->cell_really_change=1;
+	dvdnav_priv->one_cell_timer=dvdnav_priv->cell_timer;
+	dvdnav_priv->stillok=0;
+	dvdnav_priv->stillflg=0;
+	dvdnav_priv->stillcounter=0;
+	dvdnav_priv->waitcounter=0;
+	dvdnav_priv->lockstillcounter=0;
+	break; }
+      case DVDNAV_CELL_CHANGE : {
+	event->eventflag.cell_change=1;
+	event->eventflag.isevent=1;
+	dvdnav_cell_change_event_t *cell_change_event =
+	    (dvdnav_cell_change_event_t*)(buf);
+	event->cell_cellN=cell_change_event->cellN;
+	event->cell_pgN=cell_change_event->pgN;
+	event->cell_cell_length=cell_change_event->cell_length;
+	event->cell_pg_length=cell_change_event->pg_length;
+	event->cell_pgc_length=cell_change_event->pgc_length;
+	event->cell_cell_start=cell_change_event->cell_start;
+	event->cell_pg_start=cell_change_event->pg_start;
+	int pgcN = 0;
+	dvdnav_get_pgc(dvdnav_priv->dvdnav, &pgcN);
+// get dvdnav audio setting
+	uint8_t alang=dvdnav_get_active_audio_stream(dvdnav_priv->dvdnav);
+	dvdnav_priv->alang=
+	    128+dvdnav_get_active_audio_stream(dvdnav_priv->dvdnav);
+// get dvdnav spu settings
+	dvdnav_priv->slang=dvdnav_get_active_spu_stream(dvdnav_priv->dvdnav);
+// get dvdnav aspect settings
+	dvdnav_priv->aspect=dvdnav_get_video_aspect(dvdnav_priv->dvdnav);
+// setting dvdnav info
+	dvdnav_priv->vts_domain=dvdnav_is_domain_vts(dvdnav_priv->dvdnav);
+	dvdnav_get_position(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->tpos),
+	    &(dvdnav_priv->tlen));
+	dvdnav_get_number_of_titles(dvdnav_priv->dvdnav,
+	    &(dvdnav_priv->titles_nr));
+	dvdnav_priv->part=0;
+	dvdnav_priv->title=0;
+	event->cell_really_change=0;
+	if (dvdnav_priv->cell_cellN!=event->cell_cellN ||
+		dvdnav_priv->cell_pgN!=event->cell_pgN ||
+		dvdnav_priv->cell_pgcN!=pgcN)	// really cell change?
+	  {
+	  event->cell_really_change=1;
+	  dvdnav_priv->stillcounter=0;
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->lockstillcounter=0;
+	  }
+	if (event->cell_really_change)
+	  {
+	  dvdnav_priv->stillok=0;
+	  dvdnav_priv->cell_timer=GetTimer();
+	  dvdnav_priv->one_cell_timer=dvdnav_priv->cell_timer;
+	  dvdnav_priv->stillflg=0;
+	  dvdnav_priv->stillcounter=0;
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->lockstillcounter=0;
+	  }
+	if (!(dvdnav_priv->vts_domain)) {
+	  dvdnav_priv->chapters_nr=0;
+	  dvdnav_priv->menu_sid=
+		dvdnav_get_active_spu_stream(dvdnav_priv->dvdnav);
+	  dvdnav_priv->final_pts=0.0;
+	  } else {
+	  dvdnav_priv->final_pts = cell_change_event->cell_length;
+	  dvdnav_priv->final_pts = dvdnav_priv->final_pts / 90000;
+	  dvdnav_current_title_info(dvdnav_priv->dvdnav,
+		&dvdnav_priv->title,
+		&dvdnav_priv->part);
+	  dvdnav_get_number_of_parts(dvdnav_priv->dvdnav,
+		dvdnav_priv->title,
+		&dvdnav_priv->chapters_nr);
+	  event->cell_really_change=1;
+
+	  uint32_t audio_id;
+	  audio_attr_t audio_attr;
+	  dvdnav_priv->nr_of_channels=0;
+	  int language;
+	  int i;
+	  for( i=0; i<8; i++) {
+	    if (-1!=(audio_id=audio_id=
+		dvdnav_get_audio_logical_stream(dvdnav_priv->dvdnav, i))) {
+	      dvdnav_get_audio_attr(dvdnav_priv->dvdnav, i, &audio_attr);
+	      language=0;
+	      if(audio_attr.lang_type==1)
+	        language=audio_attr.lang_code;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].language=
+		    language;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id=
+		    audio_id;
+	      switch (audio_attr.audio_format) {
+		case 0: // ac3
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_AC3_AID;
+		break;
+		case 6: // dts
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_DTS_AID;
+		break;
+		case 2: // mpeg layer 1/2/3
+		case 3: // mpeg2 ext
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_MPG_AID;
+		break;
+		case 4: // lpcm
+		  dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id+=
+			FIRST_PCM_AID;
+		break;
+		}
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].type=
+		    audio_attr.audio_format;
+	      dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].channels=
+		    audio_attr.channels;
+	      if (alang==i) dvdnav_priv->alang=
+		    dvdnav_priv->audio_streams[dvdnav_priv->nr_of_channels].id;
+	      dvdnav_priv->nr_of_channels++;
+	      }
+	    }
+	  dvdnav_priv->nr_of_subtitles=0;
+	  uint32_t sub_id;
+	  subp_attr_t subp_attr;
+	  for( i=0; i<32; i++)
+	    {
+	    if (-1!=(sub_id=dvdnav_get_spu_logical_stream(dvdnav_priv->dvdnav,
+		i))) {
+	      dvdnav_get_spu_attr(dvdnav_priv->dvdnav, i, &subp_attr);
+	      language=0;
+	      if(subp_attr.type==1) language=subp_attr.lang_code;
+	      dvdnav_priv->subtitles[dvdnav_priv->nr_of_subtitles].language=
+		    language;
+	      dvdnav_priv->subtitles[dvdnav_priv->nr_of_subtitles].id=
+		    sub_id;
+	      dvdnav_priv->nr_of_subtitles++;
+	      }
+	    }
+	  }
+	dvdnav_priv->cell_cellN=cell_change_event->cellN;
+	dvdnav_priv->cell_pgN=cell_change_event->pgN;
+	dvdnav_priv->cell_pgcN=pgcN;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: cell change\n");
+#endif
+	break; }
+      case DVDNAV_NAV_PACKET : {
+	event->eventflag.nav_packet=1;
+	event->eventflag.isevent=1;
+	pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	int buttonN;
+	if (pnavpci && pnavpci->hli.hl_gi.btn_ns) {
+	  dvdnav_get_current_highlight(dvdnav_priv->dvdnav, &buttonN);	/* get current button ID */
+	  if (buttonN==0 || buttonN > pnavpci->hli.hl_gi.btn_ns)
+	    {
+	    dvdnav_button_select( dvdnav_priv->dvdnav , pnavpci, 1);
+#ifdef USE_MPDVDNAV_TRACE
+	    if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+		"dvdnav: reset menu button number\n");
+#endif
+	    }
+	  }
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: nav packet\n");
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+	dvdnav_print_buttons(dvdnav_priv,"highlight event");
+#endif
+	break; }
+      case DVDNAV_STOP: {
+        event->eventflag.stop=1;
+	event->eventflag.isevent=1;
+	dvdnav_priv->stopflg=1;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: stop\n");
+#endif
+	break; }
+      case DVDNAV_HIGHLIGHT : {
+	event->eventflag.highlight=1;
+	event->eventflag.isevent=1;
+	dvdnav_highlight_event_t *highlight_event =
+	    (dvdnav_highlight_event_t*)(buf);
+	event->hl_display=highlight_event->display;
+	/* libdvdnav v0.1.10: these fields are currently not set!! */
+	dvdnav_get_highlight(dvdnav_priv,highlight_event,1);
+	event->hl_palette=highlight_event->palette;
+	event->hl_sx=highlight_event->sx;
+	event->hl_sy=highlight_event->sy;
+	event->hl_ex=highlight_event->ex;
+	event->hl_ey=highlight_event->ey;
+	event->hl_pts=highlight_event->pts;
+	event->hl_buttonN=highlight_event->buttonN;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: highlight (%i:%i-%i:%i #%i)\n",
+	    event->hl_sx,
+	    event->hl_sy,
+	    event->hl_ex,
+	    event->hl_ey,
+	    event->hl_buttonN);
+#endif
+#ifdef USE_MPDVDNAV_TRACE
+	dvdnav_print_buttons(dvdnav_priv,"highlight event");
+#endif
+	break; }
+      case DVDNAV_SPU_CLUT_CHANGE: {
+	event->eventflag.spu_clut_change=1;
+	event->eventflag.isevent=1;
+	memcpy(event->spu_clut,buf,16*sizeof(uint32_t));
+	dvdnav_get_button_palette(dvdnav_priv,&(event->spu_palette));
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: spu clut change\n");
+#endif
+        break; }
+      case DVDNAV_HOP_CHANNEL : {
+	event->eventflag.hop_channel=1;
+	event->eventflag.isevent=1;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: hop channel\n");
+#endif
+	break; }
+      case DVDNAV_WAIT: {
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: wait\n");
+#endif
+        event->eventflag.wait=1;
+        event->eventflag.isevent=1;
+        int flag=0;
+        dvdnav_is_still_cell( dvdnav_priv->dvdnav , &flag);
+        if (!flag && dvdnav_priv->lockseek) {
+	  dvdnav_wait_back(dvdnav_priv->dvdnav);
+	  break; }
+	if (!dvdnav_priv->vts_domain && dvdnav_priv->cell_timer && !flag) {
+	pci_t* pnavpci = dvdnav_get_current_nav_pci( dvdnav_priv->dvdnav );
+	unsigned int end_time=(pnavpci->pci_gi.e_eltm.hour*3600+
+		pnavpci->pci_gi.e_eltm.minute*60+
+		pnavpci->pci_gi.e_eltm.second)*1000000;
+	unsigned int now = GetTimer();
+	float t;
+	t=now-dvdnav_priv->one_cell_timer;
+	dvdnav_priv->one_cell_timer=now;
+	t=t/1000000;
+	float rt=end_time-(now-dvdnav_priv->cell_timer);
+	rt=rt/1000000;
+	float et=end_time;
+	et=et/1000000;
+#ifdef USE_MPDVDNAV_TRACE
+	if (dvdnav_trace) mp_msg(MSGT_CPLAYER,MSGL_INFO,
+	    "dvdnav: remains time %8.3f sec (%8.3f/%8.3f sec)\n",
+	    rt,et,t);
+#endif
+	if (t<2.00 && et>4.00) {				// correct cell play time?
+	  if (now-dvdnav_priv->cell_timer<end_time) {	// cell play time end?
+	    if (dvdnav_priv->waitcounter<dvdnav_still_repeat)
+	      {
+	      dvdnav_wait_back(dvdnav_priv->dvdnav);
+	      dvdnav_priv->waitcounter++;
+	      }
+	    } else {
+	    dvdnav_priv->waitcounter=0;
+	    dvdnav_priv->cell_timer=0;
+	    dvdnav_priv->one_cell_timer=0;
+	    dvdnav_priv->back_from_timer=1;
+	    dvdnav_wait_still_clear(dvdnav_priv->dvdnav);
+	    }
+	  } else {
+	  dvdnav_wait_skip(dvdnav_priv->dvdnav);
+	  dvdnav_priv->waitcounter=0;
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;
+	  }
+	} else {
+	dvdnav_wait_skip(dvdnav_priv->dvdnav);
+	if (!flag) {
+	  dvdnav_priv->cell_timer=0;
+	  dvdnav_priv->one_cell_timer=0;
+	  dvdnav_priv->waitcounter=0;
+	  }
+	}
+      break;
+      }
+    }
+  *len=0;
+  }
+return eventid;
+}
+
+
+static int fill_buffer(stream_t *s, char *but, int len)
+{
+int event;
+dvdnav_priv_t* dvdnav_priv=s->priv;
+len=0;
+while (len==0) /* grab all event until DVDNAV_BLOCK_OK (len=2048), DVDNAV_STOP or DVDNAV_STILL_FRAME */
+  {
+  if (-1==(event=dvdnav_stream_read(dvdnav_priv, s->buffer, &len,
+	    &(dvdnav_priv->event))) ||
+	len==-1)
+    {
+    mp_msg(MSGT_CPLAYER,MSGL_ERR,
+	"DVDNAV stream read error!\n");
+    return 0;
+    }
+  switch (event) {
+    case DVDNAV_STOP: return len; break; /* return eof */
+    case DVDNAV_STILL_FRAME: {
+      if (!dvdnav_priv->stillok) dvdnav_priv->stillcounter++;
+      dvdnav_priv->lockstillcounter++;
+      return len;
+      break; }/* return eof */
+    case DVDNAV_WAIT: {
+      if (dvdnav_priv->waitcounter>=dvdnav_still_repeat) return len;
+      break;
+      }
+    }
+  if (dvdnav_priv->event.cell_really_change &&
+	dvdnav_priv->started &&
+	!dvdnav_priv->vts_domain) return len;
+  }
+mp_msg(MSGT_STREAM,MSGL_DBG2,"DVDNAV fill_buffer len: %d\n",len);
+return len;
+}
+
+static int control(stream_t *stream,int cmd,void* arg) 
+{
+dvdnav_priv_t *priv = stream->priv;
+switch(cmd) 
+  {
+  case STREAM_CTRL_GET_TIME_LENGTH:
+    {
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_LANG_FROM_SID:
+    {
+    *(int*)arg = dvdnav_lang_from_sid(priv,*(int*)arg);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_SID_FROM_LANG:
+    {
+    if (!arg) return STREAM_ERROR;
+    (*(struct dvd_idfromlang_st*)arg).id=dvdnav_sid_from_lang(priv, 
+	(*(struct dvd_idfromlang_st*)arg).lang);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_AID_FROM_LANG:
+    {
+    if (!arg) return STREAM_ERROR;
+    (*(struct dvd_idfromlang_st*)arg).id=dvdnav_aid_from_lang(priv, 
+	(*(struct dvd_idfromlang_st*)arg).lang);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_NUMBER_OF_SUBS:
+    {
+    *(int*)arg = dvdnav_number_of_subs(priv);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_REALLYEOF:
+    {
+    if (dvdnav_reallyeof(priv))
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_STOP:
+    {
+    if (priv->event.eventflag.stop)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_WAIT:
+    {
+    if (priv->event.eventflag.wait)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_STILL:
+    {
+    if (priv->event.eventflag.still_frame)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_VTS:
+    {
+    if (priv->event.eventflag.vts_change)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN:
+    {
+    if (priv->vts_domain)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_GET_AUDIO_ID:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(int*)arg = priv->alang;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_GET_DVDSUB_ID:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(int*)arg = priv->slang;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_CELL:
+    {
+    if (priv->event.eventflag.cell_change)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_REALLY_CHANGE:
+    {
+    if (priv->event.cell_really_change)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_TITLESET:
+    {
+    priv->lasttitle=priv->title;
+    priv->lastpart=priv->part;
+    priv->old_vts_domain=priv->vts_domain;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_IS_NEW_TITLE:
+    {
+    if (priv->lasttitle!=priv->title)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_SPU_CLUT:
+    {
+    if (priv->event.eventflag.spu_clut_change)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_GET_SPU_CLUT:
+    {
+    memcpy(arg,&(priv->event.spu_clut),sizeof(spu_clut_t));
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_GET_SPU_PALETTE:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(uint32_t*)arg=priv->event.spu_palette;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_HIGHLIGHT:
+    {
+    if (priv->event.eventflag.highlight)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_NAV_PACKET:
+    {
+    if (priv->event.eventflag.nav_packet)
+      return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_EVENT_CLEAR:
+    {
+    dvdnav_event_clear(priv);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_STILLOK:
+    {
+    if (priv->stillok) return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_SHOW:
+    {
+    if (!arg) return STREAM_ERROR;
+    dvdnav_highlight_event_t highlight_event;
+    dvdnav_get_highlight(priv,&highlight_event,1);
+    (*(mp_highlight_t*)arg).display=highlight_event.display;
+    (*(mp_highlight_t*)arg).sx=highlight_event.sx;
+    (*(mp_highlight_t*)arg).sy=highlight_event.sy;
+    (*(mp_highlight_t*)arg).ex=highlight_event.ex;
+    (*(mp_highlight_t*)arg).ey=highlight_event.ey;
+    (*(mp_highlight_t*)arg).pts=highlight_event.pts;
+    (*(mp_highlight_t*)arg).palette=highlight_event.palette;
+    (*(mp_highlight_t*)arg).buttonN=highlight_event.buttonN;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_ACTIVATE:
+    {
+    if (!arg) return STREAM_ERROR;
+    dvdnav_highlight_event_t highlight_event;
+    dvdnav_get_highlight(priv,&highlight_event,2);
+    (*(mp_highlight_t*)arg).display=highlight_event.display;
+    (*(mp_highlight_t*)arg).sx=highlight_event.sx;
+    (*(mp_highlight_t*)arg).sy=highlight_event.sy;
+    (*(mp_highlight_t*)arg).ex=highlight_event.ex;
+    (*(mp_highlight_t*)arg).ey=highlight_event.ey;
+    (*(mp_highlight_t*)arg).palette=highlight_event.palette;
+    (*(mp_highlight_t*)arg).pts=highlight_event.pts;
+    (*(mp_highlight_t*)arg).buttonN=highlight_event.buttonN;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_CHANGE_ASPECT:
+    {
+    if (priv->lastaspect!=priv->aspect) return STREAM_OK;
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_GET_ASPECT:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(int*)arg=priv->aspect;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_SYNC_ASPECT:
+    {
+    priv->lastaspect=priv->aspect;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_SET_LOCKSEEK:
+    {
+    if (!arg) return STREAM_ERROR;
+    priv->lockseek=*(int*)arg;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_GET_FINALPTS:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(float*)arg=priv->final_pts;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_GET_TLEN:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(uint32_t*)arg=priv->tlen;
+    return STREAM_OK;
+    }
+#ifdef HAVE_NEW_GUI
+  case STREAM_CTRL_DVDNAV_MOUSE:
+    {
+    dvdnav_mouse(priv);
+    return STREAM_OK;
+    }
+#endif
+  case STREAM_CTRL_DVDNAV_TITLE_PLAY:
+    {
+    if (!arg) return STREAM_ERROR;
+    dvdnav_title_play(priv->dvdnav,*(int32_t*)arg);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_PART_PLAY:
+    {
+    if (!arg) return STREAM_ERROR;
+    dvdnav_part_play(priv->dvdnav,priv->title,*(int32_t*)arg);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_MENUCALL:
+    {
+    if (!arg) return STREAM_ERROR;
+    switch (*(int*)arg) {
+      case DVD_MENUCALL_Escape: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Escape);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Title: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Title);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Root: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Root);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Subpicture: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Subpicture);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Audio: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Audio);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Angle: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Angle);
+	return STREAM_OK;}
+      case DVD_MENUCALL_Part: {
+	dvdnav_menu_call(priv->dvdnav,DVD_MENU_Part);
+	return STREAM_OK;}
+      }
+    return STREAM_ERROR;
+    }
+  case STREAM_CTRL_DVDNAV_MENUFORCE:
+    {
+    dvdnav_menu_force(priv);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_MENU_ACTION:
+    {
+    if (!arg) return STREAM_ERROR;
+    dvdnav_menu_action(priv,*(int*)arg);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_FULL_START:
+    {
+    dvdnav_stream_fullstart(priv);
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_SET_ALANG:
+    {
+    if (!arg) return STREAM_ERROR;
+    if (!*(char**)arg) return STREAM_ERROR;
+    if (dvdnav_audio_language_select(priv->dvdnav, *(char**)arg ) !=
+	DVDNAV_STATUS_OK) {	/* FIXME: don't work! */
+      mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting spu languages: %s\n",
+	dvdnav_err_to_string(priv->dvdnav)); 
+      return STREAM_ERROR;
+      }
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_SET_SLANG:
+    {
+    if (!arg) return STREAM_ERROR;
+    if (!*(char**)arg) return STREAM_ERROR;
+    if (dvdnav_spu_language_select(priv->dvdnav, *(char**)arg ) !=
+	DVDNAV_STATUS_OK) {	/* FIXME: don't work! */
+      mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting spu languages: %s\n",
+	dvdnav_err_to_string(priv->dvdnav)); 
+      return STREAM_ERROR;
+      }
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_SET_MLANG:
+    {
+    if (!arg) return STREAM_ERROR;
+    if (!*(char**)arg) return STREAM_ERROR;
+    if (dvdnav_menu_language_select(priv->dvdnav, *(char**)arg ) !=
+	DVDNAV_STATUS_OK) {	/* FIXME: don't work! */
+      mp_msg(MSGT_FIXME, MSGL_FIXME, "Error on setting spu languages: %s\n",
+	dvdnav_err_to_string(priv->dvdnav)); 
+      return STREAM_ERROR;
+      }
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_DVDNAV_GET_MENU_SID:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(int*)arg=priv->menu_sid;
+    return STREAM_OK;
+    }
+  case STREAM_CTRL_GET_PALETTE:
+    {
+    if (!arg) return STREAM_ERROR;
+    *(unsigned int*)arg=dvdnav_stream_get_palette(priv);;
+    return STREAM_OK;
+    }
+
+  }
+return STREAM_UNSUPORTED;
+}
+
+
+dvdnav_priv_t * new_dvdnav_stream(char * filename, uint32_t titlenum)
+{
+char * title_str;
+dvdnav_priv_t *dvdnav_priv;
+if (!filename) return NULL;
+if (!(dvdnav_priv=(dvdnav_priv_t*)calloc(1,sizeof(*dvdnav_priv)))) return NULL;
+if (!(dvdnav_priv->filename=strdup(filename)))
+  {
+  free(dvdnav_priv);
+  return NULL;
+  }
+if(dvdnav_open(&(dvdnav_priv->dvdnav),dvdnav_priv->filename)!=
+    DVDNAV_STATUS_OK)
+  {
+  free(dvdnav_priv->filename);
+  free(dvdnav_priv);
+  return NULL;
+  }
+if (!dvdnav_priv->dvdnav)
+  {
+  free(dvdnav_priv);
+  return NULL;
+  }
+/* turn on dvdnav caching */
+dvdnav_set_readahead_flag(dvdnav_priv->dvdnav,0);
+/* report the title?! */
+if (dvdmenu_lang)	// menu
+  {
+  if (dvdnav_menu_language_select(dvdnav_priv->dvdnav, dvdmenu_lang ) !=
+	DVDNAV_STATUS_OK)
+    mp_msg(MSGT_FIXME, MSGL_FIXME,
+	"Error on setting menu languages: %s\n",
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+  }
+/* use title time length (default: part time length) */
+if (dvdnav_set_PGC_positioning_flag(dvdnav_priv->dvdnav, 1) !=
+	DVDNAV_STATUS_OK)
+  mp_msg(MSGT_FIXME, MSGL_FIXME,
+	"Error on setting pgc based: %s\n",
+	dvdnav_err_to_string(dvdnav_priv->dvdnav));
+dvdnav_event_clear(dvdnav_priv);
+if (titlenum>0) dvdnav_go_title=titlenum;
+dvdnav_priv->lastaspect=-1;
+return dvdnav_priv;
+}
+
+void mp_dvdnav_update_mouse_pos(stream_t *stream, int32_t x, int32_t y, int* button) {
+  dvdnav_priv_t * dvdnav_priv=(dvdnav_priv_t*)stream->priv;
+  dvdnav_t *nav = dvdnav_priv->dvdnav;
+  dvdnav_status_t status;
+  pci_t *pci = dvdnav_get_current_nav_pci(nav);
+
+  *button = -1;
+  if(!pci) return;
+  if (pci->hli.hl_gi.btn_ns==0) return;
+
+  status = dvdnav_mouse_select(nav, pci, x, y);
+  if(status == DVDNAV_STATUS_OK) dvdnav_get_current_highlight(nav, button);
+  else *button = -1;
+  dvdnav_priv->mousex = x;
+  dvdnav_priv->mousey = y;
+}
+
+
+void free_dvdnav_stream(dvdnav_priv_t * dvdnav_priv)
+{
+if (!dvdnav_priv) return;
+dvdnav_close(dvdnav_priv->dvdnav);
+dvdnav_priv->dvdnav=NULL;
+free(dvdnav_priv);
+}
+
+
+static int open_s(stream_t *stream,int mode, void* opts, int* file_format)
+{
+struct stream_priv_s* p = (struct stream_priv_s*)opts;
+char *filename, *name;
+int event,len,tmplen=0;
+dvdnav_priv_t *dvdnav_priv;
+
+mp_msg(MSGT_OPEN,MSGL_INFO,"URL: %s\n", filename);
+filename = strdup(stream->url);
+name = (filename[9] == '\0') ? NULL : filename + 9;
+uint32_t titlenum=0;
+if (name) titlenum=atoi(name);	/* eg. mplayer dvdnav://1 */
+if (dvd_device)
+  {
+  if(!(dvdnav_priv=new_dvdnav_stream(dvd_device,titlenum)))
+    {
+    mp_msg(MSGT_OPEN,MSGL_ERR,MSGTR_CantOpenDVD,dvd_device);
+    return STREAM_UNSUPORTED;
+    }
+  } else {
+  if(!(dvdnav_priv=new_dvdnav_stream(DEFAULT_DVD_DEVICE,titlenum)))
+    {
+    mp_msg(MSGT_OPEN,MSGL_ERR,MSGTR_CantOpenDVD,dvd_device);
+    return STREAM_UNSUPORTED;
+    }
+  }
+stream->sector_size = 2048;
+stream->flags = STREAM_READ | STREAM_SEEK;
+stream->fill_buffer = fill_buffer;
+stream->seek = seek;
+stream->control = control;
+stream->close = stream_dvdnav_close;
+stream->type = STREAMTYPE_DVDNAV;
+stream->priv=(void*)dvdnav_priv;
+return STREAM_OK;
+}
+
+stream_info_t stream_info_dvdnav = {
+  "DVDNAV stream",
+  "dvdnav",
+  "Otvos Attila",
+  "",
+  open_s,
+  { "dvdnav", NULL },
+  &stream_opts,
+  1 // Urls are an option string
+};
+
+#endif	// #ifdef USE_MPDVDNAV
+
+#endif
\ No newline at end of file
diff -Nur MPlayer-1.0rc1.orig/stream/stream_dvdnav.h MPlayer-1.0rc1/stream/stream_dvdnav.h
--- MPlayer-1.0rc1.orig/stream/stream_dvdnav.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/stream/stream_dvdnav.h	2006-12-04 00:10:44.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _MPLAYER_DVDNAV_STREAM_H
 #define _MPLAYER_DVDNAV_STREAM_H
 
+#if 0
+// original stream_dvdnav.h from MPlayer-1.0rc1
 #include <dvdnav.h>
 
 typedef struct {
@@ -34,5 +36,209 @@
 
 int mp_dvdnav_handle_input(stream_t *stream, int cmd, int *button);
 void mp_dvdnav_update_mouse_pos(stream_t *stream, int32_t x, int32_t y, int* button);
+// end of original stream_dvdnav.h from MPlayer-1.0rc1
+#else
 
+#ifndef __STREAM_DVDNAV_H_
+#ifdef USE_MPDVDNAV		// enable dvdnav support?
+#define __STREAM_DVDNAV_H_
+#ifdef USE_DVDREAD
+#ifdef USE_MPDVDKIT
+#if (USE_MPDVDKIT == 2)
+#include "libmpdvdkit2/dvd_input.h"
+#include "libmpdvdkit2/dvd_reader.h"
+#include "libmpdvdkit2/ifo_types.h"
+#include "libmpdvdkit2/ifo_read.h"
+#include "libmpdvdkit2/nav_read.h"
+#else
+#include "libmpdvdkit/dvd_input.h"
+#include "libmpdvdkit/dvd_reader.h"
+#include "libmpdvdkit/ifo_types.h"
+#include "libmpdvdkit/ifo_read.h"
+#include "libmpdvdkit/nav_read.h"
+#endif
+#else
+#include <dvdread/dvd_input.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/nav_read.h>
+#endif
+
+#include "libmpdvdnav/dvdnav.h"
+
+#define DVDNAV_MAX_STILL_FRAME	5
+
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#define min(x,y) ((x) < (y) ? (x) : (y))
+
+typedef struct {
+  int event;             /* event number fromd dvdnav_events.h */
+  void * details;        /* event details */
+  int len;               /* bytes in details */
+} dvdnav_event_t;
+
+
+typedef struct stream_dvdnav_event_flg_st {
+    unsigned int nop : 1;			// 1
+    unsigned int still_frame : 1;		// 2
+    unsigned int spu_stream_change : 1;		// 3
+    unsigned int audio_stream_change : 1;	// 4
+    unsigned int vts_change : 1;		// 5
+    unsigned int cell_change : 1;		// 6
+    unsigned int nav_packet : 1;		// 7
+    unsigned int stop : 1;			// 8
+    unsigned int highlight : 1;			// 9
+    unsigned int spu_clut_change : 1;		// 10
+    unsigned int none1 : 1;
+    unsigned int hop_channel : 1;		// 12
+    unsigned int wait : 1;			// 13
+    unsigned int none2 : 2;
+    unsigned int isevent : 1;
+} stream_dvdnav_event_flg_t;
+
+
+typedef struct stream_dvdnav_event_st {
+stream_dvdnav_event_flg_t eventflag;
+off_t			eventid;
+// store dvdnav event parameters
+// DVDNAV_STILL_FRAME
+int 			still_length;
+// DVDNAV_SPU_STREAM_CHANGE
+int 			spu_physical_wide;
+int 			spu_physical_letterbox;
+int 			spu_physical_pan_scan;
+// DVDNAV_AUDIO_STREAM_CHANGE
+int 			audio_physical;
+int 			audio_logical;
+// DVDNAV_VTS_CHANGE
+int 			vts_old_vtsN;
+dvd_read_domain_t 	vts_old_domain;
+int 			vts_new_vtsN;
+dvd_read_domain_t 	vts_new_domain;
+// DVDNAV_CELL_CHANGE
+int 			cell_cellN;
+int 			cell_pgN;
+int64_t 		cell_cell_length;
+int64_t 		cell_pg_length;
+int64_t 		cell_pgc_length;
+int64_t 		cell_cell_start;
+int64_t 		cell_pg_start;
+int			cell_really_change;
+// DVDNAV_HIGHLIGHT
+int			hl_display;
+uint32_t		hl_palette;
+uint16_t		hl_sx,hl_sy,hl_ex,hl_ey;
+uint32_t		hl_pts;
+uint32_t		hl_buttonN;
+// DVDNAV_SPU_CLUT_CHANGE
+uint32_t 		spu_clut[16];
+uint32_t		spu_palette;
+} stream_dvdnav_event_t;
+
+
+
+typedef struct {
+ int id; // 0 - 31 mpeg; 128 - 159 ac3; 160 - 191 pcm
+ int language;
+ int type;
+ int channels;
+} nstream_language_t;
+
+typedef struct {
+    dvdnav_t			*dvdnav;		/* libdvdnav handle */
+    char			*filename;
+    int				started;		/* libdvdnav start */
+    int				stopflg;		/* libdvdnav stop event */
+    int 			vts_domain;		/* is vts domain flag */
+    int		   		old_vts_domain;		/* old vts domain flag */
+    uint32_t			tpos;			/* title pos */
+    uint32_t			tlen;			/* title length */
+    float			final_pts;		/* playback time */
+
+    int32_t 			title;			/* current title number */
+    int32_t 			part;			/* current chapter number */
+    int32_t			lasttitle;		/* last title number */
+    int32_t			lastpart;		/* last chapter number */
+
+    uint8_t  			alang;			/* current audio language */
+    uint8_t  			slang;			/* current spu language */
+    uint8_t			menu_sid;		/* current menu spu stream id */
+    uint8_t 			aspect;			/* current video aspect */
+    uint8_t			lastaspect;		/* last aspect */
+    uint32_t			titles_nr;		/* number of titles */
+    uint32_t			chapters_nr;		/* number of chapters in actual title */
+    int 			nr_of_channels;		/* number of audio channels */
+    nstream_language_t 		audio_streams[32]; 	/* audio properties */
+    int				nr_of_subtitles;	/* number of subtitles */
+    nstream_language_t 		subtitles[32];		/* subtitles properties */
+    stream_dvdnav_event_t	event;			/* dvdnav event storage st/ructure */
+    int				stillflg;		/* still frame mode */
+    int				stillcounter;
+    int				waitcounter;
+    int				lockstillcounter;
+    int				lockseek;		/* disable seek sector */
+    int				stillok;
+    unsigned int		cell_timer;		/* pgc cell timer */
+    unsigned int		one_cell_timer;		/* pgc only one cell timer */
+    int				back_from_timer;	/* if back from timer then nav_demux_seek required */
+
+    int				cell_cellN;		/* last cellN */
+    int				cell_pgN;		/* last pgN */
+    int				cell_pgcN;		/* last pgcN */
+    int				lock_pgN;		/* lock pgN */
+    int				lock_pgcN;		/* lock pgcN */
+    int				mousex, mousey;
+} dvdnav_priv_t;
+
+// open new dvdnav stream
+dvdnav_priv_t * new_dvdnav_stream(char * filename, uint32_t titlenum);
+// read dvdnav block or event
+int dvdnav_stream_read(dvdnav_priv_t * dvdnav_priv, unsigned char *buf, 
+    int *len,stream_dvdnav_event_t *event);
+// clear all stored event
+void dvdnav_event_clear(dvdnav_priv_t * dvdnav_priv);
+// close and free dvdnav
+void free_dvdnav_stream(dvdnav_priv_t * dvdnav_priv);
+// get palette
+unsigned int * dvdnav_stream_get_palette(dvdnav_priv_t * dvdnav_priv);
+// call menu action UP,DOWN,LEFT,RIGHT,ACTIVATE & MENU
+int dvdnav_menu_action(dvdnav_priv_t * dvdnav_priv, int action);
+// go main menu with skip intro
+int dvdnav_menu_force(dvdnav_priv_t * dvdnav_priv);
+void dvdnav_stream_fullstart(dvdnav_priv_t *dvdnav_priv);
+// is dvdnav stop event?
+int dvdnav_reallyeof(dvdnav_priv_t * dvdnav_priv);
+// set languages
+void dvdnav_set_language(dvdnav_priv_t *dvdnav_priv, char* alang, 
+    char *slang, char *mlang);
+// get lang sid
+int dvdnav_lang_from_sid(dvdnav_priv_t * dvdnav_priv, int id);
+// get lang sid
+int dvdnav_sid_from_lang(dvdnav_priv_t * dvdnav_priv, unsigned char* lang);
+// get audio sid
+int dvdnav_aid_from_lang(dvdnav_priv_t * dvdnav_priv, unsigned char* lang);
+// get subtitles number
+int dvdnav_number_of_subs(dvdnav_priv_t * dvdnav_priv);
+// get highlight properties
+void dvdnav_get_highlight(dvdnav_priv_t *dvdnav_priv,
+    dvdnav_highlight_event_t *highlight_event,
+    int display_mode);
+// show menu button (dvdnav-trace)
+void dvdnav_print_buttons(dvdnav_priv_t *dvdnav_priv,char* txt);
+// get current button palette
+void dvdnav_get_button_palette(dvdnav_priv_t *dvdnav_priv,uint32_t *palette);
+#ifdef HAVE_NEW_GUI
+// hadler gmplayer mouse
+void dvdnav_mouse(dvdnav_priv_t * dvdnav_priv);
+
+void mp_dvdnav_update_mouse_pos(stream_t *stream, int32_t x, int32_t y, int* button);
+
+#endif // HAVE_NEW_GUI
+#endif // USE_DVDREAD
+#endif // USE_MPDVDNAV
+#endif // __STREAM_DVDNAV_H_
+
+
+#endif
 #endif
diff -Nur MPlayer-1.0rc1.orig/stream/stream.h MPlayer-1.0rc1/stream/stream.h
--- MPlayer-1.0rc1.orig/stream/stream.h	2006-12-04 00:07:42.000000000 +0100
+++ MPlayer-1.0rc1/stream/stream.h	2006-12-04 00:10:44.000000000 +0100
@@ -57,6 +57,70 @@
 #define STREAM_CTRL_GET_CURRENT_CHAPTER 3
 #define STREAM_CTRL_GET_NUM_CHAPTERS 4
 
+#define STREAM_CTRL_LANG_FROM_SID 5
+#define STREAM_CTRL_SID_FROM_LANG 6
+#define STREAM_CTRL_AID_FROM_LANG 7
+typedef struct dvd_idfromlang_st {
+  unsigned char* lang;
+  int id;
+  } dvd_idfromlang_t;
+#define STREAM_CTRL_NUMBER_OF_SUBS 8
+#define STREAM_CTRL_DVDNAV_REALLYEOF 9
+#define STREAM_CTRL_DVDNAV_EVENT_STOP 10
+#define STREAM_CTRL_DVDNAV_EVENT_WAIT 11
+#define STREAM_CTRL_DVDNAV_EVENT_STILL 12
+#define STREAM_CTRL_DVDNAV_EVENT_VTS 13
+#define STREAM_CTRL_DVDNAV_EVENT_VTS_DOMAIN 14
+#define STREAM_CTRL_GET_AUDIO_ID 15
+#define STREAM_CTRL_GET_DVDSUB_ID 16
+#define STREAM_CTRL_DVDNAV_EVENT_CELL 17
+#define STREAM_CTRL_DVDNAV_REALLY_CHANGE 18
+#define STREAM_CTRL_DVDNAV_TITLESET 19
+#define STREAM_CTRL_DVDNAV_IS_NEW_TITLE 20
+#define STREAM_CTRL_DVDNAV_EVENT_SPU_CLUT 21
+#define STREAM_CTRL_GET_SPU_CLUT 22
+typedef uint32_t spu_clut_t[16];
+#define STREAM_CTRL_GET_SPU_PALETTE 23
+typedef uint32_t spu_palette_t;
+#define STREAM_CTRL_DVDNAV_EVENT_HIGHLIGHT 24
+#define STREAM_CTRL_DVDNAV_EVENT_NAV_PACKET 25
+#define STREAM_CTRL_DVDNAV_EVENT_CLEAR 26
+#define STREAM_CTRL_DVDNAV_STILLOK 27
+typedef struct {
+  int display;
+  uint32_t palette;
+  uint16_t sx,sy,ex,ey;
+  uint32_t pts;
+  uint32_t buttonN;
+} mp_highlight_t;
+#define STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_SHOW 28
+#define STREAM_CTRL_DVDNAV_GET_HIGHLIGHT_ACTIVATE 29
+#define STREAM_CTRL_CHANGE_ASPECT 30
+#define STREAM_CTRL_GET_ASPECT 31
+#define STREAM_CTRL_SYNC_ASPECT 32
+#define STREAM_CTRL_DVDNAV_SET_LOCKSEEK 33
+#define STREAM_CTRL_GET_FINALPTS 34
+#define STREAM_CTRL_GET_TLEN 35
+#define STREAM_CTRL_DVDNAV_MOUSE 36
+#define STREAM_CTRL_DVDNAV_TITLE_PLAY 37
+#define STREAM_CTRL_DVDNAV_PART_PLAY 38
+#define STREAM_CTRL_DVDNAV_MENUCALL 39
+#define DVD_MENUCALL_Escape     0
+#define DVD_MENUCALL_Title      2
+#define DVD_MENUCALL_Root       3
+#define DVD_MENUCALL_Subpicture 4
+#define DVD_MENUCALL_Audio      5
+#define DVD_MENUCALL_Angle      6
+#define DVD_MENUCALL_Part       7
+#define STREAM_CTRL_DVDNAV_MENUFORCE 40
+#define STREAM_CTRL_DVDNAV_MENU_ACTION 41
+#define STREAM_CTRL_FULL_START 42
+#define STREAM_CTRL_SET_ALANG 43
+#define STREAM_CTRL_SET_SLANG 44
+#define STREAM_CTRL_SET_MLANG 45
+#define STREAM_CTRL_DVDNAV_GET_MENU_SID 46
+#define STREAM_CTRL_GET_PALETTE 47
+
 #ifdef MPLAYER_NETWORK
 #include "network.h"
 #endif
@@ -299,6 +363,43 @@
 
 extern char * audio_stream;
 
+#ifdef USE_DVDNAV
+extern int dvd_nav_skip_opening;
+extern int dvd_nav_still;
+extern int dvdnav_menutype;		/* dvdnav menu type: 0-SPU, 1-BOX, 2-SPU&BOX */
+extern int dvdnav_continue_play;
+extern int dvdnav_go_title;		/* dvdnav_title_play */
+extern int dvdnav_go_part;		/* dvdnav_part_play */
+extern int dvdnav_go_menu;		/* call main menu */
+extern int dvdnav_go_menu_force;	/* call force main menu with skip intro*/
+extern int dvdnav_go_audio;		/* dvdnav set new audio stream */
+extern int dvdnav_go_spu;		/* dbdnav set new spu stream */
+extern int dvdnav_force_menu;		/* force display menu with simple box */
+extern int dvdnav_skipintro;		/* skip intro before dvd menu */
+extern int dvdnav_color_spu;		/* enable color spu buttons */
+extern int dvdnav_still_repeat;		/* still pgc repeat count */
+#ifdef USE_MPDVDNAV_TRACE
+extern int dvdnav_trace;		/* print trace messages (only devel)*/
+#endif
+extern char* dvdmenu_lang;		/* nav menu language */
+
+#ifdef HAVE_NEW_GUI
+extern int	dvdnav_window_width;
+extern int	dvdnav_window_height;
+extern int	dvdnav_window_orig_width;
+extern int	dvdnav_window_orig_height;
+extern int	dvdnav_mouse_x;
+extern int	dvdnav_mouse_y;
+extern int	dvdnav_mouse_button;
+extern int	dvdnav_mouse_set;
+#endif
+
+// dvdnav menu button types
+#define DVDNAV_MENUTYPE_SPU	0
+#define DVDNAV_MENUTYPE_BOX	1
+#define DVDNAV_MENUTYPE_SPU_BOX	2
+#endif
+
 typedef struct {
  int id; // 0 - 31 mpeg; 128 - 159 ac3; 160 - 191 pcm
  int language; 
