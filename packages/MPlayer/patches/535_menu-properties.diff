diff -r 84218a4f7167 libmenu/menu_param.c
--- a/libmenu/menu_param.c	Sun Apr 30 16:54:40 2006 +0200
+++ b/libmenu/menu_param.c	Sun Apr 30 16:54:41 2006 +0200
@@ -9,6 +9,14 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <ctype.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <netinet/in.h>
+#include <mntent.h>
+#include <sys/vfs.h>
+#include <libgen.h>
 
 #include "mp_msg.h"
 #include "help_mp.h"
@@ -25,6 +33,17 @@
 #include "input/input.h"
 #include "osdep/keycodes.h"
 #include "metadata.h"
+
+#include "codec-cfg.h"
+#include "stream/stream.h"
+#include "libmpdemux/demuxer.h"
+#include "libmpdemux/stheader.h"
+
+extern char *filename;
+extern sh_video_t *sh_video;
+extern sh_audio_t *sh_audio;
+extern demuxer_t *demuxer;
+extern demuxer_t *bg_demuxer;
 
 struct list_entry_s {
   struct list_entry p;
@@ -59,6 +77,10 @@ static m_option_t cfg_fields[] = {
 };
 
 #define mpriv (menu->priv)
+
+#define OPT_VERSION "Version"
+#define OPT_IP "IP"
+#define OPT_MAC "MAC"
 
 m_option_t*  mp_property_find(char* name);
 
@@ -86,6 +124,61 @@ static void update_entries(menu_t* menu)
     if(e->opt) entry_set_text(menu,e);
 }
 
+static int is_part(char *name) {
+  if(strncmp(name, "disk", 4))
+    return 0;
+  name += 4;
+  if(*name < '0' || *name > '9')
+    return 0;
+  name++;
+  if(*name == '\0')
+    return 1;
+  if(strncmp(name, "part", 4))
+    return 0;
+  name += 4;
+  if(*name < '0' || *name > '9')
+    return 0;
+  return 1;
+}
+
+static int is_cdrom(char *name) {
+  if(strncmp(name, "cdrom", 5))
+    return 0;
+  name += 5;
+  if(*name < '0' || *name > '9')
+    return 0;
+  return 1;
+}
+
+static char *part_size(char *part) {
+  static char size[32];
+  char name[] = "/dev/diskNpartN";
+  struct mntent *mpoint;
+  struct statfs buf;
+  FILE *mtab;
+
+  strcpy(name+5, part);
+  mtab = setmntent("/proc/mounts", "r");
+  while((mpoint = getmntent(mtab)) != NULL)
+    if(!strcmp(mpoint->mnt_fsname, name))
+      {
+        endmntent(mtab);
+        if(!statfs(mpoint->mnt_dir, &buf))
+          if(buf.f_bfree > 0)
+            sprintf(size, "%lld M / %lld M", 
+                    (buf.f_bsize * (long long)buf.f_bfree) >> 20,
+                    (buf.f_bsize * (long long)buf.f_blocks) >> 20);
+          else
+            sprintf(size, "%lld M", (buf.f_bsize * (long long)buf.f_blocks) >> 20);
+        else
+          sprintf(size, "unknown");
+        return size;
+      }
+  endmntent(mtab);
+  sprintf(size, "unknown");
+  return size;
+}
+
 static int parse_args(menu_t* menu,char* args) {
   char *element,*body, **attribs, *name, *meta, *val;
   list_entry_t* m = NULL;
@@ -104,9 +197,11 @@
       asx_parser_free(parser);
       if(!m)
         mp_msg(MSGT_OSD_MENU,MSGL_WARN,MSGTR_LIBMENU_NoEntryFoundInTheMenuDefinition);
+/*
       m = calloc(1,sizeof(struct list_entry_s));
       m->p.txt = strdup("Back");
       menu_list_add_entry(menu,m);
+*/
       return 1;
     }
     if(!strcmp(element,"menu")) {
@@ -125,6 +217,95 @@ static int parse_args(menu_t* menu,char*
     }
 
     name = asx_get_attrib("property",attribs);
+    val = NULL;
+    if(name) {
+      if (!strcmp (name, OPT_VERSION)) {
+        struct stat st;
+
+        if (stat ("/etc/version", &st) == 0)
+        {
+          int fd;
+          fd = open ("/etc/version", O_RDONLY);
+          val = (char *) malloc (st.st_size + 1);
+          memset (val, '\0', st.st_size + 1);
+          read (fd, val, st.st_size + 1);
+          close (fd);
+        }
+        else
+          val = strdup ("#undef");
+      }
+      else if(!strcmp(name, OPT_IP) || !strcmp(name, OPT_MAC)) {
+        struct if_nameindex *ifs, *ifp;
+        struct ifreq ifr;
+        int fd, ip;
+        unsigned char *hwaddr;
+
+        fd = socket(AF_INET, SOCK_DGRAM, 0);
+        if (fd >= 0) {
+          for (ifp = ifs = if_nameindex (); ifp->if_index != 0; ifp++) {
+            if (strcmp (ifp->if_name, "lo") && strcmp (ifp->if_name, "sit0")) {
+              strcpy(ifr.ifr_name, ifp->if_name);
+              ifr.ifr_addr.sa_family = AF_INET;
+              if (!strcmp(name, OPT_IP) && ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
+                val = (char *) malloc (16);
+                ip = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr;
+                ip = ntohl (ip);
+                sprintf (val, "%d.%d.%d.%d",
+                         (ip>>24)&0xFF, (ip>>16)&0xFF, (ip>>8)&0xFF, ip&0xFF);
+              } else if (!strcmp(name, OPT_MAC) && ioctl(fd, SIOCGIFHWADDR, &ifr) == 0) {
+                val = (char *) malloc (20);
+                hwaddr = (unsigned char *)ifr.ifr_hwaddr.sa_data;
+                sprintf (val, "%02X:%02X:%02X:%02X:%02X:%02X",
+                         hwaddr[0],hwaddr[1],hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]);
+              } else {
+                val = strdup("NULL");
+              }
+              break;
+            }
+          }
+          if_freenameindex (ifs);
+          close (fd);
+        }
+      } else if (!strcmp (name, OPT_NAME))
+        val = get_metadata (META_NAME);
+      else if (!strcmp (name, OPT_VCODEC))
+        val = get_metadata (META_VIDEO_CODEC);
+      else if (!strcmp(name, OPT_VBITRATE))
+        val = get_metadata (META_VIDEO_BITRATE);
+      else if(!strcmp(name, OPT_RESOLUTION))
+        val = get_metadata (META_VIDEO_RESOLUTION);
+      else if (!strcmp(name, OPT_ACODEC))
+        val = get_metadata (META_AUDIO_CODEC);
+      else if(!strcmp(name, OPT_ABITRATE))
+        val = get_metadata (META_AUDIO_BITRATE);
+      else if(!strcmp(name, OPT_SAMPLES))
+        val = get_metadata (META_AUDIO_SAMPLES);
+      else if (!strcmp (name, OPT_INFO_TITLE))
+        val = get_metadata (META_INFO_TITLE);
+      else if (!strcmp (name, OPT_INFO_ARTIST))
+        val = get_metadata (META_INFO_ARTIST);
+      else if (!strcmp (name, OPT_INFO_ALBUM))
+        val = get_metadata (META_INFO_ALBUM);
+      else if (!strcmp (name, OPT_INFO_YEAR))
+        val = get_metadata (META_INFO_YEAR);
+      else if (!strcmp (name, OPT_INFO_COMMENT))
+        val = get_metadata (META_INFO_COMMENT);
+      else if (!strcmp (name, OPT_INFO_TRACK))
+        val = get_metadata (META_INFO_TRACK);
+      else if (!strcmp (name, OPT_INFO_GENRE))
+        val = get_metadata (META_INFO_GENRE);
+      else if (is_part(name) || is_cdrom(name))
+        val = strdup(part_size(name));
+    }
+    if (val) {
+      int l = strlen(name) + 2 + strlen(val) + 1;
+      m = calloc(1,sizeof(struct list_entry_s));
+      m->p.txt = malloc(l);
+      sprintf(m->p.txt,"%s: %s",name,val);
+      free(val);
+      menu_list_add_entry(menu,m);
+      goto next_element;
+    }
     opt = name ? mp_property_find(name) : NULL;
     if(!opt) {
       mp_msg(MSGT_OSD_MENU,MSGL_WARN,MSGTR_LIBMENU_PrefMenuEntryDefinitionsNeed,parser->line);
diff -r 84218a4f7167 mplayer.c
--- a/mplayer.c	Sun Apr 30 16:54:40 2006 +0200
+++ b/mplayer.c	Sun Apr 30 16:54:41 2006 +0200
@@ -363,8 +363,8 @@ extern int mp_msg_level_all;
 
 stream_t* stream=NULL;
 demuxer_t *demuxer=NULL;
-static sh_audio_t *sh_audio=NULL;
-static sh_video_t *sh_video=NULL;
+sh_audio_t *sh_audio=NULL;
+sh_video_t *sh_video=NULL;
 static demux_stream_t *d_audio=NULL;
 static demux_stream_t *d_video=NULL;
 static demux_stream_t *d_dvdsub=NULL;
@@ -511,7 +511,7 @@
     if (!strcmp (info[2*n], tag))
       break;
 
-  return info[2*n+1] ? strdup (info[2*n+1]) : NULL;
+  return (info[2*n+1] && strcmp(info[2*n+1], "")) ? strdup (info[2*n+1]) : NULL;
 }
 
 char *get_metadata (metadata_t type) {
