diff -r 84218a4f7167 libmenu/menu_param.c
--- a/libmenu/menu_param.c	Sun Apr 30 16:54:40 2006 +0200
+++ b/libmenu/menu_param.c	Sun Apr 30 16:54:41 2006 +0200
@@ -9,6 +9,14 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <ctype.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <netinet/in.h>
+#include <mntent.h>
+#include <sys/vfs.h>
+#include <libgen.h>
 
 #include "mp_msg.h"
 #include "help_mp.h"
@@ -25,6 +33,17 @@
 #include "input/input.h"
 #include "osdep/keycodes.h"
 #include "metadata.h"
+
+#include "codec-cfg.h"
+#include "stream/stream.h"
+#include "libmpdemux/demuxer.h"
+#include "libmpdemux/stheader.h"
+
+extern char *filename;
+extern sh_video_t *sh_video;
+extern sh_audio_t *sh_audio;
+extern demuxer_t *demuxer;
+extern demuxer_t *bg_demuxer;
 
 struct list_entry_s {
   struct list_entry p;
@@ -59,6 +77,10 @@ static m_option_t cfg_fields[] = {
 };
 
 #define mpriv (menu->priv)
+
+#define OPT_VERSION "Version"
+#define OPT_IP "IP"
+#define OPT_MAC "MAC"
 
 m_option_t*  mp_property_find(char* name);
 
@@ -86,6 +124,131 @@ static void update_entries(menu_t* menu)
     if(e->opt) entry_set_text(menu,e);
 }
 
+static int
+is_valid_video_property (char *prop)
+{
+  if (!prop || !sh_video)
+    return 0;
+
+  if (bg_demuxer && bg_demuxer->video && bg_demuxer->video->sh
+      && sh_video == bg_demuxer->video->sh)
+    return 0;
+  
+  if (strcmp (prop, OPT_VCODEC) != 0 &&
+      strcmp (prop, OPT_VBITRATE) != 0 &&
+      strcmp (prop, OPT_RESOLUTION) != 0)
+    return 0;
+  
+  return 1;
+}
+
+static int
+is_valid_audio_property (char *prop)
+{
+  if (!prop || !sh_audio)
+    return 0;
+
+  if (strcmp (prop, OPT_ACODEC) != 0 &&
+      strcmp (prop, OPT_ABITRATE) != 0 &&
+      strcmp (prop, OPT_SAMPLES) != 0)
+    return 0;
+  
+  return 1;
+}
+
+static int
+is_valid_info_property (char *prop)
+{
+  if (!prop || !demuxer)
+    return 0;
+
+  if (!bg_demuxer || !bg_demuxer->video || !bg_demuxer->video->sh
+      || sh_video != bg_demuxer->video->sh)
+    return 0;
+  
+  if (strcmp (prop, OPT_INFO_TITLE) != 0 &&
+      strcmp (prop, OPT_INFO_ARTIST) != 0 &&
+      strcmp (prop, OPT_INFO_ALBUM) != 0 &&
+      strcmp (prop, OPT_INFO_YEAR) != 0 &&
+      strcmp (prop, OPT_INFO_COMMENT) != 0 &&
+      strcmp (prop, OPT_INFO_TRACK) != 0 &&
+      strcmp (prop, OPT_INFO_GENRE) != 0)
+    return 0;
+  
+  return 1;
+}
+
+static int is_part(char *name) {
+  if(strncmp(name, "disk", 4))
+    return 0;
+  name += 4;
+  if(*name < '0' || *name > '9')
+    return 0;
+  name++;
+  if(*name == '\0')
+    return 1;
+  if(strncmp(name, "part", 4))
+    return 0;
+  name += 4;
+  if(*name < '0' || *name > '9')
+    return 0;
+  return 1;
+}
+
+static int is_cdrom(char *name) {
+  if(strncmp(name, "cdrom", 5))
+    return 0;
+  name += 5;
+  if(*name < '0' || *name > '9')
+    return 0;
+  return 1;
+}
+
+static char *part_size(char *part) {
+  static char size[32];
+  char name[] = "/dev/diskNpartN";
+  struct mntent *mpoint;
+  struct statfs buf;
+  FILE *mtab;
+
+  strcpy(name+5, part);
+  mtab = setmntent("/proc/mounts", "r");
+  while((mpoint = getmntent(mtab)) != NULL)
+    if(!strcmp(mpoint->mnt_fsname, name))
+      {
+        endmntent(mtab);
+        if(!statfs(mpoint->mnt_dir, &buf))
+          if(buf.f_bfree > 0)
+            sprintf(size, "%lld M / %lld M", 
+                    (buf.f_bsize * (long long)buf.f_bfree) >> 20,
+                    (buf.f_bsize * (long long)buf.f_blocks) >> 20);
+          else
+            sprintf(size, "%lld M", (buf.f_bsize * (long long)buf.f_blocks) >> 20);
+        else
+          sprintf(size, "unknown");
+        return size;
+      }
+  endmntent(mtab);
+  sprintf(size, "unknown");
+  return size;
+}
+
+static char *
+grab_demuxer_info (char *tag)
+{
+  char **info = demuxer->info;
+  int n;
+
+  if (!info || !tag)
+    return strdup ("");
+
+  for (n = 0; info[2*n] != NULL ; n++)
+    if (!strcmp (info[2*n], tag))
+      break;
+
+  return info[2*n+1] ? strdup (info[2*n+1]) : strdup ("");
+}
+
 static int parse_args(menu_t* menu,char* args) {
   char *element,*body, **attribs, *name, *meta, *val;
   list_entry_t* m = NULL;
@@ -104,9 +197,11 @@
       asx_parser_free(parser);
       if(!m)
         mp_msg(MSGT_OSD_MENU,MSGL_WARN,MSGTR_LIBMENU_NoEntryFoundInTheMenuDefinition);
+/*
       m = calloc(1,sizeof(struct list_entry_s));
       m->p.txt = strdup("Back");
       menu_list_add_entry(menu,m);
+*/
       return 1;
     }
     if(!strcmp(element,"menu")) {
@@ -125,6 +217,136 @@ static int parse_args(menu_t* menu,char*
     }
 
     name = asx_get_attrib("property",attribs);
+    val = NULL;
+    if(name) {
+      if (!strcmp (name, OPT_VERSION)) {
+        struct stat st;
+
+        if (stat ("/etc/version", &st) == 0)
+        {
+          int fd;
+          fd = open ("/etc/version", O_RDONLY);
+          val = (char *) malloc (st.st_size + 1);
+          memset (val, '\0', st.st_size + 1);
+          read (fd, val, st.st_size + 1);
+          close (fd);
+        }
+        else
+          val = strdup ("#undef");
+      }
+      else if(!strcmp(name, OPT_IP)) {
+        struct if_nameindex *ifs, *ifp;
+        struct ifreq ifr;
+        int fd, ip;
+
+        fd = socket(AF_INET, SOCK_DGRAM, 0);
+        if (fd >= 0) {
+          for (ifp = ifs = if_nameindex (); ifp->if_index != 0; ifp++) {
+            if (strcmp (ifp->if_name, "lo") && strcmp (ifp->if_name, "sit0")) {
+              strcpy(ifr.ifr_name, ifp->if_name);
+              ifr.ifr_addr.sa_family = AF_INET;
+              if (ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
+                val = (char *) malloc (16);
+                ip = ((struct sockaddr_in *) &ifr.ifr_addr)->sin_addr.s_addr;
+                ip = ntohl (ip);
+                sprintf (val, "%d.%d.%d.%d",
+                         (ip>>24)&0xFF, (ip>>16)&0xFF, (ip>>8)&0xFF, ip&0xFF);
+              } else {
+                val = strdup("NULL");
+              }
+              break;
+            }
+          }
+          if_freenameindex (ifs);
+          close (fd);
+        }
+      } else if (!strcmp(name, OPT_MAC)) {
+        struct if_nameindex *ifs, *ifp;
+        struct ifreq ifr;
+        int fd;
+
+        fd = socket(AF_INET, SOCK_DGRAM, 0);
+        if (fd >= 0) {
+          for (ifp = ifs = if_nameindex (); ifp->if_index != 0; ifp++) {
+            if (strcmp (ifp->if_name, "lo") && strcmp (ifp->if_name, "sit0")) {
+              strcpy(ifr.ifr_name, ifp->if_name);
+              ifr.ifr_addr.sa_family = AF_INET;
+              if (ioctl(fd, SIOCGIFHWADDR, &ifr) == 0) {
+                val = (char *) malloc (20);
+                unsigned char *hwaddr = (unsigned char *)ifr.ifr_hwaddr.sa_data;
+                sprintf (val, "%02X:%02X:%02X:%02X:%02X:%02X",
+                         hwaddr[0],hwaddr[1],hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]);
+              } else {
+                val = strdup("NULL");
+              }
+              break;
+            }
+          }
+          if_freenameindex (ifs);
+          close (fd);
+        }
+      } else if (!strcmp (name, OPT_NAME)) {
+        val = strdup (basename (filename));
+
+      } else if (!strcmp (name, OPT_VCODEC) && is_valid_video_property(name)) {
+        val = (char *) malloc (8);
+        if (sh_video->format == 0x10000001) {
+          sprintf (val, "mpeg1");
+        }
+        else if (sh_video->format == 0x10000002) {
+          sprintf (val, "mpeg2");
+        }
+        else if (sh_video->format == 0x10000004) {
+          sprintf (val, "mpeg4");
+        }
+        else if (sh_video->format == 0x10000005) {
+          sprintf (val, "h264");
+        }
+        else if (sh_video->format >= 0x20202020) {
+          sprintf (val, "%.4s", (char *) &sh_video->format);
+        }
+        else {
+          sprintf (val, "0x%08X", sh_video->format);
+        }
+      } else if (!strcmp (name, OPT_VBITRATE) && is_valid_video_property(name)) {
+        val = (char *) malloc (16);
+        sprintf (val, "%d kbps", (int) (sh_video->i_bps * 8 / 1024));
+      } else if (!strcmp (name, OPT_RESOLUTION) && is_valid_video_property(name)) {
+        val = (char *) malloc (16);
+        sprintf (val, "%d x %d", sh_video->disp_w, sh_video->disp_h);
+      } else if (!strcmp (name, OPT_ACODEC) && is_valid_audio_property(name)) {
+        val = strdup (sh_audio->codec->name);
+      } else if (!strcmp (name, OPT_ABITRATE) && is_valid_audio_property(name)) {
+        val = (char *) malloc (16);
+        sprintf (val, "%d kbps", (int) (sh_audio->i_bps * 8 / 1000));
+      } else if (!strcmp (name, OPT_SAMPLES) && is_valid_audio_property(name)) {
+        val = (char *) malloc (16);
+        sprintf (val, "%d Hz, %d ch.",
+                 sh_audio->samplerate, sh_audio->channels);
+      } else if ((!strcmp (name, OPT_INFO_TITLE) ||
+                 !strcmp (name, OPT_INFO_ARTIST) ||
+                 !strcmp (name, OPT_INFO_ALBUM) ||
+                 !strcmp (name, OPT_INFO_YEAR) ||
+                 !strcmp (name, OPT_INFO_COMMENT) ||
+                 !strcmp (name, OPT_INFO_TRACK) ||
+                 !strcmp (name, OPT_INFO_GENRE)) &&
+                 is_valid_info_property(name) &&
+                 strcmp(grab_demuxer_info(name), "") ) {
+        val = grab_demuxer_info (name);
+
+      } else if (is_part(name) || is_cdrom(name)) {
+        val = strdup(part_size(name));
+      }
+    }
+    if (val) {
+      int l = strlen(name) + 2 + strlen(val) + 1;
+      m = calloc(1,sizeof(struct list_entry_s));
+      m->p.txt = malloc(l);
+      sprintf(m->p.txt,"%s: %s",name,val);
+      free(val);
+      menu_list_add_entry(menu,m);
+      goto next_element;
+    }
     opt = name ? mp_property_find(name) : NULL;
     if(!opt) {
       mp_msg(MSGT_OSD_MENU,MSGL_WARN,MSGTR_LIBMENU_PrefMenuEntryDefinitionsNeed,parser->line);
diff -r 84218a4f7167 mplayer.c
--- a/mplayer.c	Sun Apr 30 16:54:40 2006 +0200
+++ b/mplayer.c	Sun Apr 30 16:54:41 2006 +0200
@@ -363,8 +363,8 @@ extern int mp_msg_level_all;
 
 stream_t* stream=NULL;
 demuxer_t *demuxer=NULL;
-static sh_audio_t *sh_audio=NULL;
-static sh_video_t *sh_video=NULL;
+sh_audio_t *sh_audio=NULL;
+sh_video_t *sh_video=NULL;
 static demux_stream_t *d_audio=NULL;
 static demux_stream_t *d_video=NULL;
 static demux_stream_t *d_dvdsub=NULL;
