diff -Naur MPlayer-1.0pre8.orig/libmpdemux/asfheader.c MPlayer-1.0pre8/libmpdemux/asfheader.c
--- MPlayer-1.0pre8.orig/libmpdemux/asfheader.c	2006-06-14 21:53:00.000000000 +0200
+++ MPlayer-1.0pre8/libmpdemux/asfheader.c	2006-06-14 21:53:12.000000000 +0200
@@ -34,8 +34,6 @@
 #define ASF_GUID_PREFIX_file_header	0x8CABDCA1
 #define	ASF_GUID_PREFIX_content_desc	0x75b22633
 #define	ASF_GUID_PREFIX_stream_group	0x7bf875ce
-#define ASF_GUID_PREFIX_ext_audio_stream	0x31178C9D
-#define ASF_GUID_PREFIX_ext_stream_embed_stream_header	0x3AFB65E2
 
 /*
 const char asf_audio_stream_guid[16] = {0x40, 0x9e, 0x69, 0xf8,
@@ -53,10 +51,6 @@
   0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2};
 const char asf_data_chunk_guid[16] = {0x36, 0x26, 0xb2, 0x75,
   0x8e, 0x66, 0xcf, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c};
-const char asf_ext_stream_embed_stream_header[16] = {0xe2, 0x65, 0xfb, 0x3a,
-  0xef, 0x47, 0xf2, 0x40, 0xac, 0x2c, 0x70, 0xa9, 0x0d, 0x71, 0xd3, 0x43};
-const char asf_ext_stream_audio[16] = {0x9d, 0x8c, 0x17, 0x31,
-  0xe1, 0x03, 0x28, 0x45, 0xb5, 0x82, 0x3d, 0xf9, 0xdb, 0x22, 0xf5, 0x03};
 const char asf_ext_stream_header[16] = {0xCB, 0xA5, 0xE6, 0x14,
   0x72, 0xC6, 0x32, 0x43, 0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A};
 
@@ -85,10 +77,6 @@
   switch(ASF_LOAD_GUID_PREFIX(guid)){
     case ASF_GUID_PREFIX_audio_stream:
       return "guid_audio_stream";
-    case ASF_GUID_PREFIX_ext_audio_stream:
-      return "guid_ext_audio_stream";
-    case ASF_GUID_PREFIX_ext_stream_embed_stream_header:
-      return "guid_ext_stream_embed_stream_header";
     case ASF_GUID_PREFIX_video_stream: 
       return "guid_video_stream";
     case ASF_GUID_PREFIX_audio_conceal_none:
@@ -156,16 +144,6 @@
   return -1;
 }
 
-static int find_backwards_asf_guid(char *buf, const char *guid, int cur_pos)
-{
-  int i;
-  for (i=cur_pos-16; i>0; i--) {
-    if (memcmp(&buf[i], guid, 16) == 0)
-      return i + 16 + 8; // point after guid + length
-  }
-  return -1;
-}
-
 static int get_ext_stream_properties(char *buf, int buf_len, int stream_num, double* avg_frame_time)
 {
   // this function currently only gets the average frame time if available
@@ -191,32 +179,6 @@
   return 0;
 }
 
-static int asf_init_audio_stream(demuxer_t *demuxer,struct asf_priv* asf, sh_audio_t* sh_audio, ASF_stream_header_t *streamh, int *ppos, uint8_t** buf, char *hdr, unsigned int hdr_len)
-{
-  uint8_t *buffer = *buf;
-  int pos = *ppos;
-
-  sh_audio->wf=calloc((streamh->type_size<sizeof(WAVEFORMATEX))?sizeof(WAVEFORMATEX):streamh->type_size,1);
-  memcpy(sh_audio->wf,buffer,streamh->type_size);
-  le2me_WAVEFORMATEX(sh_audio->wf);
-  if( mp_msg_test(MSGT_HEADER,MSGL_V) ) print_wave_header(sh_audio->wf,MSGL_V);
-  if(ASF_LOAD_GUID_PREFIX(streamh->concealment)==ASF_GUID_PREFIX_audio_conceal_interleave){
-    buffer = &hdr[pos];
-    pos += streamh->stream_size;
-    if (pos > hdr_len) return 0;
-    asf->scrambling_h=buffer[0];
-    asf->scrambling_w=(buffer[2]<<8)|buffer[1];
-    asf->scrambling_b=(buffer[4]<<8)|buffer[3];
-    if(asf->scrambling_b>0){
-      asf->scrambling_w/=asf->scrambling_b;
-    }
-  } else {
-    asf->scrambling_b=asf->scrambling_h=asf->scrambling_w=1;
-  }
-  mp_msg(MSGT_HEADER,MSGL_V,"ASF: audio scrambling: %d x %d x %d\n",asf->scrambling_h,asf->scrambling_w,asf->scrambling_b);
-  return 1;
-}
-
 int read_asf_header(demuxer_t *demuxer,struct asf_priv* asf){
   int hdr_len = asf->header.objh.size - sizeof(asf->header);
   char *hdr = NULL;
@@ -204,9 +156,6 @@
   int best_video = -1;
   int best_audio = -1;
   uint64_t data_len;
-  ASF_stream_header_t *streamh;
-  uint8_t *buffer;
-  int audio_pos=0;
 
   if(hdr_len < 0) {
     mp_msg(MSGT_HEADER, MSGL_FATAL, "Header size is too small.\n");
@@ -230,40 +179,12 @@
     goto err_out;
   }
 
-  if ((pos = find_asf_guid(hdr, asf_ext_stream_audio, 0, hdr_len)) >= 0)
-  {
-    // Special case: found GUID for dvr-ms audio.
-    // Now skip back to associated stream header.
-    int sh_pos=0;
-
-    sh_pos = find_backwards_asf_guid(hdr, asf_stream_header_guid, pos);
- 
-    if (sh_pos > 0) {
-      sh_audio_t *sh_audio;
-
-       mp_msg(MSGT_HEADER, MSGL_V, "read_asf_header found dvr-ms audio stream header pos=%d\n", sh_pos);
-      // found audio stream header - following code reads header and
-      // initializes audio stream.
-      audio_pos = pos - 16 - 8;
-      streamh = (ASF_stream_header_t *)&hdr[sh_pos];
-      le2me_ASF_stream_header_t(streamh);
-      audio_pos += 64; //16+16+4+4+4+16+4;
-      buffer = &hdr[audio_pos];
-      sh_audio=new_sh_audio(demuxer,streamh->stream_no & 0x7F);
-      ++audio_streams;
-      if (!asf_init_audio_stream(demuxer, asf, sh_audio, streamh, &audio_pos, &buffer, hdr, hdr_len))
-        goto len_err_out;
-    }
-  }
   // find stream headers
-  // only reset pos if we didnt find dvr_ms audio stream
-  // if we did find it then we want to avoid reading its header twice
-  if (audio_pos == 0) 
-    pos = 0;
-
+  pos = 0;
   while ((pos = find_asf_guid(hdr, asf_stream_header_guid, pos, hdr_len)) >= 0)
   {
-    streamh = (ASF_stream_header_t *)&hdr[pos];
+    ASF_stream_header_t *streamh = (ASF_stream_header_t *)&hdr[pos];
+    uint8_t *buffer;
     pos += sizeof(ASF_stream_header_t);
     if (pos > hdr_len) goto len_err_out;
     le2me_ASF_stream_header_t(streamh);
@@ -285,8 +206,24 @@
       case ASF_GUID_PREFIX_audio_stream: {
         sh_audio_t* sh_audio=new_sh_audio(demuxer,streamh->stream_no & 0x7F);
         ++audio_streams;
-        if (!asf_init_audio_stream(demuxer, asf, sh_audio, streamh, &pos, &buffer, hdr, hdr_len))
-          goto len_err_out;
+        sh_audio->wf=calloc((streamh->type_size<sizeof(WAVEFORMATEX))?sizeof(WAVEFORMATEX):streamh->type_size,1);
+        memcpy(sh_audio->wf,buffer,streamh->type_size);
+	le2me_WAVEFORMATEX(sh_audio->wf);
+        if( mp_msg_test(MSGT_HEADER,MSGL_V) ) print_wave_header(sh_audio->wf,MSGL_V);
+	if(ASF_LOAD_GUID_PREFIX(streamh->concealment)==ASF_GUID_PREFIX_audio_conceal_interleave){
+          buffer = &hdr[pos];
+          pos += streamh->stream_size;
+          if (pos > hdr_len) goto len_err_out;
+          asf->scrambling_h=buffer[0];
+          asf->scrambling_w=(buffer[2]<<8)|buffer[1];
+          asf->scrambling_b=(buffer[4]<<8)|buffer[3];
+          if(asf->scrambling_b>0){
+            asf->scrambling_w/=asf->scrambling_b;
+          }
+	} else {
+	  asf->scrambling_b=asf->scrambling_h=asf->scrambling_w=1;
+	}
+	mp_msg(MSGT_HEADER,MSGL_V,"ASF: audio scrambling: %d x %d x %d\n",asf->scrambling_h,asf->scrambling_w,asf->scrambling_b);
 	//if(demuxer->audio->id==-1) demuxer->audio->id=streamh.stream_no & 0x7F;
         break;
         }
@@ -298,15 +235,10 @@
         sh_video->bih=calloc((len<sizeof(BITMAPINFOHEADER))?sizeof(BITMAPINFOHEADER):len,1);
         memcpy(sh_video->bih,&buffer[4+4+1+2],len);
 	le2me_BITMAPINFOHEADER(sh_video->bih);
-        if (sh_video->bih->biCompression == mmioFOURCC('D', 'V', 'R', ' ')) {
-          //mp_msg(MSGT_DEMUXER, MSGL_WARN, MSGTR_MPDEMUX_ASFHDR_DVRWantsLibavformat);
-          //sh_video->fps=(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
-          //sh_video->frametime=(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
-          asf->asf_frame_state=-1;
-          asf->asf_frame_start_found=0;
-          asf->asf_is_dvr_ms=1;
-          asf->dvr_last_vid_pts=0.0;
-        } else asf->asf_is_dvr_ms=0;
+	if (sh_video->bih->biCompression == mmioFOURCC('D', 'V', 'R', ' '))
+	  mp_msg(MSGT_DEMUXER, MSGL_WARN, MSGTR_MPDEMUX_ASFHDR_DVRWantsLibavformat);
+        //sh_video->fps=(float)sh_video->video.dwRate/(float)sh_video->video.dwScale;
+        //sh_video->frametime=(float)sh_video->video.dwScale/(float)sh_video->video.dwRate;
         if (get_ext_stream_properties(hdr, hdr_len, streamh->stream_no, &asf->avg_vid_frame_time)) {
 	  sh_video->frametime=(float)asf->avg_vid_frame_time;
 	  sh_video->fps=1.0f/sh_video->frametime; 
