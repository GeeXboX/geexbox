diff -Naur MPlayer-export-2009-06-13.orig/cfg-mplayer.h MPlayer-export-2009-06-13/cfg-mplayer.h
--- MPlayer-export-2009-06-13.orig/cfg-mplayer.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/cfg-mplayer.h	2009-06-14 00:10:51.000000000 +0200
@@ -277,6 +277,8 @@
 #ifdef CONFIG_UNRAR_EXEC
 	{"unrarexec", &unrar_executable, CONF_TYPE_STRING, 0, 0, 0, NULL},
 #endif
+	{"colorspu", &colorspu, CONF_TYPE_FLAG, 0, 0, 1, NULL},
+	{"nocolorspu", &colorspu, CONF_TYPE_FLAG, 0, 1, 0, NULL},
 
 	{"sstep", &step_sec, CONF_TYPE_INT, CONF_MIN, 0, 0, NULL},
 
diff -Naur MPlayer-export-2009-06-13.orig/command.c MPlayer-export-2009-06-13/command.c
--- MPlayer-export-2009-06-13.orig/command.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/command.c	2009-06-14 00:10:51.000000000 +0200
@@ -875,6 +875,10 @@
 		reinit_audio_chain();
 	    }
 	}
+#ifdef USE_DVDNAV
+	if (mpctx->stream->type == STREAMTYPE_DVDNAV)
+	    mp_dvdnav_set_aid(mpctx->stream, audio_id);
+#endif
 	mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_AUDIO_TRACK=%d\n", audio_id);
 	return M_PROPERTY_OK;
     default:
@@ -1510,6 +1514,10 @@
 	d_sub->id = dvdsub_id;
     }
 #endif
+#ifdef USE_DVDNAV
+    if (mpctx->stream->type == STREAMTYPE_DVDNAV)
+	mp_dvdnav_set_sid(mpctx->stream, dvdsub_id);
+#endif
     update_subtitles(mpctx->sh_video, d_sub, 1);
 
     return M_PROPERTY_OK;
diff -Naur MPlayer-export-2009-06-13.orig/libmenu/menu.c MPlayer-export-2009-06-13/libmenu/menu.c
--- MPlayer-export-2009-06-13.orig/libmenu/menu.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libmenu/menu.c	2009-06-14 00:10:51.000000000 +0200
@@ -29,6 +29,7 @@
 #include "libvo/osd.h"
 #include "libvo/font_load.h"
 #include "libvo/sub.h"
+#include "libvo/video_out.h"
 #include "osdep/keycodes.h"
 #include "asxparser.h"
 #include "stream/stream.h"
@@ -371,7 +372,7 @@
 
 ///////////////////////////// Helpers ////////////////////////////////////
 
-typedef void (*draw_alpha_f)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
+typedef void (*draw_alpha_f)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride);
 
 inline static draw_alpha_f get_draw_alpha(uint32_t fmt) {
   switch(fmt) {
@@ -484,7 +485,7 @@
   while (*txt) {
     int c=utf8_get_char((const char**)&txt);
     if ((font=vo_font->font[c])>=0 && (x + vo_font->width[c] <= mpi->w) && (y + vo_font->pic_a[font]->h <= mpi->h))
-      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h,
+      draw_alpha(vo_font->width[c], vo_font->pic_a[font]->h, DEST_PLANES_Y,
 		 vo_font->pic_b[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->bmp+vo_font->start[c],
 		 vo_font->pic_a[font]->w,
@@ -654,7 +655,7 @@
       if(font >= 0) {
  	int cs = (vo_font->pic_a[font]->h - vo_font->height) / 2;
 	if ((sx + vo_font->width[c] <= xmax) && (sy + vo_font->height <= ymax) )
-	  draw_alpha(vo_font->width[c], vo_font->height,
+	  draw_alpha(vo_font->width[c], vo_font->height, DEST_PLANES_Y,
 		     vo_font->pic_b[font]->bmp+vo_font->start[c] +
 		     cs * vo_font->pic_a[font]->w,
 		     vo_font->pic_a[font]->bmp+vo_font->start[c] +
@@ -767,7 +768,7 @@
     char pic[stride*h],pic_alpha[stride*h];
     memset(pic,g,stride*h);
     memset(pic_alpha,alpha,stride*h);
-    draw_alpha(w,h,pic,pic_alpha,stride,
+    draw_alpha(w,h,DEST_PLANES_Y,pic,pic_alpha,stride,
                mpi->planes[0] + y * mpi->stride[0] + x * (mpi->bpp>>3),
                mpi->stride[0]);
   }
diff -Naur MPlayer-export-2009-06-13.orig/libmpcodecs/vf_expand.c MPlayer-export-2009-06-13/libmpcodecs/vf_expand.c
--- MPlayer-export-2009-06-13.orig/libmpcodecs/vf_expand.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libmpcodecs/vf_expand.c	2009-06-14 00:10:51.000000000 +0200
@@ -13,6 +13,7 @@
 #include "vf.h"
 
 #include "libvo/fastmemcpy.h"
+#include "libvo/video_out.h"
 
 #ifdef OSD_SUPPORT
 #include "libvo/sub.h"
@@ -96,7 +97,47 @@
     }
 }
 
-static void draw_func(int x0,int y0, int w,int h,unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha_yv12(int x0, int y0, int w, int h, int dp,
+                            unsigned char *src, unsigned char *srca,
+                            int stride, mp_image_t *dmpi) {
+    unsigned char *dst;
+
+    switch (dp)  {
+    case DEST_PLANES_U:
+        dst=dmpi->planes[2]+dmpi->stride[2]*(y0>>0)+(dmpi->bpp>>3)*(x0>>0);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride, dst,
+                           dmpi->stride[2]);
+        break;
+    case DEST_PLANES_V:
+        dst=dmpi->planes[1]+dmpi->stride[1]*(y0>>0)+(dmpi->bpp>>3)*(x0>>0);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride, dst,
+                           dmpi->stride[1]);
+        break;
+    case DEST_PLANES_Y:
+        dst=dmpi->planes[0]+dmpi->stride[0]*y0+(dmpi->bpp>>3)*x0;
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride, dst,
+                           dmpi->stride[0]);
+        break;
+    }
+}
+
+static void draw_alpha_yuy2(int x0, int y0, int w, int h, int dp,
+                            unsigned char *src, unsigned char *srca,
+                            int stride, mp_image_t *dmpi) {
+    unsigned char *dst;
+
+    dst=dmpi->planes[0]+dmpi->stride[0]*y0+(dmpi->bpp>>3)*x0;
+    switch (dp) {
+    case DEST_PLANES_Y :
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst,dmpi->stride[0]);
+        break;
+    case DEST_PLANES_YUYV :
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,dst,dmpi->stride[0]);
+        break;
+    }
+}
+
+static void draw_func(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     unsigned char* dst;
     if(!vo_osd_changed_flag && vf->dmpi->planes[0]==vf->priv->fb_ptr){
 	// ok, enough to update the area inside the video, leave the black bands
@@ -124,19 +165,19 @@
     switch(vf->dmpi->imgfmt){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dst,vf->dmpi->stride[0]);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_I420:
@@ -145,13 +186,13 @@
     case IMGFMT_IF09:
     case IMGFMT_Y800:
     case IMGFMT_Y8:
-	vo_draw_alpha_yv12(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+        draw_alpha_yv12(x0,y0,w,h,dp,src,srca,stride,vf->dmpi);
 	break;
     case IMGFMT_YUY2:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst,vf->dmpi->stride[0]);
+        draw_alpha_yuy2(x0,y0,w,h,dp,src,srca,stride,vf->dmpi);
 	break;
     case IMGFMT_UYVY:
-	vo_draw_alpha_yuy2(w,h,src,srca,stride,dst+1,vf->dmpi->stride[0]);
+	vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,dst+1,vf->dmpi->stride[0]);
 	break;
     }
 }
@@ -415,6 +456,14 @@
     switch(request){
     case VFCTRL_DRAW_OSD:
 	if(vf->priv->osd) return CONTROL_TRUE;
+        break;
+    case VFCTRL_GET_OSD_FORMAT:
+        if(!vf->priv->osd)
+            break;
+        if(!vf->dmpi)
+            return CONTROL_FALSE;
+        *(unsigned int*)data=vf->dmpi->imgfmt;
+        return CONTROL_TRUE;
     }
 #endif
     return vf_next_control(vf,request,data);
diff -Naur MPlayer-export-2009-06-13.orig/libmpcodecs/vf.h MPlayer-export-2009-06-13/libmpcodecs/vf.h
--- MPlayer-export-2009-06-13.orig/libmpcodecs/vf.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libmpcodecs/vf.h	2009-06-14 00:10:51.000000000 +0200
@@ -89,6 +89,7 @@
 #define VFCTRL_GET_PTS         17 /* Return last pts value that reached vf_vo*/
 #define VFCTRL_SET_DEINTERLACE 18 /* Set deinterlacing status */
 #define VFCTRL_GET_DEINTERLACE 19 /* Get deinterlacing status */
+#define VFCTRL_GET_OSD_FORMAT  20 /* Query format to color osd */
 
 #include "vfcap.h"
 
diff -Naur MPlayer-export-2009-06-13.orig/libmpcodecs/vf_vo.c MPlayer-export-2009-06-13/libmpcodecs/vf_vo.c
--- MPlayer-export-2009-06-13.orig/libmpcodecs/vf_vo.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libmpcodecs/vf_vo.c	2009-06-14 00:10:51.000000000 +0200
@@ -28,6 +28,7 @@
     ass_renderer_t* ass_priv;
     int prev_visibility;
 #endif
+    unsigned int outfmt;
 };
 #define video_out (vf->priv->vo)
 
@@ -67,6 +68,8 @@
     if(config_video_out(video_out,width,height,d_width,d_height,flags,"MPlayer",outfmt))
 	return 0;
 
+    vf->priv->outfmt=outfmt;
+    
 #ifdef CONFIG_ASS
     if (vf->priv->ass_priv)
 	ass_configure(vf->priv->ass_priv, width, height, !!(vf->default_caps & VFCAP_EOSD_UNSCALED));
@@ -151,6 +154,13 @@
 	*(double *)data = vf->priv->pts;
 	return CONTROL_TRUE;
     }
+    case VFCTRL_GET_OSD_FORMAT:
+    {
+        if(video_out->control(VOCTRL_GET_OSD_FORMAT,data) == VO_TRUE)
+            return CONTROL_TRUE;
+        *(unsigned int*)data = vf->priv->outfmt;
+        return CONTROL_TRUE;
+    }
     }
     // return video_out->control(request,data);
     return CONTROL_UNKNOWN;
diff -Naur MPlayer-export-2009-06-13.orig/libvo/mga_common.c MPlayer-export-2009-06-13/libvo/mga_common.c
--- MPlayer-export-2009-06-13.orig/libvo/mga_common.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/mga_common.c	2009-06-14 00:10:51.000000000 +0200
@@ -42,20 +42,54 @@
 #endif
 static uint32_t               drwcX,drwcY,dwidth,dheight;
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     uint32_t bespitch = (mga_vid_config.src_width + 31) & ~31;
     x0+=mga_vid_config.src_width*(vo_panscan_x>>1)/(vo_dwidth+vo_panscan_x);
     switch(mga_vid_config.format){
     case MGA_VID_FORMAT_YV12:
     case MGA_VID_FORMAT_IYUV:
     case MGA_VID_FORMAT_I420:
-        vo_draw_alpha_yv12(w,h,src,srca,stride,vid_data+bespitch*y0+x0,bespitch);
+        switch (dp) {
+        case DEST_PLANES_Y :
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,vid_data+bespitch*y0+x0,bespitch);
+        break;
+        case DEST_PLANES_U :
+            dest = vid_data + bespitch*mga_vid_config.src_height +
+                   bespitch/2 * y0/2 + x0/2;
+            if(mga_vid_config.format==MGA_VID_FORMAT_YV12)
+                dest += bespitch/2*mga_vid_config.src_height / 2;
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,dest,bespitch/2);
+            break;
+        case DEST_PLANES_V :
+            dest = vid_data + bespitch*mga_vid_config.src_height +
+                   bespitch/2 * y0/2 + x0/2;
+            if(mga_vid_config.format!=MGA_VID_FORMAT_YV12)
+                dest += bespitch/2*mga_vid_config.src_height / 2;
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,dest,bespitch/2);
+            break;
+        }
         break;
     case MGA_VID_FORMAT_YUY2:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,vid_data+2*(bespitch*y0+x0),2*bespitch);
+        switch (dp) {
+        case DEST_PLANES_Y :
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,vid_data+2*(bespitch*y0+x0),2*bespitch);
+        break;
+        case DEST_PLANES_YUYV :
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                               vid_data+2*(bespitch*y0+x0),2*bespitch);
+            break;
+        }
         break;
     case MGA_VID_FORMAT_UYVY:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,vid_data+2*(bespitch*y0+x0)+1,2*bespitch);
+        switch (dp) {
+        case DEST_PLANES_Y :
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,vid_data+2*(bespitch*y0+x0)+1,2*bespitch);
+        break;
+        case DEST_PLANES_YUYV :
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                               vid_data+2*(bespitch*y0+x0)+1,2*bespitch);
+            break;
+        }
         break;
     }
 }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/osd.c MPlayer-export-2009-06-13/libvo/osd.c
--- MPlayer-export-2009-06-13.orig/libvo/osd.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/osd.c	2009-06-14 00:15:36.000000000 +0200
@@ -28,6 +28,7 @@
 #include "mp_msg.h"
 #include <inttypes.h>
 #include "cpudetect.h"
+#include "video_out.h"
 
 #if ARCH_X86
 static const uint64_t bFF __attribute__((aligned(8))) = 0xFFFFFFFFFFFFFFFFULL;
@@ -133,152 +134,152 @@
 
 #endif /* ARCH_X86 */
 
-void vo_draw_alpha_yv12(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_yv12(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #if CONFIG_RUNTIME_CPUDETECT
 #if ARCH_X86
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //CONFIG_RUNTIME_CPUDETECT
 #if HAVE_MMX2
-		vo_draw_alpha_yv12_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_AMD3DNOW
-		vo_draw_alpha_yv12_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_MMX
-		vo_draw_alpha_yv12_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif ARCH_X86
-		vo_draw_alpha_yv12_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yv12_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yv12_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!CONFIG_RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_yuy2(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_yuy2(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #if CONFIG_RUNTIME_CPUDETECT
 #if ARCH_X86
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //CONFIG_RUNTIME_CPUDETECT
 #if HAVE_MMX2
-		vo_draw_alpha_yuy2_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_AMD3DNOW
-		vo_draw_alpha_yuy2_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_MMX
-		vo_draw_alpha_yuy2_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif ARCH_X86
-		vo_draw_alpha_yuy2_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_yuy2_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_yuy2_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!CONFIG_RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_uyvy(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_uyvy(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #if CONFIG_RUNTIME_CPUDETECT
 #if ARCH_X86
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //CONFIG_RUNTIME_CPUDETECT
 #if HAVE_MMX2
-		vo_draw_alpha_uyvy_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_AMD3DNOW
-		vo_draw_alpha_uyvy_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_MMX
-		vo_draw_alpha_uyvy_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif ARCH_X86
-		vo_draw_alpha_uyvy_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_uyvy_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_uyvy_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!CONFIG_RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_rgb24(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb24(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #if CONFIG_RUNTIME_CPUDETECT
 #if ARCH_X86
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //CONFIG_RUNTIME_CPUDETECT
 #if HAVE_MMX2
-		vo_draw_alpha_rgb24_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_AMD3DNOW
-		vo_draw_alpha_rgb24_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_MMX
-		vo_draw_alpha_rgb24_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif ARCH_X86
-		vo_draw_alpha_rgb24_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb24_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb24_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!CONFIG_RUNTIME_CPUDETECT
 }
 
-void vo_draw_alpha_rgb32(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb32(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
 #if CONFIG_RUNTIME_CPUDETECT
 #if ARCH_X86
 	// ordered by speed / fastest first
 	if(gCpuCaps.hasMMX2)
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.has3DNow)
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else if(gCpuCaps.hasMMX)
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 	else
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #else //CONFIG_RUNTIME_CPUDETECT
 #if HAVE_MMX2
-		vo_draw_alpha_rgb32_MMX2(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX2(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_AMD3DNOW
-		vo_draw_alpha_rgb32_3DNow(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_3DNow(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif HAVE_MMX
-		vo_draw_alpha_rgb32_MMX(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_MMX(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #elif ARCH_X86
-		vo_draw_alpha_rgb32_X86(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_X86(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #else
-		vo_draw_alpha_rgb32_C(w, h, src, srca, srcstride, dstbase, dststride);
+		vo_draw_alpha_rgb32_C(w, h, dp, src, srca, srcstride, dstbase, dststride);
 #endif
 #endif //!CONFIG_RUNTIME_CPUDETECT
 }
@@ -329,8 +330,10 @@
 	}
 }
 
-void vo_draw_alpha_rgb15(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb15(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y:
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -359,10 +362,67 @@
         dstbase+=dststride;
     }
     return;
+  case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                g=(((g*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x1F;
+                unsigned char b=(dst[x]>>10)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<10)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
 }
 
-void vo_draw_alpha_rgb16(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+void vo_draw_alpha_rgb16(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+switch (dp) {
+  case DEST_PLANES_Y:
     for(y=0;y<h;y++){
         register unsigned short *dst = (unsigned short*) dstbase;
         register int x;
@@ -390,5 +450,60 @@
         dstbase+=dststride;
     }
     return;
+  case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                r=(((r*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                g=(((g*srca[x])>>6)+src[x])>>2;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+        register unsigned short *dst = (unsigned short*) dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+            if(srca[x]){
+                unsigned char r=dst[x]&0x1F;
+                unsigned char g=(dst[x]>>5)&0x3F;
+                unsigned char b=(dst[x]>>11)&0x1F;
+                b=(((b*srca[x])>>5)+src[x])>>3;
+                dst[x]=(b<<11)|(g<<5)|r;
+            }
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+    }
+    return;
+  }
 }
 
diff -Naur MPlayer-export-2009-06-13.orig/libvo/osd.h MPlayer-export-2009-06-13/libvo/osd.h
--- MPlayer-export-2009-06-13.orig/libvo/osd.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/osd.h	2009-06-14 00:10:51.000000000 +0200
@@ -24,12 +24,12 @@
 
 void vo_draw_alpha_init(void); // build tables
 
-void vo_draw_alpha_yv12(int w,  int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_yuy2(int w,  int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_uyvy(int w,  int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_rgb24(int w, int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_rgb32(int w, int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_rgb15(int w, int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
-void vo_draw_alpha_rgb16(int w, int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_yv12(int w,  int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_yuy2(int w,  int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_uyvy(int w,  int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_rgb24(int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_rgb32(int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_rgb15(int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
+void vo_draw_alpha_rgb16(int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase, int dststride);
 
 #endif /* MPLAYER_OSD_H */
diff -Naur MPlayer-export-2009-06-13.orig/libvo/osd_template.c MPlayer-export-2009-06-13/libvo/osd_template.c
--- MPlayer-export-2009-06-13.orig/libvo/osd_template.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/osd_template.c	2009-06-14 00:10:51.000000000 +0200
@@ -44,7 +44,7 @@
 #define EMMS     "emms"
 #endif
 
-static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yv12)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !HAVE_MMX
     w=w>>1;
@@ -114,7 +114,7 @@
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_yuy2)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #if defined(FAST_OSD) && !HAVE_MMX
     w=w>>1;
@@ -186,7 +186,7 @@
     return;
 }
 
-static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_uyvy)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
   int y;
 #if defined(FAST_OSD)
   w=w>>1;
@@ -210,8 +210,10 @@
   }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb24)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
+    switch (dp) {
+    case DEST_PLANES_Y:
 #if HAVE_MMX
     __asm__ volatile(
         "pxor %%mm7, %%mm7\n\t"
@@ -316,13 +318,58 @@
 	__asm__ volatile(EMMS:::"memory");
 #endif
     return;
+    case DEST_PLANES_RB:
+      for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+          if(srca[x])
+            dst[0]=((dst[0]*srca[x])>>8)+src[x];
+          dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+      }
+      return;
+    case DEST_PLANES_G:
+      for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+          if(srca[x])
+            dst[1]=((dst[1]*srca[x])>>8)+src[x];
+          dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+      }
+      return;
+    case DEST_PLANES_BR:
+      for(y=0;y<h;y++){
+        register unsigned char *dst = dstbase;
+        register int x;
+        for(x=0;x<w;x++){
+          if(srca[x])
+            dst[2]=((dst[2]*srca[x])>>8)+src[x];
+          dst+=3; // 24bpp
+        }
+        src+=srcstride;
+        srca+=srcstride;
+        dstbase+=dststride;
+      }
+      return;
+    }
 }
 
-static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
+static inline void RENAME(vo_draw_alpha_rgb32)(int w,int h, int dp, unsigned char* src, unsigned char *srca, int srcstride, unsigned char* dstbase,int dststride){
     int y;
 #ifdef WORDS_BIGENDIAN
     dstbase++;
 #endif
+    switch (dp) {
+    case DEST_PLANES_Y:
 #if HAVE_MMX
 #if HAVE_AMD3DNOW
     __asm__ volatile(
@@ -481,4 +528,41 @@
 	__asm__ volatile(EMMS:::"memory");
 #endif
     return;
+  case DEST_PLANES_RB:
+    for(y=0;y<h;y++){
+      register int x;
+      for(x=0;x<w;x++){
+        if(srca[x])
+          dstbase[4*x+0]=(((dstbase[4*x+0]*srca[x])>>8)+src[x])&0xff;
+      }
+      src+=srcstride;
+      srca+=srcstride;
+      dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_G:
+    for(y=0;y<h;y++){
+      register int x;
+      for(x=0;x<w;x++){
+        if(srca[x])
+          dstbase[4*x+1]=(((dstbase[4*x+1]*srca[x])>>8)+src[x])&0xff;
+      }
+      src+=srcstride;
+      srca+=srcstride;
+      dstbase+=dststride;
+    }
+    return;
+  case DEST_PLANES_BR:
+    for(y=0;y<h;y++){
+      register int x;
+      for(x=0;x<w;x++){
+        if(srca[x])
+          dstbase[4*x+2]=(((dstbase[4*x+2]*srca[x])>>8)+src[x])&0xff;
+      }
+      src+=srcstride;
+      srca+=srcstride;
+      dstbase+=dststride;
+    }
+    return;
+  }
 }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/sub.c MPlayer-export-2009-06-13/libvo/sub.c
--- MPlayer-export-2009-06-13.orig/libvo/sub.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/sub.c	2009-06-14 00:10:51.000000000 +0200
@@ -167,11 +167,12 @@
 }
 
 // renders the buffer
-inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)){
+inline static void vo_draw_text_from_buffer(mp_osd_obj_t* obj,void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)){
     if (obj->allocated > 0) {
 	draw_alpha(obj->bbox.x1,obj->bbox.y1,
 		   obj->bbox.x2-obj->bbox.x1,
 		   obj->bbox.y2-obj->bbox.y1,
+		   DEST_PLANES_Y,
 		   obj->bitmap_buffer,
 		   obj->alpha_buffer,
 		   obj->stride);
@@ -1052,7 +1053,7 @@
   obj->flags |= OSDFLAG_BBOX;
 }
 
-inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, unsigned char* src, unsigned char* srca, int stride))
+inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, int dp, unsigned char* src, unsigned char* srca, int stride))
 {
   spudec_draw_scaled(vo_spudec, obj->dxs, obj->dys, draw_alpha);
 }
@@ -1260,7 +1261,7 @@
 
 void vo_draw_text_ext(int dxs, int dys, int left_border, int top_border,
                       int right_border, int bottom_border, int orig_w, int orig_h,
-                      void (*draw_alpha)(int x0, int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)) {
+                      void (*draw_alpha)(int x0, int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)) {
     mp_osd_obj_t* obj=vo_osd_list;
     vo_update_osd_ext(dxs, dys, left_border, top_border, right_border, bottom_border, orig_w, orig_h);
     while(obj){
@@ -1290,7 +1291,7 @@
     }
 }
 
-void vo_draw_text(int dxs, int dys, void (*draw_alpha)(int x0, int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)) {
+void vo_draw_text(int dxs, int dys, void (*draw_alpha)(int x0, int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)) {
   vo_draw_text_ext(dxs, dys, 0, 0, 0, 0, dxs, dys, draw_alpha);
 }
 
diff -Naur MPlayer-export-2009-06-13.orig/libvo/sub.h MPlayer-export-2009-06-13/libvo/sub.h
--- MPlayer-export-2009-06-13.orig/libvo/sub.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/sub.h	2009-06-14 00:10:51.000000000 +0200
@@ -122,10 +122,10 @@
 extern int spu_aamode;
 extern float spu_gaussvar;
 
-void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+void vo_draw_text(int dxs,int dys,void (*draw_alpha)(int x0,int y0, int w,int h,int dp, unsigned char* src, unsigned char *srca, int stride));
 void vo_draw_text_ext(int dxs, int dys, int left_border, int top_border,
                       int right_border, int bottom_border, int orig_w, int orig_h,
-                      void (*draw_alpha)(int x0, int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+                      void (*draw_alpha)(int x0, int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void vo_remove_text(int dxs,int dys,void (*remove)(int x0,int y0, int w,int h));
 
 void vo_init_osd(void);
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vesa_lvo.c MPlayer-export-2009-06-13/libvo/vesa_lvo.c
--- MPlayer-export-2009-06-13.orig/libvo/vesa_lvo.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vesa_lvo.c	2009-06-14 00:10:51.000000000 +0200
@@ -246,50 +246,51 @@
 }
 
 #if 0
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t bespitch = /*(*/mga_vid_config.src_width;// + 15) & ~15;
     switch(mga_vid_config.format){
     case IMGFMT_BGR15:
     case IMGFMT_RGB15:
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR16:
     case IMGFMT_RGB16:
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+2*(y0*bespitch+x0),2*bespitch);
 	break;
     case IMGFMT_BGR24:
     case IMGFMT_RGB24:
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+3*(y0*bespitch+x0),3*bespitch);
 	break;
     case IMGFMT_BGR32:
     case IMGFMT_RGB32:
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+4*(y0*bespitch+x0),4*bespitch);
 	break;
     case IMGFMT_YV12:
     case IMGFMT_IYUV:
     case IMGFMT_I420:
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
         break;
     case IMGFMT_YUY2:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0),bespitch);
         break;
     case IMGFMT_UYVY:
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+2*(bespitch*y0+x0)+1,bespitch);
         break;
     default:
-        draw_alpha_null(x0,y0,w,h,src,srca,stride);
+        draw_alpha_null(x0,y0,w,h,dp,src,srca,stride);
     }
 }
 #endif
diff -Naur MPlayer-export-2009-06-13.orig/libvo/video_out.h MPlayer-export-2009-06-13/libvo/video_out.h
--- MPlayer-export-2009-06-13.orig/libvo/video_out.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/video_out.h	2009-06-14 00:10:51.000000000 +0200
@@ -97,6 +97,8 @@
   int w,h;
 } mp_win_t;
 
+#define VOCTRL_GET_OSD_FORMAT 24
+
 #define VO_TRUE		1
 #define VO_FALSE	0
 #define VO_ERROR	-1
@@ -109,6 +111,15 @@
 #define VOFLAG_FLIPPING		0x08
 #define VOFLAG_XOVERLAY_SUB_VO  0x10000
 
+// dest planes (draw_alpha)
+#define DEST_PLANES_Y		0	// Y planes (default)
+#define DEST_PLANES_U		1	// U planes in YUV mode
+#define DEST_PLANES_V		2	// V planes in YUV mode
+#define DEST_PLANES_RB		3	// R or B planes in RGB or BGR mode
+#define DEST_PLANES_G		4	// G planes in RGB or BGR mode
+#define DEST_PLANES_BR		5	// B or R planes in RGB or BGR mode
+#define DEST_PLANES_YUYV	6	// Yuv (all) planes in YUYV mode
+
 typedef struct vo_info_s
 {
         /* driver name ("Matrox Millennium G200/G400" */
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_aa.c MPlayer-export-2009-06-13/libvo/vo_aa.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_aa.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_aa.c	2009-06-14 00:10:51.000000000 +0200
@@ -518,7 +518,7 @@
     aa_close(c);
 }
 
-static void draw_alpha(int x,int y, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x,int y, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     int i,j;
     for (i = 0; i < h; i++) {
 	for (j = 0; j < w; j++) {
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_dfbmga.c MPlayer-export-2009-06-13/libvo/vo_dfbmga.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_dfbmga.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_dfbmga.c	2009-06-14 00:10:51.000000000 +0200
@@ -990,7 +990,7 @@
 }
 
 static void
-vo_draw_alpha_alut44( int w, int h,
+vo_draw_alpha_alut44( int w, int h, int dp,
                       unsigned char* src,
                       unsigned char *srca,
                       int srcstride,
@@ -1019,7 +1019,7 @@
 }
 
 static void
-draw_alpha( int x0, int y0,
+draw_alpha( int x0, int y0, int dp,
             int w, int h,
             unsigned char *src,
             unsigned char *srca,
@@ -1047,46 +1047,90 @@
 
      switch (subframe_format) {
      case DSPF_ALUT44:
-          vo_draw_alpha_alut44( w, h, src, srca, stride,
+          vo_draw_alpha_alut44( w, h, dp, src, srca, stride,
                                 dst + pitch * y0 + x0,
                                 pitch );
           break;
      case DSPF_RGB32:
      case DSPF_ARGB:
-          vo_draw_alpha_rgb32( w, h, src, srca, stride,
+          vo_draw_alpha_rgb32( w, h, dp, src, srca, stride,
                                dst + pitch * y0 + 4 * x0,
                                pitch );
           break;
      case DSPF_RGB16:
-          vo_draw_alpha_rgb16( w, h, src, srca, stride,
+          vo_draw_alpha_rgb16( w, h, dp, src, srca, stride,
                                dst + pitch * y0 + 2 * x0,
                                pitch );
           break;
      case DSPF_ARGB1555:
-          vo_draw_alpha_rgb15( w, h, src, srca, stride,
+          vo_draw_alpha_rgb15( w, h, dp, src, srca, stride,
                                dst + pitch * y0 + 2 * x0,
                                pitch );
           break;
      case DSPF_YUY2:
-          vo_draw_alpha_yuy2( w, h, src, srca, stride,
+        switch (dp) {
+        case DEST_PLANES_Y:
+          vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
                               dst + pitch * y0 + 2 * x0,
                               pitch );
           break;
+        case DEST_PLANES_YUYV:
+            vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                               ((uint8_t *) dst) + pitch * y0 + 2 * x0,
+                               pitch );
+            break;
+        }
+        break;
      case DSPF_UYVY:
-          vo_draw_alpha_yuy2( w, h, src, srca, stride,
+        switch (dp) {
+        case DEST_PLANES_Y:
+          vo_draw_alpha_yuy2( w, h, dp, src, srca, stride,
                               dst + pitch * y0 + 2 * x0 + 1,
                               pitch );
           break;
+        case DEST_PLANES_YUYV:
+            vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                               ((uint8_t *) dst) + pitch * y0 + 2 * x0,
+                               pitch );
+            break;
+        }
+        break;
 #if DIRECTFBVERSION > DFB_VERSION(0,9,21)
      case DSPF_NV12:
      case DSPF_NV21:
 #endif
      case DSPF_I420:
      case DSPF_YV12:
-          vo_draw_alpha_yv12( w, h, src, srca, stride,
+        switch (dp) {
+        case DEST_PLANES_Y:
+          vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
                               dst + pitch * y0 + x0,
                               pitch );
           break;
+        case DEST_PLANES_U:
+            if (subframe_format==DSPF_YV12)
+                vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                                   ((uint8_t *) dst) + pitch * y0 + x0 +
+                                   pitch * in_height, pitch );
+            else
+                vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                                   ((uint8_t *) dst) + pitch * y0 + x0 +
+                                   pitch * (in_height+in_height/2),
+                                   pitch );
+            break;
+        case DEST_PLANES_V:
+            if (subframe_format==DSPF_YV12)
+                vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                                   ((uint8_t *) dst) + pitch * y0 + x0 +
+                                   pitch * (in_height+in_height/2),
+                                   pitch );
+            else
+                vo_draw_alpha_yv12( w, h, dp, src, srca, stride,
+                                   ((uint8_t *) dst) + pitch * y0 + x0 +
+                                   pitch * in_height, pitch );
+            break;
+        }
+        break;
      }
 
      subframe->Unlock( subframe );
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_dga.c MPlayer-export-2009-06-13/libvo/vo_dga.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_dga.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_dga.c	2009-06-14 00:10:51.000000000 +0200
@@ -239,7 +239,7 @@
 //---------------------------------------------------------
 
 static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
-                       unsigned char *srca, int stride)
+                       int dp, unsigned char *srca, int stride)
 {
 
     char *d;
@@ -254,19 +254,19 @@
     {
 
         case 32:
-            vo_draw_alpha_rgb32(w, h, src, srca, stride, d + 4 * offset,
+            vo_draw_alpha_rgb32(w, h, dp, src, srca, stride, d + 4 * offset,
                                 4 * buffer_stride);
             break;
         case 24:
-            vo_draw_alpha_rgb24(w, h, src, srca, stride, d + 3 * offset,
+            vo_draw_alpha_rgb24(w, h, dp, src, srca, stride, d + 3 * offset,
                                 3 * buffer_stride);
             break;
         case 15:
-            vo_draw_alpha_rgb15(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb15(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
         case 16:
-            vo_draw_alpha_rgb16(w, h, src, srca, stride, d + 2 * offset,
+            vo_draw_alpha_rgb16(w, h, dp, src, srca, stride, d + 2 * offset,
                                 2 * buffer_stride);
             break;
     }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_directfb2.c MPlayer-export-2009-06-13/libvo/vo_directfb2.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_directfb2.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_directfb2.c	2009-06-14 00:10:51.000000000 +0200
@@ -1456,7 +1456,7 @@
 
 // hopefully will be removed soon
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
         void *dst;
@@ -1475,36 +1475,82 @@
 	switch(pixel_format) {
                 case DSPF_RGB32:
                 case DSPF_ARGB:
-                        vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
+                        vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 4*x0,pitch);
                         break;
 
                 case DSPF_RGB24:
-                        vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
+                        vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 3*x0,pitch);
                         break;
 
                 case DSPF_RGB16:
-                        vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 #if DIRECTFBVERSION > DFB_VERSION(0,9,15)
                 case DSPF_ARGB1555:
 #else
                 case DSPF_RGB15:
 #endif
-                        vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
+                        vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) dst)+pitch*y0 + 2*x0,pitch);
                         break;
 
 		case DSPF_YUY2:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
+                        switch (dp) {
+                        case DEST_PLANES_Y:
+    			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0,pitch);
 		break;
+                        case DEST_PLANES_YUYV:
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*y0 + 2*x0,pitch);
+                        break;
+                        }
+                break;
 
         	case DSPF_UYVY:
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
+                        switch (dp) {
+                        case DEST_PLANES_Y:
+    			vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 2*x0 + 1,pitch);
 		break;
+                        case DEST_PLANES_YUYV:
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*y0 + 2*x0,pitch);
+                        break;
+                        }
+                break;
 
         	case DSPF_I420:
 		case DSPF_YV12:
-    			vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
+                    switch (dp) {
+                    case DEST_PLANES_Y:
+    			vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) dst) + pitch*y0 + 1*x0,pitch);
 		break;
+                    case DEST_PLANES_U:
+                        if (pixel_format==DSPF_YV12)
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*height/4 +
+                                               pitch*y0 + 1*x0,pitch);
+                        else
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*height/2 + pitch*y0 +
+                                               1*x0,pitch);
+                        break;
+                    case DEST_PLANES_V:
+                        if (pixel_format==DSPF_YV12)
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*height/2 + pitch*y0 +
+                                               1*x0,pitch);
+                        else
+                            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                               ((uint8_t *) dst) +
+                                               pitch*height/4 +
+                                               pitch*y0 + 1*x0,pitch);
+                        break;
+                    }
+                break;
 		}
 
 	    unlock();
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_directx.c MPlayer-export-2009-06-13/libvo/vo_directx.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_directx.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_directx.c	2009-06-14 00:10:51.000000000 +0200
@@ -147,7 +147,7 @@
 
 const LIBVO_EXTERN(directx)
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
     switch(image_format) {
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_dxr3.c MPlayer-export-2009-06-13/libvo/vo_dxr3.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_dxr3.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_dxr3.c	2009-06-14 00:10:51.000000000 +0200
@@ -568,7 +568,7 @@
 	return 0;
 }
 
-static void draw_alpha(int x, int y, int w, int h, unsigned char* src, unsigned char *srca, int srcstride)
+static void draw_alpha(int x, int y, int w, int h, int dp, unsigned char* src, unsigned char *srca, int srcstride)
 {
 #ifdef SPU_SUPPORT
 	unsigned char *buf = &osdpicbuf[(y * osdpicbuf_w) + x];
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_fbdev2.c MPlayer-export-2009-06-13/libvo/vo_fbdev2.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_fbdev2.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_fbdev2.c	2009-06-14 00:10:51.000000000 +0200
@@ -94,7 +94,7 @@
 static int fb_bpp;		// 32: 32  24: 24  16: 16  15: 15
 static size_t fb_size; // size of frame_buffer
 static int fb_line_len; // length of one line in bytes
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride, unsigned char *dst,
 		int dstride);
 
@@ -332,7 +332,7 @@
 	return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
 		unsigned char *srca, int stride)
 {
 	unsigned char *dst;
@@ -345,7 +345,7 @@
 	dst = next_frame + (in_width * y0 + x0) * fb_pixel_size;
 	dstride = in_width * fb_pixel_size;
 #endif
-	(*draw_alpha_p)(w, h, src, srca, stride, dst, dstride);
+	(*draw_alpha_p)(w, h, dp, src, srca, stride, dst, dstride);
 }
 
 static void draw_osd(void)
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_fbdev.c MPlayer-export-2009-06-13/libvo/vo_fbdev.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_fbdev.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_fbdev.c	2009-06-14 00:10:51.000000000 +0200
@@ -575,7 +575,7 @@
 static int fb_line_len;
 static int fb_xres;
 static int fb_yres;
-static void (*draw_alpha_p)(int w, int h, unsigned char *src,
+static void (*draw_alpha_p)(int w, int h, int dp, unsigned char *src,
                             unsigned char *srca, int stride,
                             unsigned char *dst, int dstride);
 
@@ -1000,14 +1000,14 @@
     return 0;
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride)
 {
     unsigned char *dst;
 
     dst = center + fb_line_len * y0 + fb_pixel_size * x0;
 
-    (*draw_alpha_p)(w, h, src, srca, stride, dst, fb_line_len);
+    (*draw_alpha_p)(w, h, dp, src, srca, stride, dst, fb_line_len);
 }
 
 static int draw_frame(uint8_t *src[])
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_gl2.c MPlayer-export-2009-06-13/libvo/vo_gl2.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_gl2.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_gl2.c	2009-06-14 00:10:51.000000000 +0200
@@ -100,7 +100,7 @@
 static int      use_glFinish;
 
 static void (*draw_alpha_fnc)
-                 (int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+                 (int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 
 /* The squares that are tiled to make up the game screen polygon */
@@ -446,23 +446,23 @@
   glLoadIdentity();
 }
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,ImageData+4*(y0*image_width+x0),4*image_width);
 }
 
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,ImageData+3*(y0*image_width+x0),3*image_width);
 }
 
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
 }
 
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,ImageData+2*(y0*image_width+x0),2*image_width);
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 }
 
 #ifdef GL_WIN32
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_quartz.c MPlayer-export-2009-06-13/libvo/vo_quartz.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_quartz.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_quartz.c	2009-06-14 00:11:07.000000000 +0200
@@ -210,23 +210,23 @@
     }
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src, unsigned char *srca, int stride)
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src, unsigned char *srca, int stride)
 {
     switch (image_format)
     {
     case IMGFMT_RGB32:
-        vo_draw_alpha_rgb32(w, h, src, srca, stride, image_data + 4 * (y0 * imgRect.right + x0), 4 * imgRect.right);
+        vo_draw_alpha_rgb32(w, h, dp, src, srca, stride, image_data + 4 * (y0 * imgRect.right + x0), 4 * imgRect.right);
         break;
     case IMGFMT_YV12:
     case IMGFMT_IYUV:
     case IMGFMT_I420:
-        vo_draw_alpha_yv12(w, h, src, srca, stride, ((char *)P) + be2me_32(P->componentInfoY.offset) + x0 + y0 * imgRect.right, imgRect.right);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride, ((char *)P) + be2me_32(P->componentInfoY.offset) + x0 + y0 * imgRect.right, imgRect.right);
         break;
     case IMGFMT_UYVY:
-        vo_draw_alpha_uyvy(w, h, src, srca, stride, ((char *)P) + (x0 + y0 * imgRect.right) * 2, imgRect.right * 2);
+        vo_draw_alpha_uyvy(w, h, dp, src, srca, stride, ((char *)P) + (x0 + y0 * imgRect.right) * 2, imgRect.right * 2);
         break;
     case IMGFMT_YUY2:
-        vo_draw_alpha_yuy2(w, h, src, srca, stride, ((char *)P) + (x0 + y0 * imgRect.right) * 2, imgRect.right * 2);
+        vo_draw_alpha_yuy2(w, h, dp, src, srca, stride, ((char *)P) + (x0 + y0 * imgRect.right) * 2, imgRect.right * 2);
         break;
     }
 }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_sdl.c MPlayer-export-2009-06-13/libvo/vo_sdl.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_sdl.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_sdl.c	2009-06-14 00:22:27.000000000 +0200
@@ -238,7 +238,7 @@
  *
  **/
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
 	struct sdl_priv_s *priv = &sdl_priv;
 
     if(priv->osd_has_changed) {
@@ -278,18 +278,72 @@
 	switch(priv->format) {
 		case IMGFMT_YV12:
 		case IMGFMT_I420:
-        	case IMGFMT_IYUV:
-            vo_draw_alpha_yv12(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
-		break;
+        case IMGFMT_IYUV:
+          switch (dp) {
+          case DEST_PLANES_Y:
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+            break;
+          case DEST_PLANES_U:
+            SDL_OVR_LOCK(-1)
+              if (priv->format==IMGFMT_YV12)
+                vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                   ((uint8_t *) (priv->overlay->pixels[1]))+
+                                   priv->overlay->pitches[1]*y0+x0,
+                                   priv->overlay->pitches[1]);
+              else
+                vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                   ((uint8_t *) (priv->overlay->pixels[2]))+
+                                   priv->overlay->pitches[2]*y0+x0,
+                                   priv->overlay->pitches[2]);
+            SDL_OVR_UNLOCK
+              break;
+          case DEST_PLANES_V:
+            SDL_OVR_LOCK(-1)
+              if (priv->format==IMGFMT_YV12)
+                vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                   ((uint8_t *) (priv->overlay->pixels[2]))+
+                                   priv->overlay->pitches[2]*y0+x0,
+                                   priv->overlay->pitches[2]);
+              else
+                vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                   ((uint8_t *) (priv->overlay->pixels[1]))+
+                                   priv->overlay->pitches[1]*y0+x0,
+                                   priv->overlay->pitches[1]);
+            SDL_OVR_UNLOCK
+              break;
+          }
+          break;
+
 		case IMGFMT_YUY2:
         	case IMGFMT_YVYU:
-                x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
-		break;
+                  x0 *= 2;
+                  switch (dp) {
+                  case DEST_PLANES_Y:
+                    vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+                    break;
+                  case DEST_PLANES_YUYV:
+                    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                       ((uint8_t *) *(priv->overlay->pixels))+
+                                       priv->overlay->pitches[0]*y0+x0,
+                                       priv->overlay->pitches[0]);
+                    break;
+                  }
+                  break;
+
         	case IMGFMT_UYVY:
-                x0 *= 2;
-    			vo_draw_alpha_yuy2(w,h,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
-		break;
+                  x0 *= 2;
+                  switch (dp) {
+                  case DEST_PLANES_Y:
+                    vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,((uint8_t *) *(priv->overlay->pixels))+priv->overlay->pitches[0]*y0+x0,priv->overlay->pitches[0]);
+                    break;
+                  case DEST_PLANES_YUYV:
+                    vo_draw_alpha_yv12(w,h,dp,src,srca,stride,
+                                       ((uint8_t *) *(priv->overlay->pixels))+
+                                       priv->overlay->pitches[0]*y0+x0,
+                                       priv->overlay->pitches[0]);
+                    break;
+                  }
+                  break;
 
 		default:
         if(priv->dblit) {
@@ -297,19 +351,19 @@
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+    			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+    			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+    			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
+    			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->surface->pixels)+y0*priv->surface->pitch+x0,priv->surface->pitch);
 		break;
 		}
         }
@@ -318,19 +372,19 @@
 		switch(priv->format) {
 		case IMGFMT_RGB15:
 		case IMGFMT_BGR15:
-    			vo_draw_alpha_rgb15(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+    			vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB16:
 		case IMGFMT_BGR16:
-    			vo_draw_alpha_rgb16(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+    			vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB24:
 		case IMGFMT_BGR24:
-    			vo_draw_alpha_rgb24(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+    			vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		case IMGFMT_RGB32:
 		case IMGFMT_BGR32:
-    			vo_draw_alpha_rgb32(w,h,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
+    			vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,((uint8_t *) priv->rgbsurface->pixels)+y0*priv->rgbsurface->pitch+x0,priv->rgbsurface->pitch);
 		break;
 		}
         }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vosub_vidix.c MPlayer-export-2009-06-13/libvo/vosub_vidix.c
--- MPlayer-export-2009-06-13.orig/libvo/vosub_vidix.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vosub_vidix.c	2009-06-14 00:11:07.000000000 +0200
@@ -286,7 +286,7 @@
   }
 }
 
-static void draw_alpha(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
     uint32_t apitch,bespitch;
     char *lvo_mem;
@@ -301,36 +301,68 @@
     case IMGFMT_IF09:
     case IMGFMT_Y8:
     case IMGFMT_Y800:
+        switch (dp) {
+            case DEST_PLANES_Y:
 	bespitch = (vidix_play.src.w + apitch) & (~apitch);
-        vo_draw_alpha_yv12(w,h,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+        vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,bespitch);
+        break;
+        case DEST_PLANES_U:
+            lvo_mem = vidix_mem + vidix_play.offsets[next_frame] +
+                      vidix_play.offset.u;
+            lvo_mem += dstrides.u*y0/2 + x0;
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem,dstrides.u/2);
+            break;
+        case DEST_PLANES_V:
+            lvo_mem = vidix_mem + vidix_play.offsets[next_frame] +
+                      vidix_play.offset.v;
+            lvo_mem += dstrides.v*y0/2 + x0;
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem,dstrides.v/2);
+            break;
+        }
         break;
     case IMGFMT_YUY2:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+        switch (dp) {
+        case DEST_PLANES_Y:
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0,bespitch);
+        break;
+        case DEST_PLANES_YUYV:
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,
+                               bespitch);
+            break;
+        }
         break;
     case IMGFMT_UYVY:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-        vo_draw_alpha_yuy2(w,h,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
+        switch (dp) {
+        case DEST_PLANES_Y:
+        vo_draw_alpha_yuy2(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+2*x0+1,bespitch);
+        break;
+        case DEST_PLANES_YUYV:
+            vo_draw_alpha_yv12(w,h,dp,src,srca,stride,lvo_mem+bespitch*y0+x0,
+                               bespitch);
+            break;
+        }
         break;
     case IMGFMT_RGB32:
     case IMGFMT_BGR32:
 	bespitch = (vidix_play.src.w*4 + apitch) & (~apitch);
-	vo_draw_alpha_rgb32(w,h,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
+	vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+4*x0,bespitch);
         break;
     case IMGFMT_RGB24:
     case IMGFMT_BGR24:
 	bespitch = (vidix_play.src.w*3 + apitch) & (~apitch);
-	vo_draw_alpha_rgb24(w,h,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
+	vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+3*x0,bespitch);
         break;
     case IMGFMT_RGB16:
     case IMGFMT_BGR16:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb16(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     case IMGFMT_RGB15:
     case IMGFMT_BGR15:
 	bespitch = (vidix_play.src.w*2 + apitch) & (~apitch);
-	vo_draw_alpha_rgb15(w,h,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
+	vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,lvo_mem+y0*bespitch+2*x0,bespitch);
         break;
     default:
 	return;
@@ -480,7 +512,7 @@
 	    next_frame = i;
 	    memset(vidix_mem + vidix_play.offsets[i], 0x80,
 		vidix_play.frame_size);
-	    draw_alpha(0, 0, image_width, image_height, tmp, tmpa, image_width);
+	    draw_alpha(0, 0, image_width, image_height, DEST_PLANES_Y, tmp, tmpa, image_width);
 	}
 	free(tmp);
 	free(tmpa);
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_vesa.c MPlayer-export-2009-06-13/libvo/vo_vesa.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_vesa.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_vesa.c	2009-06-14 00:11:07.000000000 +0200
@@ -111,7 +111,7 @@
 static unsigned video_mode; /* selected video mode for playback */
 static struct VesaModeInfoBlock video_mode_info;
 static int flip_trigger = 0;
-static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_alpha_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 
 /* multibuffering */
 uint8_t*  video_base; /* should be never changed */
@@ -299,7 +299,7 @@
 /* Please comment it out if you want have OSD within movie */
 /*#define OSD_OUTSIDE_MOVIE 1*/
 
-static void draw_alpha_32(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_32(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -309,10 +309,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb32(w,h,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
+   vo_draw_alpha_rgb32(w,h,dp,src,srca,stride,dga_buffer+4*(y0*dstride+x0),4*dstride);
 }
 
-static void draw_alpha_24(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_24(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -322,10 +322,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb24(w,h,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
+   vo_draw_alpha_rgb24(w,h,dp,src,srca,stride,dga_buffer+3*(y0*dstride+x0),3*dstride);
 }
 
-static void draw_alpha_16(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_16(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -335,10 +335,10 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb16(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+   vo_draw_alpha_rgb16(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
 }
 
-static void draw_alpha_15(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_15(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
    int dstride=HAS_DGA()?video_mode_info.XResolution:dstW;
 #ifndef OSD_OUTSIDE_MOVIE
@@ -348,15 +348,16 @@
 	y0 += y_offset;
    }
 #endif
-   vo_draw_alpha_rgb15(w,h,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
+   vo_draw_alpha_rgb15(w,h,dp,src,srca,stride,dga_buffer+2*(y0*dstride+x0),2*dstride);
 }
 
-static void draw_alpha_null(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+static void draw_alpha_null(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride)
 {
   UNUSED(x0);
   UNUSED(y0);
   UNUSED(w);
   UNUSED(h);
+  UNUSED(dp);
   UNUSED(src);
   UNUSED(srca);
   UNUSED(stride);
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_x11.c MPlayer-export-2009-06-13/libvo/vo_x11.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_x11.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_x11.c	2009-06-14 00:11:07.000000000 +0200
@@ -70,7 +70,7 @@
 
 const LIBVO_EXTERN(x11)
 /* private prototypes */
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
@@ -114,39 +114,39 @@
         flip_page();
 }
 
-static void draw_alpha_32(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_32(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb32(w, h, src, srca, stride,
+    vo_draw_alpha_rgb32(w, h, dp, src, srca, stride,
                         ImageData + 4 * (y0 * image_width + x0),
                         4 * image_width);
 }
 
-static void draw_alpha_24(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_24(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb24(w, h, src, srca, stride,
+    vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
                         ImageData + 3 * (y0 * image_width + x0),
                         3 * image_width);
 }
 
-static void draw_alpha_16(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_16(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb16(w, h, src, srca, stride,
+    vo_draw_alpha_rgb16(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_15(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha_15(int x0, int y0, int w, int h, int dp, unsigned char *src,
                           unsigned char *srca, int stride)
 {
-    vo_draw_alpha_rgb15(w, h, src, srca, stride,
+    vo_draw_alpha_rgb15(w, h, dp, src, srca, stride,
                         ImageData + 2 * (y0 * image_width + x0),
                         2 * image_width);
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
@@ -711,6 +711,9 @@
         case VOCTRL_UPDATE_SCREENINFO:
             update_xinerama_info();
             return VO_TRUE;
+        case VOCTRL_GET_OSD_FORMAT:
+            *(uint32_t *)data=out_format;
+            return VO_TRUE;
     }
     return VO_NOTIMPL;
 }
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_xv.c MPlayer-export-2009-06-13/libvo/vo_xv.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_xv.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_xv.c	2009-06-14 00:11:07.000000000 +0200
@@ -110,47 +110,91 @@
 static struct vo_rect dst_rect;
 static uint32_t max_width = 0, max_height = 0; // zero means: not set
 
-static void (*draw_alpha_fnc) (int x0, int y0, int w, int h,
+static void (*draw_alpha_fnc) (int x0, int y0, int w, int h, int dp,
                                unsigned char *src, unsigned char *srca,
                                int stride);
 
-static void draw_alpha_yv12(int x0, int y0, int w, int h,
+static void draw_alpha_yv12(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+    switch (dp)  {
+    case DEST_PLANES_U:
+        x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                           xvimage[current_buf]->data +
+                           xvimage[current_buf]->offsets[1] +
+                           xvimage[current_buf]->pitches[1] * y0 + x0,
+                           xvimage[current_buf]->pitches[1]);
+        break;
+    case DEST_PLANES_V:
+        x0 += image_width/2 * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                           xvimage[current_buf]->data +
+                           xvimage[current_buf]->offsets[2] +
+                           xvimage[current_buf]->pitches[2] * y0 + x0,
+                           xvimage[current_buf]->pitches[2]);
+        break;
+    case DEST_PLANES_Y:
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yv12(w, h, src, srca, stride,
+    vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + x0,
                        xvimage[current_buf]->pitches[0]);
+        break;
+    }
 }
 
-static void draw_alpha_yuy2(int x0, int y0, int w, int h,
+static void draw_alpha_yuy2(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+    switch (dp) {
+    case DEST_PLANES_Y:
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
                        xvimage[current_buf]->pitches[0]);
+    break;
+    case DEST_PLANES_YUYV:
+        x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                           xvimage[current_buf]->data +
+                           xvimage[current_buf]->offsets[0] +
+                           xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
+                           xvimage[current_buf]->pitches[0]);
+    break;
+    }
 }
 
-static void draw_alpha_uyvy(int x0, int y0, int w, int h,
+static void draw_alpha_uyvy(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
+    switch (dp) {
+    case DEST_PLANES_Y:
     x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
-    vo_draw_alpha_yuy2(w, h, src, srca, stride,
+    vo_draw_alpha_yuy2(w, h, dp, src, srca, stride,
                        xvimage[current_buf]->data +
                        xvimage[current_buf]->offsets[0] +
                        xvimage[current_buf]->pitches[0] * y0 + 2 * x0 + 1,
                        xvimage[current_buf]->pitches[0]);
+    break;
+    case DEST_PLANES_YUYV:
+        x0 += image_width * (vo_panscan_x >> 1) / (vo_dwidth + vo_panscan_x);
+        vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                           xvimage[current_buf]->data +
+                           xvimage[current_buf]->offsets[0] +
+                           xvimage[current_buf]->pitches[0] * y0 + 2 * x0,
+                           xvimage[current_buf]->pitches[0]);
+    break;
+    }
 }
 
-static void draw_alpha_null(int x0, int y0, int w, int h,
+static void draw_alpha_null(int x0, int y0, int w, int h, int dp,
                             unsigned char *src, unsigned char *srca,
                             int stride)
 {
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_xvmc.c MPlayer-export-2009-06-13/libvo/vo_xvmc.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_xvmc.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_xvmc.c	2009-06-14 00:11:07.000000000 +0200
@@ -108,12 +108,12 @@
 static int free_element;
 
 
-static void (*draw_osd_fnc)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void (*draw_osd_fnc)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void (*clear_osd_fnc)(int x0,int y0, int w,int h);
 static void (*init_osd_fnc)(void);
 
-static void   draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
-static void   draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
+static void   draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride);
 static void   clear_osd_subpic(int x0,int y0, int w,int h);
 static void   init_osd_yuv_pal(void);
 
@@ -791,7 +791,7 @@
     subpicture_alloc = 1;
 }
 
-static void draw_osd_IA44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_IA44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     int ox,oy;
     int rez;
 
@@ -810,7 +810,7 @@
     }
 }
 
-static void draw_osd_AI44(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride){
+static void draw_osd_AI44(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride){
     int ox,oy;
     int rez;
 
diff -Naur MPlayer-export-2009-06-13.orig/libvo/vo_yuv4mpeg.c MPlayer-export-2009-06-13/libvo/vo_yuv4mpeg.c
--- MPlayer-export-2009-06-13.orig/libvo/vo_yuv4mpeg.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/libvo/vo_yuv4mpeg.c	2009-06-14 00:18:48.000000000 +0200
@@ -196,25 +196,41 @@
 	}
 }
 
-static void draw_alpha(int x0, int y0, int w, int h, unsigned char *src,
+static void draw_alpha(int x0, int y0, int w, int h, int dp, unsigned char *src,
                        unsigned char *srca, int stride) {
 	switch (using_format)
 	{
     	case IMGFMT_YV12:
-	    	vo_draw_alpha_yv12(w, h, src, srca, stride,
-				       image + y0 * image_width + x0, image_width);
-			break;
+          switch (dp) {
+          case DEST_PLANES_Y:
+            vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                               image + y0 * image_width + x0, image_width);
+            break;
+          case DEST_PLANES_U:
+            if (image_u)
+              vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                                 image_u + y0 * image_width + x0,
+                                 image_width);
+            break;
+          case DEST_PLANES_V:
+            if (image_v)
+              vo_draw_alpha_yv12(w, h, dp, src, srca, stride,
+                                 image_v + y0 * image_width + x0,
+                                 image_width);
+            break;
+          }
+          break;
 
 		case IMGFMT_BGR|24:
 		case IMGFMT_RGB|24:
 			if (config_interlace != Y4M_ILACE_BOTTOM_FIRST)
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width + x0) * 3, image_width * 3);
 			else
 			{
 				swap_fields (rgb_buffer, image_height, image_width * 3);
 
-				vo_draw_alpha_rgb24(w, h, src, srca, stride,
+				vo_draw_alpha_rgb24(w, h, dp, src, srca, stride,
 						rgb_buffer + (y0 * image_width  + x0) * 3, image_width * 3);
 
 				swap_fields (rgb_buffer, image_height, image_width * 3);
diff -Naur MPlayer-export-2009-06-13.orig/mp_core.h MPlayer-export-2009-06-13/mp_core.h
--- MPlayer-export-2009-06-13.orig/mp_core.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/mp_core.h	2009-06-14 00:11:07.000000000 +0200
@@ -111,6 +111,7 @@
     unsigned char *nav_start;    ///< pointer to last read video buffer
     int            nav_in_size;  ///< last read size
 #endif
+    int spu_color_inited;
 } MPContext;
 
 
diff -Naur MPlayer-export-2009-06-13.orig/mplayer.c MPlayer-export-2009-06-13/mplayer.c
--- MPlayer-export-2009-06-13.orig/mplayer.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/mplayer.c	2009-06-14 00:11:07.000000000 +0200
@@ -229,6 +229,7 @@
 // if nonzero, hide current OSD contents when GetTimerMS() reaches this
 unsigned int osd_visible;
 int osd_duration = 1000;
+int colorspu=1;
 
 int term_osd = 1;
 static char* term_osd_esc = "\x1b[A\r\x1b[K";
@@ -1092,6 +1093,7 @@
 void init_vo_spudec(void) {
   if (vo_spudec)
     spudec_free(vo_spudec);
+  mpctx->spu_color_inited=0;
   initialized_flags &= ~INITIALIZED_SPUDEC;
   vo_spudec = NULL;
   if (spudec_ifo) {
@@ -1131,6 +1133,16 @@
   }
 }
 
+void init_spu_color(void)
+{
+  uint32_t fmt=0;
+
+  if (mpctx->sh_video->vfilter)
+    ((vf_instance_t *)mpctx->sh_video->vfilter)->control(mpctx->sh_video->vfilter, VFCTRL_GET_OSD_FORMAT, &fmt);
+  spudec_set_spu_format(vo_spudec, fmt);
+  mpctx->spu_color_inited=1;
+}
+
 /*
  * In Mac OS X the SDL-lib is built upon Cocoa. The easiest way to
  * make it all work is to use the builtin SDL-bootstrap code, which
@@ -1932,6 +1944,85 @@
     if (decoded_frame && mpctx->nav_smpi != decoded_frame)
         mpctx->nav_smpi = mp_dvdnav_copy_mpi(mpctx->nav_smpi,decoded_frame);
 }
+
+//
+// set dvd menu buttons
+//
+static void mp_dvdnav_highlight_handle(int stream_is_change) {
+    nav_highlight_t highlight;
+    unsigned int *spu_clut;
+
+    if (vo_spudec!=NULL && mpctx->sh_video && !mpctx->spu_color_inited)
+        init_spu_color();
+    spu_clut = mp_dvdnav_get_spu_clut(mpctx->stream);
+    mp_dvdnav_get_highlight(mpctx->stream,&highlight);
+    if (highlight.sx==0 && highlight.sy==0 && highlight.ex==0 && highlight.ey==0) { /// is no button
+        if (stream_is_change || (spudec_visible(vo_spudec) && !mpctx->global_sub_size)) {
+            if(!colorspu)
+                spudec_set_spu_format(vo_spudec, 0);
+            spudec_update_palette(vo_spudec,spu_clut);
+            spudec_dvdnav_mode(vo_spudec, 0); /// spu menu button off
+            spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+            highlight.ey,highlight.palette); /// set spu button area & palette
+            if(vo_spudec) spudec_reset(vo_spudec);
+            vo_osd_changed(OSDTYPE_SPU);
+        }
+    } else {
+        if(vo_spudec!=NULL && mpctx->sh_video && !colorspu)
+            init_spu_color();
+        spudec_update_palette(vo_spudec,spu_clut);
+        spudec_dvdnav_mode(vo_spudec, mpctx->spu_color_inited); /// spu menu button on
+        spudec_dvdnav_area(vo_spudec,highlight.sx,highlight.sy,highlight.ex,
+                           highlight.ey,highlight.palette); /// set spu button area & palette
+        vo_osd_changed(OSDTYPE_SPU);
+        if (!vo_spudec || !spudec_visible(vo_spudec)) { /// if unsucessful spu button visible
+            osd_set_nav_box(highlight.sx,highlight.sy,highlight.ex,highlight.ey); /// then use simple box
+            vo_osd_changed(OSDTYPE_DVDNAV);
+        } else {
+            osd_set_nav_box(0,0,0,0); /// if sucessful spu button visible the
+            vo_osd_changed(OSDTYPE_DVDNAV); /// then hide simple box
+        }
+    }
+}
+
+/// Switch audio stream of DVDNAV
+static int mp_dvdnav_switch_audio(void) {
+    int new_aid=mp_dvdnav_get_current_audio(mpctx->stream);
+    int old_aid=mpctx->demuxer->audio->id;
+    int aid;
+
+    if (new_aid<0) {
+        demuxer_switch_audio(mpctx->demuxer, new_aid);
+        return 1;
+    }
+    if (new_aid==old_aid)
+        return 1;
+    aid = demuxer_switch_audio(mpctx->demuxer, new_aid);
+    if (aid!=new_aid)
+        return 0;
+    if (mpctx->demuxer->audio->id==-2) {
+        mpctx->demuxer->audio->id=-1;
+        return 1;
+    }
+    if (old_aid & 0x0F == new_aid & 0x0F)  // codec unchanged
+        return 1;
+    if (new_aid == -2 || (new_aid > -1 && old_aid != -2 &&
+                         mpctx->demuxer->audio->id != old_aid)) {
+        uninit_player(INITIALIZED_AO | INITIALIZED_ACODEC);
+        if (audio_id > -1 && mpctx->demuxer->audio->id != old_aid) {
+            sh_audio_t *sh2;
+            sh2 = mpctx->demuxer->a_streams[mpctx->demuxer->audio->id];
+            if (sh2) {
+                sh2->ds = mpctx->demuxer->audio;
+                mpctx->sh_audio = sh2;
+                reinit_audio_chain();
+            }
+        }
+    }
+    if (mpctx->demuxer->audio->id==-2)
+        mpctx->demuxer->audio->id=-1;
+    return 1;
+}
 #endif /* CONFIG_DVDNAV */
 
 static void adjust_sync_and_print_status(int between_frames, float timing_error)
@@ -3781,20 +3872,34 @@
 
 } // end if(mpctx->sh_video)
 
+ if (vo_spudec!=NULL && mpctx->sh_video
+     && !mpctx->spu_color_inited && colorspu)
+   init_spu_color();
+ 
 #ifdef CONFIG_DVDNAV
  if (mpctx->stream->type == STREAMTYPE_DVDNAV) {
-   nav_highlight_t hl;
-   mp_dvdnav_get_highlight (mpctx->stream, &hl);
-   osd_set_nav_box (hl.sx, hl.sy, hl.ex, hl.ey);
-   vo_osd_changed (OSDTYPE_DVDNAV);
-
+   if (mp_dvdnav_audio_has_changed(mpctx->stream,0))
+     if (mp_dvdnav_switch_audio())
+       mp_dvdnav_audio_has_changed(mpctx->stream,1);
+   
+   if (mp_dvdnav_spu_has_changed(mpctx->stream,1) || dvdsub_id==-2) {
+     mpctx->global_sub_size=mp_dvdnav_number_of_subs(mpctx->stream);
+     if (mpctx->d_sub) {
+       dvdsub_id=mp_dvdnav_get_current_spu(mpctx->stream);
+       if(dvdsub_id<0) dvdsub_id=-2;
+       mpctx->d_sub->id = dvdsub_id;
+     }
+   }
+   
    if (mp_dvdnav_stream_has_changed(mpctx->stream)) {
      double ar = -1.0;
+     mp_dvdnav_highlight_handle(1);
      if (stream_control (mpctx->demuxer->stream,
                          STREAM_CTRL_GET_ASPECT_RATIO, &ar)
          != STREAM_UNSUPPORTED)
        mpctx->sh_video->stream_aspect = ar;
-   }
+   } else
+     mp_dvdnav_highlight_handle(0);
  }
 #endif
 
diff -Naur MPlayer-export-2009-06-13.orig/spudec.c MPlayer-export-2009-06-13/spudec.c
--- MPlayer-export-2009-06-13.orig/spudec.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/spudec.c	2009-06-14 00:29:55.000000000 +0200
@@ -41,6 +41,15 @@
 float spu_gaussvar = 1.0;
 extern int sub_pos;
 
+/* color mode flags */
+typedef enum {
+  COLORSPU_Y   = 0, /* Grayscale */
+  COLORSPU_YUV = 1,
+  COLORSPU_YUY = 2,
+  COLORSPU_RGB = 3,
+  COLORSPU_BGR = 4,
+} colorspu_t;
+
 typedef struct packet_t packet_t;
 struct packet_t {
   unsigned char *packet;
@@ -76,22 +85,47 @@
   unsigned int start_pts, end_pts;
   unsigned int start_col, end_col;
   unsigned int start_row, end_row;
+  unsigned int start_coluv, end_coluv;
+  unsigned int start_rowuv, end_rowuv;
   unsigned int width, height, stride;
+  unsigned int widthuv, heightuv, strideuv, strideyuy;
   size_t image_size;		/* Size of the image buffer */
-  unsigned char *image;		/* Grayscale value */
+  size_t image_sizeuv;          /* Size of the imageuv buffer */
+  size_t image_sizeyuy;         /* Size of the imageyuy buffer */
+  unsigned char *image;		/* Grayscale value or Y value or RB value */
+  unsigned char *imageu;        /* U value or G value */
+  unsigned char *imagev;        /* V value or BR value */
+  unsigned char *imageyuy;      /* image yuy */
   unsigned char *aimage;	/* Alpha value */
+  unsigned char *aimageuv;      /* Alpha value to uv planes */
+  unsigned char *aimageyuy;     /* Alpha valur to yuy planes */
   unsigned int scaled_frame_width, scaled_frame_height;
   unsigned int scaled_start_col, scaled_start_row;
   unsigned int scaled_width, scaled_height, scaled_stride;
+  unsigned int scaled_frame_widthuv, scaled_frame_heightuv;
+  unsigned int scaled_start_coluv, scaled_start_rowuv;
+  unsigned int scaled_widthuv, scaled_heightuv, scaled_strideuv;
   size_t scaled_image_size;
+  size_t scaled_image_sizeuv;
   unsigned char *scaled_image;
   unsigned char *scaled_aimage;
+  unsigned char *scaled_imageu;
+  unsigned char *scaled_imagev;
+  unsigned char *scaled_aimageuv;
   int auto_palette; /* 1 if we lack a palette and must use an heuristic. */
   int font_start_level;  /* Darkest value used for the computed font */
   const vo_functions_t *hw_spu;
   int spu_changed;
   unsigned int forced_subs_only;     /* flag: 0=display all subtitle, !0 display only forced subtitles */
   unsigned int is_forced_sub;         /* true if current subtitle is a forced subtitle */
+  colorspu_t colorspu;          /* spu color mode */
+  uint32_t     dvdnav_palette;	/* dvdnav menu button palette */
+  unsigned int spu_sx;	/* dvdnav menu item box */
+  unsigned int spu_ex;
+  unsigned int spu_sy;
+  unsigned int spu_ey;
+  int dvdnav_menu;
+  packet_t *last_packet;
 } spudec_handle_t;
 
 static void spudec_queue_packet(spudec_handle_t *this, packet_t *packet)
@@ -176,6 +210,8 @@
   unsigned int first_y, last_y;
   unsigned char *image;
   unsigned char *aimage;
+  unsigned char *imageu;
+  unsigned char *imagev;
 
   if (this->stride == 0 || this->height == 0) {
     return;
@@ -211,12 +247,152 @@
   } else {
     mp_msg(MSGT_SPUDEC, MSGL_FATAL, "Fatal: update_spu: malloc requested %d bytes\n", 2 * this->stride * this->height);
   }
+//
+// Cut the sub to visible part UV planes
+//
+  switch (this->colorspu) {
+  case COLORSPU_YUV:
+  case COLORSPU_YUY:
+    for (fy = 0; fy < this->image_sizeuv && !this->aimageuv[fy]; fy++);
+    for (ly = this->strideuv * this->heightuv-1;
+      ly && !this->aimageuv[ly]; ly--);
+    first_y = fy / this->strideuv;
+    last_y = ly / this->strideuv;
+    this->start_rowuv += first_y;
+    // Some subtitles trigger this condition
+    if (last_y + 1 > first_y ) {
+      this->heightuv = last_y - first_y +1;
+    } else {
+      this->heightuv = 0;
+      this->image_sizeuv = 0;
+      return;
+    }
+    //  printf("new h %d new start %d (sz %d st %d)---\n\n", this->height, this->start_row, this->image_size, this->stride);
+    imageu = malloc(3 * this->strideuv * this->heightuv);
+    if(imageu){
+      this->image_sizeuv = this->strideuv * this->heightuv;
+      imagev = imageu + this->image_sizeuv;
+      aimage = imagev + this->image_sizeuv;
+      memcpy(imageu, this->imageu + this->strideuv * first_y,
+             this->image_sizeuv);
+      memcpy(imagev, this->imagev + this->strideuv * first_y,
+             this->image_sizeuv);
+      memcpy(aimage, this->aimageuv + this->strideuv * first_y,
+             this->image_sizeuv);
+      free(this->imageu);
+      this->imageu = imageu;
+      this->imagev = imagev;
+      this->aimageuv = aimage;
+    } else {
+      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+	    "Fatal: update_spu: malloc requested %d bytes\n",
+	    3 * this->strideuv * this->height);
+    }
+    break;
+  case COLORSPU_RGB:
+  case COLORSPU_BGR:
+    this->image_sizeuv = this->stride * this->height;
+    imageu = malloc(2 * this->stride * this->height);
+    if(imageu){
+      imagev = imageu + this->image_size;
+      memcpy(imageu, this->imageu + this->stride * first_y, this->image_size);
+      memcpy(imagev, this->imagev + this->stride * first_y, this->image_size);
+      free(this->imageu);
+      this->imageu = imageu;
+      this->imagev = imagev;
+      this->aimageuv = NULL;
+    } else {
+      mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+             "Fatal: update_spu: malloc requested %d bytes\n",
+             2 * this->stride * this->height);
+    }
+    break;
+  }
+}
+
+//
+// Fill to spu image buffer
+//	y : image col
+//	x : start pos in image row
+//	len : fill length in image row
+//	color : Y: (YUV,YUY,Y), Red: (RGB) or Blue: (BGR)
+//	coloru: U: (YUV,YUY), Green: (RGB,BGR)
+//	colorv: V: (YUV,YUY), Blue: (RGB) or Red (BGR)
+//	alpha: alpha channel
+static void spudec_process_fill(spudec_handle_t *this, int x, int y, int len,
+    unsigned char color, unsigned char coloru, unsigned char colorv,
+    unsigned char alpha)
+{
+  unsigned int corrx, corry, corrl;
+
+  if (this->stride-x-len<0) return;
+  if (len<0) return;
+  switch (this->colorspu) {
+  case COLORSPU_YUV:
+  case COLORSPU_YUY:
+    corry=y & 0x01;
+    corrx=x & 0x01;
+    corrl=len & 0x01;
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    memset(this->imageu + (y-corry)/2 * this->strideuv + (x+corrx)/2, coloru,
+           (len-corrl)/2);
+    memset(this->imagev + (y-corry)/2 * this->strideuv + (x+corrx)/2, colorv,
+           (len-corrl)/2);
+    memset(this->aimageuv + (y-corry)/2 * this->strideuv + (x+corrx)/2, alpha,
+           (len-corrl)/2);
+    break;
+  case COLORSPU_RGB:
+  case COLORSPU_BGR:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->imageu + y * this->stride + x, coloru, len);
+    memset(this->imagev + y * this->stride + x, colorv, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+  default:
+    memset(this->image + y * this->stride + x, color, len);
+    memset(this->aimage + y * this->stride + x, alpha, len);
+    break;
+  }
+}
+
+//
+// Convert yuv color to rgb color
+//
+void spu_yuv_to_rgb(unsigned int y,unsigned int u,unsigned int v,
+    unsigned int *r,unsigned int *g,unsigned int *b)
+{
+  int ty,tu,tv;
+  int tr,tg,tb;
+
+  ty=y;tv=u;tu=v;
+  tr = (298*(ty-16)+408*(tv-128))/256;
+  tg = (298*(ty-16)-100*(tu-128)-208*(tv-128))/256;
+  tb = (298*(ty-16)+516*(tu-128))/256;
+  if(tr>255) tr=255; if(tr<0) tr=0;
+  if(tg>255) tg=255; if(tg<0) tg=0;
+  if(tb>255) tb=255; if(tb<0) tb=0;
+  *r=tr; *g=tg; *b=tb;
+return;
 }
 
 static void spudec_process_data(spudec_handle_t *this, packet_t *packet)
 {
   unsigned int cmap[4], alpha[4];
+  unsigned int thpalette[4], thalpha[4];	/* dvdnav highlight menu palette */
+  unsigned int hcmap[4], halpha[4];		/* dvdnav highlight map */
+  unsigned int cmapu[4], cmapv[4];
+  unsigned int hcmapu[4], hcmapv[4];
+  unsigned int ty, tu, tv, tr, tg, tb;
   unsigned int i, x, y;
+  unsigned int control_start;
+  unsigned int current_nibble[2];
+  int deinterlace_oddness;
+
+  control_start = packet->control_start;
+  current_nibble[0]=packet->current_nibble[0];
+  current_nibble[1]=packet->current_nibble[1];
+  deinterlace_oddness=packet->deinterlace_oddness;
 
   this->scaled_frame_width = 0;
   this->scaled_frame_height = 0;
@@ -227,7 +403,136 @@
   this->height = packet->height;
   this->width = packet->width;
   this->stride = packet->stride;
+  this->strideuv = packet->stride;
+
+  this->start_coluv = packet->start_col/2;
+  this->end_coluv = packet->end_col/2;
+  this->start_rowuv = packet->start_row/2;
+  this->end_rowuv = packet->end_row/2;
+  this->heightuv = packet->height/2+1;
+  this->widthuv = packet->width/2+1;
+
   for (i = 0; i < 4; ++i) {
+    thalpha[i]=(this->dvdnav_palette >> ((3-i)*4)) & 0x0f;
+    thpalette[i]=(this->dvdnav_palette >> (16+(3-i)*4)) & 0x0f;
+    halpha[i] = mkalpha(thalpha[i]);
+    hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);
+    alpha[i] = mkalpha(packet->alpha[i]);
+    if (this->custom && (this->cuspal[i] >> 31) != 0)
+      alpha[i] = 0;
+
+    switch(this->colorspu) {
+    case COLORSPU_YUV:
+    case COLORSPU_YUY:
+      if (alpha[i] == 0)
+        cmap[i] = cmapu[i] = cmapv[i] = 0;
+      else if (this->custom){
+        cmap[i] = ((this->cuspal[i] >> 16) & 0xff);
+        cmapu[i] = ((this->cuspal[i] >> 8) & 0xff);
+        cmapv[i] = ((this->cuspal[i] >> 0) & 0xff);
+        if (cmap[i] + alpha[i] > 255)
+	  cmap[i] = 256 - alpha[i];
+      } else {
+        cmap[i] = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);
+        cmapu[i] = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);
+        cmapv[i] = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);
+        if (cmap[i] + alpha[i] > 255)
+	  cmap[i] = 256 - alpha[i];
+      }
+      if (halpha[i] == 0) {hcmap[i] = 0; hcmapu[i] = 0; hcmapv[i] = 0;} else {
+        if (hcmap[i] + halpha[i] > 255)
+          hcmap[i] = 256 - halpha[i];
+        hcmap[i] = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+	hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+        hcmapu[i] = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+	hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+        hcmapv[i] = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+      }
+      break;
+    case COLORSPU_RGB:
+      if (alpha[i] == 0)
+        cmap[i] = cmapu[i] = cmapv[i] = 0;
+      else if (this->custom){
+        ty = ((this->cuspal[i] >> 16) & 0xff);
+        tu = ((this->cuspal[i] >> 8) & 0xff);
+        tv = ((this->cuspal[i] >> 0) & 0xff);
+        spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+        cmap[i] = tr;							// Red
+        cmapu[i] = tg;							// Green
+        cmapv[i] = tb;							// Blue
+        cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+        cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+        cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+      } else {
+        ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);
+        tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);
+        tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);
+	spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	cmap[i] = tr;							// Red
+	cmapu[i] = tg;							// Green
+	cmapv[i] = tb;							// Blue
+	cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+      }
+      if (halpha[i] == 0) {hcmap[i] = 0; hcmapu[i] = 0; hcmapv[i] = 0;} else {
+        if (hcmap[i] + halpha[i] > 255)
+	  hcmap[i] = 256 - halpha[i];
+        ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+        tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+        tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	hcmap[i] = tr;
+	hcmapu[i] = tg;
+	hcmapv[i] = tb;
+	hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+      }
+      break;
+    case COLORSPU_BGR:
+      if (alpha[i] == 0)
+        cmap[i] = cmapu[i] = cmapv[i] = 0;
+      else if (this->custom){
+        ty = ((this->cuspal[i] >> 16) & 0xff);
+        tu = ((this->cuspal[i] >> 8) & 0xff);
+        tv = ((this->cuspal[i] >> 0) & 0xff);
+	spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+        cmap[i] = tb;							// Red
+	cmapu[i] = tg;							// Green
+        cmapv[i] = tr;							// Blue
+        cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+        cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+        cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+      } else {
+        ty = ((this->global_palette[packet->palette[i]] >> 16) & 0xff);
+        tu = ((this->global_palette[packet->palette[i]] >> 8) & 0xff);
+        tv = ((this->global_palette[packet->palette[i]] >> 0) & 0xff);
+        spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+        cmap[i] = tb;							// Red
+        cmapu[i] = tg;							// Green
+        cmapv[i] = tr;							// Blue
+	cmap[i] = ((0x100-alpha[i])*cmap[i]) >> 8;
+	cmapu[i] = ((0x100-alpha[i])*cmapu[i]) >> 8;
+	cmapv[i] = ((0x100-alpha[i])*cmapv[i]) >> 8;
+      }
+      if (halpha[i] == 0) {hcmap[i] = 0; hcmapu[i] = 0; hcmapv[i] = 0;} else {
+        if (hcmap[i] + halpha[i] > 255)
+	  hcmap[i] = 256 - halpha[i];
+        ty = ((this->global_palette[thpalette[i]] >> 16) & 0xff);	// Y
+        tu = ((this->global_palette[thpalette[i]] >> 8) & 0xff);	// u
+        tv = ((this->global_palette[thpalette[i]] >> 0) & 0xff);	// v
+	spu_yuv_to_rgb(ty,tu,tv,&tr,&tg,&tb);
+	hcmap[i] = tb;
+	hcmapu[i] = tg;
+	hcmapv[i] = tr;
+	hcmap[i] = ((0x100-halpha[i])*hcmap[i]) >> 8;
+	hcmapu[i] = ((0x100-halpha[i])*hcmapu[i]) >> 8;
+	hcmapv[i] = ((0x100-halpha[i])*hcmapv[i]) >> 8;
+      }
+      break;
+    default:
     alpha[i] = mkalpha(packet->alpha[i]);
     if (this->custom && (this->cuspal[i] >> 31) != 0)
       alpha[i] = 0;
@@ -244,6 +549,7 @@
 	cmap[i] = 256 - alpha[i];
     }
   }
+  }
 
   if (this->image_size < this->stride * this->height) {
     if (this->image != NULL) {
@@ -267,6 +573,52 @@
       memset(this->image + y * this->stride + this->width, 0, this->stride - this->width);
     }
 
+  if (this->imageyuy) {
+    free(this->imageyuy);
+    this->imageyuy=NULL;
+    this->aimageyuy=NULL;
+  }
+  switch(this->colorspu) {
+  case COLORSPU_YUY:
+  case COLORSPU_YUV:
+    if (this->image_sizeuv < this->strideuv * this->heightuv) {
+      if (this->imageu != NULL) {
+        free(this->imageu);
+        this->image_sizeuv = 0;
+      }
+      this->imageu = malloc(3 * this->strideuv * this->heightuv);
+      if (this->imageu) {
+        this->image_sizeuv = this->strideuv * this->heightuv;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+      }
+    }
+    if (this->imageu == NULL) return;
+    memset(this->imageu,0,3 * this->strideuv * this->heightuv);
+    break;
+  case COLORSPU_RGB:
+  case COLORSPU_BGR:
+    if (this->image_sizeuv < this->stride * this->height) {
+      if (this->imageu != NULL) {
+	free(this->imageu);
+	this->image_sizeuv = 0;
+      }
+      this->imageu = malloc(2 * this->stride * this->height);
+      if (this->imageu) {
+        this->image_sizeuv = this->stride * this->height;
+        this->imagev = this->imageu + this->image_sizeuv;
+        this->aimageuv = this->imagev + this->image_sizeuv;
+      }
+    }
+    if (this->imageu == NULL) return;
+    memset(this->imageu,0,2 * this->stride * this->height);
+    break;
+  default:
+    if (this->imageu) free(this->imageu);
+    this->imageu=NULL;
+    this->image_sizeuv=0;
+  }
+
   i = packet->current_nibble[1];
   x = 0;
   y = 0;
@@ -292,8 +644,71 @@
     if (len > this->width - x || len == 0)
       len = this->width - x;
     /* FIXME have to use palette and alpha map*/
+    switch(this->colorspu) {
+    case COLORSPU_YUV:
+    case COLORSPU_YUY:
+    case COLORSPU_RGB:
+    case COLORSPU_BGR:
+      if (!this->spu_sx && !this->spu_sy &&!this->spu_ex && !this->spu_ey) {
+	spudec_process_fill(this, x, y, len,
+                            cmap[color], cmapu[color],
+                            cmapv[color], alpha[color]);
+      } else {
+        if (this->start_row+y>=this->spu_sy &&
+	    this->start_row+y<=this->spu_ey) {
+          if (this->start_col+x>=this->spu_sx &&
+              this->start_col+x+len<=this->spu_ex)
+            spudec_process_fill(this, x, y, len,
+		                hcmap[color], hcmapu[color],
+                                hcmapv[color], halpha[color]);
+	  else if(this->start_col+x<this->spu_sx &&
+		this->start_col+x+len>this->spu_sx &&
+		this->start_col+x+len<=this->spu_ex) {
+            spudec_process_fill(this, x, y, this->spu_sx-this->start_col-x,
+                                cmap[color], cmapu[color],
+                                cmapv[color], alpha[color]);
+            spudec_process_fill(this, this->spu_sx-this->start_col, y,
+                                len+this->start_col+x-this->spu_sx,
+                                hcmap[color], hcmapu[color],
+                                hcmapv[color], halpha[color]);
+	  } else if(this->start_col+x<this->spu_sx &&
+		this->start_col+x+len>this->spu_sx &&
+		this->start_col+x+len>this->spu_ex) {
+	    spudec_process_fill(this, x, y, this->spu_sx-this->start_col-x,
+                                cmap[color], cmapu[color],
+                                cmapv[color], alpha[color]);
+            spudec_process_fill(this, this->spu_sx-this->start_col, y,
+                                this->spu_ex-this->spu_sx,
+                                hcmap[color], hcmapu[color],
+                                hcmapv[color], halpha[color]);
+            spudec_process_fill(this, this->spu_ex-this->start_col, y,
+                                x+len+this->start_col-this->spu_ex,
+                                cmap[color], cmapu[color], 
+                                cmapv[color], alpha[color]);
+	  } else if(this->start_col+x>=this->spu_sx &&
+		this->start_col+x<this->spu_ex &&
+		this->start_col+x+len>this->spu_ex) {
+            spudec_process_fill(this, x, y, this->spu_ex-this->start_col-x,
+                                hcmap[color], hcmapu[color],
+                                hcmapv[color], halpha[color]);
+            spudec_process_fill(this, this->spu_ex-this->start_col, y,
+                                len+this->start_col+x-this->spu_ex,
+                                cmap[color], cmapu[color],
+                                cmapv[color], alpha[color]);
+	  } else
+	    spudec_process_fill(this, x, y, len,
+                                cmap[color], cmapu[color],
+                                cmapv[color], alpha[color]);
+	} else
+	  spudec_process_fill(this, x, y, len,
+                              cmap[color], cmapu[color],
+                              cmapv[color], alpha[color]);
+      }
+      break;
+    default:
     memset(this->image + y * this->stride + x, cmap[color], len);
     memset(this->aimage + y * this->stride + x, alpha[color], len);
+    }
     x += len;
     if (x >= this->width) {
       next_line(packet);
@@ -301,6 +716,10 @@
       ++y;
     }
   }
+  packet->control_start = control_start;
+  packet->current_nibble[0]=current_nibble[0];
+  packet->current_nibble[1]=current_nibble[1];
+  packet->deinterlace_oddness=deinterlace_oddness;
   spudec_cut_image(this);
 }
 
@@ -505,6 +924,9 @@
 void spudec_assemble(void *this, unsigned char *packet, unsigned int len, int pts100)
 {
   spudec_handle_t *spu = (spudec_handle_t*)this;
+
+  if(spu->dvdnav_menu)
+    pts100=0;
 //  spudec_heartbeat(this, pts100);
   if (len < 2) {
       mp_msg(MSGT_SPUDEC,MSGL_WARN,"SPUasm: packet too short\n");
@@ -601,9 +1023,15 @@
     packet_t *packet = spudec_dequeue_packet(spu);
     spu->start_pts = packet->start_pts;
     spu->end_pts = packet->end_pts;
-    if (spu->auto_palette)
+    if (spu->auto_palette && spu->colorspu==COLORSPU_Y)
       compute_palette(spu, packet);
     spudec_process_data(spu, packet);
+    if (spu->dvdnav_menu) {
+      if(spu->last_packet) {
+        spudec_free_packet(spu->last_packet);
+      }
+      spu->last_packet=packet;
+    } else
     spudec_free_packet(packet);
     spu->spu_changed = 1;
   }
@@ -611,7 +1039,12 @@
 
 int spudec_visible(void *this){
     spudec_handle_t *spu = (spudec_handle_t *)this;
-    int ret=(spu->start_pts <= spu->now_pts &&
+    int ret;
+    if (spu->dvdnav_menu && spu->height > 0) {
+      if(spu->height>0) spu->end_pts=UINT_MAX;
+      return 1;
+    }
+    ret=(spu->start_pts <= spu->now_pts &&
 	     spu->now_pts < spu->end_pts &&
 	     spu->height > 0);
 //    printf("spu visible: %d  \n",ret);
@@ -626,13 +1059,106 @@
   }
 }
 
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+//
+// Convert Yuv image to YuY image
+//
+void spudec_create_yuy(void *this, int spu_scaled)
+{
+  spudec_handle_t *spu = this;
+  unsigned char *dptr;
+  unsigned char *daptr;
+  unsigned char *sptry;
+  unsigned char *sptru;
+  unsigned char *sptrv;
+  unsigned char *saptr;
+  unsigned char *saptruv;
+  int y,x;
+  
+  if (spu_scaled) {
+    spu->strideyuy=spu->scaled_stride*2;
+    spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+    memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+    spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->scaled_height;
+    for(y=0;y<spu->scaled_height;y++) {
+      dptr=spu->imageyuy+y*spu->strideyuy;
+      daptr=spu->aimageyuy+y*spu->strideyuy;
+      sptry=spu->scaled_image+y*spu->scaled_stride;
+      sptru=spu->scaled_imageu+y/2*spu->scaled_strideuv;
+      sptrv=spu->scaled_imagev+y/2*spu->scaled_strideuv;
+      saptr=spu->scaled_aimage+y*spu->scaled_stride;
+      saptruv=spu->scaled_aimageuv+y/2*spu->scaled_strideuv;
+      for(x=0;x<spu->scaled_widthuv-1;x++) {
+        *dptr++=*sptry++;
+        *dptr++=*sptrv++;
+        *dptr++=*sptry++;
+        *dptr++=*sptru++;
+        *daptr++=*saptr++;
+        *daptr++=*saptruv;
+        *daptr++=*saptr++;
+        *daptr++=*saptruv++;
+      }
+    }
+  } else {
+    spu->strideyuy=spu->stride*2;
+    spu->imageyuy=malloc(spu->strideyuy*(spu->height+2)*2);
+    memset(spu->imageyuy,0,spu->strideyuy*(spu->height+2)*2);
+    spu->aimageyuy=spu->imageyuy+spu->strideyuy*spu->height;
+    for(y=0;y<spu->height;y++) {
+      dptr=spu->imageyuy+y*spu->strideyuy;
+      daptr=spu->aimageyuy+y*spu->strideyuy;
+      sptry=spu->image+y*spu->stride;
+      sptru=spu->imageu+y/2*spu->strideuv;
+      sptrv=spu->imagev+y/2*spu->strideuv;
+      saptr=spu->aimage+y*spu->stride;
+      saptruv=spu->aimageuv+y/2*spu->strideuv;
+      for(x=0;x<spu->widthuv-1;x++) {
+        *dptr++=*sptry++;
+        *dptr++=*sptrv++;
+        *dptr++=*sptry++;
+        *dptr++=*sptru++;
+        *daptr++=*saptr++;
+        *daptr++=*saptruv;
+        *daptr++=*saptr++;
+        *daptr++=*saptruv++;
+      } 
+    }
+  }
+}
+
+
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
 {
     spudec_handle_t *spu = (spudec_handle_t *)this;
     if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts && spu->image)
     {
+	switch(spu->colorspu) {
+	case COLORSPU_YUY:
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy)
+	    draw_alpha(spu->start_col, spu->start_row, spu->width*2, spu->height/2,
+		   DEST_PLANES_YUYV, spu->imageyuy, spu->aimageyuy, spu->strideyuy);
+	  break;
+	case COLORSPU_YUV:
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_Y, spu->image, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_coluv, spu->start_rowuv, spu->widthuv, spu->heightuv,
+		   DEST_PLANES_U, spu->imageu, spu->aimageuv, spu->strideuv);
+	  draw_alpha(spu->start_coluv, spu->start_rowuv, spu->widthuv, spu->heightuv,
+		   DEST_PLANES_V, spu->imagev, spu->aimageuv, spu->strideuv);
+	  break;
+	case COLORSPU_RGB:
+	case COLORSPU_BGR:
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_BR, spu->imagev, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_G, spu->imageu, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_RB, spu->image, spu->aimage, spu->stride);
+	  break;
+	default:
 	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
-		   spu->image, spu->aimage, spu->stride);
+		   DEST_PLANES_Y, spu->image, spu->aimage, spu->stride);
+	}
 	spu->spu_changed = 0;
     }
 }
@@ -744,8 +1270,8 @@
   }
 }
 
-void sws_spu_image(unsigned char *d1, unsigned char *d2, int dw, int dh, int ds,
-	unsigned char *s1, unsigned char *s2, int sw, int sh, int ss)
+void sws_spu_image(unsigned char *d1, unsigned char *d2, unsigned char *d3, unsigned char *d4, int dw, int dh, int ds,
+	unsigned char *s1, unsigned char *s2, unsigned char *s3, unsigned char *s4, int sw, int sh, int ss)
 {
 	struct SwsContext *ctx;
 	static SwsFilter filter;
@@ -766,135 +1292,114 @@
 	sws_scale(ctx,&s1,&ss,0,sh,&d1,&ds);
 	for (i=ss*sh-1; i>=0; i--) if (!s2[i]) s2[i] = 255; //else s2[i] = 1;
 	sws_scale(ctx,&s2,&ss,0,sh,&d2,&ds);
+        if(s3)
+ 	  sws_scale(ctx,&s3,&ss,0,sh,&d3,&ds);
+        if(s4)
+ 	  sws_scale(ctx,&s4,&ss,0,sh,&d4,&ds);
 	for (i=ds*dh-1; i>=0; i--) if (d2[i]==0) d2[i] = 1; else if (d2[i]==255) d2[i] = 0;
 	sws_freeContext(ctx);
 }
 
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
-{
-  spudec_handle_t *spu = (spudec_handle_t *)me;
-  scale_pixel *table_x;
-  scale_pixel *table_y;
-
-  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
-
-    // check if only forced subtitles are requested
-    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){
-	return;
-    }
-
-    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 || spu->orig_frame_height == 0
-	|| (spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
-      if (spu->image)
-      {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
-		   spu->image, spu->aimage, spu->stride);
-	spu->spu_changed = 0;
+void spu_scaled_none(unsigned int dxs, unsigned int dys,
+                     int src_stride,
+                     int dst_width, int dst_height, int dst_stride,
+                     unsigned int scalex, unsigned int scaley,
+                     unsigned char *src_y, unsigned char *src_a,
+                     unsigned char *src_u, unsigned char *src_v,
+                     unsigned char *dst_y, unsigned char *dst_a,
+                     unsigned char *dst_u, unsigned char *dst_v)
+{
+  unsigned int x, y;
+  
+  /* no antialiasing */
+  for (y = 0; y < dst_height; ++y) {
+    int unscaled_y = y * 0x100 / scaley;
+    int strides = src_stride * unscaled_y;
+    int scaled_strides = dst_stride * y;
+    for (x = 0; x < dst_width; ++x) {
+      int unscaled_x = x * 0x100 / scalex;
+      dst_y[scaled_strides + x] = src_y[strides + unscaled_x];
+      dst_a[scaled_strides + x] = src_a[strides + unscaled_x];
+      if(src_u)
+        dst_u[scaled_strides + x] = src_u[strides + unscaled_x];
+      if(src_v)
+        dst_v[scaled_strides + x] = src_v[strides + unscaled_x];
+    }
+  }
+}
+ 
+void spu_scaled_approx(int width, int height, unsigned int dxs, unsigned int dys,
+                       int src_width, int src_height, int src_stride,
+                       int dst_width, int dst_height, int dst_stride,
+                       unsigned int scalex, unsigned int scaley,
+                       unsigned char *src_y, unsigned char *src_a,
+                       unsigned char *src_u, unsigned char *src_v,
+                       unsigned char *dst_y, unsigned char *dst_a,
+                       unsigned char *dst_u, unsigned char *dst_v)
+{
+  unsigned int x, y;
+  
+  /* Intermediate antialiasing. */
+  for (y = 0; y < dst_height; ++y) {
+    const unsigned int unscaled_top = y * src_height / dys;
+    unsigned int unscaled_bottom = (y + 1) * src_height / dys;
+    if (unscaled_bottom >= height)
+      unscaled_bottom = height - 1;
+    for (x = 0; x < dst_width; ++x) {
+      const unsigned int unscaled_left = x * src_width / dxs;
+      unsigned int unscaled_right = (x + 1) * src_width / dxs;
+      unsigned int color = 0;
+      unsigned int coloru = 0;
+      unsigned int colorv = 0;
+      unsigned int alpha = 0;
+      unsigned int walkx, walky;
+      unsigned int base, tmp;
+      if (unscaled_right >= width)
+        unscaled_right = width - 1;
+      for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
+        for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx) {
+          base = walky * src_stride + walkx;
+          tmp = canon_alpha(src_a[base]);
+          alpha += tmp;
+          color += tmp * src_y[base];
+          if(src_u)
+            coloru += tmp * src_u[base];
+          if(src_v)
+            colorv += tmp * src_v[base];
+        }
+      base = y * dst_stride + x;
+      dst_y[base] = alpha ? color / alpha : 0;
+      if(src_u)
+        dst_u[base] = alpha ? coloru / alpha : 0;
+      if(src_v)
+        dst_v[base] = alpha ? colorv / alpha : 0;
+      dst_a[base] =
+        alpha * (1 + unscaled_bottom - unscaled_top) * (1 + unscaled_right - unscaled_left);
+      /* spu->scaled_aimage[base] =
+         alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
+      if (dst_a[base]) {
+        dst_a[base] = 256 - dst_a[base];
+        if (dst_a[base] + dst_y[base] > 255)
+          dst_y[base] = 256 - dst_a[base];
+        if (src_u && dst_a[base] + dst_u[base] > 255)
+          dst_u[base] = 256 - dst_a[base];
+        if (src_v && dst_a[base] + dst_v[base] > 255)
+          dst_v[base] = 256 - dst_a[base];
       }
     }
-    else {
-      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys) {	/* Resizing is needed */
-	/* scaled_x = scalex * x / 0x100
-	   scaled_y = scaley * y / 0x100
-	   order of operations is important because of rounding. */
-	unsigned int scalex = 0x100 * dxs / spu->orig_frame_width;
-	unsigned int scaley = 0x100 * dys / spu->orig_frame_height;
-	spu->scaled_start_col = spu->start_col * scalex / 0x100;
-	spu->scaled_start_row = spu->start_row * scaley / 0x100;
-	spu->scaled_width = spu->width * scalex / 0x100;
-	spu->scaled_height = spu->height * scaley / 0x100;
-	/* Kludge: draw_alpha needs width multiple of 8 */
-	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
-	if (spu->scaled_image_size < spu->scaled_stride * spu->scaled_height) {
-	  if (spu->scaled_image) {
-	    free(spu->scaled_image);
-	    spu->scaled_image_size = 0;
-	  }
-	  spu->scaled_image = malloc(2 * spu->scaled_stride * spu->scaled_height);
-	  if (spu->scaled_image) {
-	    spu->scaled_image_size = spu->scaled_stride * spu->scaled_height;
-	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
-	  }
-	}
-	if (spu->scaled_image) {
-	  unsigned int x, y;
-	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
-	    goto nothing_to_do;
-	  }
-	  switch(spu_aamode&15) {
-	  case 4:
-	  sws_spu_image(spu->scaled_image, spu->scaled_aimage,
-		  spu->scaled_width, spu->scaled_height, spu->scaled_stride,
-		  spu->image, spu->aimage, spu->width, spu->height, spu->stride);
-	  break;
-	  case 3:
-	  table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
-	  table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
-	  if (!table_x || !table_y) {
-	    mp_msg(MSGT_SPUDEC, MSGL_FATAL, "Fatal: spudec_draw_scaled: calloc failed\n");
-	  }
-	  scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
-	  scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
-	  for (y = 0; y < spu->scaled_height; y++)
-	    for (x = 0; x < spu->scaled_width; x++)
-	      scale_image(x, y, table_x, table_y, spu);
-	  free(table_x);
-	  free(table_y);
-	  break;
-	  case 0:
-	  /* no antialiasing */
-	  for (y = 0; y < spu->scaled_height; ++y) {
-	    int unscaled_y = y * 0x100 / scaley;
-	    int strides = spu->stride * unscaled_y;
-	    int scaled_strides = spu->scaled_stride * y;
-	    for (x = 0; x < spu->scaled_width; ++x) {
-	      int unscaled_x = x * 0x100 / scalex;
-	      spu->scaled_image[scaled_strides + x] = spu->image[strides + unscaled_x];
-	      spu->scaled_aimage[scaled_strides + x] = spu->aimage[strides + unscaled_x];
-	    }
-	  }
-	  break;
-	  case 1:
-	  {
-	    /* Intermediate antialiasing. */
-	    for (y = 0; y < spu->scaled_height; ++y) {
-	      const unsigned int unscaled_top = y * spu->orig_frame_height / dys;
-	      unsigned int unscaled_bottom = (y + 1) * spu->orig_frame_height / dys;
-	      if (unscaled_bottom >= spu->height)
-		unscaled_bottom = spu->height - 1;
-	      for (x = 0; x < spu->scaled_width; ++x) {
-		const unsigned int unscaled_left = x * spu->orig_frame_width / dxs;
-		unsigned int unscaled_right = (x + 1) * spu->orig_frame_width / dxs;
-		unsigned int color = 0;
-		unsigned int alpha = 0;
-		unsigned int walkx, walky;
-		unsigned int base, tmp;
-		if (unscaled_right >= spu->width)
-		  unscaled_right = spu->width - 1;
-		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
-		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx) {
-		    base = walky * spu->stride + walkx;
-		    tmp = canon_alpha(spu->aimage[base]);
-		    alpha += tmp;
-		    color += tmp * spu->image[base];
-		  }
-		base = y * spu->scaled_stride + x;
-		spu->scaled_image[base] = alpha ? color / alpha : 0;
-		spu->scaled_aimage[base] =
-		  alpha * (1 + unscaled_bottom - unscaled_top) * (1 + unscaled_right - unscaled_left);
-		/* spu->scaled_aimage[base] =
-		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
-		if (spu->scaled_aimage[base]) {
-		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
-		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
-		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
-		}
-	      }
-	    }
-	  }
-	  break;
-	  case 2:
-	  {
+  }
+}
+ 
+void spu_scaled_full(int src_stride,
+                     int dst_width, int dst_height, int dst_stride,
+                     unsigned int scalex, unsigned int scaley,
+                     unsigned char *src_y, unsigned char *src_a,
+                     unsigned char *src_u, unsigned char *src_v,
+                     unsigned char *dst_y, unsigned char *dst_a,
+                     unsigned char *dst_u, unsigned char *dst_v)
+{
+  unsigned int x, y;
+
 	    /* Best antialiasing.  Very slow. */
 	    /* Any pixel (x, y) represents pixels from the original
 	       rectangular region comprised between the columns
@@ -936,7 +1441,7 @@
 	       unscaled_x_right. */
 	    const double inv_scalex = (double) 0x100 / scalex;
 	    const double inv_scaley = (double) 0x100 / scaley;
-	    for (y = 0; y < spu->scaled_height; ++y) {
+	    for (y = 0; y < dst_height; ++y) {
 	      const double unscaled_y = y * inv_scaley;
 	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
 	      const unsigned int top_low_row = FFMIN(unscaled_y_bottom, unscaled_y + 1.0);
@@ -947,7 +1452,7 @@
 	      const double bottom = unscaled_y_bottom > top_low_row
 		? unscaled_y_bottom - floor(unscaled_y_bottom)
 		: 0.0;
-	      for (x = 0; x < spu->scaled_width; ++x) {
+	      for (x = 0; x < dst_width; ++x) {
 		const double unscaled_x = x * inv_scalex;
 		const double unscaled_x_right = unscaled_x + inv_scalex;
 		const unsigned int left_right_column = FFMIN(unscaled_x_right, unscaled_x + 1.0);
@@ -959,6 +1464,8 @@
 		  ? unscaled_x_right - floor(unscaled_x_right)
 		  : 0.0;
 		double color = 0.0;
+		double coloru = 0.0;
+		double colorv = 0.0;
 		double alpha = 0.0;
 		double tmp;
 		unsigned int base;
@@ -970,35 +1477,51 @@
 		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
 		*/
 		/* 1: top left part */
-		base = spu->stride * (unsigned int) unscaled_y;
-		tmp = left * top * canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		base = src_stride * (unsigned int) unscaled_y;
+		tmp = left * top * canon_alpha(src_a[base + (unsigned int) unscaled_x]);
 		alpha += tmp;
-		color += tmp * spu->image[base + (unsigned int) unscaled_x];
+		color += tmp * src_y[base + (unsigned int) unscaled_x];
+	        if(src_u)
+		  coloru += tmp * src_u[base + (unsigned int) unscaled_x];
+	        if(src_v)
+		  colorv += tmp * src_v[base + (unsigned int) unscaled_x];
 		/* 2: top center part */
 		if (width > 0) {
 		  unsigned int walkx;
 		  for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		    base = spu->stride * (unsigned int) unscaled_y + walkx;
-		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    base = src_stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(src_a[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * src_y[base];
+        	    if(src_u)
+		      coloru += tmp * src_u[base];
+        	    if(src_v)
+		      colorv += tmp * src_v[base];
 		  }
 		}
 		/* 3: top right part */
 		if (right > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y + (unsigned int) unscaled_x_right;
-		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  base = src_stride * (unsigned int) unscaled_y + (unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(src_a[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * src_y[base];
+        	  if(src_u)
+		    coloru += tmp * src_u[base];
+        	  if(src_u)
+		    colorv += tmp * src_v[base];
 		}
 		/* 4: center left part */
 		if (height > 0) {
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
-		    base = spu->stride * walky + (unsigned int) unscaled_x;
-		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    base = src_stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(src_a[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * src_y[base];
+        	    if(src_u)
+		      coloru += tmp * src_u[base];
+        	    if(src_u)
+		      colorv += tmp * src_v[base];
 		  }
 		}
 		/* 5: center part */
@@ -1006,11 +1529,15 @@
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
 		    unsigned int walkx;
-		    base = spu->stride * walky;
+		    base = src_stride * walky;
 		    for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(src_a[base + walkx]);
 		      alpha += tmp;
-		      color += tmp * spu->image[base + walkx];
+		      color += tmp * src_y[base + walkx];
+        	      if(src_u)
+	        	coloru += tmp * src_u[base];
+	              if(src_u)
+		        colorv += tmp * src_v[base];
 		    }
 		  }
 		}
@@ -1018,50 +1545,300 @@
 		if (right > 0.0 && height > 0) {
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
-		    base = spu->stride * walky + (unsigned int) unscaled_x_right;
-		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    base = src_stride * walky + (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(src_a[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * src_y[base];
+        	    if(src_u)
+		      coloru += tmp * src_u[base];
+        	    if(src_u)
+		      colorv += tmp * src_v[base];
 		  }
 		}
 		/* 7: bottom left part */
 		if (bottom > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x;
-		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  base = src_stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(src_a[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * src_y[base];
+        	  if(src_u)
+		    coloru += tmp * src_u[base];
+        	  if(src_u)
+		    colorv += tmp * src_v[base];
 		}
 		/* 8: bottom center part */
 		if (width > 0 && bottom > 0.0) {
 		  unsigned int walkx;
-		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  base = src_stride * (unsigned int) unscaled_y_bottom;
 		  for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimage[base + walkx]);
+		    tmp = /* 1.0 * */ bottom * canon_alpha(src_a[base + walkx]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base + walkx];
+		    color += tmp * src_y[base + walkx];
+        	    if(src_u)
+		      coloru += tmp * src_u[base];
+        	    if(src_u)
+		      colorv += tmp * src_v[base];
 		  }
 		}
 		/* 9: bottom right part */
 		if (right > 0.0 && bottom > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x_right;
-		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  base = src_stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(src_a[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * src_y[base];
+        	  if(src_u)
+		    coloru += tmp * src_u[base];
+        	  if(src_u)
+		    colorv += tmp * src_v[base];
 		}
 		/* Finally mix these transparency and brightness information suitably */
-		base = spu->scaled_stride * y + x;
-		spu->scaled_image[base] = alpha > 0 ? color / alpha : 0;
-		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
-		if (spu->scaled_aimage[base]) {
-		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
-		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
-		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		base = dst_stride * y + x;
+		dst_y[base] = alpha > 0 ? color / alpha : 0;
+	        if(src_u)
+		  dst_u[base] = alpha > 0 ? coloru / alpha : 0;
+	        if(src_v)
+		  dst_v[base] = alpha > 0 ? colorv / alpha : 0;
+		dst_a[base] = alpha * scalex * scaley / 0x10000;
+		if (dst_a[base]) {
+		  dst_a[base] = 256 - dst_a[base];
+		  if (dst_a[base] + dst_y[base] > 255)
+		    dst_y[base] = 256 - dst_a[base];
+		  if (src_u && dst_a[base] + dst_u[base] > 255)
+		    dst_u[base] = 256 - dst_a[base];
+		  if (src_v && dst_a[base] + dst_v[base] > 255)
+		    dst_v[base] = 256 - dst_a[base];
 		}
 	      }
 	    }
 	  }
+
+static void spu_scaled_bilinear(spudec_handle_t *spu)
+{
+  unsigned int x, y;
+  scale_pixel *table_x;
+  scale_pixel *table_y;
+
+  table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
+  table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+  if (!table_x || !table_y) {
+    mp_msg(MSGT_SPUDEC, MSGL_FATAL,
+           "Fatal: spu_scaled_bilinear: calloc failed\n");
+  }
+  scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
+  scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
+  for (y = 0; y < spu->scaled_height; y++)
+    for (x = 0; x < spu->scaled_width; x++)
+      scale_image(x, y, table_x, table_y, spu);
+  free(table_x);
+  free(table_y);
+}
+
+
+void spu_scaled_sws(int width, int height, unsigned int dxs, unsigned int dys,
+                    int src_width, int src_height, int src_stride,
+                    int dst_width, int dst_height, int dst_stride,
+                    unsigned int scalex, unsigned int scaley,
+                    unsigned char *src_y, unsigned char *src_a,
+                    unsigned char *src_u, unsigned char *src_v,
+                    unsigned char *dst_y, unsigned char *dst_a,
+                    unsigned char *dst_u, unsigned char *dst_v)
+{
+  sws_spu_image(dst_y, dst_a, dst_u, dst_y,
+                dst_width, dst_height, dst_stride,
+                src_y, src_a, src_u, src_y, width, height, src_stride);
+}
+
+void aa_scaler(spudec_handle_t *spu,
+               int aamode, int width, int height, int dxs, int dys,
+               int src_width, int src_height, int src_stride,
+               int dst_width, int dst_height, int dst_stride,
+               unsigned int scalex, unsigned int scaley,
+               unsigned char *src_y, unsigned char *src_a,
+               unsigned char *src_u, unsigned char *src_v,
+               unsigned char *dst_y, unsigned char *dst_a,
+               unsigned char *dst_u, unsigned char *dst_v)
+{
+switch(aamode&15) {
+  case 4:
+    spu_scaled_sws(width, height, dxs, dys,
+                   src_width, src_height, src_stride,
+                   dst_width, dst_height, dst_stride,
+                   scalex,scaley,
+                   src_y, src_a, src_u, src_v,
+                   dst_y, dst_a, dst_u, dst_v);
+    break;
+  case 3:
+    spu_scaled_bilinear(spu);
+    break;
+  case 0:
+    spu_scaled_none(dxs, dys,
+                    src_stride,
+                    dst_width, dst_height, dst_stride,
+                    scalex,scaley,
+                    src_y, src_a, src_u, src_v,
+                    dst_y, dst_a, dst_u, dst_v);
+    break;
+  case 1:
+    spu_scaled_approx(width, height, dxs, dys,
+                      src_width, src_height, src_stride,
+                      dst_width, dst_height, dst_stride,
+                      scalex,scaley,
+                      src_y, src_a, src_u, src_v,
+                      dst_y, dst_a, dst_u, dst_v);
+    break;
+  case 2:
+    spu_scaled_full(src_stride,
+                    dst_width, dst_height, dst_stride,
+                    scalex,scaley,
+                    src_y, src_a, src_u, src_v,
+                    dst_y, dst_a, dst_u, dst_v);
+    break;
+  }
+}
+
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride))
+{
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
+
+    // check if only forced subtitles are requested 
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){ 
+	return;
+    }
+
+    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 || spu->orig_frame_height == 0
+	|| (spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
+      if (spu->image)
+      {
+	switch(spu->colorspu) {
+	case COLORSPU_YUY:
+	  if (!spu->imageyuy) spudec_create_yuy(spu,0);
+	  if (spu->imageyuy)
+	    draw_alpha(spu->start_col, spu->start_row, spu->width*2, spu->height/2,
+		   DEST_PLANES_YUYV, spu->imageyuy, spu->aimageyuy, spu->strideyuy);
+	  break;
+	case COLORSPU_YUV:
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_Y, spu->image, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_coluv, spu->start_rowuv, spu->widthuv, spu->heightuv,
+		   DEST_PLANES_U, spu->imageu, spu->aimageuv, spu->strideuv);
+	  draw_alpha(spu->start_coluv, spu->start_rowuv, spu->widthuv, spu->heightuv,
+		   DEST_PLANES_V, spu->imagev, spu->aimageuv, spu->strideuv);
+	  break;
+	case COLORSPU_RGB:
+	case COLORSPU_BGR:
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_BR, spu->imagev, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_G, spu->imageu, spu->aimage, spu->stride);
+	  draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_RB, spu->image, spu->aimage, spu->stride);
+	  break;
+	default:
+	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
+		   DEST_PLANES_Y, spu->image, spu->aimage, spu->stride);
+	}
+	spu->spu_changed = 0;
+      }
+    }
+    else {
+      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys) {	/* Resizing is needed */
+	/* scaled_x = scalex * x / 0x100
+	   scaled_y = scaley * y / 0x100
+	   order of operations is important because of rounding. */
+	unsigned int scalex = 0x100 * dxs / spu->orig_frame_width;
+	unsigned int scaley = 0x100 * dys / spu->orig_frame_height;
+	spu->scaled_start_col = spu->start_col * scalex / 0x100;
+	spu->scaled_start_row = spu->start_row * scaley / 0x100;
+	spu->scaled_width = spu->width * scalex / 0x100;
+	spu->scaled_height = spu->height * scaley / 0x100;
+        switch(spu->colorspu) {
+          case COLORSPU_YUV:
+          case COLORSPU_YUY:
+            spu->scaled_widthuv = spu->widthuv * scalex / 0x100;
+            spu->scaled_heightuv = spu->heightuv * scaley / 0x100;
+            spu->scaled_strideuv = (spu->scaled_widthuv + 7) & ~7;
+	    spu->scaled_start_coluv = spu->start_coluv * scalex / 0x100;
+	    spu->scaled_start_rowuv = spu->start_rowuv * scaley / 0x100;
+            break;
+	}
+	/* Kludge: draw_alpha needs width multiple of 8 */
+	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
+	if (spu->scaled_image_size < spu->scaled_stride * spu->scaled_height) {
+	  if (spu->scaled_image) {
+	    free(spu->scaled_image);
+	    if (spu->scaled_imageu)
+	      free(spu->scaled_imageu);
+	    spu->scaled_image_size = 0;
 	  }
-nothing_to_do:
+	  spu->scaled_image = malloc(2 * spu->scaled_stride * spu->scaled_height);
+	  if (spu->scaled_image) {
+	    spu->scaled_image_size = spu->scaled_stride * spu->scaled_height;
+	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+	  }
+	}
+        switch(spu->colorspu) {
+        case COLORSPU_YUV:
+        case COLORSPU_YUY:
+           spu->scaled_imageu = malloc(3 * spu->scaled_strideuv *
+                                       (spu->scaled_height+2));
+           if (spu->scaled_imageu) {
+              memset(spu->scaled_imageu,0,3 * spu->scaled_strideuv *
+                     (spu->scaled_height+2));
+              spu->scaled_image_sizeuv = spu->scaled_strideuv *
+                                         (spu->scaled_heightuv+2);
+              spu->scaled_imagev = spu->scaled_imageu +
+                                   spu->scaled_image_sizeuv;
+              spu->scaled_aimageuv = spu->scaled_imagev +
+                                     spu->scaled_image_sizeuv;
+            }
+ 	    break;
+ 	case COLORSPU_RGB:
+ 	case COLORSPU_BGR:
+ 	  spu->scaled_imageu = malloc(3 * spu->scaled_stride * spu->scaled_height);
+ 	  if (spu->scaled_imageu)
+ 	    spu->scaled_imagev = spu->scaled_imageu + spu->scaled_image_size;
+ 	  break;
+        }
+	if (spu->scaled_image) {
+	  unsigned int y;
+	  if (spu->scaled_width > 1 && spu->scaled_height > 1)
+            switch(spu->colorspu) {
+            case COLORSPU_YUV:
+            case COLORSPU_YUY:
+              if (spu->scaled_widthuv <= 1 || spu->scaled_heightuv <= 1) {
+            aa_scaler(spu, spu_aamode&15, spu->width, spu->height, dxs, dys,
+                      spu->orig_frame_width, spu->orig_frame_height,spu->stride,
+                      spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+                      scalex, scaley,
+                      spu->image, spu->aimage, NULL, NULL,
+                      spu->scaled_image, spu->scaled_aimage, NULL, NULL);
+              aa_scaler(spu, spu_aamode&15, spu->widthuv, spu->heightuv, dxs/2, dys/2,
+                        spu->orig_frame_width/2, spu->orig_frame_height/2, spu->strideuv,
+                        spu->scaled_widthuv, spu->scaled_heightuv, spu->scaled_strideuv,
+                        scalex, scaley,
+                        spu->imageu, spu->aimage, spu->imagev, NULL,
+                        spu->scaled_imageu, spu->scaled_aimage, spu->scaled_imagev, NULL);
+              }
+ 	      break;
+ 	    case COLORSPU_RGB:
+ 	    case COLORSPU_BGR:
+              aa_scaler(spu, spu_aamode&15, spu->width, spu->height, dxs, dys,
+                        spu->orig_frame_width, spu->orig_frame_height, spu->stride,
+                        spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+                        scalex, scaley,
+                        spu->image, spu->aimage, spu->imageu, spu->imagev,
+                        spu->scaled_image, spu->scaled_aimage, spu->scaled_imageu, spu->scaled_imagev);
+ 	      break;
+ 	    default:
+               aa_scaler(spu, spu_aamode&15, spu->width, spu->height, dxs, dys,
+                         spu->orig_frame_width, spu->orig_frame_height, spu->stride,
+                         spu->scaled_width, spu->scaled_height, spu->scaled_stride,
+                         scalex, scaley,
+                         spu->image, spu->aimage, NULL, NULL,
+                         spu->scaled_image, spu->scaled_aimage, NULL, NULL);
+            }
 	  /* Kludge: draw_alpha needs width multiple of 8. */
 	  if (spu->scaled_width < spu->scaled_stride)
 	    for (y = 0; y < spu->scaled_height; ++y) {
@@ -1070,6 +1847,16 @@
 	    }
 	  spu->scaled_frame_width = dxs;
 	  spu->scaled_frame_height = dys;
+	  if (spu->colorspu==COLORSPU_YUY || spu->colorspu==COLORSPU_YUV) {
+	    if (spu->scaled_widthuv < spu->scaled_strideuv)
+	      for (y = 0; y < spu->scaled_heightuv; ++y) {
+	        memset(spu->scaled_aimageuv + y * spu->scaled_stride +
+		       spu->scaled_widthuv, 0,
+		       spu->scaled_strideuv - spu->scaled_widthuv);
+              }
+	    spu->scaled_frame_widthuv = dxs/2;
+	    spu->scaled_frame_heightuv = dys/2;
+	  }
 	}
       }
       if (spu->scaled_image){
@@ -1078,18 +1865,60 @@
           spu->scaled_start_row = dys*sub_pos/100;
 	  if (spu->scaled_start_row + spu->scaled_height > dys)
 	    spu->scaled_start_row = dys - spu->scaled_height;
+	  if (spu->colorspu==COLORSPU_YUY || spu->colorspu==COLORSPU_YUV) {
+            spu->scaled_start_rowuv = (dys/2)*sub_pos/100;
+	    if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	      spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+          }
 	  break;
 	case 1:
           spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
 	  if (sub_pos >= 50 && spu->scaled_start_row + spu->scaled_height > dys)
 	      spu->scaled_start_row = dys - spu->scaled_height;
+	  if (spu->colorspu==COLORSPU_YUY || spu->colorspu==COLORSPU_YUV) {
+            spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv/2;
+            if (sub_pos < 50) {
+	      if (spu->scaled_start_rowuv < 0) spu->scaled_start_rowuv = 0;
+	    } else {
+	      if (spu->scaled_start_rowuv + spu->scaled_heightuv > (dys/2))
+	        spu->scaled_start_rowuv = (dys/2) - spu->scaled_heightuv;
+	    }
+          }
 	  break;
         case 2:
           spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+	  if (spu->colorspu==COLORSPU_YUY || spu->colorspu==COLORSPU_YUV)
+            spu->scaled_start_rowuv = (dys/2)*sub_pos/100 - spu->scaled_heightuv;
 	  break;
 	}
+	switch(spu->colorspu) {
+	  case COLORSPU_YUY:
+	    if (!spu->imageyuy) spudec_create_yuy(spu,1);
+	    if (spu->imageyuy)
+	      draw_alpha(spu->start_col, spu->start_row, spu->width*2, spu->height/2,
+		         DEST_PLANES_YUYV, spu->imageyuy, spu->aimageyuy, spu->strideyuy);
+	    break;
+	  case COLORSPU_YUV:
 	draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
-		   spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+		   DEST_PLANES_Y, spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+	    draw_alpha(spu->scaled_start_coluv, spu->scaled_start_rowuv, spu->scaled_widthuv, spu->scaled_heightuv,
+		       DEST_PLANES_U, spu->scaled_imageu, spu->scaled_aimageuv, spu->scaled_strideuv);
+	    draw_alpha(spu->scaled_start_coluv, spu->scaled_start_rowuv, spu->scaled_widthuv, spu->scaled_heightuv,
+		       DEST_PLANES_V, spu->scaled_imagev, spu->scaled_aimageuv, spu->scaled_strideuv);
+	    break;
+	  case COLORSPU_RGB:
+	  case COLORSPU_BGR:
+	    draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
+		       DEST_PLANES_BR, spu->scaled_imagev, spu->scaled_aimage, spu->scaled_stride);
+	    draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
+		       DEST_PLANES_G, spu->scaled_imageu, spu->scaled_aimage, spu->scaled_stride);
+	    draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
+		       DEST_PLANES_RB, spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+	    break;
+	  default:
+	    draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
+		     DEST_PLANES_Y, spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
+        }
 	spu->spu_changed = 0;
       }
     }
@@ -1207,6 +2036,17 @@
 	free(spu->scaled_image);
     if (spu->image)
       free(spu->image);
+    if (spu->last_packet) {
+      spudec_free_packet(spu->last_packet);
+      spu->last_packet=NULL;
+    }
+    if (spu->imageu)		// Free dvdnav SPU uv or GB image
+      free(spu->imageu);
+    if (spu->imageyuy)		// Free dvdnav SPU YUY image
+      free(spu->imageyuy);
+    spu->imageyuy=NULL;
+    if (spu->scaled_imageu)	// Free dvdnav SPU uv or GB alpha
+	free(spu->scaled_imageu);
     free(spu);
   }
 }
@@ -1219,3 +2059,73 @@
   spu->hw_spu = hw_spu;
   hw_spu->control(VOCTRL_SET_SPU_PALETTE,spu->global_palette);
 }
+
+void spudec_set_spu_format(void *this, uint32_t fmt)
+{
+  spudec_handle_t *spu = (spudec_handle_t*)this;
+  if (!spu)
+    return;
+  switch(fmt) {
+  case IMGFMT_YV12:
+  case IMGFMT_I420:
+  case IMGFMT_IYUV:
+  case IMGFMT_YVU9:   
+  case IMGFMT_IF09:
+  case IMGFMT_Y800:
+  case IMGFMT_Y8:
+    spu->colorspu=COLORSPU_YUV;
+    break;
+  case IMGFMT_YUY2:
+    spu->colorspu=COLORSPU_YUY;
+    break;
+  case IMGFMT_RGB15:
+  case IMGFMT_RGB16:
+  case IMGFMT_RGB24:
+  case IMGFMT_RGB32:
+    spu->colorspu=COLORSPU_RGB;
+    break;
+  case IMGFMT_BGR15:
+  case IMGFMT_BGR16:
+  case IMGFMT_BGR24:
+  case IMGFMT_BGR32:
+    spu->colorspu=COLORSPU_BGR;
+    break;
+  case 0:
+  default:
+    spu->colorspu=COLORSPU_Y;
+  }
+}
+
+void spudec_dvdnav_mode(void *this, int mode)
+{
+  spudec_handle_t *spu = (spudec_handle_t*)this;
+  if (!spu)
+    return;
+  spu->dvdnav_menu=mode;
+  if(!spu->dvdnav_menu) spu->spu_sx=spu->spu_ex=spu->spu_sy=spu->spu_ey=0;
+  if (!spu->dvdnav_menu && spu->last_packet) {
+    spudec_free_packet(spu->last_packet);
+    spu->last_packet=NULL;
+  }
+}
+
+void spudec_dvdnav_area(void *this, int sx, int sy, int ex, int ey, uint32_t palette)
+{
+  spudec_handle_t *spu = (spudec_handle_t*)this;
+  if (!spu)
+    return;
+
+  if (spu->spu_sx==FFMIN(sx,ex) &&
+      spu->spu_ex==FFMAX(sx,ex) &&
+      spu->spu_sy==FFMIN(sy,ey) &&
+      spu->spu_ey==FFMAX(sy,ey) &&
+      spu->dvdnav_palette==palette) return;
+  spu->spu_sx=FFMIN(sx,ex);		/* set spu button area, palette & on */
+  spu->spu_ex=FFMAX(sx,ex);
+  spu->spu_sy=FFMIN(sy,ey);
+  spu->spu_ey=FFMAX(sy,ey);
+  spu->dvdnav_palette=palette;
+  if (spu->dvdnav_menu && spu->last_packet)
+    spudec_process_data(spu, spu->last_packet);
+}
+
diff -Naur MPlayer-export-2009-06-13.orig/spudec.h MPlayer-export-2009-06-13/spudec.h
--- MPlayer-export-2009-06-13.orig/spudec.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/spudec.h	2009-06-14 00:11:07.000000000 +0200
@@ -5,8 +5,8 @@
 
 void spudec_heartbeat(void *this, unsigned int pts100);
 void spudec_assemble(void *this, unsigned char *packet, unsigned int len, int pts100);
-void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
-void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw(void *this, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
+void spudec_draw_scaled(void *this, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, int dp, unsigned char* src, unsigned char *srca, int stride));
 void spudec_update_palette(void *this, unsigned int *palette);
 void *spudec_new_scaled(unsigned int *palette, unsigned int frame_width, unsigned int frame_height, uint8_t *extradata, int extradata_len);
 void *spudec_new(unsigned int *palette);
@@ -18,5 +18,8 @@
 int spudec_changed(void *this);
 void spudec_calc_bbox(void *me, unsigned int dxs, unsigned int dys, unsigned int* bbox);
 void spudec_set_forced_subs_only(void * const this, const unsigned int flag);
+void spudec_set_spu_format(void *this, uint32_t fmt);
+void spudec_dvdnav_mode(void *this, int mode);
+void spudec_dvdnav_area(void *this, int sx, int sy, int ex, int ey, uint32_t palette);
 
 #endif /* MPLAYER_SPUDEC_H */
diff -Naur MPlayer-export-2009-06-13.orig/stream/stream_dvdnav.c MPlayer-export-2009-06-13/stream/stream_dvdnav.c
--- MPlayer-export-2009-06-13.orig/stream/stream_dvdnav.c	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/stream/stream_dvdnav.c	2009-06-14 00:11:07.000000000 +0200
@@ -36,6 +36,14 @@
 } dvdnav_state_t;
 
 typedef struct {
+  int title;
+  int mp_aid;
+  int nav_aid;
+  int mp_sid;
+  int nav_sid;
+} title_lang_t;
+
+typedef struct {
   dvdnav_t *       dvdnav;              /* handle to libdvdnav stuff */
   char *           filename;            /* path */
   unsigned int     duration;            /* in milliseconds */
@@ -45,6 +53,8 @@
   dvdnav_highlight_event_t hlev;
   int              still_length;        /* still frame duration */
   unsigned int     state;
+  int              title_lang_num;
+  title_lang_t*    title_lang;
 } dvdnav_priv_t;
 
 extern char *dvd_device;
@@ -1006,6 +1016,130 @@
   return 1;
 }
 
+/**
+ * \brief seek_title_lang() seek title language info
+ * \param priv: - priv pointer
+ * \param title: - title number
+ * \return title_lang_t pointer if found
+ */
+static title_lang_t* seek_title_lang(dvdnav_priv_t * priv, int title) {
+  int i;
+
+  if (!priv->title_lang)
+    return NULL;
+  if (priv->state & NAV_FLAG_VTS_DOMAIN)
+    return NULL;
+  for(i=0;i<priv->title_lang_num;i++)
+    if (priv->title_lang[i].title==title)
+      return &priv->title_lang[i];
+  return NULL;
+}
+
+/**
+ * \brief new_title_lang() new title to language info
+ * \param priv: - priv pointer
+ * \param title: - title number
+ * \return title_lang_t new pointer
+ */
+static title_lang_t* new_title_lang(dvdnav_priv_t * priv, int title) {
+  title_lang_t* title_lang;
+
+  priv->title_lang_num++;
+  if (priv->title_lang)
+    priv->title_lang=realloc(priv->title_lang,
+                             priv->title_lang_num*sizeof(title_lang_t));
+  else
+    priv->title_lang=malloc(priv->title_lang_num*sizeof(title_lang_t));
+  title_lang=&priv->title_lang[priv->title_lang_num-1];
+  title_lang->title=title;
+  title_lang->mp_aid=-1;
+  title_lang->nav_aid=-1;
+  title_lang->mp_sid=-1;
+  title_lang->nav_sid=-1;
+  return title_lang;
+}
+
+/**
+ * \brief set "mplayer" audio to title lang
+ * \param stream: - stream pointer
+ * \param audio_id: - audio number
+ */
+void mp_dvdnav_set_aid(stream_t *stream, int audio_id) {
+  dvdnav_priv_t* priv=(dvdnav_priv_t*)stream->priv;
+
+  title_lang_t* title_lang = seek_title_lang(priv,priv->title);
+  if (priv->state & NAV_FLAG_VTS_DOMAIN)
+    return;
+  if (!title_lang)
+    title_lang=new_title_lang(priv,priv->title);
+  title_lang->mp_aid=audio_id;
+}
+
+/**
+ * \brief get current audio stream id
+ * \param stream: - stream pointer
+ * \return audio number
+ */
+int mp_dvdnav_get_current_audio(stream_t *stream) {
+  dvdnav_priv_t* priv=(dvdnav_priv_t*)stream->priv;
+  int audio_id;
+  title_lang_t* title_lang = seek_title_lang(priv,priv->title);
+
+  audio_id = dvdnav_get_active_audio_stream(priv->dvdnav);
+  audio_id = mp_dvdnav_aid_from_audio_num(stream, audio_id);
+  if (priv->state & NAV_FLAG_VTS_DOMAIN)
+    return audio_id;
+  if (!title_lang)
+    title_lang=new_title_lang(priv,priv->title);
+  if (title_lang->nav_aid==audio_id && title_lang->mp_aid!=-1) {
+    title_lang->nav_aid=audio_id;
+    return title_lang->mp_aid;
+  }
+  title_lang->nav_aid=audio_id;
+  title_lang->mp_aid=-1;
+  return audio_id;
+}
+
+/**
+ * \brief set "mplayer" spu to title lang
+ * \param stream: - stream pointer
+ * \param spu_id: - spu number
+ */
+void mp_dvdnav_set_sid(stream_t *stream, int spu_id) {
+  dvdnav_priv_t* priv=(dvdnav_priv_t*)stream->priv;
+
+  title_lang_t* title_lang = seek_title_lang(priv,priv->title);
+  if (priv->state & NAV_FLAG_VTS_DOMAIN)
+    return;
+  if (!title_lang)
+    title_lang=new_title_lang(priv,priv->title);
+  title_lang->mp_sid=spu_id;
+}
+
+/**
+ * \brief get current spu stream id
+ * \param stream: - stream pointer
+ * \return spu number
+ */
+int mp_dvdnav_get_current_spu(stream_t *stream) {
+  dvdnav_priv_t* priv=(dvdnav_priv_t*)stream->priv;
+  int sub_id;
+  title_lang_t* title_lang = seek_title_lang(priv,priv->title);
+
+  sub_id = dvdnav_get_active_spu_stream(priv->dvdnav);
+  if (priv->state & NAV_FLAG_VTS_DOMAIN)
+    return sub_id;
+  if (!title_lang)
+    title_lang=new_title_lang(priv,priv->title);
+  if (title_lang->nav_sid==sub_id && title_lang->mp_sid!=-1) {
+    title_lang->nav_sid=sub_id;
+    return title_lang->mp_sid;
+  }
+  title_lang->nav_sid=sub_id;
+  title_lang->mp_sid=-1;
+  return sub_id;
+}
+
 const stream_info_t stream_info_dvdnav = {
   "DVDNAV stream",
   "null",
diff -Naur MPlayer-export-2009-06-13.orig/stream/stream_dvdnav.h MPlayer-export-2009-06-13/stream/stream_dvdnav.h
--- MPlayer-export-2009-06-13.orig/stream/stream_dvdnav.h	2009-06-13 22:53:58.000000000 +0200
+++ MPlayer-export-2009-06-13/stream/stream_dvdnav.h	2009-06-14 00:11:07.000000000 +0200
@@ -29,5 +29,7 @@
 int mp_dvdnav_audio_has_changed (stream_t *stream, int clear);
 int mp_dvdnav_spu_has_changed (stream_t *stream, int clear);
 int mp_dvdnav_stream_has_changed (stream_t *stream);
+int mp_dvdnav_get_current_spu(stream_t *stream);
+int mp_dvdnav_get_current_audio(stream_t *stream);
 
 #endif /* MPLAYER_STREAM_DVDNAV_H */
