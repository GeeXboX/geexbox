diff -r 13cd417bfd4a libmenu/Makefile
--- a/libmenu/Makefile	Sun Apr 30 16:54:39 2006 +0200
+++ b/libmenu/Makefile	Sun Apr 30 16:54:39 2006 +0200
@@ -9,6 +9,9 @@ SRCS= menu.c \
       menu_pt.c \
       menu_list.c  \
       menu_filesel.c \
+      menu_audiosel.c \
+      menu_subsel.c \
+      menu_chapsel.c \
       menu_txt.c \
       menu_console.c \
       menu_param.c \
diff -r 13cd417bfd4a libmenu/menu.c
--- a/libmenu/menu.c	Sun Apr 30 16:54:39 2006 +0200
+++ b/libmenu/menu.c	Sun Apr 30 16:54:39 2006 +0200
@@ -27,6 +27,9 @@ extern menu_info_t menu_info_cmdlist;
 extern menu_info_t menu_info_cmdlist;
 extern menu_info_t menu_info_pt;
 extern menu_info_t menu_info_filesel;
+extern menu_info_t menu_info_audiosel;
+extern menu_info_t menu_info_subsel;
+extern menu_info_t menu_info_chapsel;
 extern menu_info_t menu_info_txt;
 extern menu_info_t menu_info_console;
 extern menu_info_t menu_info_pref;
@@ -39,6 +42,9 @@ menu_info_t* menu_info_list[] = {
   &menu_info_pt,
   &menu_info_cmdlist,
   &menu_info_filesel,
+  &menu_info_audiosel,
+  &menu_info_subsel,
+  &menu_info_chapsel,
   &menu_info_txt,
   &menu_info_console,
 #ifdef HAS_DVBIN_SUPPORT
diff -r 13cd417bfd4a libmpdemux/demux_mkv.c
--- a/libmpdemux/demux_mkv.c	Sun Apr 30 16:54:39 2006 +0200
+++ b/libmpdemux/demux_mkv.c	Sun Apr 30 16:54:39 2006 +0200
@@ -255,6 +255,11 @@ typedef struct __attribute__((__packed__
   uint32_t fourcc3;             /* fourcc */
 } real_audio_v5_props_t;
 
+int mkv_subtitles[64];
+int mkv_subtitles_num;
+uint64_t mkv_chapter_start[99];
+int mkv_chapter_num;
+char* mkv_chapter_string[99];
 
 /* for e.g. "-slang ger" */
 extern char *dvdsub_lang;
@@ -1366,6 +1371,35 @@ demux_mkv_read_chapters (demuxer_t *demu
                               end = ebml_read_uint (s, &l) / 1000000;
                               break;
 
+                            case MATROSKA_ID_CHAPTERDISPLAY:
+                              {
+                                uint64_t len;
+                                int i;
+
+                                len = ebml_read_length (s, &i);
+                                l = len + i;
+
+                                while (len > 0)
+                                  {
+                                    uint64_t l;
+                                    int il;
+
+                                    switch (ebml_read_id (s, &il))
+                                      {
+                                      case MATROSKA_ID_CHAPSTRING:
+                                        mkv_chapter_string[mkv_chapter_num]
+                                          = ebml_read_utf8 (s, &l);
+                                        break;
+
+                                      default:
+                                        ebml_read_skip (s, &l);
+                                        break;
+                                      }
+                                    len -= l + il;
+                                  }
+                                break;
+                              }
+
                             default:
                               ebml_read_skip (s, &l);
                               break;
@@ -1387,6 +1421,8 @@ demux_mkv_read_chapters (demuxer_t *demu
                              (int) ((end / 60 / 1000) % 60),
                              (int) ((end / 1000) % 60),
                              (int) (end % 1000), name);
+//                      mkv_chapter_num = mkv_d->num_chapters;
+                      mkv_chapter_start[mkv_chapter_num] = start;

                       free(name);
                       break;
@@ -2363,6 +2409,10 @@ demux_mkv_open (demuxer_t *demuxer)
     track = demux_mkv_find_track_by_language (mkv_d, dvdsub_lang,
                                               MATROSKA_TRACK_SUBTITLE);
 
+  mkv_subtitles_num = 0;
+  for (i=0; i < mkv_d->num_tracks; i++)
+    if (mkv_d->tracks[i]->type == MATROSKA_TRACK_SUBTITLE)
+      mkv_subtitles[mkv_subtitles_num++] = mkv_d->tracks[i]->tnum;
   if (track && !demux_mkv_open_sub (demuxer, track))
           {
             mp_msg (MSGT_DEMUX, MSGL_INFO,
@@ -2416,6 +2466,7 @@ demux_close_mkv (demuxer_t *demuxer)
 {
   mkv_demuxer_t *mkv_d = (mkv_demuxer_t *) demuxer->priv;
 
+  mkv_subtitles_num = 0;
   if (mkv_d)
     {
       int i;
diff -r 13cd417bfd4a libmpdemux/demux_ogg.c
--- a/libmpdemux/demux_ogg.c	Sun Apr 30 16:54:39 2006 +0200
+++ b/libmpdemux/demux_ogg.c	Sun Apr 30 16:54:39 2006 +0200
@@ -170,6 +170,9 @@ extern subtitle* vo_sub;
 extern subtitle* vo_sub;
 static float clear_sub;
 //FILE* subout;
+int ogg_subtitles[64];
+int ogg_subtitles_num=0;
+
 
 static
 uint16_t get_uint16 (const void *buf)
@@ -854,6 +857,7 @@ int demux_ogg_open(demuxer_t* demuxer) {
 
   clear_sub = -1;
   s = demuxer->stream;
+  ogg_subtitles_num = 0;
 
   demuxer->priv =
   ogg_d = (ogg_demuxer_t*)calloc(1,sizeof(ogg_demuxer_t));
@@ -1125,6 +1129,7 @@ int demux_ogg_open(demuxer_t* demuxer) {
 	/// Check for text (subtitles) header
       } else if (strncmp(st->streamtype, "text", 4) == 0) {
           mp_msg(MSGT_DEMUX, MSGL_INFO, "[Ogg] stream %d: subtitles (SRT-like text subtitles), -sid %d\n", ogg_d->num_sub, ogg_d->n_text);
+          ogg_subtitles[ogg_subtitles_num++] = ogg_d->num_sub;
 	  ogg_d->subs[ogg_d->num_sub].samplerate= get_uint64(&st->time_unit)/10;
 	  ogg_d->subs[ogg_d->num_sub].text = 1;
 	  mp_msg(MSGT_IDENTIFY, MSGL_INFO, "ID_SUBTITLE_ID=%d\n", ogg_d->n_text);
@@ -1589,6 +1594,8 @@ static void demux_close_ogg(demuxer_t* d
   ogg_demuxer_t* ogg_d = demuxer->priv;
   int i;
 
+  ogg_subtitles_num = 0;
+
   if(!ogg_d)
     return;
 
diff -r 13cd417bfd4a libmpdemux/demuxer.h
--- a/libmpdemux/demuxer.h	Sun Apr 30 16:54:39 2006 +0200
+++ b/libmpdemux/demuxer.h	Sun Apr 30 16:54:39 2006 +0200
@@ -315,6 +315,16 @@ extern int pts_from_bps;
 
 extern int extension_parsing;
 
+#ifdef HAVE_OGGVORBIS
+extern int ogg_subtitles[];
+extern int ogg_subtitles_num;
+#endif /* HAVE_OGGVORBIS */
+extern int mkv_subtitles[];
+extern int mkv_subtitles_num;
+extern int mkv_chapter_num;
+extern uint64_t mkv_chapter_start[99];
+extern char* mkv_chapter_string[99];
+
 int demux_info_add(demuxer_t *demuxer, const char *opt, const char *param);
 char* demux_info_get(demuxer_t *demuxer, char *opt);
 int demux_info_print(demuxer_t *demuxer);
diff -r 13cd417bfd4a stream/stream.h
--- a/stream/stream.h	Sun Apr 30 16:54:39 2006 +0200
+++ b/stream/stream.h	Sun Apr 30 16:54:39 2006 +0200
@@ -287,6 +287,8 @@ extern int dvd_title;
 extern int dvd_title;
 extern int dvd_chapter;
 extern int dvd_last_chapter;
+extern int dvd_total_chapter;
+extern int dvd_chapter_pos[99];
 extern int dvd_angle;
 //#endif
 
diff -r 13cd417bfd4a libmpdemux/stream_dvd.c
--- a/stream/stream_dvd.c	Sun Apr 30 16:54:39 2006 +0200
+++ b/stream/stream_dvd.c	Sun Apr 30 16:54:39 2006 +0200
@@ -31,6 +31,8 @@ extern int dvd_last_chapter;
 extern int dvd_last_chapter;
 extern char* dvd_device;
 int dvd_angle=1;
+int dvd_total_chapter=0;
+int dvd_chapter_pos[99];
 
 #ifdef HAVE_DVD
 #ifdef USE_DVDREAD
@@ -721,6 +736,7 @@ static int open_s(stream_t *stream,int m
      * Make sure the chapter number is valid for this title.
      */
     mp_msg(MSGT_OPEN,MSGL_STATUS, MSGTR_DVDnumChapters, tt_srpt->title[dvd_title].nr_of_ptts);
+    dvd_total_chapter = tt_srpt->title[dvd_title].nr_of_ptts;
     if(dvd_chapter<1 || dvd_chapter>tt_srpt->title[dvd_title].nr_of_ptts) {
       mp_msg(MSGT_OPEN,MSGL_ERR, MSGTR_DVDinvalidChapter, dvd_chapter);
       ifoClose( vmg_file );
@@ -926,6 +942,12 @@ static int open_s(stream_t *stream,int m
     d->cell_last_pack=d->cur_pgc->cell_playback[ d->cur_cell ].last_sector;
     mp_msg(MSGT_DVD,MSGL_V, "DVD start cell: %d  pack: 0x%X-0x%X  \n",d->cur_cell,d->cur_pack,d->cell_last_pack);
 
+    {
+      int chap;
+      for (chap = 0; chap < dvd_total_chapter; chap++)
+        dvd_chapter_pos[chap+1] = d->cur_pgc->cell_playback[chap].first_sector;
+    }
+
     // ... (unimplemented)
     //    return NULL;
     stream->type = STREAMTYPE_DVD;
diff -r 13cd417bfd4a mplayer.c
--- a/mplayer.c	Sun Apr 30 16:54:39 2006 +0200
+++ b/mplayer.c	Sun Apr 30 16:54:39 2006 +0200
@@ -360,8 +360,8 @@ extern int mp_msg_levels[MSGT_MAX];
 extern int mp_msg_levels[MSGT_MAX];
 extern int mp_msg_level_all;
 
-static stream_t* stream=NULL;
-static demuxer_t *demuxer=NULL;
+stream_t* stream=NULL;
+demuxer_t *demuxer=NULL;
 static sh_audio_t *sh_audio=NULL;
 static sh_video_t *sh_video=NULL;
 static demux_stream_t *d_audio=NULL;
@@ -3266,8 +3266,7 @@ demux_info_print(demuxer);
 
 //================== Read SUBTITLES (DVD & TEXT) ==========================
 if(vo_spudec==NULL && sh_video &&
-     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA ||
-      d_dvdsub->id >= 0)){
+     (stream->type==STREAMTYPE_DVD || demuxer->type==DEMUXER_TYPE_MATROSKA)){
 
 if (spudec_ifo) {
   unsigned int palette[16], width, height;
diff -r 13cd417bfd4a mplayer.h
--- a/mplayer.h	Sun Apr 30 16:54:39 2006 +0200
+++ b/mplayer.h	Sun Apr 30 16:54:39 2006 +0200
@@ -36,6 +36,9 @@ extern int    sub_unicode;
 extern int    sub_unicode;
 extern char * sub_cp;
 extern sub_data* subdata; //currently used subtitles  
+extern sub_data* set_of_subtitles[MAX_SUBTITLE_FILES];
+extern int set_of_sub_size;
+extern int set_of_sub_pos;
 extern subtitle* vo_sub;
 extern int    suboverlap_enabled;
 
diff -r 13cd417bfd4a libmenu/menu_audiosel.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmenu/menu_audiosel.c	Sun Apr 30 16:54:39 2006 +0200
@@ -0,0 +1,133 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "config.h"
+
+#include "m_struct.h"
+#include "m_option.h"
+#include "input/input.h"
+
+#include "stream/stream.h"
+#include "libmpdemux/demuxer.h"
+
+#include "libmpcodecs/img_format.h"
+#include "libmpcodecs/mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+
+struct list_entry_s {
+  struct list_entry p;
+  int aid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select audio channel",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF(title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF(auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0,0,0,NULL }
+};
+
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+extern void resync_audio_stream(void *sh_audio);
+extern char *dvd_lang_from_aid(stream_t *stream, int aid);
+
+static int fill_menu(menu_t* menu) {
+  char *str, aid_str[32];
+  list_entry_t* e;
+  int aid;
+
+  if (!demuxer || !demuxer->audio || !demuxer->audio->sh){
+    menu_list_read_cmd(menu,MENU_CMD_CANCEL);
+    return 1;
+  }
+
+  menu_list_init(menu);
+
+  for (aid=0; aid<MAX_A_STREAMS; aid++)
+    if (demuxer->a_streams[aid]){
+      if (stream->type == STREAMTYPE_DVD){
+        if (!(str = dvd_lang_from_aid(stream, aid)))
+          continue;
+        strcpy (aid_str, str);
+      } else
+        sprintf(aid_str, "%d", aid);
+      if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+        e->p.next = NULL;
+        e->p.txt = strdup(aid_str);
+        e->aid = aid;
+        menu_list_add_entry(menu,e);
+      }
+    }
+
+  return 1;
+}
+
+static void read_cmd(menu_t* menu,int cmd) {
+  int aid;
+
+  switch(cmd) {
+  case MENU_CMD_RIGHT:
+  case MENU_CMD_OK:
+    aid = menu->priv->p.current->aid;
+    if (demuxer->audio->id != aid){
+      demuxer->audio->id = aid;
+      if(demuxer->audio->sh)
+        resync_audio_stream(demuxer->audio->sh);
+    }
+    if(menu->priv->auto_close)
+      mp_input_queue_cmd(mp_input_parse_cmd("menu hide"));
+    break;
+  default:
+    menu_list_read_cmd(menu,cmd);
+  }
+}
+
+static void close_as(menu_t* menu) {
+  menu_list_uninit(menu,NULL);
+}
+
+static int open_as(menu_t* menu, char* args) {
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_as;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu(menu);
+}
+  
+const menu_info_t menu_info_audiosel = {
+  "Audio selector menu",
+  "audiosel",
+  "aurel.j",
+  "",
+  {
+    "audiosel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_as
+};
diff -r 13cd417bfd4a libmenu/menu_chapsel.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmenu/menu_chapsel.c	Sun Apr 30 16:54:39 2006 +0200
@@ -0,0 +1,167 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "config.h"
+
+#include "m_struct.h"
+#include "m_option.h"
+#include "input/input.h"
+
+#include "stream/stream.h"
+#include "libmpdemux/demuxer.h"
+#include "libvo/video_out.h"
+#include "libvo/sub.h"
+#include "spudec.h"
+#include "mplayer.h"
+
+#include "libmpcodecs/img_format.h"
+#include "libmpcodecs/mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+struct list_entry_s {
+  struct list_entry p;
+  int cid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select chapter",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF (title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF (auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0, 0, 0, NULL }
+};
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+
+static int
+fill_menu (menu_t* menu)
+{
+  list_entry_t* e;
+  int cid;
+
+  if ((demuxer && stream->type == STREAMTYPE_DVD)
+      || (demuxer && demuxer->type == DEMUXER_TYPE_MATROSKA
+          && mkv_chapter_num > 0))
+    {
+      menu_list_init (menu);
+    
+      if (stream->type == STREAMTYPE_DVD)
+        {
+          for (cid = 1; cid < dvd_total_chapter + 1; cid++)
+            {
+              char *chap = malloc (3 * sizeof (char));
+              if ((e = calloc (1, sizeof (list_entry_t))) != NULL)
+                {
+                  sprintf (chap, "%d", cid);
+                  e->p.next = NULL;
+                  e->p.txt = strdup (chap);
+                  e->cid = cid;
+                  menu_list_add_entry (menu, e);
+                }
+              free (chap);
+            }
+        }
+      else if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        {
+          for (cid = 0; cid < mkv_chapter_num + 0; cid++)
+            {
+              if ((e = calloc (1, sizeof (list_entry_t))) != NULL)
+                {
+                  e->p.next = NULL;
+                  if (mkv_chapter_string[cid])
+                    e->p.txt = strdup (mkv_chapter_string[cid]);
+                  else
+                    {
+                      e->p.txt = malloc (4);
+                      sprintf (e->p.txt, "%-3d", cid+1);
+                    }
+                  e->cid = cid + 1;
+                  menu_list_add_entry (menu, e);
+                }
+            }
+        }
+    }
+  else
+    menu_list_read_cmd (menu, MENU_CMD_CANCEL);
+
+  return 1;
+}
+
+static void
+read_cmd (menu_t* menu, int cmd)
+{
+  switch (cmd)
+    {
+    case MENU_CMD_RIGHT:
+    case MENU_CMD_OK:
+      if (stream->type == STREAMTYPE_DVD)
+        {
+          stream_seek (stream,
+                       (off_t) dvd_chapter_pos[menu->priv->p.current->cid]
+                       * 2048);
+        }
+      else if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        {
+          demux_seek(demuxer,
+                     mkv_chapter_start[menu->priv->p.current->cid]/1000.0,0,1);
+        }
+
+      if (menu->priv->auto_close)
+        mp_input_queue_cmd (mp_input_parse_cmd ("menu hide"));
+      break;
+    default:
+      menu_list_read_cmd (menu, cmd);
+    }
+}
+
+static void
+close_cs (menu_t* menu)
+{
+  menu_list_uninit (menu, NULL);
+}
+
+static int
+open_cs (menu_t* menu, char* args)
+{
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_cs;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu (menu);
+}
+  
+const menu_info_t menu_info_chapsel = {
+  "Chapter selector menu",
+  "chapsel",
+  "Benjamin Zores",
+  "",
+  {
+    "chapsel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_cs
+};
diff -r 13cd417bfd4a libmenu/menu_subsel.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/libmenu/menu_subsel.c	Sun Apr 30 16:54:39 2006 +0200
@@ -0,0 +1,192 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "config.h"
+
+#include "m_struct.h"
+#include "m_option.h"
+#include "input/input.h"
+
+#include "stream/stream.h"
+#include "libmpdemux/demuxer.h"
+#include "libvo/video_out.h"
+#include "libvo/sub.h"
+#include "spudec.h"
+#include "mplayer.h"
+
+#include "libmpcodecs/img_format.h"
+#include "libmpcodecs/mp_image.h"
+
+#include "menu.h"
+#include "menu_list.h"
+
+
+struct list_entry_s {
+  struct list_entry p;
+  int sid;
+};
+
+struct menu_priv_s {
+  menu_list_priv_t p;
+  char* title;
+  int auto_close;
+};
+
+static struct menu_priv_s cfg_dflt = {
+  MENU_LIST_PRIV_DFLT,
+  "Select subtitle",
+  0
+};
+
+#define ST_OFF(m) M_ST_OFF(struct menu_priv_s,m)
+
+static m_option_t cfg_fields[] = {
+  MENU_LIST_PRIV_FIELDS,
+  { "title", ST_OFF(title),  CONF_TYPE_STRING, 0, 0, 0, NULL },
+  { "auto-close", ST_OFF(auto_close), CONF_TYPE_FLAG, 0, 0, 1, NULL },
+  { NULL, NULL, NULL, 0,0,0,NULL }
+};
+
+
+extern stream_t* stream;
+extern demuxer_t *demuxer;
+
+static int fill_menu(menu_t* menu) {
+  list_entry_t* e;
+  char txt[3];
+  int lang, sid=0, inc;
+
+  if ((demuxer && demuxer->sub && stream->type == STREAMTYPE_DVD)
+#ifdef HAVE_OGGVORBIS
+      || (demuxer && demuxer->type == DEMUXER_TYPE_OGG && ogg_subtitles_num>0)
+#endif /* HAVE_OGGVORBIS */
+      || (demuxer&&demuxer->type == DEMUXER_TYPE_MATROSKA&&mkv_subtitles_num>0)
+      || set_of_sub_size > 0){
+    menu_list_init(menu);
+
+#ifdef USE_DVDREAD
+    if(stream->type == STREAMTYPE_DVD){
+      while((lang = dvd_lang_from_sid(stream, sid)))
+        if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+          txt[0] = lang>>8;
+          txt[1] = lang;
+          txt[2] = 0;
+          e->p.txt = strdup(txt);
+          e->p.next = NULL;
+          e->sid = sid++;
+          menu_list_add_entry(menu,e);
+        }
+    } else
+#endif /* USE_DVDREAD */
+      {
+#ifdef HAVE_OGGVORBIS
+      if(demuxer->type == DEMUXER_TYPE_OGG)
+        for(sid=0; sid<ogg_subtitles_num; sid++) {
+          if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+            sprintf(txt, "%d\n", ogg_subtitles[sid]);
+            e->p.txt = strdup(txt);
+            e->p.next = NULL;
+            e->sid = sid;
+            menu_list_add_entry(menu,e);
+          }
+        }
+      else
+#endif /* HAVE_OGGVORBIS */
+      if(demuxer->type == DEMUXER_TYPE_MATROSKA)
+        for(sid=0; sid<mkv_subtitles_num; sid++) {
+          if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+            sprintf(txt, "%d\n", mkv_subtitles[sid]);
+            e->p.txt = strdup(txt);
+            e->p.next = NULL;
+            e->sid = sid;
+            menu_list_add_entry(menu,e);
+          }
+        }
+      inc = sid;
+      sid = 0;
+      while(sid < set_of_sub_size)
+        if((e = calloc(1,sizeof(list_entry_t))) != NULL){
+          e->p.txt = strrchr(set_of_subtitles[sid]->filename, '/');
+          if(e->p.txt == NULL)  e->p.txt = set_of_subtitles[sid]->filename;
+          else  e->p.txt++;
+          e->p.next = NULL;
+          e->sid = inc + sid++;
+          menu_list_add_entry(menu,e);
+        }
+    }
+  } else {
+    menu_list_read_cmd(menu,MENU_CMD_CANCEL);
+  }
+
+  return 1;
+}
+
+static void read_cmd(menu_t* menu,int cmd) {
+  int sid;
+
+  switch(cmd) {
+  case MENU_CMD_RIGHT:
+  case MENU_CMD_OK:
+    sid = menu->priv->p.current->sid;
+    if(stream->type == STREAMTYPE_DVD && demuxer->sub->id != sid){
+      demuxer->sub->id = sid;
+      if(vo_spudec)
+        spudec_reset(vo_spudec);
+#ifdef HAVE_OGGVORBIS
+    } else if(demuxer->type == DEMUXER_TYPE_OGG && sid < ogg_subtitles_num) {
+      demuxer->sub->id = ogg_subtitles[sid];
+#endif /* HAVE_OGGVORBIS */
+    } else if(demuxer->type==DEMUXER_TYPE_MATROSKA && sid<mkv_subtitles_num) {
+      demuxer->sub->id = mkv_subtitles[sid];
+    } else {
+#ifdef HAVE_OGGVORBIS
+      if (demuxer->type == DEMUXER_TYPE_OGG)
+        sid -= ogg_subtitles_num;
+      else
+#endif /* HAVE_OGGVORBIS */
+      if (demuxer->type == DEMUXER_TYPE_MATROSKA)
+        sid -= mkv_subtitles_num;
+      set_of_sub_pos = sid;
+      subdata = set_of_subtitles[set_of_sub_pos];
+      vo_sub = NULL;
+      vo_osd_changed(OSDTYPE_SUBTITLE);
+    }
+    if(menu->priv->auto_close)
+      mp_input_queue_cmd(mp_input_parse_cmd("menu hide"));
+    break;
+  default:
+    menu_list_read_cmd(menu,cmd);
+  }
+}
+
+static void close_ss(menu_t* menu) {
+  menu_list_uninit(menu,NULL);
+}
+
+static int open_ss(menu_t* menu, char* args) {
+  args = NULL;
+
+  menu->draw = menu_list_draw;
+  menu->read_cmd = read_cmd;
+  menu->read_key = menu_dflt_read_key;
+  menu->close = close_ss;
+  menu->priv->p.title = menu->priv->title;
+
+  return fill_menu(menu);
+}
+  
+const menu_info_t menu_info_subsel = {
+  "Subtitle selector menu",
+  "subsel",
+  "aurel.j",
+  "",
+  {
+    "subsel_cfg",
+    sizeof(struct menu_priv_s),
+    &cfg_dflt,
+    cfg_fields
+  },
+  open_ss
+};
