diff -Naur MPlayer-r25688.orig/command.c MPlayer-r25688/command.c
--- MPlayer-r25688.orig/command.c	2008-01-12 13:55:21.000000000 +0100
+++ MPlayer-r25688/command.c	2008-01-12 16:21:46.000000000 +0100
@@ -3069,12 +3069,9 @@
 		if (mpctx->stream->type != STREAMTYPE_DVDNAV)
 		    break;
 
-		if (mp_dvdnav_handle_input
-		    (mpctx->stream, cmd->args[0].v.i, &button)) {
-		    uninit_player(INITED_ALL - (INITED_STREAM | INITED_INPUT |
-				   (fixed_vo ? INITED_VO : 0)));
-		    brk_cmd = 2;
-		} else if (button > 0)
+		mp_dvdnav_handle_input(mpctx->stream,
+		    cmd->args[0].v.i, &button);
+		if (button > 0)
 		    set_osd_msg(OSD_MSG_TEXT, 1, osd_duration,
 				"Selected button number %d", button);
 	    }
diff -Naur MPlayer-r25688.orig/mp_core.h MPlayer-r25688/mp_core.h
--- MPlayer-r25688.orig/mp_core.h	2008-01-12 13:55:21.000000000 +0100
+++ MPlayer-r25688/mp_core.h	2008-01-12 16:21:46.000000000 +0100
@@ -102,6 +102,14 @@
 #endif
 
     int was_paused;
+#ifdef USE_DVDNAV
+    void *smpi;          // store last decoded video image
+    void *last_buffer;   // store last read video frame
+    void *last_start;    // video read buffer ptr
+    int last_in_size;    // last read size
+    int libmpeg2_count;  // libmpeg2 repeat decode counter
+    int dup_frame;       // duplicate frame mode
+#endif
 } MPContext;
 
 
diff -Naur MPlayer-r25688.orig/mplayer.c MPlayer-r25688/mplayer.c
--- MPlayer-r25688.orig/mplayer.c	2008-01-12 13:55:21.000000000 +0100
+++ MPlayer-r25688/mplayer.c	2008-01-12 16:21:46.000000000 +0100
@@ -168,6 +168,9 @@
 #endif
 
 #ifdef USE_DVDNAV
+#include "libmpcodecs/img_format.h"
+#include "libmpcodecs/mp_image.h"
+#include "libvo/fastmemcpy.h"
 #include "stream/stream_dvdnav.h"
 #endif
 
@@ -622,6 +625,17 @@
     current_module="uninit_vo";
     mpctx->video_out->uninit();
     mpctx->video_out=NULL;
+#ifdef USE_DVDNAV
+    // free stored decoded image
+    if (mpctx->smpi) free_mp_image(mpctx->smpi);
+    mpctx->smpi=NULL;
+    // free last video read frame
+    if (mpctx->last_buffer) free(mpctx->last_buffer);
+    // clear buffers
+    mpctx->last_buffer=NULL;
+    mpctx->last_start=NULL;
+    mpctx->last_in_size=0;
+#endif
   }
 
   // Must be after libvo uninit, as few vo drivers (svgalib) have tty code.
@@ -1767,6 +1781,168 @@
     return time_frame;
 }
 
+// DVDNAV *FIXME*
+#ifdef USE_DVDNAV
+//
+// store decoded video image
+//
+mp_image_t* mp_dvdnav_copympi(mp_image_t* tompi,
+        mp_image_t* frommpi) {
+    mp_image_t* mpi;
+
+    if (!frommpi) return NULL;
+    // Do not store B-frames
+    if (frommpi->pict_type==3) return tompi;
+    if (tompi && tompi->w==frommpi->w &&
+	    tompi->h==frommpi->h &&
+	    tompi->imgfmt==frommpi->imgfmt)
+        mpi=tompi;
+    else {
+        if (tompi) free_mp_image(tompi);
+        if (frommpi->w==0 || frommpi->h==0) return NULL;
+        mpi=alloc_mpi(frommpi->w,frommpi->h,frommpi->imgfmt);
+    }
+    copy_mpi(mpi,frommpi);
+    return mpi;
+}
+
+//
+// video frame preprocess: before decode_video()
+//
+static void* mp_dvdnav_decode_video_pre(int *in_size,
+    unsigned char **start, mp_image_t* decoded_frame) {
+    // change in dvdnav stream
+    if (mp_dvdnav_iscellchage(mpctx->stream,0)) {
+        // suspend read from dvdnav stream, and set auto_wait
+        mp_dvdnav_wait_read(mpctx->stream, 1, 1);
+        // free last stored frame image
+        if (mpctx->smpi) free_mp_image(mpctx->smpi);
+        // and clear buffers
+        mpctx->smpi=NULL;
+        if (mpctx->last_buffer) free(mpctx->last_buffer);
+        mpctx->last_buffer=NULL;
+        mpctx->last_in_size=0;
+        if (mpctx->d_sub) dvdsub_id = -2;
+        if (mpctx->sh_video) {
+            // clear video pts
+            mpctx->d_video->pts=0.0f;
+            mpctx->sh_video->pts=0.0f;
+            mpctx->sh_video->i_pts=0.0f;
+            mpctx->sh_video->last_pts=0.0f;
+            mpctx->sh_video->num_buffered_pts=0;
+            mpctx->sh_video->num_frames=0;
+            mpctx->sh_video->num_frames_decoded=0;
+            mpctx->sh_video->timer=0.0f;
+            mpctx->sh_video->stream_delay=0.0f;
+            mpctx->demuxer->stream_pts=MP_NOPTS_VALUE;
+            mpctx->sh_video->timer=0;
+        }
+        if (mpctx->sh_audio) {
+            // free audio packs and reset
+            ds_free_packs(mpctx->d_audio);
+            audio_delay -= mpctx->sh_audio->stream_delay;
+            mpctx->delay=-audio_delay;
+            mpctx->audio_out->reset();
+            resync_audio_stream(mpctx->sh_audio);
+        }
+        audio_delay=0.0f;
+        correct_pts=0;
+        // clear all eof flags
+        mpctx->d_video->eof=mpctx->d_audio->eof=
+	    mpctx->stream->eof=0;
+        // enable read from dvdnav stream
+        mp_dvdnav_wait_read(mpctx->stream, 0, 1);
+        // reset cell change flag
+        mp_dvdnav_iscellchage(mpctx->stream,1);
+    }
+// Wait or still frame (in_size==-1): if frame decode OK then return stored image
+    if (*in_size<0 && !mpctx->last_buffer && mpctx->smpi &&
+	    !mpctx->libmpeg2_count)
+        decoded_frame=mpctx->smpi;
+    mpctx->dup_frame=0;
+    if (*in_size<0 && mpctx->last_buffer) {
+        mpctx->dup_frame=1;
+        if (!mpctx->libmpeg2_count)
+	    mpctx->libmpeg2_count=5;
+        // is valid last video buffer (required libmpeg2!)
+        if (mpctx->last_start) {
+             // Set start, in_size and copy frame data from stored frame
+            *start=mpctx->last_start;
+            *in_size=mpctx->last_in_size;
+            memcpy(*start,mpctx->last_buffer,*in_size);
+        } else {
+            *start=mpctx->last_buffer;
+            *in_size=mpctx->last_in_size;
+        }
+    }
+    return decoded_frame;
+}
+
+//
+// video frame postprocess: after decode_video()
+//
+static void* mp_dvdnav_decode_video_post(int in_size,
+	unsigned char *start, mp_image_t* decoded_frame,
+	sh_video_t *sh_video, int drop_frame) {
+    float len;
+
+    if (in_size<0) {
+        if (mpctx->last_buffer) {
+            // free buffer
+            free(mpctx->last_buffer);
+            mpctx->last_buffer=NULL;
+            mpctx->last_in_size=0;
+        }
+        // get duration of part
+        len = demuxer_get_time_length(mpctx->demuxer);
+        if ((mpctx->sh_video->pts>=len || !mpctx->smpi) &&
+		mpctx->sh_video->pts>0.0 && len>0.0) {
+            // clear still frame in dvdnav
+            mp_dvdnav_still_skip(mpctx->stream);
+            // clear wait in dvdnav
+            mp_dvdnav_wait_skip(mpctx->stream);
+        }
+        // increment video frame
+        mpctx->sh_video->pts+=1/mpctx->sh_video->fps;
+    } else {
+        if (mpctx->dup_frame) {
+            if (mpctx->libmpeg2_count)
+		mpctx->libmpeg2_count--;
+            if (!mpctx->libmpeg2_count) {
+                // clear buffers
+                if (mpctx->last_buffer)
+		    free(mpctx->last_buffer);
+                mpctx->last_buffer=NULL;
+                mpctx->last_in_size=0;
+                if (!decoded_frame && !mpctx->smpi) {
+                    mp_msg(MSGT_CPLAYER,MSGL_ERR,
+                        "Can't decode still frame.\n"
+                        "Please, you try play dvdnav to -vc ffmpeg12 option.\n");
+                    mpctx->eof=1;
+                }
+            }
+        // no duplicate mode
+        } else {
+            // clear buffer
+            if (mpctx->last_buffer)
+		free(mpctx->last_buffer);
+            mpctx->last_in_size=in_size;
+            // allocate buffer and store read video frame data
+            mpctx->last_buffer=malloc(in_size);
+            mpctx->last_start=start;
+            if (mpctx->last_buffer)
+                memcpy(mpctx->last_buffer,start,in_size);
+            else
+                mpctx->last_in_size=-1;
+        }
+        // if decoded OK and no stored image then store image
+        if (decoded_frame && mpctx->smpi!=decoded_frame)
+	    mpctx->smpi=mp_dvdnav_copympi(mpctx->smpi,decoded_frame);
+    }
+    return decoded_frame;
+}
+#endif
+
 static void adjust_sync_and_print_status(int between_frames, float timing_error)
 {
     current_module="av_sync";
@@ -2079,7 +2255,7 @@
     *blit_frame = 0; // Don't blit if we hit EOF
     if (!correct_pts) {
 	unsigned char* start=NULL;
-	void *decoded_frame;
+	void *decoded_frame=NULL;
 	int drop_frame=0;
 	int in_size;
 
@@ -2087,6 +2263,16 @@
 	frame_time = sh_video->next_frame_time;
 	in_size = video_read_frame(sh_video, &sh_video->next_frame_time,
 				   &start, force_fps);
+#ifdef USE_DVDNAV
+    // wait, still frame or EOF
+    if (mpctx->stream->type==STREAMTYPE_DVDNAV && in_size < 0) {
+        if (mp_dvdnav_isreallyeof(mpctx->stream)) return -1;
+        // if not (wait, still frame) then clear eof flags
+        if (mpctx->d_video) mpctx->d_video->eof=0;
+        if (mpctx->d_audio) mpctx->d_audio->eof=0;
+        mpctx->stream->eof=0;
+    } else
+#endif
 	if (in_size < 0)
 	    return -1;
 	if (in_size > max_framesize)
@@ -2117,8 +2303,22 @@
 	update_teletext(sh_video, mpctx->demuxer, 0);
 	update_osd_msg();
 	current_module = "decode_video";
+#ifdef USE_DVDNAV
+    if (mpctx->stream->type==STREAMTYPE_DVDNAV)
+        // call dvdnav video preprocess
+        decoded_frame=mp_dvdnav_decode_video_pre(&in_size,
+	    &start,decoded_frame);
+    // if stored image then do not call decode_video()
+    if (in_size>0 && !decoded_frame)
+#endif
 	decoded_frame = decode_video(sh_video, start, in_size, drop_frame,
 				     sh_video->pts);
+#ifdef USE_DVDNAV
+    if (mpctx->stream->type==STREAMTYPE_DVDNAV)
+        // call dvdnav video postprocess
+        decoded_frame=mp_dvdnav_decode_video_post(in_size,
+	    start,decoded_frame,sh_video, drop_frame);
+#endif
 	current_module = "filter_video";
 	*blit_frame = (decoded_frame && filter_video(sh_video, decoded_frame,
 						    sh_video->pts));
@@ -3458,6 +3658,17 @@
     end_at.type = END_AT_NONE;
 }
 
+#ifdef USE_DVDNAV
+// free stored image
+if (mpctx->smpi) free_mp_image(mpctx->smpi);
+mpctx->smpi=NULL;
+if (mpctx->stream->type==STREAMTYPE_DVDNAV) {
+    // enable read from dvdnav stream and set auto wait mode
+    mp_dvdnav_wait_read(mpctx->stream, 0, 1);
+    // clear cell change flag
+    mp_dvdnav_iscellchage(mpctx->stream,1);
+    }
+#endif
 
 while(!mpctx->eof){
     float aq_sleep_time=0;
diff -Naur MPlayer-r25688.orig/stream/stream_dvdnav.c MPlayer-r25688/stream/stream_dvdnav.c
--- MPlayer-r25688.orig/stream/stream_dvdnav.c	2008-01-12 13:55:20.000000000 +0100
+++ MPlayer-r25688/stream/stream_dvdnav.c	2008-01-12 16:21:46.000000000 +0100
@@ -12,6 +12,7 @@
 #include "libmpdemux/demuxer.h"
 #include <dvdnav/dvdnav.h>
 #include "stream_dvdnav.h"
+#include "stream_dvd_common.h"
 #include "libvo/video_out.h"
 #include "libavutil/common.h"
 #include "spudec.h"
@@ -27,12 +28,11 @@
   int              title;
   unsigned int     spu_clut[16], spu_set;
   dvdnav_highlight_event_t hlev;
+  int              still_length;        /* still frame duration */
+  unsigned int     status;
 } dvdnav_priv_t;
 
 extern char *dvd_device;
-extern int dvd_chapter;
-extern int dvd_last_chapter;
-extern int dvd_angle;
 extern char *audio_lang, *dvdsub_lang;
 extern char *dvd_audio_stream_channels[6], *dvd_audio_stream_types[8];
 
@@ -40,7 +40,7 @@
   int track;
   char* device;
 } stream_priv_dflts = {
-  0,
+  -1,
   NULL
 };
 
@@ -151,7 +151,9 @@
 
 static int dvdnav_stream_read(dvdnav_priv_t * priv, unsigned char *buf, int *len) {
   int event = DVDNAV_NOP;
-
+  uint32_t nextstill;
+  dvdnav_still_event_t *still_event;
+  
   *len=-1;
   if (dvdnav_get_next_block(priv->dvdnav,buf,&event,len)!=DVDNAV_STATUS_OK) {
     mp_msg(MSGT_OPEN,MSGL_V, "Error getting next block from DVD %d (%s)\n",event, dvdnav_err_to_string(priv->dvdnav) );
@@ -163,7 +165,18 @@
       case DVDNAV_NAV_PACKET:
         return event;
       case DVDNAV_STILL_FRAME: {
-        dvdnav_still_skip(priv->dvdnav); // don't let dvdnav stall on this image
+        still_event = (dvdnav_still_event_t*)(buf);
+        priv->still_length=still_event->length;
+        // set still frame duration
+        if (priv->still_length!=255)
+          priv->duration = priv->still_length * 1000;
+        else
+          priv->duration = 0;
+        // FIXME: TIME HACK
+        if (priv->still_length<=1) {
+          pci_t* pnavpci = dvdnav_get_current_nav_pci( priv->dvdnav );
+          priv->duration = mp_dvdtimetomsec(&(pnavpci->pci_gi.e_eltm));
+        }
         break;
       }
       case DVDNAV_HIGHLIGHT: {
@@ -171,19 +184,46 @@
         break;
       }
       case DVDNAV_CELL_CHANGE: {
+        priv->status &= ~NAV_FLAG_WAIT_SKIP;
+        priv->status |= NAV_FLAG_STREAM_CHANGE;
         dvdnav_cell_change_event_t *ev =  (dvdnav_cell_change_event_t*)buf;
         if(ev->pgc_length)
           priv->duration = ev->pgc_length/90;
+        if (dvdnav_is_domain_vts(priv->dvdnav))
+          priv->status &= ~NAV_FLAG_VTS_DOMAIN;
+        else
+          priv->status |= NAV_FLAG_VTS_DOMAIN;
+
+        nextstill = dvdnav_get_next_still_flag(priv->dvdnav);
+        if (nextstill) {
+          if (nextstill==0xff)
+            priv->duration=0;
+            else 
+            priv->duration=nextstill * 1000;
+          priv->still_length=nextstill;
+        }
         break;
       }
       case DVDNAV_SPU_CLUT_CHANGE: {
         memcpy(priv->spu_clut, buf, 16*sizeof(unsigned int));
-        priv->spu_set = 1;
+        priv->status |= NAV_FLAG_SPU_SET;
         break;
       }
-      case DVDNAV_WAIT:
-        dvdnav_wait_skip(priv->dvdnav);
+      case DVDNAV_WAIT: {
+        // if don't open demuxer then suspend read in dvdnav stream
+        // else wait skip
+        if ((priv->status & NAV_FLAG_WAIT_SKIP) &&
+            !(priv->status & NAV_FLAG_WAIT))
+          dvdnav_wait_skip(priv->dvdnav);
+        else
+          priv->status |= NAV_FLAG_WAIT;
+        break;
+      }
+      case DVDNAV_VTS_CHANGE: {
+        priv->status &= ~NAV_FLAG_WAIT_SKIP;
+        priv->status |= NAV_FLAG_STREAM_CHANGE;
         break;
+      }
     }
 
     *len=0;
@@ -240,6 +280,11 @@
     int event;
 
     dvdnav_priv_t* priv=s->priv;
+    // is suspend read
+    if (priv->status & NAV_FLAG_WAIT_READ) {
+      len=-1;
+      return len;
+    }
     len=0;
     if(!s->end_pos)
       update_title_len(s);
@@ -252,16 +297,29 @@
         return 0;
       }
       switch (event) {
-        case DVDNAV_STOP:
+        case DVDNAV_STOP: {
+          priv->status |= NAV_FLAG_EOFSTREAM;
+          return len;
+        }
         case DVDNAV_BLOCK_OK:
         case DVDNAV_NAV_PACKET:
           return len;
+        case DVDNAV_STILL_FRAME: return len;
+        case DVDNAV_WAIT: {
+          if (priv->status & NAV_FLAG_WAIT) return len;
+          break;
+        }
         case DVDNAV_VTS_CHANGE: {
           int tit = 0, part = 0;
           dvdnav_vts_change_event_t *vts_event = (dvdnav_vts_change_event_t *)s->buffer;
           mp_msg(MSGT_CPLAYER,MSGL_INFO, "DVDNAV, switched to title: %d\r\n", vts_event->new_vtsN);
+          priv->status |= NAV_FLAG_CELL_CHANGE;
+          priv->status &= ~NAV_FLAG_WAIT_SKIP;
+          priv->status &= ~NAV_FLAG_WAIT;
           s->end_pos = 0;
           update_title_len(s);
+          if (priv->status & NAV_FLAG_WAIT_READ_AUTO)
+            priv->status |= NAV_FLAG_WAIT_READ;
           if(dvdnav_current_title_info(priv->dvdnav, &tit, &part) == DVDNAV_STATUS_OK) {
             mp_msg(MSGT_CPLAYER,MSGL_V, "\r\nDVDNAV, NEW TITLE %d\r\n", tit);
             dvdnav_get_highlight (priv, 0);
@@ -271,6 +329,11 @@
           break;
         }
         case DVDNAV_CELL_CHANGE: {
+          priv->status |= NAV_FLAG_CELL_CHANGE;
+          priv->status &= ~NAV_FLAG_WAIT_SKIP;
+          priv->status &= ~NAV_FLAG_WAIT;
+          if (priv->status & NAV_FLAG_WAIT_READ_AUTO)
+            priv->status |= NAV_FLAG_WAIT_READ;
           if(priv->title > 0 && dvd_last_chapter > 0) {
             int tit=0, part=0;
             if(dvdnav_current_title_info(priv->dvdnav, &tit, &part) == DVDNAV_STATUS_OK && part > dvd_last_chapter)
@@ -320,7 +383,7 @@
     }
     case STREAM_CTRL_GET_TIME_LENGTH:
     {
-      if(priv->duration)
+      if (priv->duration || priv->still_length)
       {
         *((double *)arg) = (double)priv->duration / 1000.0;
         return 1;
@@ -487,11 +550,9 @@
     }
     if(dvd_chapter > 0)
       dvdnav_part_play(priv->dvdnav, p->track, dvd_chapter);
-  } else if(p->track == -1)
-    dvdnav_menu_call(priv->dvdnav, DVD_MENU_Root);
-  else {
-    mp_msg(MSGT_OPEN,MSGL_INFO,"dvdnav_stream, you didn't specify a track number (as in dvdnav://1), playing whole disc\n");
-    dvdnav_menu_call(priv->dvdnav, DVD_MENU_Title);
+  } else if (p->track == 0) {
+    if(dvdnav_menu_call(priv->dvdnav, DVD_MENU_Root) != DVDNAV_STATUS_OK)
+      dvdnav_menu_call(priv->dvdnav, DVD_MENU_Title);
   }
   if(mp_msg_test(MSGT_IDENTIFY, MSGL_INFO))
     identify(priv, p);
@@ -511,7 +572,7 @@
   *file_format = DEMUXER_TYPE_MPEG_PS;
 
   update_title_len(stream);
-  if(!stream->pos)
+  if(!stream->pos && p->track>0)
     mp_msg(MSGT_OPEN,MSGL_ERR, "INIT ERROR: couldn't get init pos %s\r\n", dvdnav_err_to_string(priv->dvdnav));
 
   mp_msg(MSGT_OPEN,MSGL_INFO, "Remember to disable MPlayer's cache when playing dvdnav:// streams (adding -nocache to your command line)\r\n");
@@ -520,15 +581,14 @@
 }
 
 
-int mp_dvdnav_handle_input(stream_t *stream, int cmd, int *button) {
+void mp_dvdnav_handle_input(stream_t *stream, int cmd, int *button) {
   dvdnav_priv_t * priv=(dvdnav_priv_t*)stream->priv;
   dvdnav_t *nav = priv->dvdnav;
   dvdnav_status_t status=DVDNAV_STATUS_ERR;
   pci_t *pci = dvdnav_get_current_nav_pci(nav);
-  int reset = 0;
 
   if(cmd != MP_CMD_DVDNAV_SELECT && !pci)
-    return 0;
+    return;
 
   switch(cmd) {
     case MP_CMD_DVDNAV_UP:
@@ -545,26 +605,22 @@
       break;
     case MP_CMD_DVDNAV_MENU:
       status = dvdnav_menu_call(nav,DVD_MENU_Root);
-      reset = 1;
       break;
     case MP_CMD_DVDNAV_PREVMENU: {
       int title=0, part=0;
 
       dvdnav_current_title_info(nav, &title, &part);
       if(title) {
-        if(dvdnav_menu_call(nav, DVD_MENU_Part) == DVDNAV_STATUS_OK
-           || dvdnav_menu_call(nav, DVD_MENU_Title) == DVDNAV_STATUS_OK) {
-          reset = 1;
+        if((status=dvdnav_menu_call(nav, DVD_MENU_Part)) == DVDNAV_STATUS_OK)
+          break;
+        if((status=dvdnav_menu_call(nav, DVD_MENU_Title)) == DVDNAV_STATUS_OK)
           break;
-        }
       }
-      if(dvdnav_menu_call(nav, DVD_MENU_Root) == DVDNAV_STATUS_OK)
-        reset = 1;
+      status=dvdnav_menu_call(nav, DVD_MENU_Root);
       }
       break;
     case MP_CMD_DVDNAV_SELECT:
       status = dvdnav_button_activate(nav, pci);
-      if(status == DVDNAV_STATUS_OK) reset = 1;
       break;
     case MP_CMD_DVDNAV_MOUSECLICK:
       /*
@@ -575,7 +631,6 @@
         This last call always works well
       */
       status = dvdnav_mouse_activate(nav, pci, priv->mousex, priv->mousey);
-      if(status == DVDNAV_STATUS_OK) reset = 1;
       break;
     default:
       mp_msg(MSGT_CPLAYER, MSGL_V, "Unknown DVDNAV cmd %d\n", cmd);
@@ -585,7 +640,7 @@
   if(status == DVDNAV_STATUS_OK)
     dvdnav_get_current_highlight(nav, button);
 
-  return reset;
+  return;
 }
 
 void mp_dvdnav_update_mouse_pos(stream_t *stream, int32_t x, int32_t y, int* button) {
@@ -740,7 +795,7 @@
  */
 unsigned int *mp_dvdnav_get_spu_clut(stream_t *stream) {
     dvdnav_priv_t *priv=(dvdnav_priv_t*)stream->priv;
-    if(!priv->spu_set) return NULL;
+    if (!(priv->status & NAV_FLAG_SPU_SET)) return NULL;
     return priv->spu_clut;
 }
 
@@ -759,6 +814,68 @@
   hl->ey = hlev.ey;
 }
 
+/**
+ * \brief mp_dvdnav_isreallyeof() get really EOF flag
+ * \param stream: - stream pointer
+ * \return 1 on really eof
+ */
+int mp_dvdnav_isreallyeof(stream_t *stream) {
+  return ((dvdnav_priv_t*) stream->priv )->status & NAV_FLAG_EOFSTREAM;
+}
+
+/**
+ * \brief mp_dvdnav_still_skip() call still skip
+ * \param stream: - stream pointer
+ * \return 0 on success
+ */
+int mp_dvdnav_still_skip(stream_t *stream) {
+  dvdnav_priv_t * priv=(dvdnav_priv_t*)stream->priv;
+  if (priv->still_length==0xff) return 1;
+  dvdnav_still_skip(priv->dvdnav);
+  return 0;
+}
+
+/**
+ * \brief mp_dvdnav_wait_skip() call wait skip
+ * \param stream: - stream pointer
+ * \return 0 on success
+ */
+int mp_dvdnav_wait_skip(stream_t *stream) {
+  dvdnav_priv_t * priv=(dvdnav_priv_t*)stream->priv;
+  if (!(priv->status & NAV_FLAG_WAIT)) return 1;
+  priv->status &= ~NAV_FLAG_WAIT;
+  dvdnav_wait_skip(priv->dvdnav);
+  return 0;
+}
+
+/**
+ * \brief mp_dvdnav_iscellchage() get cell change flag and clear this flag
+ * \param stream: - stream pointer
+ * \param clear : - if true then clear cell change flag
+ * \return 1 if cell change
+ */
+int mp_dvdnav_iscellchage(stream_t *stream, int clear) {
+  dvdnav_priv_t * priv=(dvdnav_priv_t*)stream->priv;
+  if (!(priv->status & NAV_FLAG_CELL_CHANGE)) return 0;
+  if (clear) priv->status &= ~NAV_FLAG_CELL_CHANGE;
+  return 1;
+}
+
+/**
+ * \brief mp_dvdnav_wait_read() set wait mode
+ * \param stream  : - stream pointer
+ * \param mode    : - if true then suspend block read
+ * \param automode: - if true then vts or cell change set wait mode
+ */
+void mp_dvdnav_wait_read(stream_t *stream, int mode, int automode) {
+  dvdnav_priv_t * priv=(dvdnav_priv_t*)stream->priv;
+  if (mode==0) priv->status &= ~NAV_FLAG_WAIT_READ;
+  if (mode>0) priv->status |= NAV_FLAG_WAIT_READ;
+  if (automode==0) priv->status &= ~NAV_FLAG_WAIT_READ_AUTO;
+  if (automode>0) priv->status |= NAV_FLAG_WAIT_READ_AUTO;
+  return;
+}
+
 const stream_info_t stream_info_dvdnav = {
   "DVDNAV stream",
   "null",
diff -Naur MPlayer-r25688.orig/stream/stream_dvdnav.h MPlayer-r25688/stream/stream_dvdnav.h
--- MPlayer-r25688.orig/stream/stream_dvdnav.h	2008-01-12 13:55:20.000000000 +0100
+++ MPlayer-r25688/stream/stream_dvdnav.h	2008-01-12 16:21:46.000000000 +0100
@@ -1,6 +1,17 @@
 #ifndef MPLAYER_STREAM_DVDNAV_H
 #define MPLAYER_STREAM_DVDNAV_H
 
+/* status flags */
+#define NAV_FLAG_EOFSTREAM      0x0001  /* stream eof flag */
+#define NAV_FLAG_WAIT           0x0002  /* wait event */
+#define NAV_FLAG_WAIT_SKIP      0x0004  /* wait skip disable */
+#define NAV_FLAG_CELL_CHANGE    0x0008  /* cell change event */
+#define NAV_FLAG_WAIT_READ_AUTO 0x0010  /* wait read auto mode (if opening demuxer then off else on) */
+#define NAV_FLAG_WAIT_READ      0x0020  /* wait read flag (suspend read from dvdnav stream */
+#define NAV_FLAG_STREAM_CHANGE  0x0040  /* stream change flag: title, part, audio or SPU */
+#define NAV_FLAG_VTS_DOMAIN     0x0080  /* vts domain */
+#define NAV_FLAG_SPU_SET        0x0100  /* spu_clut is valid */
+
 typedef struct {
   int event;             /* event number fromd dvdnav_events.h */
   void * details;        /* event details */
@@ -17,9 +28,14 @@
 int dvdnav_lang_from_aid(stream_t *stream, int id, unsigned char *buf);
 int dvdnav_sid_from_lang(stream_t *stream, unsigned char *language);
 int dvdnav_lang_from_sid(stream_t *stream, int sid, unsigned char *buf);
-int mp_dvdnav_handle_input(stream_t *stream, int cmd, int *button);
+void mp_dvdnav_handle_input(stream_t *stream, int cmd, int *button);
 void mp_dvdnav_update_mouse_pos(stream_t *stream, int32_t x, int32_t y, int* button);
 void mp_dvdnav_get_highlight (stream_t *stream, nav_highlight_t *hl);
 unsigned int *mp_dvdnav_get_spu_clut(stream_t *stream);
+int mp_dvdnav_isreallyeof(stream_t *stream);
+int mp_dvdnav_still_skip(stream_t *stream);
+int mp_dvdnav_wait_skip(stream_t *stream);
+int mp_dvdnav_iscellchage(stream_t *stream, int clear);
+void mp_dvdnav_wait_read(stream_t *stream, int mode, int automode);
 
 #endif /* MPLAYER_STREAM_DVDNAV_H */
