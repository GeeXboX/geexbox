From e20a0f14b5fdbff9afa5d0d6ee35de8728f6a200 Mon Sep 17 00:00:00 2001
From: Kristian HÃ¸gsberg <krh@bitplanet.net>
Date: Tue, 16 Oct 2012 18:30:53 +0000
Subject: wayland: Drop support for ill-defined, unused wl_egl_pixmap

It doesn't provide the cross-process buffer sharing that a window system
pixmap could otherwise support and we don't have anything left that uses
this type of surface.
---
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 089a5d7..9153ef9 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -108,7 +108,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
    struct dri2_egl_surface *dri2_surf;
-   struct dri2_egl_buffer *dri2_buf;
    int i;
 
    (void) drv;
@@ -146,17 +145,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       dri2_surf->base.Width =  -1;
       dri2_surf->base.Height = -1;
       break;
-   case EGL_PIXMAP_BIT:
-      dri2_surf->wl_pix = (struct wl_egl_pixmap *) window;
-
-      dri2_surf->base.Width  = dri2_surf->wl_pix->width;
-      dri2_surf->base.Height = dri2_surf->wl_pix->height;
-
-      if (dri2_surf->wl_pix->driver_private) {
-         dri2_buf = dri2_surf->wl_pix->driver_private;
-         dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] = dri2_buf->dri_buffer;
-      }
-      break;
    default: 
       goto cleanup_surf;
    }
@@ -194,15 +182,6 @@ dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
 			      window, attrib_list);
 }
 
-static _EGLSurface *
-dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
-			   _EGLConfig *conf, EGLNativePixmapType pixmap,
-			   const EGLint *attrib_list)
-{
-   return dri2_create_surface(drv, disp, EGL_PIXMAP_BIT, conf,
-			      pixmap, attrib_list);
-}
-
 /**
  * Called via eglDestroySurface(), drv->API.DestroySurface().
  */
@@ -225,8 +204,7 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
          wl_buffer_destroy(dri2_surf->wl_drm_buffer[i]);
 
    for (i = 0; i < __DRI_BUFFER_COUNT; ++i)
-      if (dri2_surf->dri_buffers[i] && !(i == __DRI_BUFFER_FRONT_LEFT &&
-          dri2_surf->base.Type == EGL_PIXMAP_BIT))
+      if (dri2_surf->dri_buffers[i])
          dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                        dri2_surf->dri_buffers[i]);
 
@@ -240,22 +218,6 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
    return EGL_TRUE;
 }
 
-static void
-dri2_wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct dri2_egl_buffer *dri2_buf = egl_pixmap->driver_private;
-
-   assert(dri2_buf);
-
-   dri2_buf->dri2_dpy->dri2->releaseBuffer(dri2_buf->dri2_dpy->dri_screen,
-                                           dri2_buf->dri_buffer);
-
-   free(dri2_buf);
-   
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
 static struct wl_buffer *
 wayland_create_buffer(struct dri2_egl_surface *dri2_surf,
                       __DRIbuffer *buffer)
@@ -296,30 +258,6 @@ dri2_process_back_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
 }
 
 static void
-dri2_process_front_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
-{
-   struct dri2_egl_display *dri2_dpy =
-      dri2_egl_display(dri2_surf->base.Resource.Display);
-   struct dri2_egl_buffer *dri2_buf;
-
-   switch (dri2_surf->base.Type) {
-   case EGL_PIXMAP_BIT:
-      dri2_buf = malloc(sizeof *dri2_buf);
-      if (!dri2_buf)
-         return;
-
-      dri2_buf->dri_buffer = dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT];
-      dri2_buf->dri2_dpy   = dri2_dpy;
-
-      dri2_surf->wl_pix->driver_private = dri2_buf;
-      dri2_surf->wl_pix->destroy        = dri2_wl_egl_pixmap_destroy;
-      break;
-   default:
-      break;
-   }
-}
-
-static void
 dri2_release_pending_buffer(void *data,
 			    struct wl_callback *callback, uint32_t time)
 {
@@ -496,9 +434,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
          if (!dri2_surf->dri_buffers[attachments[i]]) 
             continue;
 
-         if (attachments[i] == __DRI_BUFFER_FRONT_LEFT)
-            dri2_process_front_buffer(dri2_surf, attachments[i+1]);
-         else if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
+         if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
             dri2_process_back_buffer(dri2_surf, attachments[i+1]);
       }
 
@@ -509,13 +445,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
       dri2_surf->buffer_count++;
    }
 
-   assert(dri2_surf->base.Type == EGL_PIXMAP_BIT ||
-          dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
-
-   if (dri2_surf->base.Type == EGL_PIXMAP_BIT && !dri2_surf->wl_pix->buffer)
-      dri2_surf->wl_pix->buffer =
-         wayland_create_buffer(dri2_surf,
-			       dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT]);
+   assert(dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
 
    *out_count = dri2_surf->buffer_count;
    if (dri2_surf->buffer_count == 0)
@@ -659,71 +589,6 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
    return EGL_TRUE;
 }
 
-/**
- * Called via eglCreateImageKHR(), drv->API.CreateImageKHR().
- */
-static _EGLImage *
-dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
-			     EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct wl_egl_pixmap *wl_egl_pixmap = (struct wl_egl_pixmap *) buffer;
-   struct dri2_egl_buffer *dri2_buf;
-   EGLint wl_attr_list[] = {
-		EGL_WIDTH,		0,
-		EGL_HEIGHT,		0,
-		EGL_DRM_BUFFER_STRIDE_MESA,	0,
-		EGL_DRM_BUFFER_FORMAT_MESA,	EGL_DRM_BUFFER_FORMAT_ARGB32_MESA,
-		EGL_NONE
-   };
-
-   dri2_buf = malloc(sizeof *dri2_buf);
-   if (!dri2_buf)
-           return NULL;
-
-   dri2_buf->dri2_dpy = dri2_dpy;
-   dri2_buf->dri_buffer =
-      dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
-				     __DRI_BUFFER_FRONT_LEFT, 32,
-				     wl_egl_pixmap->width,
-				     wl_egl_pixmap->height);
-
-   wl_egl_pixmap->destroy = dri2_wl_egl_pixmap_destroy;
-   wl_egl_pixmap->driver_private = dri2_buf;
-
-   /* FIXME: Get buffer format from attr_list somehow... or from the
-      wl_egl_piaxmap.  */
-   wl_egl_pixmap->buffer =
-      wl_drm_create_buffer(dri2_dpy->wl_drm,
-			   dri2_buf->dri_buffer->name,
-			   wl_egl_pixmap->width,
-			   wl_egl_pixmap->height,
-			   dri2_buf->dri_buffer->pitch,
-			   WL_DRM_FORMAT_ARGB8888);
-
-   wl_attr_list[1] = wl_egl_pixmap->width;
-   wl_attr_list[3] = wl_egl_pixmap->height;
-   wl_attr_list[5] = dri2_buf->dri_buffer->pitch / 4;
-
-   return dri2_create_image_khr(disp->Driver, disp, ctx, EGL_DRM_BUFFER_MESA,
-	(EGLClientBuffer)(intptr_t) dri2_buf->dri_buffer->name, wl_attr_list);
-}
-
-static _EGLImage *
-dri2_wayland_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
-			      _EGLContext *ctx, EGLenum target,
-			      EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   (void) drv;
-
-   switch (target) {
-   case EGL_NATIVE_PIXMAP_KHR:
-      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
-   default:
-      return dri2_create_image_khr(drv, disp, ctx, target, buffer, attr_list);
-   }
-}
-
 static int
 dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
 {
@@ -858,10 +723,8 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
 
    drv->API.CreateWindowSurface = dri2_create_window_surface;
-   drv->API.CreatePixmapSurface = dri2_create_pixmap_surface;
    drv->API.DestroySurface = dri2_destroy_surface;
    drv->API.SwapBuffers = dri2_swap_buffers;
-   drv->API.CreateImageKHR = dri2_wayland_create_image_khr;
    drv->API.Terminate = dri2_terminate;
 
    dri2_dpy = calloc(1, sizeof *dri2_dpy);
@@ -917,7 +780,7 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    if (!dri2_create_screen(disp))
       goto cleanup_driver;
 
-   types = EGL_WINDOW_BIT | EGL_PIXMAP_BIT;
+   types = EGL_WINDOW_BIT;
    for (i = 0; dri2_dpy->driver_configs[i]; i++) {
       config = dri2_dpy->driver_configs[i];
       if (dri2_dpy->formats & HAS_XRGB8888)
@@ -926,8 +789,6 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
 	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
    }
 
-   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
-
    disp->Extensions.WL_bind_wayland_display = EGL_TRUE;
    dri2_dpy->authenticate = dri2_wayland_authenticate;
 
diff --git a/src/egl/wayland/wayland-egl/wayland-egl-priv.h b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
index accd2dd..bdbf32a 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl-priv.h
+++ b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
@@ -26,17 +26,6 @@ struct wl_egl_window {
 	int attached_height;
 };
 
-struct wl_egl_pixmap {
-	struct wl_buffer *buffer;
-
-	int width;
-	int height;
-
-	void (*destroy) (struct wl_egl_pixmap *egl_pixmap);
-
-	void *driver_private;
-};
-
 #ifdef  __cplusplus
 }
 #endif
diff --git a/src/egl/wayland/wayland-egl/wayland-egl.c b/src/egl/wayland/wayland-egl/wayland-egl.c
index e950b4a..c61fb4f 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl.c
+++ b/src/egl/wayland/wayland-egl/wayland-egl.c
@@ -48,36 +48,3 @@ wl_egl_window_get_attached_size(struct wl_egl_window *egl_window,
 	if (height)
 		*height = egl_window->attached_height;
 }
-
-WL_EGL_EXPORT struct wl_egl_pixmap *
-wl_egl_pixmap_create(int width, int height, uint32_t flags)
-{
-	struct wl_egl_pixmap *egl_pixmap;
-
-	egl_pixmap = malloc(sizeof *egl_pixmap);
-	if (egl_pixmap == NULL)
-		return NULL;
-
-	egl_pixmap->width   = width;
-	egl_pixmap->height  = height;
-
-	egl_pixmap->destroy = NULL;
-	egl_pixmap->buffer  = NULL;
-	egl_pixmap->driver_private = NULL;
-
-	return egl_pixmap;
-}
-
-WL_EGL_EXPORT void
-wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-	if (egl_pixmap->destroy)
-		egl_pixmap->destroy(egl_pixmap);
-	free(egl_pixmap);
-}
-
-WL_EGL_EXPORT struct wl_buffer *
-wl_egl_pixmap_create_buffer(struct wl_egl_pixmap *egl_pixmap)
-{
-	return egl_pixmap->buffer;
-}
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.c b/src/gallium/state_trackers/egl/wayland/native_wayland.c
index 635b65f..62c87f3 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.c
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.c
@@ -99,7 +99,6 @@ wayland_display_get_configs(struct native_display *ndpy, int *num_configs)
             (1 << NATIVE_ATTACHMENT_BACK_LEFT);
          
          nconf->window_bit = TRUE;
-         nconf->pixmap_bit = TRUE;
          
          nconf->color_format = wayland_formats[i].format;
          display->num_configs++;
@@ -138,49 +137,6 @@ wayland_display_get_param(struct native_display *ndpy,
    return val;
 }
 
-static boolean
-wayland_display_get_pixmap_format(struct native_display *ndpy,
-                                  EGLNativePixmapType pix,
-                                  enum pipe_format *format)
-{
-   /* all wl_egl_pixmaps are supported */
-   *format = PIPE_FORMAT_NONE;
-
-   return TRUE;
-}
-
-static void
-wayland_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct pipe_resource *resource = egl_pixmap->driver_private;
-
-   assert(resource);
-
-   pipe_resource_reference(&resource, NULL);
-   if (egl_pixmap->buffer) {
-      wl_buffer_destroy(egl_pixmap->buffer);
-      egl_pixmap->buffer = NULL;
-   }
-
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
-static void
-wayland_pixmap_surface_initialize(struct wayland_surface *surface)
-{
-   struct wayland_display *display = wayland_display(&surface->display->base);
-   const enum native_attachment front_natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-
-   if (surface->pix->buffer != NULL)
-      return;
-
-   surface->pix->buffer  = display->create_buffer(display, surface, front_natt);
-   surface->pix->destroy = wayland_pixmap_destroy;
-   surface->pix->driver_private =
-      resource_surface_get_single_resource(surface->rsurf, front_natt);
-}
-
 static void
 wayland_release_pending_resource(void *data,
                                  struct wl_callback *callback,
@@ -262,9 +218,6 @@ wayland_surface_validate(struct native_surface *nsurf, uint attachment_mask,
 
    resource_surface_get_size(surface->rsurf, (uint *) width, (uint *) height);
 
-   if (surface->type == WL_PIXMAP_SURFACE)
-      wayland_pixmap_surface_initialize(surface);
-
    return TRUE;
 }
 
@@ -407,61 +360,6 @@ wayland_surface_destroy(struct native_surface *nsurf)
 }
 
 
-
-static struct native_surface *
-wayland_create_pixmap_surface(struct native_display *ndpy,
-                              EGLNativePixmapType pix,
-                              const struct native_config *nconf)
-{
-   struct wayland_display *display = wayland_display(ndpy);
-   struct wayland_surface *surface;
-   struct wl_egl_pixmap *egl_pixmap = (struct wl_egl_pixmap *) pix;
-   enum native_attachment natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-   uint bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW |
-      PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT;
-
-   surface = CALLOC_STRUCT(wayland_surface);
-   if (!surface)
-      return NULL;
-
-   surface->display = display;
-
-   surface->pending_resource = NULL;
-   surface->type = WL_PIXMAP_SURFACE;
-   surface->pix = egl_pixmap;
-
-   if (nconf)
-      surface->color_format = nconf->color_format;
-   else /* FIXME: derive format from wl_visual */
-      surface->color_format = PIPE_FORMAT_B8G8R8A8_UNORM;
-
-   surface->attachment_mask = (1 << NATIVE_ATTACHMENT_FRONT_LEFT);
-
-   surface->rsurf = resource_surface_create(display->base.screen,
-                                            surface->color_format, bind);
-
-   if (!surface->rsurf) {
-      FREE(surface);
-      return NULL;
-   }
-
-   resource_surface_set_size(surface->rsurf,
-                             egl_pixmap->width, egl_pixmap->height);
-
-   /* the pixmap is already allocated, so import it */
-   if (surface->pix->buffer != NULL)
-      resource_surface_import_resource(surface->rsurf, natt,
-                                       surface->pix->driver_private);
-
-   surface->base.destroy = wayland_surface_destroy;
-   surface->base.present = wayland_surface_present;
-   surface->base.validate = wayland_surface_validate;
-   surface->base.wait = wayland_surface_wait;
-
-   return &surface->base;
-}
-
-
 static struct native_surface *
 wayland_create_window_surface(struct native_display *ndpy,
                               EGLNativeWindowType win,
@@ -536,10 +434,7 @@ native_create_display(void *dpy, boolean use_sw)
 
    display->base.get_param = wayland_display_get_param;
    display->base.get_configs = wayland_display_get_configs;
-   display->base.get_pixmap_format = wayland_display_get_pixmap_format;
-   display->base.copy_to_pixmap = native_display_copy_to_pixmap;
    display->base.create_window_surface = wayland_create_window_surface;
-   display->base.create_pixmap_surface = wayland_create_pixmap_surface;
 
    display->own_dpy = own_dpy;
 
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.h b/src/gallium/state_trackers/egl/wayland/native_wayland.h
index 268b3b7..b623fee 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.h
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.h
@@ -67,7 +67,6 @@ enum wayland_buffer_type {
 
 enum wayland_surface_type {
    WL_WINDOW_SURFACE,
-   WL_PIXMAP_SURFACE,
    WL_PBUFFER_SURFACE
 };
 
@@ -76,7 +75,6 @@ struct wayland_surface {
    struct wayland_display *display;
 
    struct wl_egl_window *win;
-   struct wl_egl_pixmap *pix;
    enum wayland_surface_type type;
    int dx, dy;
    struct resource_surface *rsurf;
--
cgit v0.9.0.2-2-gbebe
