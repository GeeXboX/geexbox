diff -urN xine-lib-1.2.6/include/xine/audio_decoder.h xine-lib-1.2.6_hg20140709/include/xine/audio_decoder.h
--- xine-lib-1.2.6/include/xine/audio_decoder.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/audio_decoder.h	2014-07-25 05:29:40.000000000 +0200
@@ -44,7 +44,7 @@
   /*
    * open a new instance of this plugin class
    */
-  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *this, xine_stream_t *stream);
+  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
    * free all class-related resources
    */
 
-  void (*dispose) (audio_decoder_class_t *this);
+  void (*dispose) (audio_decoder_class_t *self);
 };
 
 #define default_audio_decoder_class_dispose (void (*) (audio_decoder_class_t *this))free
@@ -78,24 +78,24 @@
    * decode data from buf and feed decoded samples to
    * audio output
    */
-  void (*decode_data) (audio_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (audio_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * audio data not related to recently decoded data)
    */
-  void (*reset) (audio_decoder_t *this);
+  void (*reset) (audio_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (audio_decoder_t *this);
+  void (*discontinuity) (audio_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (audio_decoder_t *this);
+  void (*dispose) (audio_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -urN xine-lib-1.2.6/include/xine/broadcaster.h xine-lib-1.2.6_hg20140709/include/xine/broadcaster.h
--- xine-lib-1.2.6/include/xine/broadcaster.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/broadcaster.h	2014-07-25 05:29:40.000000000 +0200
@@ -30,8 +30,8 @@
 typedef struct broadcaster_s broadcaster_t;
 
 broadcaster_t *_x_init_broadcaster(xine_stream_t *stream, int port) XINE_MALLOC XINE_PROTECTED;
-void _x_close_broadcaster(broadcaster_t *this) XINE_PROTECTED;
-int _x_get_broadcaster_port(broadcaster_t *this) XINE_PROTECTED;
+void _x_close_broadcaster(broadcaster_t *self) XINE_PROTECTED;
+int _x_get_broadcaster_port(broadcaster_t *self) XINE_PROTECTED;
 
 
 #ifdef __cplusplus
diff -urN xine-lib-1.2.6/include/xine/demux.h xine-lib-1.2.6_hg20140709/include/xine/demux.h
--- xine-lib-1.2.6/include/xine/demux.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/demux.h	2014-07-25 05:29:40.000000000 +0200
@@ -49,7 +49,7 @@
   /*
    * open a new instance of this plugin class
    */
-  demux_plugin_t* (*open_plugin) (demux_class_t *this, xine_stream_t *stream, input_plugin_t *input);
+  demux_plugin_t* (*open_plugin) (demux_class_t *self, xine_stream_t *stream, input_plugin_t *input);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -85,7 +85,7 @@
   /*
    * close down, free all resources
    */
-  void (*dispose) (demux_class_t *this);
+  void (*dispose) (demux_class_t *self);
 };
 
 #define default_demux_class_dispose (void (*) (demux_class_t *this))free
@@ -101,7 +101,7 @@
    * fifos, then return. do not start demux thread (yet)
    */
 
-  void (*send_headers) (demux_plugin_t *this);
+  void (*send_headers) (demux_plugin_t *self);
 
   /*
    * ask demux to seek
@@ -122,7 +122,7 @@
    *                           starting the demuxer)
    */
 
-  int (*seek) (demux_plugin_t *this,
+  int (*seek) (demux_plugin_t *self,
 	       off_t start_pos, int start_time, int playing );
 
   /*
@@ -135,37 +135,37 @@
    * the demux current status
    */
 
-  int (*send_chunk) (demux_plugin_t *this);
+  int (*send_chunk) (demux_plugin_t *self);
 
   /*
    * free resources
    */
 
-  void (*dispose) (demux_plugin_t *this) ;
+  void (*dispose) (demux_plugin_t *self) ;
 
   /*
    * returns DEMUX_OK or  DEMUX_FINISHED
    */
 
-  int (*get_status) (demux_plugin_t *this) ;
+  int (*get_status) (demux_plugin_t *self) ;
 
   /*
    * gets stream length in miliseconds (might be estimated)
    * may return 0 for non-seekable streams
    */
 
-  int (*get_stream_length) (demux_plugin_t *this);
+  int (*get_stream_length) (demux_plugin_t *self);
 
   /*
    * return capabilities of demuxed stream
    */
 
-  uint32_t (*get_capabilities) (demux_plugin_t *this);
+  uint32_t (*get_capabilities) (demux_plugin_t *self);
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (demux_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (demux_plugin_t *self, void *data, int data_type);
 
   /*
    * "backwards" link to plugin class
@@ -186,7 +186,7 @@
 #endif
 } ;
 
-#define default_demux_plugin_dispose (void (*) (demux_plugin_t *this))free
+#define default_demux_plugin_dispose (void (*) (demux_plugin_t *self))free
 
 /*
  * possible capabilites a demux plugin can have:
diff -urN xine-lib-1.2.6/include/xine/input_plugin.h xine-lib-1.2.6_hg20140709/include/xine/input_plugin.h
--- xine-lib-1.2.6/include/xine/input_plugin.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/input_plugin.h	2014-07-25 05:29:41.000000000 +0200
@@ -43,7 +43,7 @@
    * create a new instance of this plugin class
    * return NULL if the plugin does'nt handle the given mrl
    */
-  input_plugin_t* (*get_instance) (input_class_t *this, xine_stream_t *stream, const char *mrl);
+  input_plugin_t* (*get_instance) (input_class_t *self, xine_stream_t *stream, const char *mrl);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -66,28 +66,28 @@
    * ls function, optional: may be NULL
    * return value: NULL => filename is a file, **char=> filename is a dir
    */
-  xine_mrl_t ** (*get_dir) (input_class_t *this, const char *filename, int *nFiles);
+  xine_mrl_t ** (*get_dir) (input_class_t *self, const char *filename, int *nFiles);
 
   /*
    * generate autoplay list, optional: may be NULL
    * return value: list of MRLs
    */
-  const char * const * (*get_autoplay_list) (input_class_t *this, int *num_files);
+  const char * const * (*get_autoplay_list) (input_class_t *self, int *num_files);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (input_class_t *this);
+  void (*dispose) (input_class_t *self);
 
   /*
    * eject/load the media (if possible), optional: may be NULL
    *
    * returns 0 for temporary failures
    */
-  int (*eject_media) (input_class_t *this);
+  int (*eject_media) (input_class_t *self);
 };
 
-#define default_input_class_dispose (void (*) (input_class_t *this))free
+#define default_input_class_dispose (void (*) (input_class_t *self))free
 
 struct input_plugin_s {
 
@@ -95,7 +95,7 @@
    * open the stream
    * return 0 if an error occured
    */
-  int (*open) (input_plugin_t *this);
+  int (*open) (input_plugin_t *self);
 
   /*
    * return capabilities of the current playable entity. See
@@ -113,14 +113,14 @@
    * make a best-effort attempt to seek, e.g. at least
    * relative forward seeking should work.
    */
-  uint32_t (*get_capabilities) (input_plugin_t *this);
+  uint32_t (*get_capabilities) (input_plugin_t *self);
 
   /*
    * read nlen bytes, return number of bytes read
    * Should block until some bytes available for read;
    * a return value of 0 indicates no data available
    */
-  off_t (*read) (input_plugin_t *this, void *buf, off_t nlen);
+  off_t (*read) (input_plugin_t *self, void *buf, off_t nlen);
 
 
   /*
@@ -128,7 +128,7 @@
    * for blocked input sources len must be == blocksize
    * the fifo parameter is only used to get access to the buffer_pool_alloc function
    */
-  buf_element_t *(*read_block)(input_plugin_t *this, fifo_buffer_t *fifo, off_t len);
+  buf_element_t *(*read_block)(input_plugin_t *self, fifo_buffer_t *fifo, off_t len);
 
 
   /*
@@ -136,7 +136,7 @@
    *
    * if seeking failed, -1 is returned
    */
-  off_t (*seek) (input_plugin_t *this, off_t offset, int origin);
+  off_t (*seek) (input_plugin_t *self, off_t offset, int origin);
 
 
   /*
@@ -148,14 +148,14 @@
    * note: only SEEK_SET (0) is currently supported as origin
    * note: may be NULL is not supported
    */
-  off_t (*seek_time) (input_plugin_t *this, int time_offset, int origin);
+  off_t (*seek_time) (input_plugin_t *self, int time_offset, int origin);
 
 
   /*
    * get current position in stream.
    *
    */
-  off_t (*get_current_pos) (input_plugin_t *this);
+  off_t (*get_current_pos) (input_plugin_t *self);
 
 
   /*
@@ -163,7 +163,7 @@
    *
    * note: may be NULL is not supported
    */
-  int (*get_current_time) (input_plugin_t *this);
+  int (*get_current_time) (input_plugin_t *self);
 
 
   /*
@@ -183,7 +183,7 @@
    * absolute or relative play position or possibly calculating the
    * bit rate.
    */
-  off_t (*get_length) (input_plugin_t *this);
+  off_t (*get_length) (input_plugin_t *self);
 
 
   /*
@@ -199,25 +199,25 @@
    * make this function simply return 0 if unsure.
    */
 
-  uint32_t (*get_blocksize) (input_plugin_t *this);
+  uint32_t (*get_blocksize) (input_plugin_t *self);
 
 
   /*
    * return current MRL
    */
-  const char * (*get_mrl) (input_plugin_t *this);
+  const char * (*get_mrl) (input_plugin_t *self);
 
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (input_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (input_plugin_t *self, void *data, int data_type);
 
 
   /*
    * close stream, free instance resources
    */
-  void (*dispose) (input_plugin_t *this);
+  void (*dispose) (input_plugin_t *self);
 
   /*
    * "backward" link to input plugin class struct
diff -urN xine-lib-1.2.6/include/xine/osd.h xine-lib-1.2.6_hg20140709/include/xine/osd.h
--- xine-lib-1.2.6/include/xine/osd.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/osd.h	2014-07-25 05:29:40.000000000 +0200
@@ -91,7 +91,7 @@
    * A default palette is initialized (i sugest keeping color 0 as transparent
    * for the sake of simplicity)
    */
-  osd_object_t* (*new_object) (osd_renderer_t *this, int width, int height);
+  osd_object_t* (*new_object) (osd_renderer_t *self, int width, int height);
 
   /*
    * free osd object
@@ -194,7 +194,7 @@
    * loaded fonts are unloaded
    * osd objects are closed
    */
-  void (*close) (osd_renderer_t *this);
+  void (*close) (osd_renderer_t *self);
 
   /*
    * clear an osd object (empty drawing area)
@@ -215,6 +215,10 @@
    */
   int (*show_unscaled) (osd_object_t *osd, int64_t vpts );
 
+
+
+  int (*show_scaled) (osd_object_t *osd, int64_t vpts );
+
   /*
    * see xine.h for defined XINE_OSD_CAP_ values.
    */
diff -urN xine-lib-1.2.6/include/xine/scratch.h xine-lib-1.2.6_hg20140709/include/xine/scratch.h
--- xine-lib-1.2.6/include/xine/scratch.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/scratch.h	2014-07-25 05:29:40.000000000 +0200
@@ -33,11 +33,11 @@
 struct scratch_buffer_s {
 
   void         XINE_FORMAT_PRINTF(2, 0)
-               (*scratch_printf) (scratch_buffer_t *this, const char *format, va_list ap);
+               (*scratch_printf) (scratch_buffer_t *self, const char *format, va_list ap);
 
-  char       **(*get_content) (scratch_buffer_t *this);
+  char       **(*get_content) (scratch_buffer_t *self);
 
-  void         (*dispose) (scratch_buffer_t *this);
+  void         (*dispose) (scratch_buffer_t *self);
 
   char         **lines;
   char         **ordered;
diff -urN xine-lib-1.2.6/include/xine/spu_decoder.h xine-lib-1.2.6_hg20140709/include/xine/spu_decoder.h
--- xine-lib-1.2.6/include/xine/spu_decoder.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/spu_decoder.h	2013-03-03 08:54:34.000000000 +0100
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *this, xine_stream_t *stream);
+  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (spu_decoder_class_t *this);
+  void (*dispose) (spu_decoder_class_t *self);
 };
 
 #define default_spu_decoder_class_dispose (void (*) (spu_decoder_class_t *this))free
@@ -77,24 +77,24 @@
   /*
    * decode data from buf and feed the overlay to overlay manager
    */
-  void (*decode_data) (spu_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (spu_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * SPU data not related to recently decoded data)
    */
-  void (*reset) (spu_decoder_t *this);
+  void (*reset) (spu_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (spu_decoder_t *this);
+  void (*discontinuity) (spu_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (spu_decoder_t *this);
+  void (*dispose) (spu_decoder_t *self);
 
   /*
    * When the SPU decoder also handles data used in user interaction,
@@ -106,7 +106,7 @@
    * This function pointer may be NULL, if the plugin does not have
    * such functionality.
    */
-  int  (*get_interact_info) (spu_decoder_t *this, void *data);
+  int  (*get_interact_info) (spu_decoder_t *self, void *data);
 
   /*
    * When the SPU decoder also handles menu overlays for user inter-
diff -urN xine-lib-1.2.6/include/xine/video_decoder.h xine-lib-1.2.6_hg20140709/include/xine/video_decoder.h
--- xine-lib-1.2.6/include/xine/video_decoder.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/video_decoder.h	2014-07-25 05:29:40.000000000 +0200
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  video_decoder_t* (*open_plugin) (video_decoder_class_t *this, xine_stream_t *stream);
+  video_decoder_t* (*open_plugin) (video_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (video_decoder_class_t *this);
+  void (*dispose) (video_decoder_class_t *self);
 };
 
 #define default_video_decoder_class_dispose (void (*) (video_decoder_class_t *this))free
@@ -78,29 +78,29 @@
    * decode data from buf and feed decoded frames to
    * video output
    */
-  void (*decode_data) (video_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (video_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * video data not related to recently decoded data)
    */
-  void (*reset) (video_decoder_t *this);
+  void (*reset) (video_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (video_decoder_t *this);
+  void (*discontinuity) (video_decoder_t *self);
 
   /*
    * flush out any frames that are still stored in the decoder
    */
-  void (*flush) (video_decoder_t *this);
+  void (*flush) (video_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (video_decoder_t *this);
+  void (*dispose) (video_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -urN xine-lib-1.2.6/include/xine/video_out.h xine-lib-1.2.6_hg20140709/include/xine/video_out.h
--- xine-lib-1.2.6/include/xine/video_out.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/video_out.h	2014-07-25 05:29:41.000000000 +0200
@@ -268,7 +268,10 @@
 #define VO_PROP_BUFS_FREE             27 /* read-only */
 #define VO_PROP_MAX_VIDEO_WIDTH       28 /* read-only */
 #define VO_PROP_MAX_VIDEO_HEIGHT      29 /* read-only */
-#define VO_NUM_PROPERTIES             30
+#define VO_PROP_LAST_PTS              30
+#define VO_PROP_DEINTERLACE_SD        31
+#define VO_PROP_DEINTERLACE_HD        32
+#define VO_NUM_PROPERTIES             33
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
diff -urN xine-lib-1.2.6/include/xine/xine_internal.h xine-lib-1.2.6_hg20140709/include/xine/xine_internal.h
--- xine-lib-1.2.6/include/xine/xine_internal.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine/xine_internal.h	2014-07-25 05:29:41.000000000 +0200
@@ -495,7 +495,7 @@
  * load a specific video output plugin
  */
 
-vo_driver_t *_x_load_video_output_plugin(xine_t *this,
+vo_driver_t *_x_load_video_output_plugin(xine_t *self,
 					 char *id, int visual_type, void *visual) XINE_PROTECTED;
 
 /*
diff -urN xine-lib-1.2.6/include/xine.h xine-lib-1.2.6_hg20140709/include/xine.h
--- xine-lib-1.2.6/include/xine.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/include/xine.h	2014-07-25 05:29:40.000000000 +0200
@@ -1750,6 +1750,7 @@
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
 #define XINE_EVENT_NBC_STATS             15 /* nbc buffer status */
+#define XINE_EVENT_FRAMERATE_CHANGE      16
 
 
 /* input events coming from frontend */
@@ -1841,6 +1842,10 @@
 /* events generated from post plugins */
 #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
 
+#define XINE_EVENT_SET_VIDEO_STREAMTYPE 501
+#define XINE_EVENT_SET_AUDIO_STREAMTYPE 502
+
+
 /*
  * xine event struct
  */
@@ -1874,6 +1879,11 @@
   char                str[256]; /* might be longer */
 } xine_ui_data_t;
 
+typedef struct {
+  int                 pid;
+  int                 streamtype;
+} xine_streamtype_data_t;
+
 /*
  * Send messages to UI. used mostly to report errors.
  */
@@ -1952,6 +1962,10 @@
   int                 type;         /* 0=buffer put, 1=buffer get */
 } xine_nbc_stats_data_t;
 
+typedef struct {
+  int64_t             framerate;
+} xine_framerate_data_t;
+
 /*
  * mrl reference data is sent by demuxers when a reference stream is found.
  * this stream just contains pointers (urls) to the real data, which are
@@ -2242,6 +2256,7 @@
 void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
 void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_scaled   (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 /* empty drawing area */
 void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
diff -urN xine-lib-1.2.6/misc/Makefile.plugins xine-lib-1.2.6_hg20140709/misc/Makefile.plugins
--- xine-lib-1.2.6/misc/Makefile.plugins	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/misc/Makefile.plugins	2013-06-16 03:56:51.000000000 +0200
@@ -0,0 +1 @@
+DESTDIR:=$(if $(DESTDIR),$(DESTDIR),/)
diff -urN xine-lib-1.2.6/src/combined/ffmpeg/avcodec_video.list xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/avcodec_video.list
--- xine-lib-1.2.6/src/combined/ffmpeg/avcodec_video.list	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/avcodec_video.list	2013-03-27 01:53:21.000000000 +0100
@@ -0,0 +1,166 @@
+CODEC_ID_MPEG1VIDEO
+CODEC_ID_MPEG2VIDEO
+CODEC_ID_MPEG2VIDEO_XVMC
+CODEC_ID_H261
+CODEC_ID_H263
+CODEC_ID_RV10
+CODEC_ID_RV20
+CODEC_ID_MJPEG
+CODEC_ID_MJPEGB
+CODEC_ID_LJPEG
+CODEC_ID_SP5X
+CODEC_ID_JPEGLS
+CODEC_ID_MPEG4
+CODEC_ID_RAWVIDEO
+CODEC_ID_MSMPEG4V1
+CODEC_ID_MSMPEG4V2
+CODEC_ID_MSMPEG4V3
+CODEC_ID_WMV1
+CODEC_ID_WMV2
+CODEC_ID_H263P
+CODEC_ID_H263I
+CODEC_ID_FLV1
+CODEC_ID_SVQ1
+CODEC_ID_SVQ3
+CODEC_ID_DVVIDEO
+CODEC_ID_HUFFYUV
+CODEC_ID_CYUV
+CODEC_ID_H264
+CODEC_ID_INDEO3
+CODEC_ID_VP3
+CODEC_ID_THEORA
+CODEC_ID_ASV1
+CODEC_ID_ASV2
+CODEC_ID_FFV1
+CODEC_ID_4XM
+CODEC_ID_VCR1
+CODEC_ID_CLJR
+CODEC_ID_MDEC
+CODEC_ID_ROQ
+CODEC_ID_INTERPLAY_VIDEO
+CODEC_ID_XAN_WC3
+CODEC_ID_XAN_WC4
+CODEC_ID_RPZA
+CODEC_ID_CINEPAK
+CODEC_ID_WS_VQA
+CODEC_ID_MSRLE
+CODEC_ID_MSVIDEO1
+CODEC_ID_IDCIN
+CODEC_ID_8BPS
+CODEC_ID_SMC
+CODEC_ID_FLIC
+CODEC_ID_TRUEMOTION1
+CODEC_ID_VMDVIDEO
+CODEC_ID_MSZH
+CODEC_ID_ZLIB
+CODEC_ID_QTRLE
+CODEC_ID_SNOW
+CODEC_ID_TSCC
+CODEC_ID_ULTI
+CODEC_ID_QDRAW
+CODEC_ID_VIXL
+CODEC_ID_QPEG
+CODEC_ID_PNG
+CODEC_ID_PPM
+CODEC_ID_PBM
+CODEC_ID_PGM
+CODEC_ID_PGMYUV
+CODEC_ID_PAM
+CODEC_ID_FFVHUFF
+CODEC_ID_RV30
+CODEC_ID_RV40
+CODEC_ID_VC1
+CODEC_ID_WMV3
+CODEC_ID_LOCO
+CODEC_ID_WNV1
+CODEC_ID_AASC
+CODEC_ID_INDEO2
+CODEC_ID_FRAPS
+CODEC_ID_TRUEMOTION2
+CODEC_ID_BMP
+CODEC_ID_CSCD
+CODEC_ID_MMVIDEO
+CODEC_ID_ZMBV
+CODEC_ID_AVS
+CODEC_ID_SMACKVIDEO
+CODEC_ID_NUV
+CODEC_ID_KMVC
+CODEC_ID_FLASHSV
+CODEC_ID_CAVS
+CODEC_ID_JPEG2000
+CODEC_ID_VMNC
+CODEC_ID_VP5
+CODEC_ID_VP6
+CODEC_ID_VP6F
+CODEC_ID_TARGA
+CODEC_ID_DSICINVIDEO
+CODEC_ID_TIERTEXSEQVIDEO
+CODEC_ID_TIFF
+CODEC_ID_GIF
+CODEC_ID_FFH264
+CODEC_ID_DXA
+CODEC_ID_DNXHD
+CODEC_ID_THP
+CODEC_ID_SGI
+CODEC_ID_C93
+CODEC_ID_BETHSOFTVID
+CODEC_ID_PTX
+CODEC_ID_TXD
+CODEC_ID_VP6A
+CODEC_ID_AMV
+CODEC_ID_VB
+CODEC_ID_PCX
+CODEC_ID_SUNRAST
+CODEC_ID_INDEO4
+CODEC_ID_INDEO5
+CODEC_ID_MIMIC
+CODEC_ID_RL2
+CODEC_ID_8SVX_EXP
+CODEC_ID_8SVX_FIB
+CODEC_ID_ESCAPE124
+CODEC_ID_DIRAC
+CODEC_ID_BFI
+CODEC_ID_CMV
+CODEC_ID_MOTIONPIXELS
+CODEC_ID_TGV
+CODEC_ID_TGQ
+CODEC_ID_TQI
+CODEC_ID_AURA
+CODEC_ID_AURA2
+CODEC_ID_V210X
+CODEC_ID_TMV
+CODEC_ID_V210
+CODEC_ID_DPX
+CODEC_ID_MAD
+CODEC_ID_FRWU
+CODEC_ID_FLASHSV2
+CODEC_ID_CDGRAPHICS
+CODEC_ID_R210
+CODEC_ID_ANM
+CODEC_ID_BINKVIDEO
+CODEC_ID_IFF_ILBM
+CODEC_ID_IFF_BYTERUN1
+CODEC_ID_KGV1
+CODEC_ID_YOP
+CODEC_ID_VP8
+CODEC_ID_PICTOR
+CODEC_ID_ANSI
+CODEC_ID_A64_MULTI
+CODEC_ID_A64_MULTI5
+CODEC_ID_R10K
+CODEC_ID_MXPEG
+CODEC_ID_LAGARITH
+CODEC_ID_PRORES
+CODEC_ID_JV
+CODEC_ID_DFA
+CODEC_ID_WMV3IMAGE
+CODEC_ID_VC1IMAGE
+CODEC_ID_G723_1
+CODEC_ID_G729
+CODEC_ID_UTVIDEO
+CODEC_ID_BMV_VIDEO
+CODEC_ID_VBLE
+CODEC_ID_DXTORY
+CODEC_ID_V410
+CODEC_ID_FIRST_AUDIO 
+CODEC_ID_PCM_S16LE 
diff -urN xine-lib-1.2.6/src/combined/ffmpeg/ff_audio_list.h xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/ff_audio_list.h
--- xine-lib-1.2.6/src/combined/ffmpeg/ff_audio_list.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/ff_audio_list.h	2013-03-27 01:53:21.000000000 +0100
@@ -0,0 +1,81 @@
+#ifndef AV_VERSION_INT
+# define AV_VERSION_INT(a,b,c) 0x7FFFFFFF
+#endif
+static const ff_codec_t ff_audio_lookup[] = {
+  { BUF_AUDIO_WMAV1, CODEC_ID_WMAV1, "MS Windows Media Audio 1 (ffmpeg)" },
+  { BUF_AUDIO_WMAV2, CODEC_ID_WMAV2, "MS Windows Media Audio 2 (ffmpeg)" },
+  { BUF_AUDIO_WMAPRO, CODEC_ID_WMAPRO, "MS Windows Media Audio Professional (ffmpeg)" },
+  { BUF_AUDIO_28_8, CODEC_ID_RA_288, "Real 28.8 (ffmpeg)" },
+  { BUF_AUDIO_MPEG, CODEC_ID_MP3, "MP3 (ffmpeg)" },
+  { BUF_AUDIO_MP3ADU, CODEC_ID_MP3ADU, "MPEG-3 adu (ffmpeg)" },
+  { BUF_AUDIO_MSADPCM, CODEC_ID_ADPCM_MS, "MS ADPCM (ffmpeg)" },
+  { BUF_AUDIO_MSIMAADPCM, CODEC_ID_ADPCM_IMA_WAV, "MS IMA ADPCM (ffmpeg)" },
+  { BUF_AUDIO_DK3ADPCM, CODEC_ID_ADPCM_IMA_DK3, "Duck DK3 ADPCM (ffmpeg)" },
+  { BUF_AUDIO_DK4ADPCM, CODEC_ID_ADPCM_IMA_DK4, "Duck DK4 ADPCM (ffmpeg)" },
+  { BUF_AUDIO_VQA_IMA, CODEC_ID_ADPCM_IMA_WS, "Westwood Studios IMA (ffmpeg)" },
+  { BUF_AUDIO_SMJPEG_IMA, CODEC_ID_ADPCM_IMA_SMJPEG, "SMJPEG IMA (ffmpeg)" },
+  { BUF_AUDIO_XA_ADPCM, CODEC_ID_ADPCM_XA, "CD-ROM/XA ADPCM (ffmpeg)" },
+  { BUF_AUDIO_4X_ADPCM, CODEC_ID_ADPCM_4XM, "4X ADPCM (ffmpeg)" },
+  { BUF_AUDIO_EA_ADPCM, CODEC_ID_ADPCM_EA, "Electronic Arts ADPCM (ffmpeg)" },
+  { BUF_AUDIO_MULAW, CODEC_ID_PCM_MULAW, "mu-law logarithmic PCM (ffmpeg)" },
+  { BUF_AUDIO_ALAW, CODEC_ID_PCM_ALAW, "A-law logarithmic PCM (ffmpeg)" },
+  { BUF_AUDIO_INTERPLAY, CODEC_ID_INTERPLAY_DPCM, "Interplay DPCM (ffmpeg)" },
+  { BUF_AUDIO_MAC3, CODEC_ID_MACE3, "MACE 3:1 (ffmpeg)" },
+  { BUF_AUDIO_MAC6, CODEC_ID_MACE6, "MACE 6:1 (ffmpeg)" },
+  { BUF_AUDIO_XAN_DPCM, CODEC_ID_XAN_DPCM, "Origin Xan DPCM (ffmpeg)" },
+  { BUF_AUDIO_VMD, CODEC_ID_VMDAUDIO, "Sierra VMD Audio (ffmpeg)" },
+  { BUF_AUDIO_FLAC, CODEC_ID_FLAC, "FLAC (ffmpeg)" },
+  { BUF_AUDIO_SHORTEN, CODEC_ID_SHORTEN, "Shorten (ffmpeg)" },
+  { BUF_AUDIO_ALAC, CODEC_ID_ALAC, "ALAC (ffmpeg)" },
+  { BUF_AUDIO_QDESIGN2, CODEC_ID_QDM2, "QDesign (ffmpeg)" },
+  { BUF_AUDIO_COOK, CODEC_ID_COOK, "RealAudio Cooker (ffmpeg)" },
+  { BUF_AUDIO_TRUESPEECH, CODEC_ID_TRUESPEECH, "TrueSpeech (ffmpeg)" },
+  { BUF_AUDIO_TTA, CODEC_ID_TTA, "True Audio Lossless (ffmpeg)" },
+  { BUF_AUDIO_SMACKER, CODEC_ID_SMACKAUDIO, "Smacker (ffmpeg)" },
+  { BUF_AUDIO_FLVADPCM, CODEC_ID_ADPCM_SWF, "Flash ADPCM (ffmpeg)" },
+  { BUF_AUDIO_WAVPACK, CODEC_ID_WAVPACK, "WavPack (ffmpeg)" },
+  { BUF_AUDIO_AMR_WB, CODEC_ID_AMR_WB, "AMR wide band (ffmpeg)" },
+  { BUF_AUDIO_EAC3, CODEC_ID_EAC3, "E-AC-3 (ffmpeg)" },
+  { BUF_AUDIO_AAC, CODEC_ID_AAC, "MPEG4 (ffmpeg)" },
+  { BUF_AUDIO_AAC_LATM, CODEC_ID_AAC_LATM, "AAC LATM (ffmpeg)" },
+};
+
+static uint32_t supported_audio_types[] = {
+  BUF_AUDIO_WMAV1,
+  BUF_AUDIO_WMAV2,
+  BUF_AUDIO_WMAPRO,
+  BUF_AUDIO_28_8,
+  BUF_AUDIO_MPEG,
+  BUF_AUDIO_MP3ADU,
+  BUF_AUDIO_MSADPCM,
+  BUF_AUDIO_MSIMAADPCM,
+  BUF_AUDIO_DK3ADPCM,
+  BUF_AUDIO_DK4ADPCM,
+  BUF_AUDIO_VQA_IMA,
+  BUF_AUDIO_SMJPEG_IMA,
+  BUF_AUDIO_XA_ADPCM,
+  BUF_AUDIO_4X_ADPCM,
+  BUF_AUDIO_EA_ADPCM,
+  BUF_AUDIO_MULAW,
+  BUF_AUDIO_ALAW,
+  BUF_AUDIO_INTERPLAY,
+  BUF_AUDIO_MAC3,
+  BUF_AUDIO_MAC6,
+  BUF_AUDIO_XAN_DPCM,
+  BUF_AUDIO_VMD,
+  BUF_AUDIO_FLAC,
+  BUF_AUDIO_SHORTEN,
+  BUF_AUDIO_ALAC,
+  BUF_AUDIO_QDESIGN2,
+  BUF_AUDIO_COOK,
+  BUF_AUDIO_TRUESPEECH,
+  BUF_AUDIO_TTA,
+  BUF_AUDIO_SMACKER,
+  BUF_AUDIO_FLVADPCM,
+  BUF_AUDIO_WAVPACK,
+  BUF_AUDIO_AMR_WB,
+  BUF_AUDIO_EAC3,
+  BUF_AUDIO_AAC,
+  BUF_AUDIO_AAC_LATM,
+  0,
+};
diff -urN xine-lib-1.2.6/src/combined/ffmpeg/ff_video_list.h xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/ff_video_list.h
--- xine-lib-1.2.6/src/combined/ffmpeg/ff_video_list.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/combined/ffmpeg/ff_video_list.h	2013-03-27 01:53:21.000000000 +0100
@@ -0,0 +1,169 @@
+#ifndef AV_VERSION_INT
+# define AV_VERSION_INT(a,b,c) 0x7FFFFFFF
+#endif
+static const ff_codec_t ff_video_lookup[] = {
+  { BUF_VIDEO_MSMPEG4_V1, CODEC_ID_MSMPEG4V1, "Microsoft MPEG-4 v1 (ffmpeg)" },
+  { BUF_VIDEO_MSMPEG4_V2, CODEC_ID_MSMPEG4V2, "Microsoft MPEG-4 v2 (ffmpeg)" },
+  { BUF_VIDEO_MSMPEG4_V3, CODEC_ID_MSMPEG4V3, "Microsoft MPEG-4 v3 (ffmpeg)" },
+  { BUF_VIDEO_WMV7, CODEC_ID_WMV1, "MS Windows Media Video 7 (ffmpeg)" },
+  { BUF_VIDEO_WMV8, CODEC_ID_WMV2, "MS Windows Media Video 8 (ffmpeg)" },
+  { BUF_VIDEO_WMV9, CODEC_ID_WMV3, "MS Windows Media Video 9 (ffmpeg)" },
+  { BUF_VIDEO_VC1, CODEC_ID_VC1, "MS Windows Media Video VC-1 (ffmpeg)" },
+  { BUF_VIDEO_MPEG4, CODEC_ID_MPEG4, "ISO MPEG-4 (ffmpeg)" },
+  { BUF_VIDEO_XVID, CODEC_ID_MPEG4, "ISO MPEG-4 (XviD) (ffmpeg)" },
+  { BUF_VIDEO_DIVX5, CODEC_ID_MPEG4, "ISO MPEG-4 (DivX5) (ffmpeg)" },
+  { BUF_VIDEO_3IVX, CODEC_ID_MPEG4, "ISO MPEG-4 (3ivx) (ffmpeg)" },
+  { BUF_VIDEO_JPEG, CODEC_ID_MJPEG, "Motion JPEG (ffmpeg)" },
+  { BUF_VIDEO_MJPEG, CODEC_ID_MJPEG, "Motion JPEG (ffmpeg)" },
+  { BUF_VIDEO_MJPEG_B, CODEC_ID_MJPEGB, "Motion JPEG B (ffmpeg)" },
+  { BUF_VIDEO_I263, CODEC_ID_H263I, "ITU H.263 (ffmpeg)" },
+  { BUF_VIDEO_H263, CODEC_ID_H263, "H.263 (ffmpeg)" },
+  { BUF_VIDEO_RV10, CODEC_ID_RV10, "Real Video 1.0 (ffmpeg)" },
+  { BUF_VIDEO_RV20, CODEC_ID_RV20, "Real Video 2.0 (ffmpeg)" },
+  { BUF_VIDEO_RV30, CODEC_ID_RV30, "Real Video 3.0 (ffmpeg)" },
+  { BUF_VIDEO_RV40, CODEC_ID_RV40, "Real Video 4.0 (ffmpeg)" },
+  { BUF_VIDEO_IV31, CODEC_ID_INDEO3, "Indeo Video 3.1 (ffmpeg)" },
+  { BUF_VIDEO_IV32, CODEC_ID_INDEO3, "Indeo Video 3.2 (ffmpeg)" },
+  { BUF_VIDEO_SORENSON_V1, CODEC_ID_SVQ1, "Sorenson Video 1 (ffmpeg)" },
+  { BUF_VIDEO_SORENSON_V3, CODEC_ID_SVQ3, "Sorenson Video 3 (ffmpeg)" },
+  { BUF_VIDEO_DV, CODEC_ID_DVVIDEO, "DV (ffmpeg)" },
+  { BUF_VIDEO_HUFFYUV, CODEC_ID_HUFFYUV, "HuffYUV (ffmpeg)" },
+  { BUF_VIDEO_VP31, CODEC_ID_VP3, "On2 VP3.1 (ffmpeg)" },
+  { BUF_VIDEO_VP5, CODEC_ID_VP5, "On2 VP5 (ffmpeg)" },
+  { BUF_VIDEO_VP6, CODEC_ID_VP6, "On2 VP6 (ffmpeg)" },
+  { BUF_VIDEO_VP6F, CODEC_ID_VP6F, "On2 VP6 (ffmpeg)" },
+  { BUF_VIDEO_VP8, CODEC_ID_VP8, "On2 VP8 (ffmpeg)" },
+  { BUF_VIDEO_4XM, CODEC_ID_4XM, "4X Video (ffmpeg)" },
+  { BUF_VIDEO_CINEPAK, CODEC_ID_CINEPAK, "Cinepak (ffmpeg)" },
+  { BUF_VIDEO_MSVC, CODEC_ID_MSVIDEO1, "Microsoft Video 1 (ffmpeg)" },
+  { BUF_VIDEO_MSRLE, CODEC_ID_MSRLE, "Microsoft RLE (ffmpeg)" },
+  { BUF_VIDEO_RPZA, CODEC_ID_RPZA, "Apple Quicktime Video/RPZA (ffmpeg)" },
+  { BUF_VIDEO_CYUV, CODEC_ID_CYUV, "Creative YUV (ffmpeg)" },
+  { BUF_VIDEO_ROQ, CODEC_ID_ROQ, "Id Software RoQ (ffmpeg)" },
+  { BUF_VIDEO_IDCIN, CODEC_ID_IDCIN, "Id Software CIN (ffmpeg)" },
+  { BUF_VIDEO_WC3, CODEC_ID_XAN_WC3, "Xan (ffmpeg)" },
+  { BUF_VIDEO_VQA, CODEC_ID_WS_VQA, "Westwood Studios VQA (ffmpeg)" },
+  { BUF_VIDEO_INTERPLAY, CODEC_ID_INTERPLAY_VIDEO, "Interplay MVE (ffmpeg)" },
+  { BUF_VIDEO_FLI, CODEC_ID_FLIC, "FLIC Video (ffmpeg)" },
+  { BUF_VIDEO_8BPS, CODEC_ID_8BPS, "Planar RGB (ffmpeg)" },
+  { BUF_VIDEO_SMC, CODEC_ID_SMC, "Apple Quicktime Graphics/SMC (ffmpeg)" },
+  { BUF_VIDEO_DUCKTM1, CODEC_ID_TRUEMOTION1, "Duck TrueMotion v1 (ffmpeg)" },
+  { BUF_VIDEO_DUCKTM2, CODEC_ID_TRUEMOTION2, "Duck TrueMotion v2 (ffmpeg)" },
+  { BUF_VIDEO_VMD, CODEC_ID_VMDVIDEO, "Sierra VMD Video (ffmpeg)" },
+  { BUF_VIDEO_ZLIB, CODEC_ID_ZLIB, "ZLIB Video (ffmpeg)" },
+  { BUF_VIDEO_MSZH, CODEC_ID_MSZH, "MSZH Video (ffmpeg)" },
+  { BUF_VIDEO_ASV1, CODEC_ID_ASV1, "ASV v1 Video (ffmpeg)" },
+  { BUF_VIDEO_ASV2, CODEC_ID_ASV2, "ASV v2 Video (ffmpeg)" },
+  { BUF_VIDEO_ATIVCR1, CODEC_ID_VCR1, "ATI VCR-1 (ffmpeg)" },
+  { BUF_VIDEO_FLV1, CODEC_ID_FLV1, "Flash Video (ffmpeg)" },
+  { BUF_VIDEO_QTRLE, CODEC_ID_QTRLE, "Apple Quicktime Animation/RLE (ffmpeg)" },
+  { BUF_VIDEO_H264, CODEC_ID_H264, "H.264/AVC (ffmpeg)" },
+  { BUF_VIDEO_H261, CODEC_ID_H261, "H.261 (ffmpeg)" },
+  { BUF_VIDEO_AASC, CODEC_ID_AASC, "Autodesk Video (ffmpeg)" },
+  { BUF_VIDEO_LOCO, CODEC_ID_LOCO, "LOCO (ffmpeg)" },
+  { BUF_VIDEO_QDRW, CODEC_ID_QDRAW, "QuickDraw (ffmpeg)" },
+  { BUF_VIDEO_QPEG, CODEC_ID_QPEG, "Q-Team QPEG (ffmpeg)" },
+  { BUF_VIDEO_TSCC, CODEC_ID_TSCC, "TechSmith Video (ffmpeg)" },
+  { BUF_VIDEO_ULTI, CODEC_ID_ULTI, "IBM UltiMotion (ffmpeg)" },
+  { BUF_VIDEO_WNV1, CODEC_ID_WNV1, "Winnow Video (ffmpeg)" },
+  { BUF_VIDEO_XL, CODEC_ID_VIXL, "Miro/Pinnacle VideoXL (ffmpeg)" },
+  { BUF_VIDEO_RT21, CODEC_ID_INDEO2, "Indeo/RealTime 2 (ffmpeg)" },
+  { BUF_VIDEO_FPS1, CODEC_ID_FRAPS, "Fraps (ffmpeg)" },
+  { BUF_VIDEO_MPEG, CODEC_ID_MPEG1VIDEO, "MPEG 1/2 (ffmpeg)" },
+  { BUF_VIDEO_CSCD, CODEC_ID_CSCD, "CamStudio (ffmpeg)" },
+  { BUF_VIDEO_AVS, CODEC_ID_AVS, "AVS (ffmpeg)" },
+  { BUF_VIDEO_ALGMM, CODEC_ID_MMVIDEO, "American Laser Games MM (ffmpeg)" },
+  { BUF_VIDEO_ZMBV, CODEC_ID_ZMBV, "Zip Motion Blocks Video (ffmpeg)" },
+  { BUF_VIDEO_SMACKER, CODEC_ID_SMACKVIDEO, "Smacker (ffmpeg)" },
+  { BUF_VIDEO_NUV, CODEC_ID_NUV, "NuppelVideo (ffmpeg)" },
+  { BUF_VIDEO_KMVC, CODEC_ID_KMVC, "Karl Morton's Video Codec (ffmpeg)" },
+  { BUF_VIDEO_FLASHSV, CODEC_ID_FLASHSV, "Flash Screen Video (ffmpeg)" },
+  { BUF_VIDEO_CAVS, CODEC_ID_CAVS, "Chinese AVS (ffmpeg)" },
+  { BUF_VIDEO_VMNC, CODEC_ID_VMNC, "VMware Screen Codec (ffmpeg)" },
+  { BUF_VIDEO_THEORA_RAW, CODEC_ID_THEORA, "Theora (ffmpeg)" },
+  { BUF_VIDEO_SNOW, CODEC_ID_SNOW, "Snow (ffmpeg)" },
+};
+
+static uint32_t supported_video_types[] = {
+  BUF_VIDEO_MSMPEG4_V1,
+  BUF_VIDEO_MSMPEG4_V2,
+  BUF_VIDEO_MSMPEG4_V3,
+  BUF_VIDEO_WMV7,
+  BUF_VIDEO_WMV8,
+  BUF_VIDEO_WMV9,
+  BUF_VIDEO_VC1,
+  BUF_VIDEO_MPEG4,
+  BUF_VIDEO_XVID,
+  BUF_VIDEO_DIVX5,
+  BUF_VIDEO_3IVX,
+  BUF_VIDEO_JPEG,
+  BUF_VIDEO_MJPEG,
+  BUF_VIDEO_MJPEG_B,
+  BUF_VIDEO_I263,
+  BUF_VIDEO_H263,
+  BUF_VIDEO_RV10,
+  BUF_VIDEO_RV20,
+  BUF_VIDEO_RV30,
+  BUF_VIDEO_RV40,
+  BUF_VIDEO_IV31,
+  BUF_VIDEO_IV32,
+  BUF_VIDEO_SORENSON_V1,
+  BUF_VIDEO_SORENSON_V3,
+  BUF_VIDEO_DV,
+  BUF_VIDEO_HUFFYUV,
+  BUF_VIDEO_VP31,
+  BUF_VIDEO_VP5,
+  BUF_VIDEO_VP6,
+  BUF_VIDEO_VP6F,
+  BUF_VIDEO_VP8,
+  BUF_VIDEO_4XM,
+  BUF_VIDEO_CINEPAK,
+  BUF_VIDEO_MSVC,
+  BUF_VIDEO_MSRLE,
+  BUF_VIDEO_RPZA,
+  BUF_VIDEO_CYUV,
+  BUF_VIDEO_ROQ,
+  BUF_VIDEO_IDCIN,
+  BUF_VIDEO_WC3,
+  BUF_VIDEO_VQA,
+  BUF_VIDEO_INTERPLAY,
+  BUF_VIDEO_FLI,
+  BUF_VIDEO_8BPS,
+  BUF_VIDEO_SMC,
+  BUF_VIDEO_DUCKTM1,
+  BUF_VIDEO_DUCKTM2,
+  BUF_VIDEO_VMD,
+  BUF_VIDEO_ZLIB,
+  BUF_VIDEO_MSZH,
+  BUF_VIDEO_ASV1,
+  BUF_VIDEO_ASV2,
+  BUF_VIDEO_ATIVCR1,
+  BUF_VIDEO_FLV1,
+  BUF_VIDEO_QTRLE,
+  BUF_VIDEO_H264,
+  BUF_VIDEO_H261,
+  BUF_VIDEO_AASC,
+  BUF_VIDEO_LOCO,
+  BUF_VIDEO_QDRW,
+  BUF_VIDEO_QPEG,
+  BUF_VIDEO_TSCC,
+  BUF_VIDEO_ULTI,
+  BUF_VIDEO_WNV1,
+  BUF_VIDEO_XL,
+  BUF_VIDEO_RT21,
+  BUF_VIDEO_FPS1,
+  BUF_VIDEO_MPEG,
+  BUF_VIDEO_CSCD,
+  BUF_VIDEO_AVS,
+  BUF_VIDEO_ALGMM,
+  BUF_VIDEO_ZMBV,
+  BUF_VIDEO_SMACKER,
+  BUF_VIDEO_NUV,
+  BUF_VIDEO_KMVC,
+  BUF_VIDEO_FLASHSV,
+  BUF_VIDEO_CAVS,
+  BUF_VIDEO_VMNC,
+  BUF_VIDEO_THEORA_RAW,
+  BUF_VIDEO_SNOW,
+  0,
+};
diff -urN xine-lib-1.2.6/src/demuxers/demux_ts.c xine-lib-1.2.6_hg20140709/src/demuxers/demux_ts.c
--- xine-lib-1.2.6/src/demuxers/demux_ts.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/demuxers/demux_ts.c	2014-07-25 05:29:41.000000000 +0200
@@ -792,27 +792,6 @@
   demux_ts_send_buffer(m, BUF_FLAG_FRAME_END);
 }
 
-static void post_sequence_end(fifo_buffer_t *fifo, uint32_t video_type) {
-
-  if (video_type == BUF_VIDEO_H264 ||
-      video_type == BUF_VIDEO_MPEG ||
-      video_type == BUF_VIDEO_VC1) {
-
-    buf_element_t *buf = fifo->buffer_pool_try_alloc(fifo);
-    if (buf) {
-      buf->type = video_type;
-      buf->size = 4;
-      buf->decoder_flags = BUF_FLAG_FRAME_END;
-      buf->content[0] = 0x00;
-      buf->content[1] = 0x00;
-      buf->content[2] = 0x01;
-      buf->content[3] = (video_type == BUF_VIDEO_MPEG) ? 0xb7 : 0x0a;
-      fifo->put(fifo, buf);
-    }
-  }
-}
-
-
 static void demux_ts_flush(demux_ts_t *this)
 {
   unsigned int i;
@@ -820,10 +799,6 @@
     demux_ts_flush_media(&this->media[i]);
     this->media[i].corrupted_pes = 1;
   }
-
-  /* append sequence end code to video stream */
-  if (this->videoPid != INVALID_PID)
-    post_sequence_end(this->stream->video_fifo, this->media[this->videoMedia].type);
 }
 
 /*
@@ -1319,6 +1294,9 @@
 
     /* allocate the buffer here, as pes_header needs a valid buf for dvbsubs */
     m->buf = m->fifo->buffer_pool_alloc(m->fifo);
+    /* dont let decoder crash on incomplete frames.
+       Also needed by net_buf_ctrl/dvbspeed. */
+    m->buf->decoder_flags |= BUF_FLAG_FRAME_START;
 
     int pes_header_len = demux_ts_parse_pes_header(this->stream->xine, m, ts, len);
 
@@ -2291,30 +2269,8 @@
   }
 
   /* PAT */
-  if (pid == 0) {
-    demux_ts_parse_pat(this, originalPkt, originalPkt + data_offset,
-		       payload_unit_start_indicator, PKT_SIZE - data_offset);
-    return;
-  }
-
   /* PMT */
-  program_count=0;
-  while ((this->program_number[program_count] != INVALID_PROGRAM) &&
-         (program_count < MAX_PMTS)) {
-    if (pid == this->pmt_pid[program_count]) {
-
-#ifdef TS_LOG
-      printf ("demux_ts: PMT prog: 0x%.4x pid: 0x%.4x\n",
-              this->program_number[program_count],
-              this->pmt_pid[program_count]);
-#endif
-      demux_ts_parse_pmt (this, originalPkt, originalPkt + data_offset,
-                          payload_unit_start_indicator, PKT_SIZE - data_offset,
-                          program_count);
-      return;
-    }
-    program_count++;
-  }
+  // PAT and PMT are not processed for openpliPC. PIDs are recognized in E2
 
   data_len = PKT_SIZE - data_offset;
 
@@ -2376,6 +2332,7 @@
 static void demux_ts_event_handler (demux_ts_t *this) {
 
   xine_event_t *event;
+  int           mi;
 
   while ((event = xine_event_get (this->event_queue))) {
 
@@ -2386,13 +2343,37 @@
       /* flush all streams */
       demux_ts_flush(this);
       /* fall thru */
-
+      break;
+      
     case XINE_EVENT_PIDS_CHANGE:
-
-      demux_ts_dynamic_pmt_clear(this);
+      demux_ts_dynamic_pmt_clear(this); 
       this->send_newpts = 1;
       _x_demux_control_start (this->stream);
       break;
+      
+    case XINE_EVENT_SET_VIDEO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_VIDEO_STREAMTYPE\n");
+ 
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_VIDEO_BASE, data->streamtype);
+        if (mi >= 0) {
+          this->videoPid = data->pid;
+          this->videoMedia = mi;
+        }
+      }
+      break;
+
+    case XINE_EVENT_SET_AUDIO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_AUDIO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_AUDIO_BASE, data->streamtype);
+      }
+      break;  
 
     }
 
diff -urN xine-lib-1.2.6/src/input/combined_enigma.c xine-lib-1.2.6_hg20140709/src/input/combined_enigma.c
--- xine-lib-1.2.6/src/input/combined_enigma.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/input/combined_enigma.c	2013-03-03 08:54:34.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * plugins for VDR
+ */
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+static const post_info_t enigma_video_special_info = { XINE_POST_TYPE_VIDEO_FILTER };
+static const post_info_t enigma_audio_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
+
+/* exported plugin catalog entry */
+const plugin_info_t xine_plugin_info[] EXPORTED =
+{
+  /* type       , API, "name"     , version          , special_info           , init_function */
+  { PLUGIN_INPUT,  18, "ENIGMA"      , XINE_VERSION_CODE, NULL                   , &init_class },
+  { PLUGIN_POST ,  10, "enigma"      , XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_video", XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+//  { PLUGIN_POST ,  10, "vdr_audio", XINE_VERSION_CODE, &vdr_audio_special_info, &vdr_audio_init_plugin },
+  { PLUGIN_NONE ,   0, ""         , 0                , NULL                   , NULL }
+};
+
diff -urN xine-lib-1.2.6/src/input/combined_enigma.h xine-lib-1.2.6_hg20140709/src/input/combined_enigma.h
--- xine-lib-1.2.6/src/input/combined_enigma.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/input/combined_enigma.h	2013-03-03 08:54:34.000000000 +0100
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifndef __COMBINED_ENIGMA_H
+#define __COMBINED_ENIGMA_H
+
+
+
+typedef struct enigma_set_video_window_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+} enigma_set_video_window_data_t;
+
+
+
+typedef struct enigma_frame_size_changed_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  double r;
+
+} enigma_frame_size_changed_data_t;
+
+
+
+typedef struct enigma_select_audio_data_s {
+  uint8_t channels;
+
+} enigma_select_audio_data_t;
+
+
+
+inline static int enigma_is_stream(xine_stream_t *stream)
+{
+  if (!stream
+      || !stream->input_plugin
+      || !stream->input_plugin->input_class)
+  {
+    return 0;
+  }
+
+  if (stream->input_plugin->input_class->identifier &&
+      0 == strcmp(stream->input_plugin->input_class->identifier, "ENIGMA"))
+    return 1;
+
+  return 0;
+}
+
+
+/* plugin class initialization function */
+void *init_class(xine_t *xine, void *data);
+void *enigma_video_init_plugin(xine_t *xine, void *data);
+//void *vdr_audio_init_plugin(xine_t *xine, void *data);
+
+
+
+#endif /* __COMBINED_ENIGMA_H */
+
diff -urN xine-lib-1.2.6/src/input/input_dvb.c xine-lib-1.2.6_hg20140709/src/input/input_dvb.c
--- xine-lib-1.2.6/src/input/input_dvb.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/input/input_dvb.c	2014-07-25 05:30:14.000000000 +0200
@@ -1420,7 +1420,7 @@
    EPG OSD of all channels found in the currently tuned stream. */
 static void load_epg_data(dvb_input_plugin_t *this)
 {
-  /*int table_id;*/
+  int table_id;
   char skip_byte;
   int descriptor_id;
   int section_len = 0;
@@ -1467,7 +1467,7 @@
        xprintf(this->stream->xine,XINE_VERBOSITY_LOG,"Error reading EPG section length\n");
        break;
     }
-    /*table_id =*/ getbits(eit, 0, 8);
+    table_id = getbits(eit, 0, 8);
     section_len = (unsigned int)getbits(eit, 12, 12);
     n = read(this->tuner->fd_pidfilter[EITFILTER], eit + 3, section_len);
     if (n != section_len) {
diff -urN xine-lib-1.2.6/src/input/input_enigma.c xine-lib-1.2.6_hg20140709/src/input/input_enigma.c
--- xine-lib-1.2.6/src/input/input_enigma.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/input/input_enigma.c	2013-03-03 08:54:34.000000000 +0100
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2000-2003 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+#define LOG_MODULE "input_enigma"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/input_plugin.h>
+#include "net_buf_ctrl.h"
+#include "combined_enigma.h"
+
+#define ENIGMA_ABS_FIFO_DIR     "/tmp"
+#define DEFAULT_PTS_START       150000
+#define BUFSIZE                 768
+#define FILE_FLAGS O_RDONLY
+#define FIFO_PUT                0
+
+typedef struct enigma_input_plugin_s enigma_input_plugin_t;
+
+struct enigma_input_plugin_s {
+  input_plugin_t      input_plugin;
+  xine_stream_t      *stream;
+  int                 fh;
+  char               *mrl;
+  off_t               curpos;
+  char                seek_buf[BUFSIZE];
+  xine_t             *xine;
+  int                 last_disc_type;
+  nbc_t              *nbc;
+};
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+} enigma_input_class_t;
+
+
+/* Put callback the fifo mutex is locked */
+static void enigma_nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen) {
+  nbc_t *this = (nbc_t*)this_gen;
+  int64_t progress = 0;
+  int64_t video_p = 0;
+  int64_t audio_p = 0;
+  int force_dvbspeed = 0;
+  int has_video, has_audio;
+  force_dvbspeed = 0;
+  xine_t *xine = this->stream->xine;
+
+  cfg_entry_t *entry;
+	config_values_t *cfg;
+	cfg = xine->config;
+	entry = cfg->lookup_entry(cfg, "input.buffer.dynamic");
+  if  (strdup(entry->unknown_value) == "1");
+  			force_dvbspeed = 1;
+
+  lprintf("enter enigma_nbc_put_cb\n");
+  pthread_mutex_lock(&this->mutex);
+
+  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+
+    if (this->enabled) {
+      if (this->dvbspeed)
+        dvbspeed_put (this, fifo, buf);
+      else {
+      nbc_compute_fifo_length(this, fifo, buf, FIFO_PUT);
+
+      if (this->buffering) {
+
+        has_video = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_VIDEO);
+        has_audio = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_AUDIO);
+        /* restart playing if high_water_mark is reached by all fifos
+         * do not restart if has_video and has_audio are false to avoid
+         * a yoyo effect at the beginning of the stream when these values
+         * are not yet known.
+         *
+         * be sure that the next buffer_pool_alloc() call will not deadlock,
+         * we need at least 2 buffers (see buffer.c)
+         */
+//printf("this->video_last_pts %lld   this->audio_last_pts %lld\n", this->video_last_pts, this->audio_last_pts);
+        int64_t first_pts = this->video_first_pts>this->audio_first_pts?this->video_first_pts:this->audio_first_pts;
+        int64_t last_pts = this->video_last_pts<this->audio_last_pts?this->video_last_pts:this->audio_last_pts;
+//printf("AAA first_pts %lld  last_pts %lld\n", first_pts, last_pts);
+        if ( has_video && has_audio && (last_pts-first_pts)>DEFAULT_PTS_START ) {
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+          nbc_set_speed_normal(this);
+        }
+        else if ((((!has_video) || (this->video_fifo_length > this->high_water_mark)) &&
+             ((!has_audio) || (this->audio_fifo_length > this->high_water_mark)) &&
+             (has_video || has_audio))) {
+
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+          nbc_set_speed_normal(this);
+
+          this->high_water_mark += this->high_water_mark / 2;
+
+        } else {
+          /*  compute the buffering progress
+           *    50%: video
+           *    50%: audio */
+          video_p = ((this->video_fifo_length * 50) / this->high_water_mark);
+          if (video_p > 50) video_p = 50;
+          audio_p = ((this->audio_fifo_length * 50) / this->high_water_mark);
+          if (audio_p > 50) audio_p = 50;
+
+          if ((has_video) && (has_audio)) {
+            progress = video_p + audio_p;
+          } else if (has_video) {
+            progress = 2 * video_p;
+          } else {
+            progress = 2 * audio_p;
+          }
+
+          /* if the progress can't be computed using the fifo length,
+             use the number of buffers */
+          if (!progress) {
+            video_p = this->video_fifo_fill;
+            audio_p = this->audio_fifo_fill;
+            progress = (video_p > audio_p) ? video_p : audio_p;
+          }
+
+          if (progress > this->progress) {
+            //report_progress (this->stream, progress);
+            this->progress = progress;
+          }
+        }
+      }
+      //if(this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
+      //  display_stats(this);
+
+      //report_stats(this, 0);
+      }
+  	}
+  } else {
+
+    switch (buf->type) {
+      case BUF_CONTROL_START:
+        lprintf("BUF_CONTROL_START\n");
+        if (!this->enabled) {
+          /* a new stream starts */
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: starts buffering\n");
+          this->enabled           = 1;
+          this->buffering         = 1;
+          this->video_first_pts   = 0;
+          this->video_last_pts    = 0;
+          this->audio_first_pts   = 0;
+          this->audio_last_pts    = 0;
+          this->video_fifo_length = 0;
+          this->audio_fifo_length = 0;
+          dvbspeed_init (this, force_dvbspeed);
+          if (!this->dvbspeed) nbc_set_speed_pause(this);
+/*          this->progress = 0;
+          report_progress (this->stream, progress);*/
+        }
+        break;
+      case BUF_CONTROL_NOP:
+        if (!(buf->decoder_flags & BUF_FLAG_END_USER) &&
+            !(buf->decoder_flags & BUF_FLAG_END_STREAM)) {
+          break;
+        }
+        /* fall through */
+      case BUF_CONTROL_END:
+      case BUF_CONTROL_QUIT:
+        lprintf("BUF_CONTROL_END\n");
+        dvbspeed_close (this);
+        if (this->enabled) {
+          /* end of stream :
+           *   - disable the nbc
+           *   - unpause the engine if buffering
+           */
+          this->enabled = 0;
+
+          lprintf("DISABLE netbuf\n");
+
+          if (this->buffering) {
+            this->buffering = 0;
+            this->progress = 100;
+            //report_progress (this->stream, this->progress);
+
+            xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+            nbc_set_speed_normal(this);
+          }
+        }
+        break;
+
+      case BUF_CONTROL_NEWPTS:
+        /* discontinuity management */
+        if (fifo == this->video_fifo) {
+          this->video_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb video disc %d\n", this->video_in_disc);
+        } else {
+          this->audio_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb audio disc %d\n", this->audio_in_disc);
+        }
+        break;
+    }
+
+    if (fifo == this->video_fifo) {
+      this->video_fifo_free = fifo->buffer_pool_num_free;
+      this->video_fifo_size = fifo->fifo_data_size;
+    } else {
+      this->audio_fifo_free = fifo->buffer_pool_num_free;
+      this->audio_fifo_size = fifo->fifo_data_size;
+    }
+  }
+  pthread_mutex_unlock(&this->mutex);
+  lprintf("exit enigma_nbc_put_cb\n");
+}
+
+nbc_t *enigma_nbc_init (xine_stream_t *stream) {
+
+  nbc_t *this = calloc(1, sizeof (nbc_t));
+  fifo_buffer_t *video_fifo = stream->video_fifo;
+  fifo_buffer_t *audio_fifo = stream->audio_fifo;
+  
+  
+  double video_fifo_factor, audio_fifo_factor;
+  cfg_entry_t *entry;
+
+  lprintf("enigma_nbc_init\n");
+  pthread_mutex_init (&this->mutex, NULL);
+
+  this->stream              = stream;
+  this->video_fifo          = video_fifo;
+  this->audio_fifo          = audio_fifo;
+
+  /* when the FIFO sizes are increased compared to the default configuration,
+   * apply a factor to the high water mark */
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.video_num_buffers");
+  /* No entry when no video output */
+  if (entry)
+    video_fifo_factor = (double)video_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    video_fifo_factor = 1.0;
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.audio_num_buffers");
+  /* When there's no audio output, there's no entry */
+  if (entry)
+    audio_fifo_factor = (double)audio_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    audio_fifo_factor = 1.0;
+  /* use the smaller factor */
+  if (video_fifo_factor < audio_fifo_factor)
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * video_fifo_factor;
+  else
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * audio_fifo_factor;
+
+  video_fifo->register_alloc_cb(video_fifo, nbc_alloc_cb, this);
+  video_fifo->register_put_cb(video_fifo, enigma_nbc_put_cb, this);
+  video_fifo->register_get_cb(video_fifo, nbc_get_cb, this);
+
+  audio_fifo->register_alloc_cb(audio_fifo, nbc_alloc_cb, this);
+  audio_fifo->register_put_cb(audio_fifo, enigma_nbc_put_cb, this);
+  audio_fifo->register_get_cb(audio_fifo, nbc_get_cb, this);
+
+  return this;
+}
+
+void enigma_nbc_close (nbc_t *this) {
+  fifo_buffer_t *video_fifo = this->stream->video_fifo;
+  fifo_buffer_t *audio_fifo = this->stream->audio_fifo;
+  xine_t        *xine       = this->stream->xine;
+
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close\n");
+
+  /* unregister all fifo callbacks */
+  /* do not lock the mutex to avoid deadlocks if a decoder calls fifo->get() */
+  video_fifo->unregister_alloc_cb(video_fifo, nbc_alloc_cb);
+  video_fifo->unregister_put_cb(video_fifo, enigma_nbc_put_cb);
+  video_fifo->unregister_get_cb(video_fifo, nbc_get_cb);
+
+  audio_fifo->unregister_alloc_cb(audio_fifo, nbc_alloc_cb);
+  audio_fifo->unregister_put_cb(audio_fifo, enigma_nbc_put_cb);
+  audio_fifo->unregister_get_cb(audio_fifo, nbc_get_cb);
+
+  /* now we are sure that nobody will call a callback */
+  this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
+
+  pthread_mutex_destroy(&this->mutex);
+  free (this);
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close: done\n");
+}
+
+static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{
+  off_t ret;
+
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+
+    break;
+  }
+
+  return ret;
+}
+
+static off_t enigma_plugin_read (input_plugin_t *this_gen,
+				void *buf_gen, off_t len) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+  uint8_t *buf = (uint8_t *)buf_gen;
+  off_t n, total = 0;
+#ifdef LOG_READ
+  lprintf ("reading %lld bytes...\n", len);
+#endif
+
+  if( len > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = enigma_read_abort (this->stream, this->fh, (char *)&buf[total], len-total);
+      //n = _x_io_file_read (this->stream, this->fh, &buf[total], len - total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); // 200 * 50ms
+#ifdef LOG_READ
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n", n, total, len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+
+  return total;
+
+}
+
+static buf_element_t *enigma_plugin_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo,
+					       off_t todo) {
+
+  off_t                 total_bytes;
+  /* enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen; */
+  buf_element_t         *buf = fifo->buffer_pool_alloc (fifo);
+
+  if (todo > buf->max_size)
+    todo = buf->max_size;
+  if (todo < 0) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = enigma_plugin_read (this_gen, (char*)buf->content, todo);
+
+  if (total_bytes != todo) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("seek %"PRId64" offset, %d origin...\n", offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0)) {
+
+    for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+      if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET) {
+
+    if (offset < this->curpos) {
+
+      //if( this->curpos <= this->preview_size )
+      //  this->curpos = offset;
+      //else
+        xprintf (this->xine, XINE_VERBOSITY_LOG,
+                 _("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n"),
+                 (intmax_t)this->curpos, (intmax_t)offset);
+        printf ("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n",
+                 (intmax_t)this->curpos, (intmax_t)offset);
+
+    } else {
+      offset -= this->curpos;
+
+      for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+        if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+          return this->curpos;
+      }
+
+      this_gen->read (this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t enigma_plugin_get_length(input_plugin_t *this_gen) {
+  return 0;
+}
+
+static uint32_t enigma_plugin_get_capabilities(input_plugin_t *this_gen) {
+
+  return INPUT_CAP_PREVIEW;
+}
+
+static uint32_t enigma_plugin_get_blocksize(input_plugin_t *this_gen) {
+
+  return 0;
+}
+
+static off_t enigma_plugin_get_current_pos (input_plugin_t *this_gen){
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->curpos;
+}
+
+static const char* enigma_plugin_get_mrl (input_plugin_t *this_gen) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->mrl;
+}
+
+static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  if (this->nbc) {
+    enigma_nbc_close (this->nbc);
+  }
+
+  if (this->fh != -1)
+    close(this->fh);
+
+  free (this->mrl);
+  free (this);
+}
+
+static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
+					   void *data, int data_type) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    /* just fake what mpeg_pes demuxer expects */
+    memcpy (data, "\x00\x00\x01\xe0\x00\x03\x80\x00\x00", 9);
+    return 9;
+  case INPUT_OPTIONAL_DATA_DEMUXER:
+    {
+      char **tmp = (char**)data;
+      *tmp = "mpeg-ts";
+    }
+    return 0;
+  }
+
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int enigma_plugin_open (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1) {
+    int err = 0;
+    char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
+    this->fh = open (filename, FILE_FLAGS);
+
+    printf("filename '%s'\n", filename);
+
+    if (this->fh == -1) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, _("enigma_fifo: failed to open '%s'\n"), filename);
+      printf ("enigma_fifo: failed to open '%s'\n", filename);
+      return 0;
+    }
+
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this->curpos          = 0;
+
+  return 1;
+}
+
+static input_plugin_t *enigma_class_get_instance (input_class_t *class_gen,
+						 xine_stream_t *stream, const char *data) {
+
+  enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
+  enigma_input_plugin_t *this;
+  char                 *mrl = strdup(data);
+  int                   fh;
+
+  if (!strncasecmp(mrl, "enigma:/", 8)) {
+    lprintf("Enigma plugin\n");
+  } else {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this       = calloc(1, sizeof(enigma_input_plugin_t));
+
+  this->stream = stream;
+  this->curpos = 0;
+  this->mrl    = mrl;
+  this->fh     = -1;
+  this->xine   = class->xine;
+
+  this->input_plugin.open              = enigma_plugin_open;
+  this->input_plugin.get_capabilities  = enigma_plugin_get_capabilities;
+  this->input_plugin.read              = enigma_plugin_read;
+  this->input_plugin.read_block        = enigma_plugin_read_block;
+  this->input_plugin.seek              = enigma_plugin_seek;
+  this->input_plugin.get_current_pos   = enigma_plugin_get_current_pos;
+  this->input_plugin.get_length        = enigma_plugin_get_length;
+  this->input_plugin.get_blocksize     = enigma_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = enigma_plugin_get_mrl;
+  this->input_plugin.dispose           = enigma_plugin_dispose;
+  this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
+  this->input_plugin.input_class       = class_gen;
+
+  /*
+   * buffering control
+   */
+  this->nbc    = enigma_nbc_init (this->stream);
+
+  return &this->input_plugin;
+}
+
+
+//static void *init_class (xine_t *xine, void *data) {
+void *init_class (xine_t *xine, void *data) {
+
+  enigma_input_class_t  *this;
+
+  this = calloc(1, sizeof (enigma_input_class_t));
+
+  this->xine   = xine;
+
+  this->input_class.get_instance       = enigma_class_get_instance;
+  this->input_class.identifier         = "ENIGMA";
+  this->input_class.description        = N_("ENIGMA2PC display device plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = default_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
+
+/*
+ * exported plugin catalog entry
+ */
+
+/*
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+//  type, API, "name", version, special_info, init_function 
+  { PLUGIN_INPUT, 18, "enigma", XINE_VERSION_CODE, NULL, init_class },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
+*/
diff -urN xine-lib-1.2.6/src/input/Makefile.am xine-lib-1.2.6_hg20140709/src/input/Makefile.am
--- xine-lib-1.2.6/src/input/Makefile.am	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/input/Makefile.am	2014-07-25 05:30:14.000000000 +0200
@@ -88,7 +88,8 @@
 	$(in_pvr) \
 	$(in_dvb) \
 	$(in_bluray) \
-	xineplug_inp_cdda.la
+	xineplug_inp_cdda.la \
+	xineplug_inp_enigma.la
 
 
 xineplug_inp_file_la_SOURCES = input_file.c
@@ -162,3 +163,7 @@
 xineplug_inp_bluray_la_SOURCES = input_bluray.c media_helper.c
 xineplug_inp_bluray_la_LIBADD = $(XINE_LIB) $(LIBBLURAY_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL)
 xineplug_inp_bluray_la_CFLAGS = $(AM_CFLAGS) $(LIBBLURAY_CFLAGS)
+
+xineplug_inp_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c net_buf_ctrl.c post_enigma_video.c
+xineplug_vdr_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
+xineplug_inp_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
diff -urN xine-lib-1.2.6/src/input/net_buf_ctrl.c xine-lib-1.2.6_hg20140709/src/input/net_buf_ctrl.c
--- xine-lib-1.2.6/src/input/net_buf_ctrl.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/input/net_buf_ctrl.c	2014-07-25 05:29:40.000000000 +0200
@@ -40,60 +40,12 @@
 
 #include "net_buf_ctrl.h"
 
-#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
-
 #define FULL_FIFO_MARK             5 /* buffers free */
 
 #define FIFO_PUT                   0
 #define FIFO_GET                   1
 
-struct nbc_s {
-
-  xine_stream_t   *stream;
 
-  int              buffering;
-  int              enabled;
-
-  int              progress;
-  fifo_buffer_t   *video_fifo;
-  fifo_buffer_t   *audio_fifo;
-  int              video_fifo_fill;
-  int              audio_fifo_fill;
-  int              video_fifo_free;
-  int              audio_fifo_free;
-  int64_t          video_fifo_length;     /* in ms */
-  int64_t          audio_fifo_length;     /* in ms */
-  int64_t          video_fifo_length_int; /* in ms */
-  int64_t          audio_fifo_length_int; /* in ms */
-
-  int64_t          high_water_mark;
-  /* bitrate */
-  int64_t          video_last_pts;
-  int64_t          audio_last_pts;
-  int64_t          video_first_pts;
-  int64_t          audio_first_pts;
-  int64_t          video_fifo_size;
-  int64_t          audio_fifo_size;
-  int64_t          video_br;
-  int64_t          audio_br;
-
-  int              video_in_disc;
-  int              audio_in_disc;
-
-  pthread_mutex_t  mutex;
-
-  /* follow live dvb delivery speed.
-     0 = fix disabled
-     1 = play at normal speed
-     2 = play 0.5% slower to fill video fifo
-     3 = play 0.5% faster to empty video fifo
-     4..6 = same as 1..3 but watch audio fifo instead
-     7 = pause */
-  int dvbspeed;
-  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
-  int64_t dvbs_audio_in, dvbs_audio_out;
-  int64_t dvbs_video_in, dvbs_video_out;
-};
 
 static void report_progress (xine_stream_t *stream, int p) {
 
@@ -110,7 +62,7 @@
   xine_event_send (stream, &event);
 }
 
-static void nbc_set_speed_pause (nbc_t *this) {
+void nbc_set_speed_pause (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_pause\n");
@@ -118,7 +70,7 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);
 }
 
-static void nbc_set_speed_normal (nbc_t *this) {
+void nbc_set_speed_normal (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_normal\n");
@@ -126,13 +78,13 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
 }
 
-static void dvbspeed_init (nbc_t *this) {
+void dvbspeed_init (nbc_t *this, int force) {
   const char *mrl;
-  if (this->stream && this->stream->input_plugin) {
+  if (this->stream && this->stream->input_plugin || force == 1) {
     mrl = this->stream->input_plugin->get_mrl (this->stream->input_plugin);
-    if (mrl) {
+    if (mrl || force == 1) {
       /* detect Kaffeine: fifo://~/.kde4/share/apps/kaffeine/dvbpipe.m2t */
-      if ((strcasestr (mrl, "/dvbpipe.")) ||
+      if (force == 1 || (strcasestr (mrl, "/dvbpipe.")) ||
         ((!strncasecmp (mrl, "dvb", 3)) &&
         ((mrl[3] == ':') || (mrl[3] && (mrl[4] == ':'))))) {
         this->dvbs_center = 2 * 90000;
@@ -158,8 +110,8 @@
 #endif
           }
           if (xine_config_lookup_entry (xine, "engine.buffers.video_num_buffers",
-            &entry) && (entry.num_value < 800)) {
-            config->update_num (config, "engine.buffers.video_num_buffers", 800);
+            &entry) && (entry.num_value < 1800)) {
+            config->update_num (config, "engine.buffers.video_num_buffers", 1800);
 #ifdef LOG_DVBSPEED
             printf ("net_buf_ctrl: enlarged video fifo to 800 buffers\n");
 #endif
@@ -169,9 +121,10 @@
       }
     }
   }
+
 }
 
-static void dvbspeed_close (nbc_t *this) {
+void dvbspeed_close (nbc_t *this) {
   if (((0xec >> this->dvbspeed) & 1) && this->stream)
     _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
 #ifdef LOG_DVBSPEED
@@ -180,7 +133,7 @@
   this->dvbspeed = 0;
 }
 
-static void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -256,7 +209,7 @@
   }
 }
 
-static void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -363,7 +316,7 @@
  *    else
  *      use the the first and the last pts of the fifo
  */
-static void nbc_compute_fifo_length(nbc_t *this,
+void nbc_compute_fifo_length(nbc_t *this,
                                     fifo_buffer_t *fifo,
                                     buf_element_t *buf,
                                     int action) {
@@ -465,7 +418,7 @@
 }
 
 /* Alloc callback */
-static void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
   lprintf("enter nbc_alloc_cb\n");
@@ -489,13 +442,15 @@
 
 /* Put callback
  * the fifo mutex is locked */
-static void nbc_put_cb (fifo_buffer_t *fifo,
+void nbc_put_cb (fifo_buffer_t *fifo,
                         buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
   int64_t progress = 0;
   int64_t video_p = 0;
   int64_t audio_p = 0;
   int has_video, has_audio;
+	int force_dvbspeed = 1;
+	
 
   lprintf("enter nbc_put_cb\n");
   pthread_mutex_lock(&this->mutex);
@@ -588,7 +543,7 @@
           this->audio_last_pts    = 0;
           this->video_fifo_length = 0;
           this->audio_fifo_length = 0;
-          dvbspeed_init (this);
+          dvbspeed_init (this, force_dvbspeed);
           if (!this->dvbspeed) nbc_set_speed_pause(this);
           this->progress = 0;
           report_progress (this->stream, progress);
@@ -653,7 +608,7 @@
 
 /* Get callback
  * the fifo mutex is locked */
-static void nbc_get_cb (fifo_buffer_t *fifo,
+void nbc_get_cb (fifo_buffer_t *fifo,
 			buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
diff -urN xine-lib-1.2.6/src/input/net_buf_ctrl.h xine-lib-1.2.6_hg20140709/src/input/net_buf_ctrl.h
--- xine-lib-1.2.6/src/input/net_buf_ctrl.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/input/net_buf_ctrl.h	2014-07-25 05:29:40.000000000 +0200
@@ -25,10 +25,71 @@
 
 #include <xine/xine_internal.h>
 
+struct nbc_s {
+
+  xine_stream_t   *stream;
+
+  int              buffering;
+  int              enabled;
+
+  int              progress;
+  fifo_buffer_t   *video_fifo;
+  fifo_buffer_t   *audio_fifo;
+  int              video_fifo_fill;
+  int              audio_fifo_fill;
+  int              video_fifo_free;
+  int              audio_fifo_free;
+  int64_t          video_fifo_length;     /* in ms */
+  int64_t          audio_fifo_length;     /* in ms */
+  int64_t          video_fifo_length_int; /* in ms */
+  int64_t          audio_fifo_length_int; /* in ms */
+
+  int64_t          high_water_mark;
+  /* bitrate */
+  int64_t          video_last_pts;
+  int64_t          audio_last_pts;
+  int64_t          video_first_pts;
+  int64_t          audio_first_pts;
+  int64_t          video_fifo_size;
+  int64_t          audio_fifo_size;
+  int64_t          video_br;
+  int64_t          audio_br;
+
+  int              video_in_disc;
+  int              audio_in_disc;
+
+  pthread_mutex_t  mutex;
+
+  /* follow live dvb delivery speed.
+     0 = fix disabled
+     1 = play at normal speed
+     2 = play 0.5% slower to fill video fifo
+     3 = play 0.5% faster to empty video fifo
+     4..6 = same as 1..3 but watch audio fifo instead
+     7 = pause */
+  int dvbspeed;
+  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
+  int64_t dvbs_audio_in, dvbs_audio_out;
+  int64_t dvbs_video_in, dvbs_video_out;
+};
+
+
 typedef struct nbc_s nbc_t;
 
 nbc_t *nbc_init (xine_stream_t *xine) XINE_MALLOC;
 
 void nbc_close (nbc_t *this);
+void nbc_set_speed_pause (nbc_t *this);
+void nbc_set_speed_normal (nbc_t *this);
+void dvbspeed_init (nbc_t *this, int force);
+void dvbspeed_close (nbc_t *this);
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+void nbc_compute_fifo_length(nbc_t *this, fifo_buffer_t *fifo, buf_element_t *buf, int action);
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen);
+void nbc_get_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+
+#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
 
 #endif
diff -urN xine-lib-1.2.6/src/input/post_enigma_video.c xine-lib-1.2.6_hg20140709/src/input/post_enigma_video.c
--- xine-lib-1.2.6/src/input/post_enigma_video.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.6_hg20140709/src/input/post_enigma_video.c	2013-03-03 08:54:34.000000000 +0100
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * frame scaler plugin for ENIGMA2PC
+ */
+
+#define LOG_MODULE "enigma_video"
+/*
+#define LOG
+#define LOG_VERBOSE
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_video_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  int8_t trick_speed_mode;
+  int8_t enabled;
+
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+  int32_t old_frame_left;
+  int32_t old_frame_top;
+  int32_t old_frame_width;
+  int32_t old_frame_height;
+  double  old_frame_ratio;
+
+}
+enigma_video_post_plugin_t;
+
+
+static void enigma_video_set_video_window(enigma_video_post_plugin_t *this, int32_t x, int32_t y, int32_t w, int32_t h, int32_t w_ref, int32_t h_ref)
+{
+  this->enabled = 0;
+
+  this->x     = x;
+  this->y     = y;
+  this->w     = w;
+  this->h     = h;
+  this->w_ref = w_ref;
+  this->h_ref = h_ref;
+
+  if (w != w_ref || h != h_ref)
+    this->enabled = 1;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_video_dispose(post_plugin_t *this_gen);
+
+/* route preprocessing functions check */
+static int            enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame);
+
+/* replaced vo_frame functions */
+static int            enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream);
+
+
+void *enigma_video_init_plugin(xine_t *xine, void *data)
+{
+  post_class_t *class = (post_class_t *)xine_xmalloc(sizeof (post_class_t));
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_video_open_plugin;
+  class->identifier      = "enigma";
+  class->description     = N_("modifies every video frame as requested by ENIGMA");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)xine_xmalloc(sizeof (enigma_video_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_video_port_t       *port;
+
+  if (!this || !video_target || !video_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  _x_post_init(&this->post_plugin, 0, 1);
+  this->post_plugin.dispose = enigma_video_dispose;
+
+  port = _x_post_intercept_video_port(&this->post_plugin, video_target[ 0 ], &input, &output);
+  port->route_preprocessing_procs = enigma_video_route_preprocessing_procs;
+  port->new_frame->draw           = enigma_video_draw;
+  this->post_plugin.xine_post.video_input[ 0 ] = &port->new_port;
+
+  this->enabled          = 0;
+  this->enigma_stream    = 0;
+  this->event_queue      = 0;
+  this->old_frame_left   = 0;
+  this->old_frame_top    = 0;
+  this->old_frame_width  = 0;
+  this->old_frame_height = 0;
+  this->old_frame_ratio  = 0;
+  this->trick_speed_mode = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_video_dispose(post_plugin_t *this_gen)
+{
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = 0;
+      event_data.y = 0;
+      event_data.w = 0;
+      event_data.h = 0;
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      xine_event_dispose_queue(this->event_queue);
+    }
+
+    free(this_gen);
+  }
+}
+
+static int enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  return !this->enabled
+    || (frame->format != XINE_IMGFMT_YUY2
+      && frame->format != XINE_IMGFMT_YV12);
+}
+
+static inline void enigma_video_scale(uint8_t *src, uint8_t *dst, int y_inc, int x_inc, int w_dst, int h_dst, int x, int y, int w, int h, int w_ref, int h_ref, int init)
+{
+  int x0 = x * w_dst / w_ref;
+  int y0 = y * h_dst / h_ref;
+
+  int x1 = ((x + w) * w_dst - 1 + w_ref) / w_ref;
+  int y1 = ((y + h) * h_dst - 1 + h_ref) / h_ref;
+
+  int dx = x1 - x0;
+  int dy = y1 - y0;
+
+  int yy, xx;
+
+  int dy2    = dy + dy;
+  int h_dst2 = h_dst + h_dst;
+  int y_eps  = h_dst - dy2;
+
+  int dx2    = dx + dx;
+  int w_dst2 = w_dst + w_dst;
+  int x_eps0 = w_dst - dx2;
+
+  for (yy = 0; yy < y0; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+
+  for (yy = y0; yy < y1; yy++)
+  {
+    uint8_t *dst0 = dst;
+    uint8_t *src0 = src;
+
+    int x_eps = x_eps0;
+
+    for (xx = 0; xx < x0; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    for (xx = x0; xx < x1; xx++)
+    {
+      *dst0 = *src0;
+      dst0 += x_inc;
+
+      x_eps += w_dst2;
+      while (x_eps >= 0)
+      {
+        src0  += x_inc;
+        x_eps -= dx2;
+      }
+    }
+
+    for (xx = x1; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+
+    y_eps += h_dst2;
+    while (y_eps >= 0)
+    {
+      src   += y_inc;
+      y_eps -= dy2;
+    }
+  }
+
+  for (yy = y1; yy < h_dst; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+}
+
+static void enigma_video_scale_YUY2(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] * dst->crop_top + 2 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 2,  w         , h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 1 ] + offset, &dst->base[ 0 ][ 1 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 3 ] + offset, &dst->base[ 0 ][ 3 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+static void enigma_video_scale_YV12(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] *   dst->crop_top           + 1 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 1,  w         ,  h         , this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 1 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 1 ][ 0 ] + offset, &dst->base[ 1 ][ 0 ] + offset, dst->pitches[ 1 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 2 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 2 ][ 0 ] + offset, &dst->base[ 2 ][ 0 ] + offset, dst->pitches[ 2 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+
+static int enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t       *port = (post_video_port_t *)frame->port;
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  vo_frame_t *enigma_frame;
+  xine_event_t *event;
+  int skip;
+
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->old_frame_left   = 0;
+    this->old_frame_top    = 0;
+    this->old_frame_width  = 0;
+    this->old_frame_height = 0;
+    this->old_frame_ratio  = 0;
+  }
+
+  if (!this->enigma_stream
+      && enigma_is_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_VDR_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 0; /* vdr_video */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_VDR_SETVIDEOWINDOW)
+      {
+        enigma_set_video_window_data_t *data = (enigma_set_video_window_data_t *)event->data;
+
+        enigma_video_set_video_window(this, data->x, data->y, data->w, data->h, data->w_ref, data->h_ref);
+      }
+      else if (event->type == XINE_EVENT_VDR_TRICKSPEEDMODE)
+      {
+/*
+        fprintf(stderr, "###############################: %p, %d\n", event->data, event->data_length);
+        this->trick_speed_mode = (0 != event->data_length);
+*/
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  {
+    int32_t frame_left   = frame->crop_left;
+    int32_t frame_width  = frame->width - frame->crop_left - frame->crop_right;
+    int32_t frame_top    = frame->crop_top;
+    int32_t frame_height = frame->height - frame->crop_top - frame->crop_bottom;
+    double  frame_ratio  = frame->ratio;
+
+    if (frame_left < 0)
+      frame_left = 0;
+    if (frame_width > frame->width)
+      frame_width = frame->width;
+    if (frame_top < 0)
+      frame_top = 0;
+    if (frame_height > frame->height)
+      frame_height = frame->height;
+
+    if (this->enigma_stream
+        && frame_width != 0
+        && frame_height != 0
+        && (this->old_frame_left    != frame_left
+          || this->old_frame_top    != frame_top
+          || this->old_frame_width  != frame_width
+          || this->old_frame_height != frame_height
+          || this->old_frame_ratio  != frame_ratio))
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = frame_left;
+      event_data.y = frame_top;
+      event_data.w = frame_width;
+      event_data.h = frame_height;
+      event_data.r = frame_ratio;
+
+      xprintf(this->enigma_stream->xine, XINE_VERBOSITY_LOG,
+            _(LOG_MODULE ": osd: (%d, %d)-(%d, %d)@%lg\n"), frame_left, frame_top, frame_width, frame_height, frame_ratio);
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+// Enigma2PC send event
+      xine_format_change_data_t event_data_enigma;
+
+      event_data_enigma.width = frame_width;
+      event_data_enigma.height = frame_height;
+
+      int ratio = (int)(10000 * frame_ratio + 0.5);
+      int matches4_3 = abs(ratio - 13333);
+      int matches16_9 = abs(ratio - 17778);
+      if (matches4_3 < matches16_9)
+       {
+        event_data_enigma.aspect = 2;
+       }
+      else
+      {
+        event_data_enigma.aspect = 3;
+      }
+      event_data_enigma.pan_scan = 0;
+
+      event.type        = XINE_EVENT_FRAME_FORMAT_CHANGE;
+      event.data        = &event_data_enigma;
+      event.data_length = sizeof (event_data_enigma);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      this->old_frame_left   = frame_left;
+      this->old_frame_top    = frame_top;
+      this->old_frame_width  = frame_width;
+      this->old_frame_height = frame_height;
+      this->old_frame_ratio  = frame_ratio;
+    }
+  }
+/*
+  fprintf(stderr, "~~~~~~~~~~~~ trickspeedmode: %d\n", this->trick_speed_mode);
+
+  if (this->vdr_stream
+      && this->trick_speed_mode)
+  {
+    frame->pts = 0;
+    frame->next->pts = 0;
+  }
+*/
+#if defined(LOG) && defined(LOG_VERBOSE)
+  {
+    int a = 0, b = 0, c = 0, d = 0;
+    if (stream)
+      _x_query_buffer_usage(stream, &a, &b, &c, &d);
+    lprintf("buffer usage: %3d, %2d, %2d, %2d, %p\n", a, b, c, d, stream);
+  }
+#endif
+
+  if (!this->enabled
+      || frame->bad_frame
+      || (frame->format != XINE_IMGFMT_YUY2
+          && frame->format != XINE_IMGFMT_YV12)
+      || frame->proc_frame
+      || frame->proc_slice)
+  {
+    _x_post_frame_copy_down(frame, frame->next);
+    skip = frame->next->draw(frame->next, stream);
+    _x_post_frame_copy_up(frame, frame->next);
+    return skip;
+  }
+
+  enigma_frame = port->original_port->get_frame(port->original_port,
+    frame->width, frame->height, frame->ratio, frame->format, frame->flags | VO_BOTH_FIELDS);
+
+  _x_post_frame_copy_down(frame, enigma_frame);
+
+  switch (enigma_frame->format)
+  {
+  case XINE_IMGFMT_YUY2:
+    enigma_video_scale_YUY2(this, frame, enigma_frame);
+    break;
+
+  case XINE_IMGFMT_YV12:
+    enigma_video_scale_YV12(this, frame, enigma_frame);
+    break;
+  }
+
+  skip = enigma_frame->draw(enigma_frame, stream);
+  _x_post_frame_copy_up(frame, enigma_frame);
+  enigma_frame->free(enigma_frame);
+
+  return skip;
+}
diff -urN xine-lib-1.2.6/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in xine-lib-1.2.6_hg20140709/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in
--- xine-lib-1.2.6/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: libmpeg2convert
-Description: libmpeg2 helper functions for converting to various formats.
-Version: @VERSION@
-Libs: -L${libdir} -lmpeg2convert
-Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2.6/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in xine-lib-1.2.6_hg20140709/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in
--- xine-lib-1.2.6/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: libmpeg2
-Description: A decoding library for MPEG-1 and MPEG-2 streams.
-Version: @VERSION@
-Libs: -L${libdir} -lmpeg2
-Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2.6/src/video_dec/libvdpau/alterh264_decode.c xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/alterh264_decode.c
--- xine-lib-1.2.6/src/video_dec/libvdpau/alterh264_decode.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/alterh264_decode.c	2014-07-25 05:29:40.000000000 +0200
@@ -26,7 +26,7 @@
 
 
 #define MAX_DPB_SIZE 16
-#define MIN_BUFFER_SIZE 10000
+#define MIN_BUFFER_SIZE 1000
 #define MAX_BUFFER_SIZE 3145728
 
 #define NAL_UNSPECIFIED 0
@@ -1838,7 +1838,18 @@
     event.data_length = sizeof (data);
     data.width = seq->coded_width;
     data.height = seq->coded_height;
-    data.aspect = seq->ratio;
+
+    if (fabs(seq->ratio-1.0)<0.1)
+      data.aspect = XINE_VO_ASPECT_SQUARE;
+    else if (fabs(seq->ratio-1.33)<0.1)
+      data.aspect = XINE_VO_ASPECT_4_3;
+    else if (fabs(seq->ratio-1.77)<0.1)
+      data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+    else if (fabs(seq->ratio-2.11)<0.1)
+      data.aspect = XINE_VO_ASPECT_DVB;
+    else
+      data.aspect = XINE_VO_ASPECT_AUTO;
+
     xine_event_send (vd->stream, &event);
   }
 
diff -urN xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_h264.c xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_h264.c
--- xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_h264.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_h264.c	2014-07-25 05:29:40.000000000 +0200
@@ -377,7 +377,18 @@
   event.data_length = sizeof(data);
   data.width = this->width;
   data.height = this->height;
-  data.aspect = this->ratio;
+
+  if (fabs(this->ratio-1.0)<0.1)
+    data.aspect = XINE_VO_ASPECT_SQUARE;
+  else if (fabs(this->ratio-1.33)<0.1)
+    data.aspect = XINE_VO_ASPECT_4_3;
+  else if (fabs(this->ratio-1.77)<0.1)
+    data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+  else if (fabs(this->ratio-2.11)<0.1)
+    data.aspect = XINE_VO_ASPECT_DVB;
+  else
+    data.aspect = XINE_VO_ASPECT_AUTO;
+
   xine_event_send( this->stream, &event );
 
   switch(this->completed_pic->sps_nal->sps.profile_idc) {
diff -urN xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_mpeg12.c xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_mpeg12.c
--- xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_mpeg12.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_mpeg12.c	2014-07-25 05:29:40.000000000 +0200
@@ -405,7 +405,8 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+    //data.aspect = sequence->ratio;
+    data.aspect = sequence->aspect_ratio_information;
     xine_event_send( this_gen->stream, &event );
   }
   else if ( sequence->have_header == 2 && sequence->reported_video_step != sequence->video_step ) {
diff -urN xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_mpeg4.c xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_mpeg4.c
--- xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_mpeg4.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_mpeg4.c	2014-07-25 05:29:40.000000000 +0200
@@ -321,7 +321,18 @@
   event.data_length = sizeof(data);
   data.width = sequence->coded_width;
   data.height = sequence->coded_height;
-  data.aspect = sequence->ratio;
+
+  if (fabs(sequence->ratio-1.0)<0.1)
+    data.aspect = XINE_VO_ASPECT_SQUARE;
+  else if (fabs(sequence->ratio-1.33)<0.1)
+    data.aspect = XINE_VO_ASPECT_4_3;
+  else if (fabs(sequence->ratio-1.77)<0.1)
+    data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+  else if (fabs(sequence->ratio-2.11)<0.1)
+    data.aspect = XINE_VO_ASPECT_DVB;
+  else
+    data.aspect = XINE_VO_ASPECT_AUTO;
+
   xine_event_send( this_gen->stream, &event );
 }
 
diff -urN xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_vc1.c xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_vc1.c
--- xine-lib-1.2.6/src/video_dec/libvdpau/vdpau_vc1.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_dec/libvdpau/vdpau_vc1.c	2014-07-25 05:29:40.000000000 +0200
@@ -239,7 +239,18 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+
+    if (fabs(sequence->ratio-1.0)<0.1)
+      data.aspect = XINE_VO_ASPECT_SQUARE;
+    else if (fabs(sequence->ratio-1.33)<0.1)
+      data.aspect = XINE_VO_ASPECT_4_3;
+    else if (fabs(sequence->ratio-1.77)<0.1)
+      data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+    else if (fabs(sequence->ratio-2.11)<0.1)
+      data.aspect = XINE_VO_ASPECT_DVB;
+    else
+      data.aspect = XINE_VO_ASPECT_AUTO;
+
     xine_event_send( this_gen->stream, &event );
   }
 }
diff -urN xine-lib-1.2.6/src/video_out/video_out_fb.c xine-lib-1.2.6_hg20140709/src/video_out/video_out_fb.c
--- xine-lib-1.2.6/src/video_out/video_out_fb.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/video_out_fb.c	2014-07-25 05:30:14.000000000 +0200
@@ -97,6 +97,8 @@
 
   vo_scale_t         sc;
 
+  void              *chunk[3]; /* mem alloc by xmalloc_aligned           */
+
   yuv2rgb_t         *yuv2rgb;  /* yuv2rgb converter for this frame */
   uint8_t           *rgb_dst;
   int                yuv_stride;
diff -urN xine-lib-1.2.6/src/video_out/video_out_opengl.c xine-lib-1.2.6_hg20140709/src/video_out/video_out_opengl.c
--- xine-lib-1.2.6/src/video_out/video_out_opengl.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/video_out_opengl.c	2014-07-25 05:30:14.000000000 +0200
@@ -139,6 +139,14 @@
 #define MY_PI                3.1415926
 #define MY_2PI               6.2831853
 
+typedef struct opengl_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} opengl_argb_layer_t;
 
 typedef struct {
   vo_frame_t         vo_frame;
@@ -215,8 +223,14 @@
 
   /* Frame state */
   opengl_frame_t    *frame[NUM_FRAMES_BACKLOG];
+  
+  /* Overlay */
   x11osd            *xoverlay;
+  opengl_argb_layer_t argb_layer;
   int                ovl_changed;
+  int                last_ovl_width, last_ovl_height;
+  int                tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   config_values_t   *config;
   xine_t            *xine;
@@ -246,6 +260,10 @@
     enum render_e defaction;
     /* Fallback: change to following render backend if this one doesn't work */
     int fallback;
+    /* Upload new overlay image; Returns 0 if failed */
+    int (*ovl_image)(opengl_driver_t *, opengl_frame_t *);
+    /* Display current overlay */
+    void (*ovl_display)(opengl_driver_t *, opengl_frame_t *);
 } opengl_render_t;
 
 
@@ -265,10 +283,21 @@
   float           tx, ty;
 
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
+  
   tx = (float) frame->width  / this->tex_width;
   ty = (float) frame->height / this->tex_height;
   /* Draw quad */
@@ -280,6 +309,56 @@
   glEnd ();
 }
 
+/* Static Overlay display */
+static void render_overlay (opengl_driver_t *this, opengl_frame_t *frame) {
+  int             x1, x2, y1, y2;
+  float           tx, ty;
+
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  
+  if (this->tex_ovl_width == 0 && this->tex_ovl_height == 0) // Image_Pipeline renderer is active (no texture support)
+  {
+    glPixelZoom   (((float)this->gui_width)    / this->argb_layer.width,
+	       	 - ((float)this->gui_height)   / this->argb_layer.height);
+    glRasterPos2i (0, 0);
+    glDrawPixels  (this->argb_layer.width, this->argb_layer.height, GL_BGRA,
+		             GL_UNSIGNED_BYTE, this->argb_layer.buffer);
+  }
+  else
+  {
+    if (this->glBindTextureEXT) // bind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+
+    if (this->fprog != -1)  // 2D_Tex_Fragprog is active which uses a pixelshader to make yuv2rgb conversion
+	                    // -> disable it because texture is already argb
+      glDisable(MYGL_FRAGMENT_PROGRAM_ARB);
+		    
+    /* Calc texture/rectangle coords */
+    x1 = 0;
+    y1 = 0;
+    x2 = this->gui_width;
+    y2 = this->gui_height;
+    tx = (float) this->argb_layer.width  / this->tex_ovl_width;
+    ty = (float) this->argb_layer.height / this->tex_ovl_height;
+
+    /* Draw quad */
+    glBegin (GL_QUADS);
+    glTexCoord2f (tx, ty);   glVertex2i (x2, y2);
+    glTexCoord2f (0,  ty);   glVertex2i (x1, y2);
+    glTexCoord2f (0,  0);    glVertex2i (x1, y1);
+    glTexCoord2f (tx, 0);    glVertex2i (x2, y1);
+    glEnd ();
+
+    if (this->fprog != -1)  // enable pixelshader for next normal video frame
+      glEnable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    if (this->glBindTextureEXT) // unbind overlay texture  
+      this->glBindTextureEXT (GL_TEXTURE_2D, 0);
+  }
+  glDisable(GL_BLEND);
+}
+
 /* Static 2d texture tiled based display */
 static void render_tex2dtiled (opengl_driver_t *this, opengl_frame_t *frame) {
   int    tex_w, tex_h, frame_w, frame_h;
@@ -291,10 +370,20 @@
   frame_w = frame->width;
   frame_h = frame->height;
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
   txa = 1.0 / tex_w;
   tya = 1.0 / tex_h;
   txb = (float) frame_w / (tex_w-2);	/* temporary: total */
@@ -325,11 +414,23 @@
 
 /* Static image pipline based display */
 static void render_draw (opengl_driver_t *this, opengl_frame_t *frame) {
-  glPixelZoom   (((float)this->sc.output_width)    / frame->width,
-		 - ((float)this->sc.output_height) / frame->height);
-  glRasterPos2i (this->sc.output_xoffset, this->sc.output_yoffset);
-  glDrawPixels  (frame->width, frame->height, RGB_TEXTURE_FORMAT,
-		 GL_UNSIGNED_BYTE, frame->rgb);
+	
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    glPixelZoom(((float)this->video_window_width)  / frame->width,
+              - ((float)this->video_window_height) / frame->height);
+    glRasterPos2i(this->video_window_x, this->video_window_y);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
+  else
+  {
+    glPixelZoom(((float)this->sc.output_width)  / frame->width,
+              - ((float)this->sc.output_height) / frame->height);
+    glRasterPos2i(this->sc.output_xoffset, this->sc.output_yoffset);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
 }
 
 /* Animated spinning cylinder */
@@ -480,6 +581,45 @@
   return 2;
 }
 
+/* holds/allocates extra texture for overlay */
+/* returns 0: allocation failure  1: texture updated  2: texture kept */
+static int render_help_overlay_image_tex(opengl_driver_t *this, int new_w, int new_h,
+				                         GLint glformat, GLint texformat) {
+  int tex_w, tex_h, err;
+
+  /* check necessary texture size and allocate */
+  if (new_w != this->last_ovl_width ||
+      new_h != this->last_ovl_height ||
+      ! this->tex_ovl_width || ! this->tex_ovl_height) {
+    tex_w = tex_h = 16;
+    while (tex_w < new_w)
+      tex_w <<= 1;
+    while (tex_h < new_h)
+      tex_h <<= 1;
+
+    if (tex_w != this->tex_ovl_width || tex_h != this->tex_ovl_height) {
+      char *tmp = calloc (tex_w * tex_h, 4); /* 4 enough until RGBA */
+      if (this->glBindTextureEXT)  // xine code binds without call glGenTextures -> seems to me not correct
+        this->glBindTextureEXT (GL_TEXTURE_2D, 1000);  // bind 1000 to avoid collision with tiledtex textures / don't want to rewrite everything ...
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexImage2D (GL_TEXTURE_2D, 0, glformat, tex_w, tex_h,
+		      0, texformat, GL_UNSIGNED_BYTE, tmp);
+      err = glGetError ();
+      free (tmp);
+      if (err)
+	    return 0;
+      this->tex_ovl_width  = tex_w;
+      this->tex_ovl_height = tex_h;
+      lprintf ("* new texsize: %dx%d\n", tex_w, tex_h);
+    }
+    this->last_ovl_width  = new_w;
+    this->last_ovl_height = new_h;
+    return 1;
+  }
+  return 2;										 
+}
+
 /* returns 0: allocation failure  1: textures updated  2: textures kept */
 static int render_help_image_tiledtex (opengl_driver_t *this,
 				       int new_w, int new_h,
@@ -564,6 +704,24 @@
   return 1;
 }
 
+static int render_overlay_image_tex (opengl_driver_t *this, opengl_frame_t *frame) {
+  int ret;
+  
+  // use own texture
+  ret = render_help_overlay_image_tex (this, this->argb_layer.width, this->argb_layer.height,
+                                       4, GL_BGRA);
+
+  if (! ret)
+    return 0;
+
+  if (this->glBindTextureEXT)
+    this->glBindTextureEXT (GL_TEXTURE_2D, 1000); 
+  glTexSubImage2D (GL_TEXTURE_2D, 0, 4, 0, this->argb_layer.width, this->argb_layer.height,
+                   GL_BGRA, GL_UNSIGNED_BYTE,
+                   this->argb_layer.buffer);
+  return 1;
+}
+
 static int render_image_tiledtex (opengl_driver_t *this, opengl_frame_t *frame) {
   int ret;
   int frame_w, frame_h, tex_w, tex_h, i, j, nx, ny;
@@ -1033,20 +1191,20 @@
 /*
  * List of render backends
  */
-/* name, display, image,  setup, needsrgb, defaction, fallback */
+/* name, display, image,  setup, needsrgb, defaction, fallback, ovl_image, ovl_display */
 static const opengl_render_t opengl_rb[] = {
     {   "2D_Tex_Fragprog",  render_tex2d, render_image_fp_yuv,
-	render_setup_fp_yuv, 0, RENDER_NONE, 1 },
+	render_setup_fp_yuv, 0, RENDER_NONE, 1, render_overlay_image_tex, render_overlay },
     {   "2D_Tex",           render_tex2d, render_image_tex,
-	render_setup_tex2d,  1, RENDER_NONE, 2 },
+	render_setup_tex2d,  1, RENDER_NONE, 2, render_overlay_image_tex, render_overlay },
     {   "2D_Tex_Tiled",     render_tex2dtiled, render_image_tiledtex,
-	render_setup_tex2d,  1, RENDER_NONE, 3 },
+	render_setup_tex2d,  1, RENDER_NONE, 3, render_overlay_image_tex, render_overlay },
     {   "Image_Pipeline",   render_draw, render_image_nop,
-	render_setup_2d,     1, RENDER_NONE, -1 },
+	render_setup_2d,     1, RENDER_NONE, -1, render_image_nop, render_overlay },
     {   "Cylinder",         render_cyl, render_image_tex,
-	render_setup_cyl,    1, RENDER_DRAW, 1 },
+	render_setup_cyl,    1, RENDER_DRAW, 1, render_image_nop, render_image_nop },
     {   "Env_Mapped_Torus", render_env_tor, render_image_envtex,
-	render_setup_torus,  1, RENDER_DRAW, 1 }
+	render_setup_torus,  1, RENDER_DRAW, 1, render_image_nop, render_image_nop }
 } ;
 
 
@@ -1133,12 +1291,27 @@
 	CHECKERR ("pre-render");
 	ret = 1;
 	if (changed)
+	  if (this->argb_layer.changed) // clean window after every overlay change - do it twice because of double buffering
+	  {
+      glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+      if (this->argb_layer.changed == 1) 
+        this->argb_layer.changed++;
+      else this->argb_layer.changed = 0;
+    }
 	  ret = (render->image) (this, frame);
-	(render->display) (this, frame);
-	if (this->render_double_buffer)
-	  glXSwapBuffers(this->display, this->drawable);
-	else
-	  glFlush ();
+    (render->display) (this, frame);
+    // display overlay
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+    {
+      ret = (render->ovl_image) (this, frame);
+      (render->ovl_display) (this, frame);
+    }
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    if (this->render_double_buffer)
+      glXSwapBuffers(this->display, this->drawable);
+    else
+      glFlush ();
 	/* Note: no glFinish() - work concurrently to the graphics pipe */
 	CHECKERR ("post-render");
 	XUnlockDisplay (this->display);
@@ -1200,6 +1373,7 @@
 	}
 	XUnlockDisplay (this->display);
 	this->tex_width = this->tex_height = 0;
+	this->tex_ovl_width = this->tex_ovl_height = 0;
       }
       break;
 
@@ -1556,6 +1730,9 @@
   opengl_driver_t  *this  = (opengl_driver_t *) this_gen;
   opengl_frame_t   *frame = (opengl_frame_t *) frame_gen;
 
+  if (overlay->width <= 0 || overlay->height <= 0 || (!overlay->rle && (!overlay->argb_layer || !overlay->argb_layer->buffer)))
+    return;
+
   /* Alpha Blend here */
   if (overlay->rle) {
     if (overlay->unscaled) {
@@ -1597,6 +1774,28 @@
 #     endif
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  { 
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(opengl_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy(this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static int opengl_redraw_needed (vo_driver_t *this_gen) {
@@ -1890,6 +2089,11 @@
     XUnlockDisplay (this->display);
   }
 
+  pthread_mutex_lock (&this->argb_layer.mutex);
+  if (this->argb_layer.buffer)
+	free(this->argb_layer.buffer);
+  pthread_mutex_unlock (&this->argb_layer.mutex);
+
   _x_alphablend_free(&this->alphablend_extra_data);
 
   free (this);
@@ -1941,7 +2145,17 @@
   this->fprog = -1;
 
   this->xoverlay                = NULL;
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
   this->ovl_changed             = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
+  
   this->xine                    = class->xine;
   this->config                  = config;
 
diff -urN xine-lib-1.2.6/src/video_out/video_out_raw.c xine-lib-1.2.6_hg20140709/src/video_out/video_out_raw.c
--- xine-lib-1.2.6/src/video_out/video_out_raw.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/video_out_raw.c	2014-07-25 05:30:14.000000000 +0200
@@ -66,6 +66,7 @@
 
   int                width, height, format, flags;
   double             ratio;
+  void              *chunk[4]; /* mem alloc by xmalloc_aligned           */
   uint8_t           *rgb, *rgb_dst;
   yuv2rgb_t         *yuv2rgb; /* yuv2rgb converter set up for this frame */
 
diff -urN xine-lib-1.2.6/src/video_out/video_out_vdpau.c xine-lib-1.2.6_hg20140709/src/video_out/video_out_vdpau.c
--- xine-lib-1.2.6/src/video_out/video_out_vdpau.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/video_out_vdpau.c	2014-07-25 05:30:14.000000000 +0200
@@ -188,8 +188,8 @@
 static VdpDecoderRender *orig_vdp_decoder_render;
 
 #ifdef LOCKDISPLAY
-#define DO_LOCKDISPLAY          XLockDisplay(guarded_display)
-#define DO_UNLOCKDISPLAY        XUnlockDisplay(guarded_display)
+#define DO_LOCKDISPLAY          if (guarded_display) XLockDisplay(guarded_display);
+#define DO_UNLOCKDISPLAY        if (guarded_display) XUnlockDisplay(guarded_display);
 static Display *guarded_display;
 #else
 #define DO_LOCKDISPLAY
@@ -746,7 +746,14 @@
       this->ovl_video_dest_rect = vid_rect;
     }
 
-    if (!ovl->unscaled) {
+    if (ovl->unscaled==2) {
+      ovl_rect.x0 = 0;
+      ovl_rect.y0 = 0;
+      ovl_rect.x1 = this->sc.gui_width;
+      ovl_rect.y1 = this->sc.gui_height;
+      this->ovl_changed = 1;
+    }
+    else if (ovl->unscaled==0) {
       double rx, ry;
       VdpRect clip_rect;
       if (ovl->extent_width > 0 && ovl->extent_height > 0) {
@@ -778,7 +785,6 @@
         rx = (double)this->sc.output_width / (double)this->sc.displayed_width;
         ry = (double)this->sc.output_height / (double)this->sc.displayed_height;
       }
-
       if (zoom) {
         /* clip overlay window to margins of displayed video window */
         if (ovl_rect.x0 < clip_rect.x0) {
@@ -2158,6 +2164,12 @@
       this->deinterlace = value;
       vdpau_set_deinterlace( this_gen );
       break;
+    case VO_PROP_DEINTERLACE_SD:
+      this->deinterlace_method_sd = value;
+      break;
+    case VO_PROP_DEINTERLACE_HD:
+      this->deinterlace_method_hd = value;
+      break;
     case VO_PROP_ZOOM_X:
       if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
         this->zoom_x = value;
@@ -2631,7 +2643,12 @@
     return NULL;
 
 #ifdef LOCKDISPLAY
-  guarded_display     = visual->display;
+  int buggy_xcb_workaround = config->register_bool( config, "video.output.vdpau_enable_buggy_xcb_workaround", 1,
+    _("vdpau: Use lock display synchronization for some vdpau calls (workaround for buggy libX11/xcb)"),
+    _("Enable this if you have a buggy libX11/xcb."),
+      10, NULL, this );
+  guarded_display     = buggy_xcb_workaround ? visual->display: NULL;
+  fprintf( stderr, "vo_vdpau: %s lock display synchronization for some vdpau calls\n", buggy_xcb_workaround ? "Use": "Do not use" );
 #endif
 
   this->display       = visual->display;
diff -urN xine-lib-1.2.6/src/video_out/video_out_xshm.c xine-lib-1.2.6_hg20140709/src/video_out/video_out_xshm.c
--- xine-lib-1.2.6/src/video_out/video_out_xshm.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/video_out_xshm.c	2014-07-25 05:30:14.000000000 +0200
@@ -128,6 +128,7 @@
   xshm_frame_t      *cur_frame;
   x11osd            *xoverlay;
   int                ovl_changed;
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   int (*x11_old_error_handler)  (Display *, XErrorEvent *);
 
@@ -793,6 +794,18 @@
       }
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  {
+    pthread_mutex_lock (&overlay->argb_layer->mutex); 
+    LOCK_DISPLAY(this);
+    x11osd_blend(this->xoverlay, overlay);
+    UNLOCK_DISPLAY(this);
+    pthread_mutex_unlock (&overlay->argb_layer->mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static void clean_output_area (xshm_driver_t *this, xshm_frame_t *frame) {
@@ -806,7 +819,7 @@
   for( i = 0; i < 4; i++ ) {
     if( this->sc.border[i].w && this->sc.border[i].h )
       XFillRectangle(this->display, this->drawable, this->gc,
-                     this->sc.border[i].x, this->sc.border[i].y,
+                     this->sc.border[i].x + this->video_window_x, this->sc.border[i].y + this->video_window_y,
                      this->sc.border[i].w, this->sc.border[i].h);
   }
   if (this->xoverlay) {
@@ -1237,6 +1250,10 @@
   UNLOCK_DISPLAY(this);
   this->xoverlay                = NULL;
   this->ovl_changed             = 0;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
 
   this->x11_old_error_handler = NULL;
   this->xine                  = class->xine;
diff -urN xine-lib-1.2.6/src/video_out/x11osd.c xine-lib-1.2.6_hg20140709/src/video_out/x11osd.c
--- xine-lib-1.2.6/src/video_out/x11osd.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/x11osd.c	2014-07-25 05:30:14.000000000 +0200
@@ -44,6 +44,9 @@
 #include <X11/extensions/shape.h>
 #include <X11/Xatom.h>
 
+#include <xine/xineutils.h>
+#include "xine_mmx.h"
+
 #define LOG_MODULE "x11osd"
 #define LOG_VERBOSE
 
@@ -78,6 +81,9 @@
   Pixmap bitmap;
   Visual *visual;
   Colormap cmap;
+  XImage *argb_img;
+  void (*scale_func) (uint32_t* src, uint32_t* dst, int width, int step);
+  int scale_mmx;
 
   GC gc;
 
@@ -96,6 +102,12 @@
   assert (osd);
 
   lprintf("expose (state:%d)\n", osd->clean );
+  
+  // copy argb data to bitmap
+  if (osd->argb_img && osd->argb_img->data)
+  {
+     XPutImage(osd->display, osd->bitmap, osd->gc, osd->argb_img, 0, 0, 0, 0, osd->width, osd->height);
+  }
 
   switch (osd->mode) {
     case X11OSD_SHAPED:
@@ -153,6 +165,11 @@
 		       osd->width, osd->height, osd->depth);
       break;
   }
+  
+  // resize argb_img data
+  XDestroyImage(osd->argb_img);
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
 
   osd->clean = UNDEFINED;
   x11osd_clear(osd);
@@ -224,6 +241,11 @@
       break;
   }
 
+  // resize argb_img data
+  XDestroyImage(osd->argb_img);
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
+
   osd->clean = UNDEFINED;
   /* do not x11osd_clear() here: osd->u.colorkey.sc has not being updated yet */
 }
@@ -268,6 +290,26 @@
   assert(osd->width);
   assert(osd->height);
 
+  // create image for argb overlay
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
+  
+  // scale function
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+  uint32_t mm = xine_mm_accel();
+  if ((osd->scale_func == NULL) && ((mm & MM_ACCEL_X86_MMX) || (mm & MM_ACCEL_X86_MMXEXT)))
+  {
+    osd->scale_func= x11osd_scale_line_mmx;
+    osd->scale_mmx= 1;
+    printf("X11OSD: MMX OSD scaling active\n");
+  }
+#endif
+  if (osd->scale_func == NULL)
+  {
+    osd->scale_func= x11osd_scale_line;
+    osd->scale_mmx= 0;
+  }  
+
   switch (mode) {
     case X11OSD_SHAPED:
       if (!XShapeQueryExtension (osd->display, &event_basep, &error_basep)) {
@@ -395,7 +437,7 @@
     XFreePixmap (osd->display, osd->u.shaped.mask_bitmap);
     XDestroyWindow (osd->display, osd->u.shaped.window);
   }
-
+  XDestroyImage(osd->argb_img);
   free (osd);
 }
 
@@ -550,5 +592,292 @@
     }
     osd->clean = DRAWN;
   }
+  else if (overlay->argb_layer && overlay->argb_layer->buffer)
+  {
+    osd->argb_img->data = realloc(osd->argb_img->data, osd->width * osd->height * sizeof(uint32_t));
+    
+    x11osd_scale_argb32_image(osd, (uint32_t*)overlay->argb_layer->buffer, (uint32_t*)osd->argb_img->data, overlay->extent_width, overlay->extent_height, osd->width, osd->height);
+	  
+	uint32_t bx, by;
+	uint32_t w, h;
+	if(osd->mode==X11OSD_SHAPED) // fill bitmask / if bit is set, the corresponding pixel is drawn to screen
+	{
+	  w= osd->width - overlay->x;
+	  h= osd->height - overlay->y;
+	  for (by= 0; by < h; by++)
+		for (bx= 0; bx < w; bx++)
+		  if ((((uint32_t*)osd->argb_img->data)[bx+by*w] >> 24) != 0 )
+		    XDrawPoint(osd->display, osd->u.shaped.mask_bitmap, osd->u.shaped.mask_gc, bx, by);
+	}    
+
+	osd->clean = DRAWN;
+  }
+}
+
+// adapted algorithm from yuv2rgb.c to scale rgb images
+void x11osd_scale_argb32_image(x11osd *osd, uint32_t* src, uint32_t* dst, int src_width, int src_height, int dst_width, int dst_height)
+{
+	int step_dx = src_width * 32768 / dst_width;
+	int step_dy = src_height * 32768 / dst_height;
+	int height, dy= 0;
+		
+	if (src_width == dst_width && src_height == dst_height)
+	{
+	  xine_fast_memcpy (dst, src, dst_width*dst_height*4);
+	  return;
+	}
+	
+	for (height = 0;; ) 
+	{
+	  osd->scale_func(src, dst, dst_width, step_dx);  // scale_line with or without mmx
+	    
+      dy += step_dy;
+      dst += dst_width;
+
+      while (--dst_height > 0 && dy < 32768)    // copy scaled line (only enlarging)
+      {
+        xine_fast_memcpy (dst, dst-(dst_width), dst_width*4); // copy last line
+
+	    dy += step_dy;
+	    dst += dst_width;
+      }
+      if (dst_height <= 0)
+	    break;
+
+      do 
+      { // skip at least one line (possibly more if scale factor < 1)
+        dy -= 32768;
+        src += src_width;  
+
+        height++;
+      } while( dy>=32768);
+    }	
+    if (osd->scale_mmx) emms();   // empties the MMX state
 }
 
+// adapted algorithm from yuv2rgb.c to scale single argb line
+void x11osd_scale_line(uint32_t* src, uint32_t* dst, int width, int step)
+{
+  uint32_t p1;
+  uint32_t p2;
+  int dx;
+  
+  p1 = *src++;
+  p2 = *src++;
+  dx = 0;
+  
+  if (step < 32768) 
+  {
+    while (width) 
+    {
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24                   // interpolate A: (A1*(32768-dx)+A2*dx) / 32768
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16 // interpolate R
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8 // interpolate G
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;                        // interpolate B
+      
+      dx += step;
+      if (dx > 32768) 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else if (step <= 65536) 
+  {
+    while (width) 
+    {
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;
+
+      dx += step;
+      if (dx > 65536) 
+      {
+	    dx -= 65536;
+	    p1 = *src++;
+	    p2 = *src++;
+      } else 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else 
+  {
+    while (width) 
+    {
+      int offs;
+
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;
+
+      dx += step;
+      offs=((dx-1)>>15);
+      dx-=offs<<15;
+      src+=offs-2;
+      p1=*src++;
+      p2=*src++;
+      dst ++;
+      width --;
+    }
+  }
+};
+
+// adapted algorithm from yuv2rgb.c to scale single argb line
+void x11osd_scale_line_mmx(uint32_t* src, uint32_t* dst, int width, int step)
+{
+  uint32_t p1;
+  uint32_t p2;
+  int dx;
+  int dx2; 
+  
+  p1 = *src++;
+  p2 = *src++;
+  dx = 0;
+  
+  if (step < 32768) 
+  {
+    while (width) 
+    {
+	  dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+       
+      /*  
+       *  MMX ARGB interpolation between p1(a1,r1,g1,b1) and p2(a2,r2,g2,b2)
+       *  a= (a1* (32768-dx) + a2 * dx) / 32768 -> a = a1 - a1*dx/32768 + a2*dx/32768
+       *  r= (r1* (32768-dx) + r2 * dx) / 32768 -> r = r1 - r1*dx/32768 + r2*dx/32768
+       *  ...
+       *  Doing multiplication of a,r,g,b with dx in one step
+       *  Division by 32768 is not necessary in mmx because you can get only the high 16 bits of a multiplication
+      */
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+      
+      dx += step;
+      if (dx > 32768) 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else if (step <= 65536) 
+  {
+    while (width) 
+    {
+	  dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+	      
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+
+      dx += step;
+      if (dx > 65536) 
+      {
+	    dx -= 65536;
+	    p1 = *src++;
+	    p2 = *src++;
+      } else 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else 
+  {
+    while (width) 
+    {
+      int offs;
+      
+      dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+      
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+
+      dx += step;
+      offs=((dx-1)>>15);
+      dx-=offs<<15;
+      src+=offs-2;
+      p1=*src++;
+      p2=*src++;
+      dst ++;
+      width --;
+    }
+  }
+};
diff -urN xine-lib-1.2.6/src/video_out/x11osd.h xine-lib-1.2.6_hg20140709/src/video_out/x11osd.h
--- xine-lib-1.2.6/src/video_out/x11osd.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/video_out/x11osd.h	2014-07-25 05:29:40.000000000 +0200
@@ -29,6 +29,7 @@
 #define X11OSD_H
 
 #include <xine/vo_scale.h>
+#include <sys/time.h>
 
 typedef struct x11osd x11osd;
 enum x11osd_mode {X11OSD_SHAPED, X11OSD_COLORKEY};
@@ -49,4 +50,10 @@
 
 void x11osd_blend(x11osd *osd, vo_overlay_t *overlay);
 
+void x11osd_scale_argb32_image(x11osd *osd, uint32_t* src, uint32_t* dst, int src_width, int src_height, int dst_width, int dst_height);
+
+void x11osd_scale_line(uint32_t* src, uint32_t* dst, int width, int step);
+
+void x11osd_scale_line_mmx(uint32_t* src, uint32_t* dst, int width, int step);
+
 #endif
diff -urN xine-lib-1.2.6/src/xine-engine/load_plugins.c xine-lib-1.2.6_hg20140709/src/xine-engine/load_plugins.c
--- xine-lib-1.2.6/src/xine-engine/load_plugins.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/load_plugins.c	2014-07-25 05:30:14.000000000 +0200
@@ -1324,6 +1324,9 @@
   xine_list_delete (plugindirs);
   free(homedir);
 
+ if ((_x_flags & XINE_FLAG_NO_WRITE_CACHE) == 0)
+   save_catalog (this);
+
   load_required_plugins (this);
 
   if ((_x_flags & XINE_FLAG_NO_WRITE_CACHE) == 0)
diff -urN xine-lib-1.2.6/src/xine-engine/Makefile.am xine-lib-1.2.6_hg20140709/src/xine-engine/Makefile.am
--- xine-lib-1.2.6/src/xine-engine/Makefile.am	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/Makefile.am	2014-07-25 05:30:14.000000000 +0200
@@ -44,7 +44,8 @@
                     $(LIBXINEPOSIX) $(RT_LIBS) $(NET_LIBS) $(XDG_BASEDIR_LIBS) \
                     $(AVUTIL_LIBS) $(MLIB_LIBS)
 
-libxine_la_LDFLAGS = $(LDFLAGS_NOUNDEFINED) $(AM_LDFLAGS) $(def_ldflags) $(GCSECTIONS) \
+libxine_la_LDFLAGS = $(AM_LDFLAGS) $(def_ldflags) $(GCSECTIONS) \
+	$(LDFLAGS_NOUNDEFINED) \
 	-weak libxine-interface.la \
 	-version-info $(XINE_LT_CURRENT):$(XINE_LT_REVISION):$(XINE_LT_AGE)
 
@@ -74,3 +75,4 @@
 uninstall-local:
 	rm -f "$(DESTDIR)$(libdir)"/libxine-interface.la
 	-rm -f $(DESTDIR)$(libdir)/$(DEF_FILE)
+
diff -urN xine-lib-1.2.6/src/xine-engine/osd.c xine-lib-1.2.6_hg20140709/src/xine-engine/osd.c
--- xine-lib-1.2.6/src/xine-engine/osd.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/osd.c	2014-07-25 05:30:14.000000000 +0200
@@ -511,6 +511,10 @@
   return _osd_show(osd, vpts, 1);
 }
 
+static int osd_show_gui_scaled (osd_object_t *osd, int64_t vpts) {
+  return _osd_show(osd, vpts, 2);
+}
+
 /*
  * send event to hide osd at given pts (0=now)
  * the object is not changed. there may be subsequent drawing  on it.
@@ -1917,6 +1921,7 @@
   this->draw_bitmap        = osd_draw_bitmap;
   this->set_argb_buffer    = osd_set_argb_buffer;
   this->show_unscaled      = osd_show_unscaled;
+  this->show_scaled        = osd_show_gui_scaled;
   this->get_capabilities   = osd_get_capabilities;
   this->set_extent         = osd_set_extent;
   this->set_video_window   = osd_set_video_window;
diff -urN xine-lib-1.2.6/src/xine-engine/video_out.c xine-lib-1.2.6_hg20140709/src/xine-engine/video_out.c
--- xine-lib-1.2.6/src/xine-engine/video_out.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/video_out.c	2014-07-25 05:30:14.000000000 +0200
@@ -143,7 +143,7 @@
 
   /* pts value when decoder delivered last video frame */
   int64_t                   last_delivery_pts;
-
+  int64_t                   last_pts;
 
   video_overlay_manager_t  *overlay_source;
 
@@ -151,6 +151,7 @@
 
   int                       current_width, current_height;
   int64_t                   current_duration;
+  int                       framerate;
   int                       frame_drop_limit_max;
   int                       frame_drop_limit;
   int                       frame_drop_cpt;
@@ -788,6 +789,24 @@
   this->current_height = img->height;
 
   if (stream) {
+
+    int new_framerate = img->duration==0?0:90000*1000/img->duration;
+    if (this->framerate != new_framerate) {
+      this->framerate = new_framerate;
+
+      xine_event_t event;
+      xine_framerate_data_t data;
+      event.type = XINE_EVENT_FRAMERATE_CHANGE;
+      event.stream = stream;
+      event.data = &data;
+      event.data_length = sizeof(data);
+      data.framerate = this->framerate;
+      xine_event_send( stream, &event );
+    }
+
+    if (img->pts!=0)
+      this->last_pts = img->pts;
+
     _x_refcounter_inc(stream->refcounter);
     _x_extra_info_merge( img->extra_info, stream->video_decoder_extra_info );
     stream->metronom->got_video_frame (stream->metronom, img);
@@ -1308,6 +1327,7 @@
       pthread_mutex_unlock( &this->free_img_buf_queue->mutex );
       if( img ) {
         img->vpts = cur_vpts;
+        img->duration = DEFAULT_FRAME_DURATION;
         /* extra info of the backup is thrown away, because it is not up to date */
         _x_extra_info_reset(img->extra_info);
         img->future_frame = NULL;
@@ -1884,6 +1904,10 @@
     pthread_mutex_unlock(&this->streams_lock);
     break;
 
+  case VO_PROP_LAST_PTS:
+    ret = (int)&this->last_pts;
+    break;
+
   /*
    * handle XINE_PARAM_xxx properties (convert from driver's range)
    */
diff -urN xine-lib-1.2.6/src/xine-engine/vo_scale.c xine-lib-1.2.6_hg20140709/src/xine-engine/vo_scale.c
--- xine-lib-1.2.6/src/xine-engine/vo_scale.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/vo_scale.c	2014-07-25 05:30:14.000000000 +0200
@@ -79,7 +79,7 @@
       desired_ratio = 4.0 / 3.0;
     }
 
-    this->video_pixel_aspect = desired_ratio / image_ratio;
+    this->video_pixel_aspect = desired_ratio / image_ratio * this->gui_pixel_aspect;
 
     _x_assert(this->gui_pixel_aspect != 0.0);
 
diff -urN xine-lib-1.2.6/src/xine-engine/xine_interface.c xine-lib-1.2.6_hg20140709/src/xine-engine/xine_interface.c
--- xine-lib-1.2.6/src/xine-engine/xine_interface.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-engine/xine_interface.c	2014-07-25 05:29:40.000000000 +0200
@@ -825,6 +825,10 @@
   this->osd.renderer->show_unscaled(&this->osd, vpts);
 }
 
+void xine_osd_show_scaled(xine_osd_t *this, int64_t vpts) {
+  this->osd.renderer->show_scaled(&this->osd, vpts);
+}
+
 void xine_osd_hide(xine_osd_t *this, int64_t vpts) {
   this->osd.renderer->hide(&this->osd, vpts);
 }
diff -urN xine-lib-1.2.6/src/xine-utils/color.c xine-lib-1.2.6_hg20140709/src/xine-utils/color.c
--- xine-lib-1.2.6/src/xine-utils/color.c	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-utils/color.c	2014-07-25 05:30:14.000000000 +0200
@@ -62,10 +62,6 @@
  * instructions.
  */
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #include <xine/xine_internal.h>
 #include "xine_mmx.h"
 
diff -urN xine-lib-1.2.6/src/xine-utils/xine_mmx.h xine-lib-1.2.6_hg20140709/src/xine-utils/xine_mmx.h
--- xine-lib-1.2.6/src/xine-utils/xine_mmx.h	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/src/xine-utils/xine_mmx.h	2014-07-25 05:29:40.000000000 +0200
@@ -275,15 +275,15 @@
 
 #define	sfence() __asm__ __volatile__ ("sfence\n\t")
 
-typedef	union {
-	int64_t			q[2];	/* Quadword (64-bit) value */
-	uint64_t		uq[2];	/* Unsigned Quadword */
-	int32_t			d[4];	/* Doubleword (32-bit) values */
-	uint32_t		ud[4];	/* Unsigned Doubleword */
-	short			w[8];	/* Word (16-bit) values */
-	unsigned short		uw[8];	/* Unsigned Word */
-	char			b[16];	/* Byte (8-bit) values */
-	unsigned char		ub[16];	/* Unsigned Byte */
+typedef		union {
+	int64_t                 q[2];   /* Quadword (64-bit) value */
+	uint64_t                uq[2];  /* Unsigned Quadword */
+	int32_t                 d[4];   /* Doubleword (32-bit) values */
+	uint32_t                ud[4];  /* Unsigned Doubleword */
+	short                   w[8];   /* Word (16-bit) values */
+	unsigned short          uw[8];  /* Unsigned Word */
+	char                    b[16];  /* Byte (8-bit) values */
+	unsigned char           ub[16]; /* Unsigned Byte */
 	float			sf[4];	/* Single-precision (32-bit) value */
 } ATTR_ALIGN(16) sse_t;	/* On a 16 byte (128-bit) boundary */
 
diff -urN xine-lib-1.2.6/version.sh xine-lib-1.2.6_hg20140709/version.sh
--- xine-lib-1.2.6/version.sh	2014-07-09 10:52:46.000000000 +0200
+++ xine-lib-1.2.6_hg20140709/version.sh	2014-07-25 05:30:14.000000000 +0200
@@ -39,7 +39,7 @@
 XINE_LT_REVISION=0
 XINE_LT_AGE=5
 
-test -f "`dirname $0`/.cvsversion" && XINE_VERSION_SUFFIX="hg"
+test -f "`dirname $0`/.cvsversion" && XINE_VERSION_SUFFIX="openpliPC-e2"
 XINE_VERSION_SPEC="${XINE_VERSION_MAJOR}.${XINE_VERSION_MINOR}.${XINE_VERSION_SUB}${XINE_VERSION_PATCH}${XINE_VERSION_SUFFIX}"
 
 ####
