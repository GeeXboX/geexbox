#!/bin/sh

# Create a minimalist X.org configuration file.
# It is required to be able to set custom resolution.

. /etc/X11/X.cfg

CFG_FILE=/etc/X11/xorg.conf
DEFAULT_CFG_FILE=/etc/X11/xorg.default
HAVE_EDID=0
HAVE_DDC=0
EDID_DATA=/tmp/edid-data
EDID_XORG=/tmp/edid-xorg
DDC_DATA=/tmp/ddc-data
DDC_RESOLUTIONS=/tmp/ddc-resolutions
DDC_MODELINES=/tmp/ddc-modelines
DDC_MONITOR=/tmp/ddc-monitor
MODES=/tmp/modes
MONITOR_ID="Generic Monitor"
DRV=${XORG_DRIVER}

set_monitor () {
  # set monitor identifier
  sed -i "s%::MONITOR_ID::%${MONITOR_ID}%" $CFG_FILE
}

no_monitor_info () {
  # no monitor info can be found
  sed -i 's%::CUSTOM_MONITOR::%%' $CFG_FILE
}

add_custom_monitor () {
  # declare custom monitor settings in config file
  CNT=`grep -n ::CUSTOM_MONITOR:: $DEFAULT_CFG_FILE | sed 's%\([0-9]*\).*%\1%'`
  TOTAL=`cat $DEFAULT_CFG_FILE | wc -l`
  head -n $((${CNT}-1)) $DEFAULT_CFG_FILE > $CFG_FILE
  cat $1 >> $CFG_FILE
  tail -n $(($TOTAL-$CNT)) $DEFAULT_CFG_FILE >> $CFG_FILE
}

read_edid () {
  # get EDID info
  get-edid 2>/dev/null > $EDID_DATA
  [ "$?" != 0 ] && return

  # read EDID info: check for valid ones
  parse-edid < $EDID_DATA 2>/dev/null > $EDID_XORG
  [ "$?" != 0 ] && return

  # valid EDID info
  HAVE_EDID=1

  # force disabling DPMS 
  sed -i 's%.*# DPMS .*%      Option "DPMS" "false"%' $EDID_XORG

  # declare new monitor settings in config file
  add_custom_monitor "$EDID_XORG"

  # tell X.Org to use custom monitor
  MONITOR_ID=`grep Identifier $EDID_XORG | sed 's%.*"\(.*\)".*%\1%'`
}

ddc_write_monitor () {
  echo "Section \"Monitor\"" > $DDC_MONITOR
  echo -e "\tIdentifier\t\"$MONITOR_ID\"" >> $DDC_MONITOR
  echo -e "\tOption\t\"DPMS\"\t\"false\"" >> $DDC_MONITOR
  echo -e "\tOption\t\"IgnoreEDID\"\t\"true\"" >> $DDC_MONITOR
  echo -e "\tHorizSync\t${HORIZSYNC}" >> $DDC_MONITOR
  echo -e "\tVertRefresh\t${VERTREFRESH}" >> $DDC_MONITOR
  cat $DDC_MODELINES >> $DDC_MONITOR
  echo "EndSection" >> $DDC_MONITOR
}

ddc_probe () {
  ddcprobe 2>/dev/null > $DDC_DATA
  [ "$?" != 0 ] && return

  # check if ddcprobe has found valid EDID info
  cat $DDC_DATA | grep -q noedid && return

  HAVE_DDC=1
  HORIZSYNC="`cat $DDC_DATA | grep monitorrange | sed 's%monitorrange: \(.*\),.*%\1%'`"
  VERTREFRESH="`cat $DDC_DATA | grep monitorrange | sed 's%monitorrange:.*, \(.*\)%\1%'`"
  MONITOR_ID="`cat $DDC_DATA | grep monitorname | sed 's%monitorname: \(.*\)%\1%'`"

  # find monitor supported resolutions
  grep dtiming $DDC_DATA | sed 's%dtiming: %%' | sort -r > $DDC_RESOLUTIONS

  # create corresponding modelines
  rm -f $DDC_MODELINES
  for i in `cat $DDC_RESOLUTIONS`; do
    DDC_WIDTH=`echo $i | sed 's%\(.*\)x.*%\1%'`
    DDC_HEIGHT=`echo $i | sed 's%.*x\(.*\)@.*%\1%'`
    DDC_FREQ=`echo $i | sed 's%.*@\(.*\)%\1%'`
    gtf $DDC_WIDTH $DDC_HEIGHT $DDC_FREQ >> $DDC_MODELINES
  done

  # now write custom monitor
  ddc_write_monitor

  # and write xorg.conf file
  add_custom_monitor "$DDC_MONITOR"
}

configure_device () {
  if [ $XORG_DRIVER = "auto" ]; then
    # Start X server in probe mode to find the best GPU driver
    Xorg -configure -probeonly -br
    DRV=`cat /xorg.conf.new | grep "Driver.*\"" | grep -v kbd | grep -v mouse | cut -f2 -d\"`
  fi
  sed -i "s%::DRIVER::%${DRV}%" $CFG_FILE
}

configure_monitor () {
  set_monitor
  if [ "$HAVE_EDID" = 1 -o "$HAVE_DDC" = 1 ]; then
    # monitor has already been configured
    sed -i "s%.*HorizSync.*::HS::%%" $CFG_FILE
    sed -i "s%.*VertRefresh.*::VR::%%" $CFG_FILE
    sed -i "s%::MODELINE::%%" $CFG_FILE
    return
  fi

  if [ "$XORG_HORIZSYNC" = "auto" -o "$XORG_VERTREFRESH" = "auto" ]; then
    # Default refresh rate
    HORIZSYNC="28-51"
    VERTREFRESH="43-60"

    # Try to get monitor's accurate refresh rate through EDID information
    ddcprobe | grep monitorrange 2>&1 > /dev/null
    if [ "$?" = 0 ]; then
      HORIZSYNC="`ddcprobe | grep monitorrange | sed 's%monitorrange: \(.*\),.*%\1%'`"
      VERTREFRESH="`ddcprobe | grep monitorrange | sed 's%monitorrange:.*, \(.*\)%\1%'`"
    fi
  else
    HORIZSYNC="$XORG_HORIZSYNC"
    VERTREFRESH="$XORG_VERTREFRESH"
  fi

  sed -i "s%::HS::%${HORIZSYNC}%" $CFG_FILE
  sed -i "s%::VR::%${VERTREFRESH}%" $CFG_FILE

  if [ "$XORG_RESX" != "auto" -a "$XORG_RESY" != "auto" ]; then
    if [ "$XORG_RATE" != "auto" ]; then
      # Try to get modeline for resolution user asked for
      MODELINE="`gtf $XORG_RESX $XORG_RESY $XORG_RATE | grep Modeline`"
      sed -i "s%::MODELINE::%${MODELINE}%" $CFG_FILE
    else
      # no custom modeline, use built-in ones
      sed -i "s%::MODELINE::%%" $CFG_FILE
    fi
  else
    # auto: try any fitting resolution
    sed -i "s%::MODELINE::%%" $CFG_FILE
  fi
}

configure_screen () {
  if [ "$HAVE_EDID" = 1 ]; then
    cat $EDID_XORG | grep "Mode\ " | sed 's%.*"\(.*\)".*%\1%' > $MODES
    for r in `cat $MODES`; do
      MODELINES="$MODELINES \"$r\""
    done
  elif [ "$HAVE_DDC" = 1 ]; then
    cat $DDC_MODELINES | grep "Modeline\ " | sed 's%.*"\(.*\)".*%\1%' > $MODES
    for r in `cat $MODES`; do
      MODELINES="$MODELINES \"$r\""
    done
  elif [ "$XORG_RESX" != "auto" -a "$XORG_RESY" != "auto" ]; then
    if [ "$XORG_RATE" != "auto" ]; then
      MODE_NAME=`gtf $XORG_RESX $XORG_RESY $XORG_RATE | grep Modeline | sed 's%.*"\(.*\)".*%\1%'`
      MODELINES="\"${MODE_NAME}\""
    else
      MODELINES="\"${XORG_RESX}x${XORG_RESY}\""
    fi
  else
    sed -i "s%.*::MODES::.*%%g" $CFG_FILE
    return
  fi
  RES="${MODELINES} ${FAILSAFE_RESOLUTIONS}"
  sed -i "s%::MODES::%${RES}%g" $CFG_FILE
}

if [ ! -f $CFG_FILE ]; then
  cp $DEFAULT_CFG_FILE $CFG_FILE

  if [ "$XORG_RESX" = "auto" -o "$XORG_RESY" = "auto" ]; then
    # try to get/set the best resolution suited for the monitor using EDID
    read_edid
    # as a fallback we may get EDID through ddcprobe
    [ "$HAVE_EDID" = 0 ] && ddc_probe
    # both autoconfiguration methods failed: remove monitor info
    [ "$HAVE_EDID" = 0 -a "$HAVE_DDC" = 0 ] && no_monitor_info
  else
    no_monitor_info
  fi

  configure_device
  configure_monitor
  configure_screen
fi
