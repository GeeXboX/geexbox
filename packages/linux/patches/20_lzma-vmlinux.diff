diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/lzma_misc.c linux-2.6.23-rc9/arch/i386/boot/compressed/lzma_misc.c
--- linux-2.6.23-rc9.orig/arch/x86/boot/compressed/lzma_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-rc9/arch/x86/boot/compressed/lzma_misc.c	2007-10-06 12:29:58.000000000 +0200
@@ -0,0 +1,279 @@
+/*
+ * lzma_misc.c
+ * 
+ * Decompress LZMA compressed vmlinuz 
+ * Version 0.91 Copyright (c) Ming-Ching Tiew mctiew@yahoo.com
+ * Program adapted from misc.c for 2.6 kernel
+ * Date: 5 Feb 2008 for kernel 2.6.24-git14
+ * Source released under GPL
+ */
+
+#undef CONFIG_PARAVIRT
+#ifdef CONFIG_X86_64
+#define _LINUX_STRING_H_ 1
+#define __LINUX_BITMAP_H 1
+#endif
+
+#include <linux/linkage.h>
+#include <linux/vmalloc.h>
+#include <linux/screen_info.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <asm/boot.h>
+
+#define OF(args)  args
+#define STATIC static
+
+#undef memset
+#undef memcpy
+#define memzero(s, n)     memset ((s), 0, (n))
+static void* memcpy(void *, __const void *, unsigned n);
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x8000		/* Window size must be at least 32k, */
+				/* and a power of two */
+
+static uch *inbuf;	     /* input buffer */
+
+static unsigned insize = 0;  /* valid bytes in inbuf */
+static unsigned inptr = 0;   /* index of next byte to be processed in inbuf */
+
+#define get_byte()  inbuf[inptr++]
+		
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static void error(char *m);
+  
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+static unsigned char *real_mode; /* Pointer to real-mode data */
+
+#define RM_EXT_MEM_K   (*(unsigned short *)(real_mode + 0x2))
+#ifndef STANDARD_MEMORY_BIOS_CALL
+#define RM_ALT_MEM_K   (*(unsigned long *)(real_mode + 0x1e0))
+#endif
+#define RM_SCREEN_INFO (*(struct screen_info *)(real_mode+0))
+
+static void putstr(const char *);
+
+#ifdef CONFIG_X86_64
+#define memptr long
+#else
+#define memptr unsigned
+#endif
+
+static memptr free_mem_ptr;
+static memptr free_mem_end_ptr;
+
+#ifdef CONFIG_X86_64
+#define HEAP_SIZE             0x7000
+#else
+#define HEAP_SIZE             0x4000
+#endif
+
+static char *vidmem = (char *)0xb8000;
+static int vidport;
+static int lines, cols;
+
+static void scroll(void)
+{
+	int i;
+
+	memcpy ( vidmem, vidmem + cols * 2, ( lines - 1 ) * cols * 2 );
+	for ( i = ( lines - 1 ) * cols * 2; i < lines * cols * 2; i += 2 )
+		vidmem[i] = ' ';
+}
+
+static void putstr(const char *s)
+{
+	int x,y,pos;
+	char c;
+
+#ifdef CONFIG_X86_32
+        if (RM_SCREEN_INFO.orig_video_mode == 0 && lines == 0 && cols == 0)
+               return;
+#endif
+
+	x = RM_SCREEN_INFO.orig_x;
+	y = RM_SCREEN_INFO.orig_y;
+
+	while ( ( c = *s++ ) != '\0' ) {
+		if ( c == '\n' ) {
+			x = 0;
+			if ( ++y >= lines ) {
+				scroll();
+				y--;
+			}
+		} else {
+			vidmem [ ( x + cols * y ) * 2 ] = c; 
+			if ( ++x >= cols ) {
+				x = 0;
+				if ( ++y >= lines ) {
+					scroll();
+					y--;
+				}
+			}
+		}
+	}
+
+	RM_SCREEN_INFO.orig_x = x;
+	RM_SCREEN_INFO.orig_y = y;
+
+	pos = (x + cols * y) * 2;	/* Update cursor position */
+	outb(14, vidport);
+	outb(0xff & (pos >> 9), vidport+1);
+	outb(15, vidport);
+	outb(0xff & (pos >> 1), vidport+1);
+}
+
+static void* memcpy(void* dest, const void* src, unsigned n)
+{
+	int i;
+	const char *s = src;
+	char *d = dest;
+
+	for (i=0;i<n;i++) d[i] = s[i];
+	return dest;
+}
+
+static void error(char *x)
+{
+	putstr("\n\n");
+	putstr(x);
+	putstr("\n\n -- System halted");
+
+	while(1);	/* Halt */
+}
+
+#ifdef CONFIG_X86_NUMAQ
+void *xquad_portio;
+#endif
+
+#define _LZMA_IN_CB
+#include "LzmaDecode.h"
+#include "LzmaDecode.c"
+
+static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize);
+
+
+/*
+ * Do the lzma decompression
+ */
+static int lzma_unzip( uch* output )
+{
+
+	unsigned int i;
+        CLzmaDecoderState state;
+	unsigned int uncompressedSize = 0;
+	unsigned char* p;
+        
+        ILzmaInCallback callback;
+        callback.Read = read_byte;
+
+	// lzma args
+	i = get_byte();
+	state.Properties.lc = i % 9, i = i / 9;
+        state.Properties.lp = i % 5, state.Properties.pb = i / 5;
+        
+        // skip dictionary size
+        for (i = 0; i < 4; i++) 
+        	get_byte();
+        // get uncompressed size
+        p= (char*)&uncompressedSize;	
+        for (i = 0; i < 4; i++) 
+            *p++ = get_byte();
+            
+        // skip high order bytes
+        for (i = 0; i < 4; i++) 
+        	get_byte();
+        	
+        // point it beyond uncompresedSize
+        state.Probs = (CProb*) (free_mem_ptr);
+	// decompress kernel
+	if (LzmaDecode( &state, &callback,
+	   output, uncompressedSize, &i) == LZMA_RESULT_OK)
+	{
+		if ( i != uncompressedSize )
+		   error( "kernel corrupted!\n");
+		return 0;
+	}
+	return 1;
+}
+
+
+static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize)
+{
+	static unsigned int i = 0;
+	static unsigned char val;
+	*bufferSize = 1;
+	val = get_byte();
+	*buffer = &val;
+        if ( i++ % ( 1024 * 50 ) == 0 )
+               putstr(".");
+	return LZMA_RESULT_OK;
+}	
+
+asmlinkage void decompress_kernel(void *rmode, memptr heap,
+			uch *input_data, unsigned long input_len, uch *output)
+{
+	real_mode = rmode;
+
+	if (RM_SCREEN_INFO.orig_video_mode == 7) {
+		vidmem = (char *) 0xb0000;
+		vidport = 0x3b4;
+	} else {
+		vidmem = (char *) 0xb8000;
+		vidport = 0x3d4;
+	}
+
+	lines = RM_SCREEN_INFO.orig_video_lines;
+	cols = RM_SCREEN_INFO.orig_video_cols;
+
+	free_mem_ptr     = heap;	/* Heap  */
+	free_mem_end_ptr = heap + HEAP_SIZE;
+	inbuf  = input_data;	/* Input buffer */
+	insize = input_len;
+	inptr  = 0;
+
+#ifdef CONFIG_X86_64
+        if ((ulg)output & (__KERNEL_ALIGN - 1))
+                error("Destination address not 2M aligned");
+        if ((ulg)output >= 0xffffffffffUL)
+                error("Destination address too large");
+#else
+        if ((u32)output & (CONFIG_PHYSICAL_ALIGN -1))
+                error("Destination address not CONFIG_PHYSICAL_ALIGN aligned");
+        if (heap > ((-__PAGE_OFFSET-(512<<20)-1) & 0x7fffffff))
+                error("Destination address too large");
+#ifndef CONFIG_RELOCATABLE
+        if ((u32)output != LOAD_PHYSICAL_ADDR)
+                error("Wrong destination address");
+#endif
+#endif
+
+	putstr("LZMA vmlinuz: Ming-Ching Tiew <mctiew@yahoo.com> ...");
+	if( lzma_unzip( output ) != 0 )
+	{
+	   error("inflate error\n");
+	}
+	putstr("Ok, booting the kernel.\n");
+}
diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/Makefile linux-2.6.23-rc9/arch/i386/boot/compressed/Makefile
--- linux-2.6.23-rc9.orig/arch/x86/boot/compressed/Makefile	2007-10-06 12:26:14.000000000 +0200
+++ linux-2.6.23-rc9/arch/x86/boot/compressed/Makefile	2007-10-06 12:31:59.000000000 +0200
@@ -4,7 +4,7 @@
 # create a compressed vmlinux image from the original vmlinux
 #
 
-targets := vmlinux vmlinux.bin vmlinux.bin.gz head_$(BITS).o misc.o piggy.o
+targets := vmlinux vmlinux.bin vmlinux.bin.gz head_$(BITS).o lzma_misc.o piggy.o
 
 KBUILD_CFLAGS := -m$(BITS) -D__KERNEL__ $(LINUX_INCLUDE) -O2
 KBUILD_CFLAGS += -fno-strict-aliasing -fPIC
@@ -17,7 +17,7 @@
 LDFLAGS := -m elf_$(UTS_MACHINE)
 LDFLAGS_vmlinux := -T
 
-$(obj)/vmlinux: $(src)/vmlinux_$(BITS).lds $(obj)/head_$(BITS).o $(obj)/misc.o $(obj)/piggy.o FORCE
+$(obj)/vmlinux: $(src)/vmlinux_$(BITS).lds $(obj)/head_$(BITS).o $(obj)/lzma_misc.o $(obj)/piggy.o FORCE
 	$(call if_changed,ld)
 	@:
 
@@ -38,10 +38,10 @@
 
 ifdef CONFIG_RELOCATABLE
 $(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin.all FORCE
-	$(call if_changed,gzip)
+	$(call if_changed,lzma)
 else
 $(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,gzip)
+	$(call if_changed,lzma)
 endif
 LDFLAGS_piggy.o := -r --format binary --oformat elf32-i386 -T
 
diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/vmlinux.scr linux-2.6.23-rc9/arch/i386/boot/compressed/vmlinux.scr
--- linux-2.6.23-rc9.orig/arch/x86/boot/compressed/vmlinux.scr	2007-10-06 12:26:14.000000000 +0200
+++ linux-2.6.23-rc9/arch/x86/boot/compressed/vmlinux.scr	2007-10-06 12:29:58.000000000 +0200
@@ -3,8 +3,8 @@
   .rodata.compressed : {
 	input_len = .;
 	LONG(input_data_end - input_data) input_data = .;
+	output_len = . + 5;
 	*(.data)
-	output_len = . - 4;
 	input_data_end = .;
 	}
 }
diff -Naur linux-2.6.23-rc9.orig/scripts/Makefile.lib linux-2.6.23-rc9/scripts/Makefile.lib
--- linux-2.6.23-rc9.orig/scripts/Makefile.lib	2007-10-06 12:26:26.000000000 +0200
+++ linux-2.6.23-rc9/scripts/Makefile.lib	2007-10-06 12:29:58.000000000 +0200
@@ -162,4 +162,9 @@
 quiet_cmd_gzip = GZIP    $@
 cmd_gzip = gzip -f -9 < $< > $@
 
+# LZMA
+#
+quiet_cmd_lzma = LZMA    $@
+cmd_lzma = lzma e $< $@ -lc7 -lp0 -pb0 2>/dev/null
+
 
