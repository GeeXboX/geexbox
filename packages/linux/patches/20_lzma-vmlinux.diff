diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/lzma_misc.c linux-2.6.23-rc9/arch/i386/boot/compressed/lzma_misc.c
--- linux-2.6.23-rc9.orig/arch/i386/boot/compressed/lzma_misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.23-rc9/arch/i386/boot/compressed/lzma_misc.c	2007-10-06 12:29:58.000000000 +0200
@@ -0,0 +1,293 @@
+/*
+ * lzma_misc.c
+ * 
+ * Decompress LZMA compressed vmlinuz
+ * Version 0.9 Copyright (c) Ming-Ching Tiew mctiew@yahoo.com
+ * Program adapted from misc.c for 2.6.20.1 kernel
+ * Please refer to misc.c for authorship and copyright.
+ * Date: 25 March 2007
+ * Source released under GPL
+ */
+
+#undef CONFIG_PARAVIRT
+#include <linux/linkage.h>
+#include <linux/vmalloc.h>
+#include <linux/screen_info.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <asm/boot.h>
+
+/* WARNING!!
+ * This code is compiled with -fPIC and it is relocated dynamically
+ * at run time, but no relocation processing is performed.
+ * This means that it is not safe to place pointers in static structures.
+ */
+
+#define OF(args)  args
+#define STATIC static
+
+#undef memset
+#undef memcpy
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x80000000	/* Window size must be at least 32k,
+				 * and a power of two
+				 * We don't actually have a window just
+				 * a huge output buffer so I report
+				 * a 2G windows size, as that should
+				 * always be larger than our output buffer.
+				 */
+
+static uch *inbuf;	/* input buffer */
+static uch *window;	/* Sliding window buffer, (and final output buffer) */
+
+static unsigned insize;  /* valid bytes in inbuf */
+static unsigned inptr;   /* index of next byte to be processed in inbuf */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
+#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+#define RESERVED     0xC0 /* bit 6,7:   reserved */
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+		
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static int  fill_inbuf(void);
+static void error(char *m);
+  
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+static unsigned char *real_mode; /* Pointer to real-mode data */
+
+#define RM_EXT_MEM_K   (*(unsigned short *)(real_mode + 0x2))
+#ifndef STANDARD_MEMORY_BIOS_CALL
+#define RM_ALT_MEM_K   (*(unsigned long *)(real_mode + 0x1e0))
+#endif
+#define RM_SCREEN_INFO (*(struct screen_info *)(real_mode+0))
+
+extern unsigned char input_data[];
+extern int input_len;
+
+static long bytes_out = 0;
+
+static void *memcpy(void *dest, const void *src, unsigned n);
+
+static void putstr(const char *);
+
+static unsigned long free_mem_ptr;
+static unsigned long free_mem_end_ptr;
+
+#define HEAP_SIZE             0x3000
+
+static char *vidmem = (char *)0xb8000;
+static int vidport;
+static int lines, cols;
+
+#ifdef CONFIG_X86_NUMAQ
+void *xquad_portio;
+#endif
+
+static void scroll(void)
+{
+	int i;
+
+	memcpy ( vidmem, vidmem + cols * 2, ( lines - 1 ) * cols * 2 );
+	for ( i = ( lines - 1 ) * cols * 2; i < lines * cols * 2; i += 2 )
+		vidmem[i] = ' ';
+}
+
+static void putstr(const char *s)
+{
+	int x,y,pos;
+	char c;
+
+	x = RM_SCREEN_INFO.orig_x;
+	y = RM_SCREEN_INFO.orig_y;
+
+	while ( ( c = *s++ ) != '\0' ) {
+		if ( c == '\n' ) {
+			x = 0;
+			if ( ++y >= lines ) {
+				scroll();
+				y--;
+			}
+		} else {
+			vidmem [ ( x + cols * y ) * 2 ] = c;
+			if ( ++x >= cols ) {
+				x = 0;
+				if ( ++y >= lines ) {
+					scroll();
+					y--;
+				}
+			}
+		}
+	}
+
+	RM_SCREEN_INFO.orig_x = x;
+	RM_SCREEN_INFO.orig_y = y;
+
+	pos = (x + cols * y) * 2;	/* Update cursor position */
+	outb_p(14, vidport);
+	outb_p(0xff & (pos >> 9), vidport+1);
+	outb_p(15, vidport);
+	outb_p(0xff & (pos >> 1), vidport+1);
+}
+
+static void* memcpy(void* dest, const void* src, unsigned n)
+{
+	int i;
+	char *d = (char *)dest, *s = (char *)src;
+
+	for (i=0;i<n;i++) d[i] = s[i];
+	return dest;
+}
+
+/* ===========================================================================
+ * Fill the input buffer. This is called only when the buffer is empty
+ * and at least one byte is really needed.
+ */
+static int fill_inbuf(void)
+{
+	error("ran out of input data");
+	return 0;
+}
+
+/* ===========================================================================
+ */
+static void error(char *x)
+{
+	putstr("\n\n");
+	putstr(x);
+	putstr("\n\n -- System halted");
+
+	while(1);	/* Halt */
+}
+
+#define _LZMA_IN_CB
+#include "LzmaDecode.h"
+#include "LzmaDecode.c"
+
+static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize);
+
+/*
+ * Do the lzma decompression
+ */
+static int lzma_unzip(uch* output)
+{
+
+	unsigned int i;
+        CLzmaDecoderState state;
+	unsigned int uncompressedSize = 0;
+	unsigned char* p;
+        
+        ILzmaInCallback callback;
+        callback.Read = read_byte;
+
+	// lzma args
+	i = get_byte();
+	state.Properties.lc = i % 9, i = i / 9;
+        state.Properties.lp = i % 5, state.Properties.pb = i / 5;
+        
+        // skip dictionary size
+        for (i = 0; i < 4; i++) 
+        	get_byte();
+        // get uncompressed size
+        p= (char*)&uncompressedSize;	
+        for (i = 0; i < 4; i++) 
+            *p++ = get_byte();
+            
+        // skip high order bytes
+        for (i = 0; i < 4; i++) 
+        	get_byte();
+
+	// Just point it beyond
+        state.Probs = (CProb*) ( free_mem_ptr );
+	// decompress kernel
+	if (LzmaDecode( &state, &callback,
+	   (unsigned char*)output, uncompressedSize, &i) == LZMA_RESULT_OK)
+	{
+		if ( i != uncompressedSize )
+		   error( "kernel corrupted!\n");
+		bytes_out = i;
+		return 0;
+	}
+	return 1;
+}
+
+
+static int read_byte(void *object, const unsigned char **buffer, SizeT *bufferSize)
+{
+	static unsigned int i = 0;
+	static unsigned char val;
+	*bufferSize = 1;
+	val = get_byte();
+	*buffer = &val;
+        if ( i++ % ( 1024 * 50 ) == 0 )
+               putstr(".");
+	return LZMA_RESULT_OK;
+}	
+
+asmlinkage void decompress_kernel(void *rmode, unsigned long end,
+			uch *input_data, unsigned long input_len, uch *output)
+{
+	real_mode = rmode;
+
+	if (RM_SCREEN_INFO.orig_video_mode == 7) {
+		vidmem = (char *) 0xb0000;
+		vidport = 0x3b4;
+	} else {
+		vidmem = (char *) 0xb8000;
+		vidport = 0x3d4;
+	}
+
+	lines = RM_SCREEN_INFO.orig_video_lines;
+	cols = RM_SCREEN_INFO.orig_video_cols;
+
+	window = output;  	/* Output buffer (Normally at 1M) */
+	free_mem_ptr     = end;	/* Heap  */
+	free_mem_end_ptr = end + HEAP_SIZE;
+	inbuf  = input_data;	/* Input buffer */
+	insize = input_len;
+	inptr  = 0;
+
+	if ((u32)output & (CONFIG_PHYSICAL_ALIGN -1))
+		error("Destination address not CONFIG_PHYSICAL_ALIGN aligned");
+	if (end > ((-__PAGE_OFFSET-(512 <<20)-1) & 0x7fffffff))
+		error("Destination address too large");
+#ifndef CONFIG_RELOCATABLE
+	if ((u32)output != LOAD_PHYSICAL_ADDR)
+		error("Wrong destination address");
+#endif
+	putstr("LZMA vmlinuz: Ming-Ching Tiew <mctiew@yahoo.com> ...");
+        if( lzma_unzip(output) != 0 )
+        {
+           error("inflate error\n");
+        }
+        putstr("Ok, booting the kernel.\n");
+
+	return;
+}
diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/Makefile linux-2.6.23-rc9/arch/i386/boot/compressed/Makefile
--- linux-2.6.23-rc9.orig/arch/i386/boot/compressed/Makefile	2007-10-06 12:26:14.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/boot/compressed/Makefile	2007-10-06 12:31:59.000000000 +0200
@@ -4,7 +4,7 @@
 # create a compressed vmlinux image from the original vmlinux
 #
 
-targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o misc.o piggy.o \
+targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o lzma_misc.o piggy.o \
 			vmlinux.bin.all vmlinux.relocs
 EXTRA_AFLAGS	:= -traditional
 
@@ -17,7 +17,7 @@
 	   $(call cc-option,-fno-stack-protector)
 LDFLAGS := -m elf_i386
 
-$(obj)/vmlinux: $(src)/vmlinux.lds $(obj)/head.o $(obj)/misc.o $(obj)/piggy.o FORCE
+$(obj)/vmlinux: $(src)/vmlinux.lds $(obj)/head.o $(obj)/lzma_misc.o $(obj)/piggy.o FORCE
 	$(call if_changed,ld)
 	@:
 
@@ -38,10 +38,10 @@
 
 ifdef CONFIG_RELOCATABLE
 $(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin.all FORCE
-	$(call if_changed,gzip)
+	$(call if_changed,lzma)
 else
 $(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,gzip)
+	$(call if_changed,lzma)
 endif
 
 LDFLAGS_piggy.o := -r --format binary --oformat elf32-i386 -T
diff -Naur linux-2.6.23-rc9.orig/arch/i386/boot/compressed/vmlinux.scr linux-2.6.23-rc9/arch/i386/boot/compressed/vmlinux.scr
--- linux-2.6.23-rc9.orig/arch/i386/boot/compressed/vmlinux.scr	2007-10-06 12:26:14.000000000 +0200
+++ linux-2.6.23-rc9/arch/i386/boot/compressed/vmlinux.scr	2007-10-06 12:29:58.000000000 +0200
@@ -3,8 +3,8 @@
   .data.compressed : {
 	input_len = .;
 	LONG(input_data_end - input_data) input_data = .; 
+	output_len = . + 5;
 	*(.data) 
-	output_len = . - 4;
 	input_data_end = .; 
 	}
 }
diff -Naur linux-2.6.23-rc9.orig/scripts/Makefile.lib linux-2.6.23-rc9/scripts/Makefile.lib
--- linux-2.6.23-rc9.orig/scripts/Makefile.lib	2007-10-06 12:26:26.000000000 +0200
+++ linux-2.6.23-rc9/scripts/Makefile.lib	2007-10-06 12:29:58.000000000 +0200
@@ -162,4 +162,9 @@
 quiet_cmd_gzip = GZIP    $@
 cmd_gzip = gzip -f -9 < $< > $@
 
+# LZMA
+#
+quiet_cmd_lzma = LZMA    $@
+cmd_lzma = lzma e $< $@ -lc7 -lp0 -pb0 2>/dev/null
+
 
