bring back the broken %e enumeration
which was removed in udev-095

diff -Nur udev-098.orig/udev_rules.c udev-098/udev_rules.c
--- udev-098.orig/udev_rules.c	Wed Aug 23 02:32:25 2006
+++ udev-098/udev_rules.c	Sat Aug 26 10:40:54 2006
@@ -263,6 +263,88 @@
 	return rc;
 }
 
+static int match_name_and_get_number(const char *base, const char *devname)
+{
+	size_t baselen;
+	char *endptr;
+	int num;
+
+	baselen = strlen(base);
+	if (strncmp(base, devname, baselen) != 0)
+		return -1;
+	if (devname[baselen] == '\0')
+		return 0;
+	if (!isdigit(devname[baselen]))
+		return -1;
+	num = strtoul(&devname[baselen], &endptr, 10);
+	if (endptr[0] != '\0')
+		return -1;
+	return num;
+}
+
+/* finds the lowest positive device number such that <name>N isn't present in the udevdb
+ * if <name> doesn't exist, 0 is returned, N otherwise */
+static int find_free_number(const char *base, const char *devpath)
+{
+	char db_devpath[PATH_SIZE];
+	char filename[PATH_SIZE];
+	struct udevice *udev_db;
+	int num = 0;
+	static int warn = 1;
+
+	if (warn) {
+		err("%%e is deprecated, will be removed and is unlikely to work correctly. Don't use it.");
+		warn = 0;
+	}
+
+	/* check if the device already owns a matching name */
+	udev_db = udev_device_init(NULL);
+	if (udev_db == NULL)
+		return -1;
+	if (udev_db_get_device(udev_db, devpath) == 0) {
+		struct name_entry *name_loop;
+		int devnum;
+
+		devnum = match_name_and_get_number(base, udev_db->name);
+		if (devnum >= 0) {
+			num = devnum;
+			dbg("device '%s', already has the node '%s' with num %u, use it", devpath, base, num);
+			goto out;
+		}
+		list_for_each_entry(name_loop, &udev_db->symlink_list, node) {
+			devnum = match_name_and_get_number(base, name_loop->name);
+			if (devnum >= 0) {
+				num = devnum;
+				dbg("device '%s', already has a symlink '%s' with num %u, use it", devpath, base, num);
+				goto out;
+			}
+		}
+	}
+
+	/* just search the database again and again until a free name is found */
+	strlcpy(filename, base, sizeof(filename));
+	while (1) {
+		dbg("look for existing node '%s'", filename);
+		if (udev_db_lookup_name(filename, db_devpath, sizeof(db_devpath)) != 0) {
+			dbg("free num=%d", num);
+			break;
+		}
+
+		num++;
+		if (num > 100000) {
+			err("find_free_number aborted at num=%d", num);
+			num = -1;
+			break;
+		}
+		snprintf(filename, sizeof(filename), "%s%d", base, num);
+		filename[sizeof(filename)-1] = '\0';
+	}
+
+out:
+	udev_device_cleanup(udev_db);
+	return num;
+}
+
 #define WAIT_LOOP_PER_SECOND		50
 static int wait_for_sysfs(struct udevice *udev, const char *file, int timeout)
 {
@@ -304,6 +386,7 @@
 	int len;
 	int i;
 	int count;
+	unsigned int next_free_number;
 	enum subst_type {
 		SUBST_UNKNOWN,
 		SUBST_DEVPATH,
@@ -318,6 +401,7 @@
 		SUBST_TEMP_NODE,
 		SUBST_ROOT,
 		SUBST_ENV,
+		SUBST_ENUM,
 	};
 	static const struct subst_map {
 		char *name;
@@ -337,6 +421,7 @@
 		{ .name = "tempnode",	.fmt = 'N',	.type = SUBST_TEMP_NODE },
 		{ .name = "root",	.fmt = 'r',	.type = SUBST_ROOT },
 		{ .name = "env",	.fmt = 'E',	.type = SUBST_ENV },
+		{ .name = "enum",	.fmt = 'e',	.type = SUBST_ENUM },
 		{ NULL, '\0', 0 }
 	};
 	enum subst_type type;
@@ -486,6 +571,13 @@
 					info("%i untrusted character(s) replaced" , count);
 				strlcat(string, temp2, maxsize);
 				dbg("substitute sysfs value '%s'", temp2);
+			}
+			break;
+		case SUBST_ENUM:
+			next_free_number = find_free_number(string, udev->dev->devpath);
+			if (next_free_number > 0) {
+				sprintf(temp2, "%d", next_free_number);
+				strlcat(string, temp2, maxsize);
 			}
 			break;
 		case SUBST_PARENT:
diff -Nur udev-098.orig/udev_db.c udev-098/udev_db.c
--- udev-098.orig/udev_db.c	Wed Aug 23 02:32:25 2006
+++ udev-098/udev_db.c	Sat Aug 26 10:40:54 2006
@@ -20,3 +20,64 @@
 
 	return 0;
 }
+int udev_db_lookup_name(const char *name, char *devpath, size_t len)
+{
+       char dirname[PATH_MAX];
+       size_t start;
+       DIR *dir;
+       int found = 0;
+
+       strlcpy(dirname, udev_root, sizeof(dirname));
+       start = strlcat(dirname, "/"DB_NAME_INDEX_DIR"/", sizeof(dirname));
+       strlcat(dirname, name, sizeof(dirname));
+       path_encode(&dirname[start], sizeof(dirname) - start);
+
+       dir = opendir(dirname);
+       if (dir == NULL) {
+               info("no index directory '%s': %s", dirname, strerror(errno));
+               return -1;
+       }
+
+       info("found index directory '%s'", dirname);
+       while (!found) {
+               struct dirent *ent;
+               char device[PATH_SIZE];
+               struct udevice *udev;
+
+               ent = readdir(dir);
+               if (ent == NULL || ent->d_name[0] == '\0')
+                       break;
+               if (ent->d_name[0] == '.')
+                       continue;
+
+               strlcpy(device, ent->d_name, sizeof(device));
+               path_decode(device);
+               udev = udev_device_init(NULL);
+               if (udev == NULL)
+                       break;
+               if (udev_db_get_device(udev, device) == 0) {
+                       char filename[PATH_SIZE];
+                       struct stat statbuf;
+
+                       info("found db entry '%s'", device);
+                       strlcpy(filename, udev_root, sizeof(filename));
+                       strlcat(filename, "/", sizeof(filename));
+                       strlcat(filename, name, sizeof(filename));
+                       /* make sure device entry matches dev_t */
+                       if (stat(filename, &statbuf) == 0) {
+                               if (statbuf.st_rdev == udev->devt) {
+                                       info("node '%s' matches dev_t", udev->name);
+                                       strlcpy(devpath, device, len);
+                                       found = 1;
+                               }
+                       }
+               }
+               udev_device_cleanup(udev);
+       }
+
+       closedir(dir);
+       if (found)
+               return 0;
+       else
+               return -1;
+}
 
 int udev_db_get_all_entries(struct list_head *name_list)
 {
