bring back the broken %e enumeration
which was removed in udev-095

diff -Naur udev-124.orig/udev_db.c udev-124/udev_db.c
--- udev-124.orig/udev_db.c	2008-11-15 14:57:42.000000000 +0100
+++ udev-124/udev_db.c	2008-11-15 14:57:57.000000000 +0100
@@ -329,3 +329,64 @@
 	closedir(dir);
 	return 0;
 }
+int udev_db_lookup_name(const char *name, char *devpath, size_t len)
+{
+       char dirname[PATH_MAX];
+       size_t start;
+       DIR *dir;
+       int found = 0;
+
+       strlcpy(dirname, udev_root, sizeof(dirname));
+       start = strlcat(dirname, "/"DB_NAME_INDEX_DIR"/", sizeof(dirname));
+       strlcat(dirname, name, sizeof(dirname));
+       path_encode(&dirname[start], sizeof(dirname) - start);
+
+       dir = opendir(dirname);
+       if (dir == NULL) {
+               info("no index directory '%s': %s", dirname, strerror(errno));
+               return -1;
+       }
+
+       info("found index directory '%s'", dirname);
+       while (!found) {
+               struct dirent *ent;
+               char device[PATH_SIZE];
+               struct udevice *udev;
+
+               ent = readdir(dir);
+               if (ent == NULL || ent->d_name[0] == '\0')
+                       break;
+               if (ent->d_name[0] == '.')
+                       continue;
+
+               strlcpy(device, ent->d_name, sizeof(device));
+               path_decode(device);
+               udev = udev_device_init(NULL);
+               if (udev == NULL)
+                       break;
+               if (udev_db_get_device(udev, device) == 0) {
+                       char filename[PATH_SIZE];
+                       struct stat statbuf;
+
+                       info("found db entry '%s'", device);
+                       strlcpy(filename, udev_root, sizeof(filename));
+                       strlcat(filename, "/", sizeof(filename));
+                       strlcat(filename, name, sizeof(filename));
+                       /* make sure device entry matches dev_t */
+                       if (stat(filename, &statbuf) == 0) {
+                               if (statbuf.st_rdev == udev->devt) {
+                                       info("node '%s' matches dev_t", udev->name);
+                                       strlcpy(devpath, device, len);
+                                       found = 1;
+                               }
+                       }
+               }
+               udev_device_cleanup(udev);
+       }
+
+       closedir(dir);
+       if (found)
+               return 0;
+       else
+               return -1;
+}
diff -Naur udev-124.orig/udev_rules.c udev-124/udev_rules.c
--- udev-124.orig/udev_rules.c	2008-11-15 14:57:42.000000000 +0100
+++ udev-124/udev_rules.c	2008-11-15 14:59:19.000000000 +0100
@@ -527,6 +527,88 @@
 	return retval;
 }
 
+static int match_name_and_get_number(const char *base, const char *devname)
+{
+	size_t baselen;
+	char *endptr;
+	int num;
+
+	baselen = strlen(base);
+	if (strncmp(base, devname, baselen) != 0)
+		return -1;
+	if (devname[baselen] == '\0')
+		return 0;
+	if (!isdigit(devname[baselen]))
+		return -1;
+	num = strtoul(&devname[baselen], &endptr, 10);
+	if (endptr[0] != '\0')
+		return -1;
+	return num;
+}
+
+/* finds the lowest positive device number such that <name>N isn't present in the udevdb
+ * if <name> doesn't exist, 0 is returned, N otherwise */
+static int find_free_number(const char *base, const char *devpath)
+{
+	char db_devpath[PATH_SIZE];
+	char filename[PATH_SIZE];
+	struct udevice *udev_db;
+	int num = 0;
+	static int warn = 1;
+
+	if (warn) {
+		err("%%e is deprecated, will be removed and is unlikely to work correctly. Don't use it.");
+		warn = 0;
+	}
+
+	/* check if the device already owns a matching name */
+	udev_db = udev_device_init(NULL);
+	if (udev_db == NULL)
+		return -1;
+	if (udev_db_get_device(udev_db, devpath) == 0) {
+		struct name_entry *name_loop;
+		int devnum;
+
+		devnum = match_name_and_get_number(base, udev_db->name);
+		if (devnum >= 0) {
+			num = devnum;
+			dbg("device '%s', already has the node '%s' with num %u, use it", devpath, base, num);
+			goto out;
+		}
+		list_for_each_entry(name_loop, &udev_db->symlink_list, node) {
+			devnum = match_name_and_get_number(base, name_loop->name);
+			if (devnum >= 0) {
+				num = devnum;
+				dbg("device '%s', already has a symlink '%s' with num %u, use it", devpath, base, num);
+				goto out;
+			}
+		}
+	}
+
+	/* just search the database again and again until a free name is found */
+	strlcpy(filename, base, sizeof(filename));
+	while (1) {
+		dbg("look for existing node '%s'", filename);
+		if (udev_db_lookup_name(filename, db_devpath, sizeof(db_devpath)) != 0) {
+			dbg("free num=%d", num);
+			break;
+		}
+
+		num++;
+		if (num > 100000) {
+			err("find_free_number aborted at num=%d", num);
+			num = -1;
+			break;
+		}
+		snprintf(filename, sizeof(filename), "%s%d", base, num);
+		filename[sizeof(filename)-1] = '\0';
+	}
+
+out:
+	udev_device_cleanup(udev_db);
+	return num;
+}
+
 #define WAIT_LOOP_PER_SECOND		50
 static int wait_for_file(struct udevice *udev, const char *file, int timeout)
 {
@@ -649,6 +731,7 @@
 	int len;
 	int i;
 	int count;
+	unsigned int next_free_number;
 	enum subst_type {
 		SUBST_UNKNOWN,
 		SUBST_DEVPATH,
@@ -667,6 +750,7 @@
 		SUBST_ROOT,
 		SUBST_SYS,
 		SUBST_ENV,
+		SUBST_ENUM,
 	};
 	static const struct subst_map {
 		char *name;
@@ -690,6 +774,7 @@
 		{ .name = "root",	.fmt = 'r',	.type = SUBST_ROOT },
 		{ .name = "sys",	.fmt = 'S',	.type = SUBST_SYS },
 		{ .name = "env",	.fmt = 'E',	.type = SUBST_ENV },
+		{ .name = "enum",	.fmt = 'e',	.type = SUBST_ENUM },
 		{ NULL, '\0', 0 }
 	};
 	enum subst_type type;
@@ -872,6 +957,13 @@
 				dbg("substitute sysfs value '%s'\n", temp2);
 			}
 			break;
+                case SUBST_ENUM:
+ 			next_free_number = find_free_number(string, udev->dev->devpath);
+ 			if (next_free_number > 0) {
+ 				sprintf(temp2, "%d", next_free_number);
+ 				strlcat(string, temp2, maxsize);
+  			}
+  			break;
 		case SUBST_PARENT:
 			{
 				struct sysfs_device *dev_parent;
