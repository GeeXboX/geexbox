diff -Nur udev-098.orig/udev_rules.c udev-098/udev_rules.c
--- udev-098.orig/udev_rules.c	Sat Aug 26 10:40:54 2006
+++ udev-098/udev_rules.c	Sat Aug 26 10:43:03 2006
@@ -284,13 +284,12 @@
 
 /* finds the lowest positive device number such that <name>N isn't present in the udevdb
  * if <name> doesn't exist, 0 is returned, N otherwise */
-static int find_free_number(const char *base, const char *devpath)
+static int find_free_number(const char *base, const char *devpath, int num)
 {
 	char db_devpath[PATH_SIZE];
 	char filename[PATH_SIZE];
 	struct udevice *udev_db;
-	int num = 0;
-	static int warn = 1;
+	static int warn = 0;
 
 	if (warn) {
 		err("%%e is deprecated, will be removed and is unlikely to work correctly. Don't use it.");
@@ -322,7 +321,10 @@
 	}
 
 	/* just search the database again and again until a free name is found */
-	strlcpy(filename, base, sizeof(filename));
+	if (num)
+		snprintf(filename, sizeof(filename), "%s%d", base, num);
+	else
+		strlcpy(filename, base, sizeof(filename));
 	while (1) {
 		dbg("look for existing node '%s'", filename);
 		if (udev_db_lookup_name(filename, db_devpath, sizeof(db_devpath)) != 0) {
@@ -402,6 +404,7 @@
 		SUBST_ROOT,
 		SUBST_ENV,
 		SUBST_ENUM,
+		SUBST_ENUM_ONE,
 	};
 	static const struct subst_map {
 		char *name;
@@ -422,6 +425,7 @@
 		{ .name = "root",	.fmt = 'r',	.type = SUBST_ROOT },
 		{ .name = "env",	.fmt = 'E',	.type = SUBST_ENV },
 		{ .name = "enum",	.fmt = 'e',	.type = SUBST_ENUM },
+		{ .name = "enum1",	.fmt = 'U',	.type = SUBST_ENUM_ONE },
 		{ NULL, '\0', 0 }
 	};
 	enum subst_type type;
@@ -574,11 +578,16 @@
 			}
 			break;
 		case SUBST_ENUM:
-			next_free_number = find_free_number(string, udev->dev->devpath);
+			next_free_number = find_free_number(string, udev->dev->devpath, 0);
 			if (next_free_number > 0) {
 				sprintf(temp2, "%d", next_free_number);
 				strlcat(string, temp2, maxsize);
 			}
+			break;
+		case SUBST_ENUM_ONE:
+			next_free_number = find_free_number(string, udev->dev->devpath, 1);
+			sprintf(temp2, "%d", next_free_number);
+			strlcat(string, temp2, maxsize);
 			break;
 		case SUBST_PARENT:
 			{
