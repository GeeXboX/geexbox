diff -Naur udev-124.orig/udev_rules.c udev-124/udev_rules.c
--- udev-124.orig/udev_rules.c	2008-11-15 15:02:00.000000000 +0100
+++ udev-124/udev_rules.c	2008-11-15 15:03:23.000000000 +0100
@@ -548,13 +548,12 @@
 
 /* finds the lowest positive device number such that <name>N isn't present in the udevdb
  * if <name> doesn't exist, 0 is returned, N otherwise */
-static int find_free_number(const char *base, const char *devpath)
+static int find_free_number(const char *base, const char *devpath, int num)
 {
 	char db_devpath[PATH_SIZE];
 	char filename[PATH_SIZE];
 	struct udevice *udev_db;
-	int num = 0;
-	static int warn = 1;
+	static int warn = 0;
 
 	if (warn) {
 		err("%%e is deprecated, will be removed and is unlikely to work correctly. Don't use it.");
@@ -586,7 +585,10 @@
 	}
 
 	/* just search the database again and again until a free name is found */
-	strlcpy(filename, base, sizeof(filename));
+	if (num)
+		snprintf(filename, sizeof(filename), "%s%d", base, num);
+	else
+		strlcpy(filename, base, sizeof(filename));
 	while (1) {
 		dbg("look for existing node '%s'", filename);
 		if (udev_db_lookup_name(filename, db_devpath, sizeof(db_devpath)) != 0) {
@@ -751,6 +753,7 @@
 		SUBST_SYS,
 		SUBST_ENV,
 		SUBST_ENUM,
+		SUBST_ENUM_ONE,
 	};
 	static const struct subst_map {
 		char *name;
@@ -775,6 +778,7 @@
 		{ .name = "sys",	.fmt = 'S',	.type = SUBST_SYS },
 		{ .name = "env",	.fmt = 'E',	.type = SUBST_ENV },
 		{ .name = "enum",	.fmt = 'e',	.type = SUBST_ENUM },
+		{ .name = "enum1",	.fmt = 'U',	.type = SUBST_ENUM_ONE },
 		{ NULL, '\0', 0 }
 	};
 	enum subst_type type;
@@ -958,12 +962,17 @@
 			}
 			break;
                 case SUBST_ENUM:
- 			next_free_number = find_free_number(string, udev->dev->devpath);
+ 			next_free_number = find_free_number(string, udev->dev->devpath, 0);
  			if (next_free_number > 0) {
  				sprintf(temp2, "%d", next_free_number);
  				strlcat(string, temp2, maxsize);
   			}
   			break;
+                case SUBST_ENUM_ONE:
+ 			next_free_number = find_free_number(string, udev->dev->devpath, 1);
+ 			sprintf(temp2, "%d", next_free_number);
+ 			strlcat(string, temp2, maxsize);
+  			break;
 		case SUBST_PARENT:
 			{
 				struct sysfs_device *dev_parent;
