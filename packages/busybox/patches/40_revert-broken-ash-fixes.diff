diff -Naur busybox-1.15.2/shell/ash.c busybox-1.15.2a/shell/ash.c
--- busybox-1.15.2/shell/ash.c	2009-10-08 03:18:15.000000000 +0200
+++ busybox-1.15.2a/shell/ash.c	2009-11-25 14:56:47.000000000 +0100
@@ -112,7 +112,7 @@
 
 static const char homestr[] ALIGN1 = "HOME";
 static const char snlfmt[] ALIGN1 = "%s\n";
-static const char msg_illnum[] ALIGN1 = "Illegal number: %s";
+static const char illnum[] ALIGN1 = "Illegal number: %s";
 
 /*
  * We enclose jmp_buf in a structure so that we can declare pointers to
@@ -142,10 +142,17 @@
 
 	struct jmploc *exception_handler;
 
-	volatile int suppress_int; /* counter */
-	volatile /*sig_atomic_t*/ smallint pending_int; /* 1 = got SIGINT */
+// disabled by vda: cannot understand how it was supposed to work -
+// cannot fix bugs. That's why you have to explain your non-trivial designs!
+//	/* do we generate EXSIG events */
+//	int exsig; /* counter */
+	volatile int suppressint; /* counter */
+// TODO: rename
+// pendingsig -> pending_sig
+// intpending -> pending_int
+	volatile /*sig_atomic_t*/ smallint intpending; /* 1 = got SIGINT */
 	/* last pending signal */
-	volatile /*sig_atomic_t*/ smallint pending_sig;
+	volatile /*sig_atomic_t*/ smallint pendingsig;
 	smallint exception_type; /* kind of exception (0..5) */
 	/* exceptions */
 #define EXINT 0         /* SIGINT received */
@@ -193,7 +200,6 @@
 	/* indicates specified signal received */
 	uint8_t gotsig[NSIG - 1]; /* offset by 1: "signal" 0 is meaningless */
 	char *trap[NSIG];
-	char **trap_ptr;        /* used only by "trap hack" */
 
 	/* Rarely referenced stuff */
 #if ENABLE_ASH_RANDOM_SUPPORT
@@ -214,16 +220,16 @@
 #define arg0        (G_misc.arg0       )
 #define exception_handler (G_misc.exception_handler)
 #define exception_type    (G_misc.exception_type   )
-#define suppress_int      (G_misc.suppress_int     )
-#define pending_int       (G_misc.pending_int      )
-#define pending_sig       (G_misc.pending_sig      )
+#define suppressint       (G_misc.suppressint      )
+#define intpending        (G_misc.intpending       )
+//#define exsig             (G_misc.exsig            )
+#define pendingsig        (G_misc.pendingsig       )
 #define isloginsh   (G_misc.isloginsh  )
 #define nullstr     (G_misc.nullstr    )
 #define optlist     (G_misc.optlist    )
 #define sigmode     (G_misc.sigmode    )
 #define gotsig      (G_misc.gotsig     )
 #define trap        (G_misc.trap       )
-#define trap_ptr    (G_misc.trap_ptr   )
 #define random_galois_LFSR (G_misc.random_galois_LFSR)
 #define random_LCG         (G_misc.random_LCG        )
 #define backgndpid  (G_misc.backgndpid )
@@ -233,7 +239,6 @@
 	barrier(); \
 	curdir = nullstr; \
 	physdir = nullstr; \
-	trap_ptr = trap; \
 } while (0)
 
 
@@ -278,7 +283,7 @@
  * more fun than worrying about efficiency and portability. :-))
  */
 #define INT_OFF do { \
-	suppress_int++; \
+	suppressint++; \
 	xbarrier(); \
 } while (0)
 
@@ -319,11 +324,11 @@
 {
 	int ex_type;
 
-	pending_int = 0;
+	intpending = 0;
 	/* Signal is not automatically unmasked after it is raised,
 	 * do it ourself - unmask all signals */
 	sigprocmask_allsigs(SIG_UNBLOCK);
-	/* pending_sig = 0; - now done in onsig() */
+	/* pendingsig = 0; - now done in onsig() */
 
 	ex_type = EXSIG;
 	if (gotsig[SIGINT - 1] && !trap[SIGINT]) {
@@ -348,7 +353,7 @@
 int_on(void)
 {
 	xbarrier();
-	if (--suppress_int == 0 && pending_int) {
+	if (--suppressint == 0 && intpending) {
 		raise_interrupt();
 	}
 }
@@ -357,18 +362,18 @@
 force_int_on(void)
 {
 	xbarrier();
-	suppress_int = 0;
-	if (pending_int)
+	suppressint = 0;
+	if (intpending)
 		raise_interrupt();
 }
 #define FORCE_INT_ON force_int_on()
 
-#define SAVE_INT(v) ((v) = suppress_int)
+#define SAVE_INT(v) ((v) = suppressint)
 
 #define RESTORE_INT(v) do { \
 	xbarrier(); \
-	suppress_int = (v); \
-	if (suppress_int == 0 && pending_int) \
+	suppressint = (v); \
+	if (suppressint == 0 && intpending) \
 		raise_interrupt(); \
 } while (0)
 
@@ -456,15 +461,15 @@
 /* ============ Parser structures */
 
 /* control characters in argument strings */
-#define CTLESC       ((unsigned char)'\201')    /* escape next character */
-#define CTLVAR       ((unsigned char)'\202')    /* variable defn */
-#define CTLENDVAR    ((unsigned char)'\203')
-#define CTLBACKQ     ((unsigned char)'\204')
+#define CTLESC '\201'           /* escape next character */
+#define CTLVAR '\202'           /* variable defn */
+#define CTLENDVAR '\203'
+#define CTLBACKQ '\204'
 #define CTLQUOTE 01             /* ored with CTLBACKQ code if in quotes */
 /*      CTLBACKQ | CTLQUOTE == '\205' */
-#define CTLARI       ((unsigned char)'\206')    /* arithmetic expression */
-#define CTLENDARI    ((unsigned char)'\207')
-#define CTLQUOTEMARK ((unsigned char)'\210')
+#define CTLARI  '\206'          /* arithmetic expression */
+#define CTLENDARI '\207'
+#define CTLQUOTEMARK '\210'
 
 /* variable substitution byte (follows CTLVAR) */
 #define VSTYPE  0x0f            /* type of variable substitution */
@@ -680,7 +685,7 @@
 	if (DEBUG_PID)
 		fprintf(tracefile, "[%u] ", (int) getpid());
 	if (DEBUG_SIG)
-		fprintf(tracefile, "pending s:%d i:%d(supp:%d) ", pending_sig, pending_int, suppress_int);
+		fprintf(tracefile, "pending s:%d i:%d(supp:%d) ", pendingsig, intpending, suppressint);
 	va_start(va, fmt);
 	vfprintf(tracefile, fmt, va);
 	va_end(va);
@@ -696,7 +701,7 @@
 	if (DEBUG_PID)
 		fprintf(tracefile, "[%u] ", (int) getpid());
 	if (DEBUG_SIG)
-		fprintf(tracefile, "pending s:%d i:%d(supp:%d) ", pending_sig, pending_int, suppress_int);
+		fprintf(tracefile, "pending s:%d i:%d(supp:%d) ", pendingsig, intpending, suppressint);
 	vfprintf(tracefile, fmt, va);
 }
 
@@ -1551,7 +1556,7 @@
 number(const char *s)
 {
 	if (!is_number(s))
-		ash_msg_and_raise_error(msg_illnum, s);
+		ash_msg_and_raise_error(illnum, s);
 	return atoi(s);
 }
 
@@ -2346,6 +2351,8 @@
 #define CD_PHYSICAL 1
 #define CD_PRINT 2
 
+static int docd(const char *, int);
+
 static int
 cdopt(void)
 {
@@ -2353,7 +2360,7 @@
 	int i, j;
 
 	j = 'L';
-	while ((i = nextopt("LP")) != '\0') {
+	while ((i = nextopt("LP"))) {
 		if (i != j) {
 			flags ^= CD_PHYSICAL;
 			j = i;
@@ -2703,8 +2710,8 @@
 	} else
 #endif
 	{
-		if ((unsigned char)c >= CTLESC
-		 && (unsigned char)c <= CTLQUOTEMARK
+		if ((unsigned char)c >= (unsigned char)(CTLESC)
+		 && (unsigned char)c <= (unsigned char)(CTLQUOTEMARK)
 		) {
 			return CCTL;
 		}
@@ -3233,9 +3240,9 @@
 #define FORK_NOJOB 2
 
 /* mode flags for showjob(s) */
-#define SHOW_ONLY_PGID  0x01    /* show only pgid (jobs -p) */
-#define SHOW_PIDS       0x02    /* show individual pids, not just one line per job */
-#define SHOW_CHANGED    0x04    /* only jobs whose state has changed */
+#define SHOW_PGID       0x01    /* only show pgid - for jobs -p */
+#define SHOW_PID        0x04    /* include process pid */
+#define SHOW_CHANGED    0x08    /* only jobs whose state has changed */
 
 /*
  * A job structure contains information about a job.  A job is either a
@@ -3243,6 +3250,7 @@
  * latter case, pidlist will be non-NULL, and will point to a -1 terminated
  * array of pids.
  */
+
 struct procstat {
 	pid_t   pid;            /* process id */
 	int     status;         /* last process status from wait() */
@@ -3305,14 +3313,14 @@
 {
 	gotsig[signo - 1] = 1;
 
-	if (signo == SIGINT && !trap[SIGINT]) {
-		if (!suppress_int) {
-			pending_sig = 0;
+	if (/* exsig || */ (signo == SIGINT && !trap[SIGINT])) {
+		if (!suppressint) {
+			pendingsig = 0;
 			raise_interrupt(); /* does not return */
 		}
-		pending_int = 1;
+		intpending = 1;
 	} else {
-		pending_sig = signo;
+		pendingsig = signo;
 	}
 }
 
@@ -3535,6 +3543,7 @@
 	}
 
 	if (is_number(p)) {
+// TODO: number() instead? It does error checking...
 		num = atoi(p);
 		if (num < njobs) {
 			jp = jobtab + num - 1;
@@ -3906,7 +3915,7 @@
 blocking_wait_with_raise_on_sig(struct job *job)
 {
 	pid_t pid = dowait(DOWAIT_BLOCK, job);
-	if (pid <= 0 && pending_sig)
+	if (pid <= 0 && pendingsig)
 		raise_exception(EXSIG);
 	return pid;
 }
@@ -3923,7 +3932,7 @@
 
 	ps = jp->ps;
 
-	if (mode & SHOW_ONLY_PGID) { /* jobs -p */
+	if (mode & SHOW_PGID) {
 		/* just output process (group) id of pipeline */
 		fprintf(out, "%d\n", ps->pid);
 		return;
@@ -3933,11 +3942,11 @@
 	indent_col = col;
 
 	if (jp == curjob)
-		s[col - 3] = '+';
+		s[col - 2] = '+';
 	else if (curjob && jp == curjob->prev_job)
-		s[col - 3] = '-';
+		s[col - 2] = '-';
 
-	if (mode & SHOW_PIDS)
+	if (mode & SHOW_PID)
 		col += fmtstr(s + col, 16, "%d ", ps->pid);
 
 	psend = ps + jp->nprocs;
@@ -3951,32 +3960,25 @@
 			status = jp->stopstatus;
 		col += sprint_status(s + col, status, 0);
 	}
-	/* By now, "[JOBID]*  [maybe PID] STATUS" is printed */
 
-	/* This loop either prints "<cmd1> | <cmd2> | <cmd3>" line
-	 * or prints several "PID             | <cmdN>" lines,
-	 * depending on SHOW_PIDS bit.
-	 * We do not print status of individual processes
-	 * between PID and <cmdN>. bash does it, but not very well:
-	 * first line shows overall job status, not process status,
-	 * making it impossible to know 1st process status.
-	 */
 	goto start;
-	while (1) {
+
+	do {
 		/* for each process */
-		s[0] = '\0';
-		col = 33;
-		if (mode & SHOW_PIDS)
-			col = fmtstr(s, 48, "\n%*c%d ", indent_col, ' ', ps->pid) - 1;
+		col = fmtstr(s, 48, " |\n%*c%d ", indent_col, ' ', ps->pid) - 3;
  start:
-		fprintf(out, "%s%*c", s, 33 - col >= 0 ? 33 - col : 0, ' ');
-		if (ps != jp->ps)
-			fprintf(out, "| ");
-		fprintf(out, "%s", ps->cmd);
-		if (++ps == psend)
+		fprintf(out, "%s%*c%s",
+			s, 33 - col >= 0 ? 33 - col : 0, ' ', ps->cmd
+		);
+		if (!(mode & SHOW_PID)) {
+			showpipe(jp, out);
 			break;
-	}
-	outcslow('\n', out);
+		}
+		if (++ps == psend) {
+			outcslow('\n', out);
+			break;
+		}
+	} while (1);
 
 	jp->changed = 0;
 
@@ -4014,17 +4016,17 @@
 	int mode, m;
 
 	mode = 0;
-	while ((m = nextopt("lp")) != '\0') {
+	while ((m = nextopt("lp"))) {
 		if (m == 'l')
-			mode |= SHOW_PIDS;
+			mode = SHOW_PID;
 		else
-			mode |= SHOW_ONLY_PGID;
+			mode = SHOW_PGID;
 	}
 
 	argv = argptr;
 	if (*argv) {
 		do
-			showjob(stdout, getjob(*argv, 0), mode);
+			showjob(stdout, getjob(*argv,0), mode);
 		while (*++argv);
 	} else
 		showjobs(stdout, mode);
@@ -4068,7 +4070,9 @@
 	int retval;
 	struct job *jp;
 
-	if (pending_sig)
+//	exsig++;
+//	xbarrier();
+	if (pendingsig)
 		raise_exception(EXSIG);
 
 	nextopt(nullstr);
@@ -4304,7 +4308,7 @@
 		if (!str)
 			continue;
  dostr:
-		while ((c = *str++) != '\0') {
+		while ((c = *str++)) {
 			USTPUTC(c, nextc);
 		}
 	}
@@ -4523,11 +4527,9 @@
 	for (tp = trap; tp < &trap[NSIG]; tp++) {
 		if (*tp && **tp) {      /* trap not NULL or "" (SIG_IGN) */
 			INT_OFF;
-			if (trap_ptr == trap)
-				free(*tp);
-			/* else: it "belongs" to trap_ptr vector, don't free */
+			free(*tp);
 			*tp = NULL;
-			if ((tp - trap) != 0)
+			if (tp != &trap[0])
 				setsignal(tp - trap);
 			INT_ON;
 		}
@@ -4552,53 +4554,6 @@
 	 * Do we do it correctly? */
 
 	closescript();
-
-	if (mode == FORK_NOJOB          /* is it `xxx` ? */
-	 && n && n->type == NCMD        /* is it single cmd? */
-	/* && n->ncmd.args->type == NARG - always true? */
-	 && strcmp(n->ncmd.args->narg.text, "trap") == 0
-	 && n->ncmd.args->narg.next == NULL /* "trap" with no arguments */
-	/* && n->ncmd.args->narg.backquote == NULL - do we need to check this? */
-	) {
-		TRACE(("Trap hack\n"));
-		/* Awful hack for `trap` or $(trap).
-		 *
-		 * http://www.opengroup.org/onlinepubs/009695399/utilities/trap.html
-		 * contains an example where "trap" is executed in a subshell:
-		 *
-		 * save_traps=$(trap)
-		 * ...
-		 * eval "$save_traps"
-		 *
-		 * Standard does not say that "trap" in subshell shall print
-		 * parent shell's traps. It only says that its output
-		 * must have suitable form, but then, in the above example
-		 * (which is not supposed to be normative), it implies that.
-		 *
-		 * bash (and probably other shell) does implement it
-		 * (traps are reset to defaults, but "trap" still shows them),
-		 * but as a result, "trap" logic is hopelessly messed up:
-		 *
-		 * # trap
-		 * trap -- 'echo Ho' SIGWINCH  <--- we have a handler
-		 * # (trap)        <--- trap is in subshell - no output (correct, traps are reset)
-		 * # true | trap   <--- trap is in subshell - no output (ditto)
-		 * # echo `true | trap`    <--- in subshell - output (but traps are reset!)
-		 * trap -- 'echo Ho' SIGWINCH
-		 * # echo `(trap)`         <--- in subshell in subshell - output
-		 * trap -- 'echo Ho' SIGWINCH
-		 * # echo `true | (trap)`  <--- in subshell in subshell in subshell - output!
-		 * trap -- 'echo Ho' SIGWINCH
-		 *
-		 * The rules when to forget and when to not forget traps
-		 * get really complex and nonsensical.
-		 *
-		 * Our solution: ONLY bare $(trap) or `trap` is special.
-		 */
-		/* Save trap handler strings for trap builtin to print */
-		trap_ptr = memcpy(xmalloc(sizeof(trap)), trap, sizeof(trap));
-		/* Fall through into clearing traps */
-	}
 	clear_traps();
 #if JOBS
 	/* do job control only in root shell */
@@ -4643,14 +4598,8 @@
 		setsignal(SIGQUIT);
 	}
 #if JOBS
-	if (n && n->type == NCMD
-	 && strcmp(n->ncmd.args->narg.text, "jobs") == 0
-	) {
+	if (n && n->type == NCMD && strcmp(n->ncmd.args->narg.text, "jobs") == 0) {
 		TRACE(("Job hack\n"));
-		/* "jobs": we do not want to clear job list for it,
-		 * instead we remove only _its_ own_ job from job list.
-		 * This makes "jobs .... | cat" more useful.
-		 */
 		freejob(curjob);
 		return;
 	}
@@ -5043,7 +4992,7 @@
 	struct redirtab *next;
 	int nullredirs;
 	int pair_count;
-	struct two_fd_t two_fd[];
+	struct two_fd_t two_fd[0];
 };
 #define redirlist (G_var.redirlist)
 
@@ -5354,7 +5303,7 @@
 #define EXP_WORD        0x80    /* expand word in parameter expansion */
 #define EXP_QWORD       0x100   /* expand word in quoted parameter expansion */
 /*
- * rmescape() flags
+ * _rmescape() flags
  */
 #define RMESCAPE_ALLOC  0x1     /* Allocate a new string */
 #define RMESCAPE_GLOB   0x2     /* Add backslashes for glob */
@@ -5408,7 +5357,7 @@
 {
 	size_t esc = 0;
 
-	while (p > start && (unsigned char)*--p == CTLESC) {
+	while (p > start && *--p == CTLESC) {
 		esc++;
 	}
 	return esc;
@@ -5418,19 +5367,19 @@
  * Remove any CTLESC characters from a string.
  */
 static char *
-rmescapes(char *str, int flag)
+_rmescapes(char *str, int flag)
 {
 	static const char qchars[] ALIGN1 = { CTLESC, CTLQUOTEMARK, '\0' };
 
 	char *p, *q, *r;
 	unsigned inquotes;
-	unsigned protect_against_glob;
-	unsigned globbing;
+	int notescaped;
+	int globbing;
 
 	p = strpbrk(str, qchars);
-	if (!p)
+	if (!p) {
 		return str;
-
+	}
 	q = p;
 	r = str;
 	if (flag & RMESCAPE_ALLOC) {
@@ -5449,33 +5398,28 @@
 			q = (char *)memcpy(q, str, len) + len;
 		}
 	}
-
 	inquotes = (flag & RMESCAPE_QUOTED) ^ RMESCAPE_QUOTED;
 	globbing = flag & RMESCAPE_GLOB;
-	protect_against_glob = globbing;
+	notescaped = globbing;
 	while (*p) {
 		if (*p == CTLQUOTEMARK) {
-// TODO: if no RMESCAPE_QUOTED in flags, inquotes never becomes 0
-// (alternates between RMESCAPE_QUOTED and ~RMESCAPE_QUOTED). Is it ok?
-// Note: both inquotes and protect_against_glob only affect whether
-// CTLESC,<ch> gets converted to <ch> or to \<ch>
 			inquotes = ~inquotes;
 			p++;
-			protect_against_glob = globbing;
+			notescaped = globbing;
 			continue;
 		}
 		if (*p == '\\') {
 			/* naked back slash */
-			protect_against_glob = 0;
+			notescaped = 0;
 			goto copy;
 		}
 		if (*p == CTLESC) {
 			p++;
-			if (protect_against_glob && inquotes && *p != '/') {
+			if (notescaped && inquotes && *p != '/') {
 				*q++ = '\\';
 			}
 		}
-		protect_against_glob = globbing;
+		notescaped = globbing;
  copy:
 		*q++ = *p++;
 	}
@@ -5486,6 +5430,8 @@
 	}
 	return r;
 }
+#define rmescapes(p) _rmescapes((p), 0)
+
 #define pmatch(a, b) !fnmatch((a), (b), 0)
 
 /*
@@ -5500,7 +5446,7 @@
 	if (quoted) {
 		flag |= RMESCAPE_QUOTED;
 	}
-	return rmescapes((char *)pattern, flag);
+	return _rmescapes((char *)pattern, flag);
 }
 
 /*
@@ -5511,17 +5457,14 @@
 {
 	char *q = expdest;
 
-	q = makestrspace(quotes ? len * 2 : len, q);
+	q = makestrspace(len * 2, q);
 
 	while (len--) {
 		int c = signed_char2int(*p++);
 		if (!c)
 			continue;
-		if (quotes) {
-			int n = SIT(c, syntax);
-			if (n == CCTL || n == CBACK)
-				USTPUTC(CTLESC, q);
-		}
+		if (quotes && (SIT(c, syntax) == CCTL || SIT(c, syntax) == CBACK))
+			USTPUTC(CTLESC, q);
 		USTPUTC(c, q);
 	}
 
@@ -5598,13 +5541,13 @@
 }
 
 static char *
-exptilde(char *startp, char *p, int flags)
+exptilde(char *startp, char *p, int flag)
 {
 	char c;
 	char *name;
 	struct passwd *pw;
 	const char *home;
-	int quotes = flags & (EXP_FULL | EXP_CASE | EXP_REDIR);
+	int quotes = flag & (EXP_FULL | EXP_CASE);
 	int startloc;
 
 	name = p + 1;
@@ -5616,7 +5559,7 @@
 		case CTLQUOTEMARK:
 			return startp;
 		case ':':
-			if (flags & EXP_VARTILDE)
+			if (flag & EXP_VARTILDE)
 				goto done;
 			break;
 		case '/':
@@ -5821,7 +5764,7 @@
 	expdest = p;
 
 	if (quotes)
-		rmescapes(p + 2, 0);
+		rmescapes(p + 2);
 
 	len = cvtnum(ash_arith(p + 2));
 
@@ -5831,7 +5774,7 @@
 #endif
 
 /* argstr needs it */
-static char *evalvar(char *p, int flags, struct strlist *var_str_list);
+static char *evalvar(char *p, int flag, struct strlist *var_str_list);
 
 /*
  * Perform variable and command substitution.  If EXP_FULL is set, output CTLESC
@@ -5843,7 +5786,7 @@
  * for correct expansion of "B=$A" word.
  */
 static void
-argstr(char *p, int flags, struct strlist *var_str_list)
+argstr(char *p, int flag, struct strlist *var_str_list)
 {
 	static const char spclchars[] ALIGN1 = {
 		'=',
@@ -5861,44 +5804,42 @@
 	};
 	const char *reject = spclchars;
 	int c;
-	int quotes = flags & (EXP_FULL | EXP_CASE | EXP_REDIR); /* do CTLESC */
-	int breakall = flags & EXP_WORD;
+	int quotes = flag & (EXP_FULL | EXP_CASE | EXP_REDIR); /* do CTLESC */
+	int breakall = flag & EXP_WORD;
 	int inquotes;
 	size_t length;
 	int startloc;
 
-	if (!(flags & EXP_VARTILDE)) {
+	if (!(flag & EXP_VARTILDE)) {
 		reject += 2;
-	} else if (flags & EXP_VARTILDE2) {
+	} else if (flag & EXP_VARTILDE2) {
 		reject++;
 	}
 	inquotes = 0;
 	length = 0;
-	if (flags & EXP_TILDE) {
+	if (flag & EXP_TILDE) {
 		char *q;
 
-		flags &= ~EXP_TILDE;
+		flag &= ~EXP_TILDE;
  tilde:
 		q = p;
-		if (*q == CTLESC && (flags & EXP_QWORD))
+		if (*q == CTLESC && (flag & EXP_QWORD))
 			q++;
 		if (*q == '~')
-			p = exptilde(p, q, flags);
+			p = exptilde(p, q, flag);
 	}
  start:
 	startloc = expdest - (char *)stackblock();
 	for (;;) {
 		length += strcspn(p + length, reject);
-		c = (unsigned char) p[length];
-		if (c) {
-			if (!(c & 0x80)
+		c = p[length];
+		if (c && (!(c & 0x80)
 #if ENABLE_SH_MATH_SUPPORT
-			 || c == CTLENDARI
+					|| c == CTLENDARI
 #endif
-			) {
-				/* c == '=' || c == ':' || c == CTLENDARI */
-				length++;
-			}
+		   )) {
+			/* c == '=' || c == ':' || c == CTLENDARI */
+			length++;
 		}
 		if (length > 0) {
 			int newloc;
@@ -5916,11 +5857,11 @@
 		case '\0':
 			goto breakloop;
 		case '=':
-			if (flags & EXP_VARTILDE2) {
+			if (flag & EXP_VARTILDE2) {
 				p--;
 				continue;
 			}
-			flags |= EXP_VARTILDE2;
+			flag |= EXP_VARTILDE2;
 			reject++;
 			/* fall through */
 		case ':':
@@ -5939,13 +5880,15 @@
 			goto breakloop;
 		case CTLQUOTEMARK:
 			/* "$@" syntax adherence hack */
-			if (!inquotes
-			 && memcmp(p, dolatstr, 4) == 0
-			 && (  p[4] == CTLQUOTEMARK
-			    || (p[4] == CTLENDVAR && p[5] == CTLQUOTEMARK)
-			    )
+			if (
+				!inquotes &&
+				!memcmp(p, dolatstr, 4) &&
+				(p[4] == CTLQUOTEMARK || (
+					p[4] == CTLENDVAR &&
+					p[5] == CTLQUOTEMARK
+				))
 			) {
-				p = evalvar(p + 1, flags, /* var_str_list: */ NULL) + 1;
+				p = evalvar(p + 1, flag, /* var_str_list: */ NULL) + 1;
 				goto start;
 			}
 			inquotes = !inquotes;
@@ -5961,10 +5904,10 @@
 			length++;
 			goto addquote;
 		case CTLVAR:
-			p = evalvar(p, flags, var_str_list);
+			p = evalvar(p, flag, var_str_list);
 			goto start;
 		case CTLBACKQ:
-			c = '\0';
+			c = 0;
 		case CTLBACKQ|CTLQUOTE:
 			expbackq(argbackq->n, c, quotes);
 			argbackq = argbackq->next;
@@ -6170,15 +6113,15 @@
 #if ENABLE_ASH_BASH_COMPAT
 	case VSSUBSTR:
 		loc = str = stackblock() + strloc;
-		/* Read POS in ${var:POS:LEN} */
-		pos = atoi(loc); /* number(loc) errors out on "1:4" */
+// TODO: number() instead? It does error checking...
+		pos = atoi(loc);
 		len = str - startp - 1;
 
 		/* *loc != '\0', guaranteed by parser */
 		if (quotes) {
 			char *ptr;
 
-			/* Adjust the length by the number of escapes */
+			/* We must adjust the length by the number of escapes we find. */
 			for (ptr = startp; ptr < (str - 1); ptr++) {
 				if (*ptr == CTLESC) {
 					len--;
@@ -6189,22 +6132,15 @@
 		orig_len = len;
 
 		if (*loc++ == ':') {
-			/* ${var::LEN} */
-			len = number(loc);
+// TODO: number() instead? It does error checking...
+			len = atoi(loc);
 		} else {
-			/* Skip POS in ${var:POS:LEN} */
 			len = orig_len;
-			while (*loc && *loc != ':') {
-				/* TODO?
-				 * bash complains on: var=qwe; echo ${var:1a:123}
-				if (!isdigit(*loc))
-					ash_msg_and_raise_error(msg_illnum, str);
-				 */
+			while (*loc && *loc != ':')
 				loc++;
-			}
-			if (*loc++ == ':') {
-				len = number(loc);
-			}
+			if (*loc++ == ':')
+// TODO: number() instead? It does error checking...
+				len = atoi(loc);
 		}
 		if (pos >= orig_len) {
 			pos = 0;
@@ -6248,7 +6184,7 @@
 	rmesc = startp;
 	rmescend = (char *)stackblock() + strloc;
 	if (quotes) {
-		rmesc = rmescapes(startp, RMESCAPE_ALLOC | RMESCAPE_GROW);
+		rmesc = _rmescapes(startp, RMESCAPE_ALLOC | RMESCAPE_GROW);
 		if (rmesc != startp) {
 			rmescend = expdest;
 			startp = (char *)stackblock() + startloc;
@@ -6379,7 +6315,7 @@
 	int syntax;
 	int quoted = varflags & VSQUOTE;
 	int subtype = varflags & VSTYPE;
-	int quotes = flags & (EXP_FULL | EXP_CASE | EXP_REDIR);
+	int quotes = flags & (EXP_FULL | EXP_CASE);
 
 	if (quoted && (flags & EXP_FULL))
 		sep = 1 << CHAR_BIT;
@@ -6423,7 +6359,7 @@
 		ap = shellparam.p;
 		if (!ap)
 			return -1;
-		while ((p = *ap++) != NULL) {
+		while ((p = *ap++)) {
 			size_t partlen;
 
 			partlen = strlen(p);
@@ -6457,7 +6393,8 @@
 	case '7':
 	case '8':
 	case '9':
-		num = atoi(name); /* number(name) fails on ${N#str} etc */
+// TODO: number() instead? It does error checking...
+		num = atoi(name);
 		if (num < 0 || num > shellparam.nparam)
 			return -1;
 		p = num ? shellparam.p[num - 1] : arg0;
@@ -6509,7 +6446,7 @@
  * input string.
  */
 static char *
-evalvar(char *p, int flags, struct strlist *var_str_list)
+evalvar(char *p, int flag, struct strlist *var_str_list)
 {
 	char varflags;
 	char subtype;
@@ -6520,7 +6457,7 @@
 	int startloc;
 	ssize_t varlen;
 
-	varflags = (unsigned char) *p++;
+	varflags = *p++;
 	subtype = varflags & VSTYPE;
 	quoted = varflags & VSQUOTE;
 	var = p;
@@ -6529,7 +6466,7 @@
 	p = strchr(p, '=') + 1;
 
  again:
-	varlen = varvalue(var, varflags, flags, var_str_list);
+	varlen = varvalue(var, varflags, flag, var_str_list);
 	if (varflags & VSNUL)
 		varlen--;
 
@@ -6542,8 +6479,8 @@
  vsplus:
 		if (varlen < 0) {
 			argstr(
-				p, flags | EXP_TILDE |
-					(quoted ? EXP_QWORD : EXP_WORD),
+				p, flag | EXP_TILDE |
+					(quoted ?  EXP_QWORD : EXP_WORD),
 				var_str_list
 			);
 			goto end;
@@ -6615,8 +6552,7 @@
 		patloc = expdest - (char *)stackblock();
 		if (0 == subevalvar(p, /* str: */ NULL, patloc, subtype,
 				startloc, varflags,
-//TODO: | EXP_REDIR too? All other such places do it too
-				/* quotes: */ flags & (EXP_FULL | EXP_CASE),
+				/* quotes: */ flag & (EXP_FULL | EXP_CASE),
 				var_str_list)
 		) {
 			int amount = expdest - (
@@ -6870,7 +6806,7 @@
 		p++;
 	if (*p == '.')
 		matchdot++;
-	while (!pending_int && (dp = readdir(dirp)) != NULL) {
+	while (!intpending && (dp = readdir(dirp)) != NULL) {
 		if (dp->d_name[0] == '.' && !matchdot)
 			continue;
 		if (pmatch(start, dp->d_name)) {
@@ -6991,7 +6927,7 @@
 			 */
  nometa:
 			*exparg.lastp = str;
-			rmescapes(str->text, 0);
+			rmescapes(str->text);
 			exparg.lastp = &str->next;
 		} else {
 			*exparg.lastp = NULL;
@@ -7039,7 +6975,7 @@
 		expandmeta(exparg.list /*, flag*/);
 	} else {
 		if (flag & EXP_REDIR) /*XXX - for now, just remove escapes */
-			rmescapes(p, 0);
+			rmescapes(p);
 		sp = stzalloc(sizeof(*sp));
 		sp->text = p;
 		*exparg.lastp = sp;
@@ -7264,8 +7200,8 @@
 		break;
 	}
 	exitstatus = exerrno;
-	TRACE(("shellexec failed for %s, errno %d, suppress_int %d\n",
-		argv[0], e, suppress_int));
+	TRACE(("shellexec failed for %s, errno %d, suppressint %d\n",
+		argv[0], e, suppressint));
 	ash_msg_and_raise(EXEXEC, "%s: %s", argv[0], errmsg(e, "not found"));
 	/* NOTREACHED */
 }
@@ -8067,7 +8003,7 @@
 	uint8_t savestatus;
 
 	savestatus = exitstatus;
-	pending_sig = 0;
+	pendingsig = 0;
 	xbarrier();
 
 	TRACE(("dotrap entered\n"));
@@ -8247,7 +8183,7 @@
  out1:
 	if (checkexit & exitstatus)
 		evalskip |= SKIPEVAL;
-	else if (pending_sig && dotrap())
+	else if (pendingsig && dotrap())
 		goto exexit;
 
 	if (flags & EV_EXIT) {
@@ -9167,7 +9103,7 @@
 			if (i == EXINT)
 				exit_status = 128 + SIGINT;
 			if (i == EXSIG)
-				exit_status = 128 + pending_sig;
+				exit_status = 128 + pendingsig;
 			exitstatus = exit_status;
 			if (i == EXINT || spclbltin > 0) {
  raise:
@@ -9221,6 +9157,7 @@
 	exitstatus |= ferror(stdout);
 	clearerr(stdout);
 	commandname = savecmdname;
+//	exsig = 0;
 	exception_handler = savehandler;
 
 	return i;
@@ -9271,7 +9208,7 @@
 	int n = argv[1] ? number(argv[1]) : 1;
 
 	if (n <= 0)
-		ash_msg_and_raise_error(msg_illnum, argv[1]);
+		ash_msg_and_raise_error(illnum, argv[1]);
 	if (n > loopnest)
 		n = loopnest;
 	if (n > 0) {
@@ -10079,7 +10016,7 @@
 		vrandom.flags &= ~VNOFUNC;
 	} else {
 		/* set/reset */
-		random_galois_LFSR = random_LCG = strtoul(value, NULL, 10);
+		random_galois_LFSR = random_LCG = strtoul(value, (char **)NULL, 10);
 	}
 }
 #endif
@@ -10463,7 +10400,7 @@
 		TRACE(("Here document %d\n", n->type));
 		if (!noexpand(wordtext) || (i = strlen(wordtext)) == 0 || i > EOFMARKLEN)
 			raise_error_syntax("illegal eof marker for << redirection");
-		rmescapes(wordtext, 0);
+		rmescapes(wordtext);
 		here->eofmark = wordtext;
 		here->next = NULL;
 		if (heredoclist == NULL)
@@ -12259,30 +12196,14 @@
 	ap = argptr;
 	if (!*ap) {
 		for (signo = 0; signo < NSIG; signo++) {
-			char *tr = trap_ptr[signo];
-			if (tr) {
-				/* note: bash adds "SIG", but only if invoked
-				 * as "bash". If called as "sh", or if set -o posix,
-				 * then it prints short signal names.
-				 * We are printing short names: */
+			if (trap[signo] != NULL) {
 				out1fmt("trap -- %s %s\n",
-						single_quote(tr),
+						single_quote(trap[signo]),
 						get_signame(signo));
-		/* trap_ptr != trap only if we are in special-cased `trap` code.
-		 * In this case, we will exit very soon, no need to free(). */
-				/* if (trap_ptr != trap && tp[0]) */
-				/*	free(tr); */
 			}
 		}
-		/*
-		if (trap_ptr != trap) {
-			free(trap_ptr);
-			trap_ptr = trap;
-		}
-		*/
 		return 0;
 	}
-
 	action = NULL;
 	if (ap[1])
 		action = *ap++;
@@ -12778,7 +12699,7 @@
 			mask = 0;
 			do {
 				if (*ap >= '8' || *ap < '0')
-					ash_msg_and_raise_error(msg_illnum, argv[1]);
+					ash_msg_and_raise_error(illnum, argv[1]);
 				mask = (mask << 3) + (*ap - '0');
 			} while (*++ap != '\0');
 			umask(mask);
@@ -13039,7 +12960,6 @@
 	if (p) {
 		trap[0] = NULL;
 		evalstring(p, 0);
-		free(p);
 	}
 	flush_stdout_stderr();
  out:
@@ -13060,7 +12980,7 @@
 	/* from var.c: */
 	{
 		char **envp;
-		char ppid[sizeof(int)*3 + 2];
+		char ppid[sizeof(int)*3 + 1];
 		const char *p;
 		struct stat st1, st2;
 
@@ -13071,7 +12991,7 @@
 			}
 		}
 
-		sprintf(ppid, "%u", (unsigned) getppid());
+		snprintf(ppid, sizeof(ppid), "%u", (unsigned) getppid());
 		setvar("PPID", ppid, 0);
 
 		p = lookupvar("PWD");
@@ -13311,7 +13231,7 @@
 	}
 
 	if (sflag || minusc == NULL) {
-#if MAX_HISTORY > 0 && ENABLE_FEATURE_EDITING_SAVEHISTORY
+#if ENABLE_FEATURE_EDITING_SAVEHISTORY
 		if (iflag) {
 			const char *hp = lookupvar("HISTFILE");
 			if (hp)
