From 6b2fac332b0107872eeb859a3afbb4cfa2276c4c Mon Sep 17 00:00:00 2001
From: Thomas Genty <tomlohave@openbricks.org>
Date: Sat, 25 Aug 2012 13:38:25 +0200
Subject: [PATCH 1/2] bump galcore to 3184

---
 .../gc600_driver_dove/galcore_ko_src/Makefile      |   11 +-
 .../unified/hal/kernel/gc_hal_kernel_hardware.c    | 1008 ++--
 .../unified/hal/kernel/gc_hal_kernel_hardware.h    |   52 +-
 .../arch/unified/hal/kernel/makefile.linux         |   12 +-
 .../gc600_driver_dove/galcore_ko_src/common.target |   60 +-
 .../gc600_driver_dove/galcore_ko_src/config        |    3 +
 .../galcore_ko_src/hal/inc/gc_hal.h                |  459 ++-
 .../galcore_ko_src/hal/inc/gc_hal_base.h           |  279 +-
 .../galcore_ko_src/hal/inc/gc_hal_compiler.h       |    2 +-
 .../galcore_ko_src/hal/inc/gc_hal_driver.h         |   22 +-
 .../galcore_ko_src/hal/inc/gc_hal_dump.h           |    2 +-
 .../galcore_ko_src/hal/inc/gc_hal_engine.h         |   88 +-
 .../galcore_ko_src/hal/inc/gc_hal_enum.h           |  681 ++--
 .../galcore_ko_src/hal/inc/gc_hal_mem.h            |    2 +-
 .../galcore_ko_src/hal/inc/gc_hal_options.h        |  257 +-
 .../galcore_ko_src/hal/inc/gc_hal_profiler.h       |    2 +-
 .../galcore_ko_src/hal/inc/gc_hal_raster.h         |   17 +-
 .../galcore_ko_src/hal/inc/gc_hal_types.h          |   64 +-
 .../galcore_ko_src/hal/kernel/gc_hal_kernel.c      |  218 +-
 .../galcore_ko_src/hal/kernel/gc_hal_kernel.h      |  416 +-
 .../hal/kernel/gc_hal_kernel_command.c             |  940 ++--
 .../hal/kernel/gc_hal_kernel_event.c               |  369 +-
 .../galcore_ko_src/hal/kernel/gc_hal_kernel_heap.c |   41 +-
 .../galcore_ko_src/hal/kernel/gc_hal_kernel_mmu.c  |   54 +-
 .../hal/kernel/gc_hal_kernel_precomp.h             |    2 +-
 .../hal/kernel/gc_hal_kernel_video_memory.c        | 2419 ++++----
 .../galcore_ko_src/hal/kernel/makefile.linux       |   16 +-
 .../galcore_ko_src/hal/makefile.linux              |   14 +-
 .../hal/os/linux/kernel/gc_hal_kernel_debug.c      |   14 +-
 .../hal/os/linux/kernel/gc_hal_kernel_device.c     |  477 ++-
 .../hal/os/linux/kernel/gc_hal_kernel_device.h     |   74 +-
 .../hal/os/linux/kernel/gc_hal_kernel_driver.c     | 1327 ++---
 .../hal/os/linux/kernel/gc_hal_kernel_linux.c      |   45 +-
 .../hal/os/linux/kernel/gc_hal_kernel_linux.h      |   10 +-
 .../hal/os/linux/kernel/gc_hal_kernel_os.c         | 4179 ++++++++++-----
 .../hal/os/linux/kernel/gc_hal_kernel_os.c-temp    | 5873 ++++++++++++++++++++
 .../hal/os/linux/kernel/gc_hal_kernel_os.h         |   18 +-
 .../galcore_ko_src/hal/user/gcProfiler.h           |    2 +-
 .../galcore_ko_src/hal/user/gc_hal_user.h          |   89 +-
 .../galcore_ko_src/hal/user/gc_hal_user_compiler.h |    3 +
 .../galcore_ko_src/hal/user/gc_hal_user_context.h  |   34 +
 .../galcore_ko_src/makefile.linux.def              |   52 +-
 42 files changed, 14546 insertions(+), 5161 deletions(-)
 create mode 100644 arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c-temp

diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/Makefile b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/Makefile
index 15bbf17..779d08c 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/Makefile
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/Makefile
@@ -130,11 +130,18 @@ EXTRA_CFLAGS += -DUSE_PLATFORM_DRIVER=0
 endif
 
 ifeq ($(USE_PROFILER), 1)
-EXTRA_CFLAGS += -DVIVANTE_PROFILER=1
+    EXTRA_CFLAGS += -DVIVANTE_PROFILER=1
 else
-EXTRA_CFLAGS += -DVIVANTE_PROFILER=0
+    EXTRA_CFLAGS += -DVIVANTE_PROFILER=0
 endif
 
+ifeq ($(USE_MRVL_PROFILER),1)
+    EXTRA_CFLAGS += -DMRVL_BENCH=1
+else
+    EXTRA_CFLAGS += -DMRVL_BENCH=0
+endif
+
+
 ifeq ($(ANDROID), 1)
 EXTRA_CFLAGS += -DANDROID=1
 endif
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.c
index 93d4dd3..a70f94d 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -24,6 +24,8 @@
 #include "gc_hal.h"
 #include "gc_hal_kernel.h"
 
+#include <linux/delay.h>
+
 #define _GC_OBJ_ZONE	gcvZONE_HARDWARE
 
 /******************************************************************************\
@@ -141,8 +143,8 @@ _IdentifyHardware(
 	}
 
 #if MRVL_DISABLE_FASTCLEAR
-		*ChipFeatures = *ChipFeatures &  ~0x00000001;
-#endif
+		*ChipFeatures = *ChipFeatures &  ~0x00000001;	
+#endif 
 
 	/* Success. */
 	gcmkFOOTER_ARG("*ChipModel=%x *ChipRevision=%x *ChipFeatures=%08x "
@@ -199,7 +201,7 @@ _GetChipSpecs(
 						  : (Hardware->chipModel >= gcv1000) ? 4 : 1;
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: streamCount=%u%s\n",
+                   "Specs: streamCount=%u%s",
 				   Hardware->streamCount,
 				   (streamCount == 0) ? " (default)" : "");
 
@@ -216,7 +218,7 @@ _GetChipSpecs(
 								     : 512;
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: vertexOutputBufferSize=%u%s\n",
+                   "Specs: vertexOutputBufferSize=%u%s",
 				   Hardware->vertexOutputBufferSize,
 				   (vertexOutputBufferSize == 0) ? " (default)" : "");
 
@@ -229,7 +231,7 @@ _GetChipSpecs(
 						  : 256;
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: threadCount=%u%s\n",
+                   "Specs: threadCount=%u%s",
 				   Hardware->threadCount,
 				   (threadCount == 0) ? " (default)" : "");
 
@@ -239,7 +241,7 @@ _GetChipSpecs(
 							  : (Hardware->chipModel >= gcv1000) ? 2
 							  : 1;
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: shaderCoreCount=%u%s\n",
+                   "Specs: shaderCoreCount=%u%s",
 				   Hardware->shaderCoreCount,
 				   (shaderCoreCount == 0) ? " (default)" : "");
 
@@ -248,7 +250,7 @@ _GetChipSpecs(
 							  ? vertexCacheSize
 							  : 8;
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: vertexCacheSize=%u%s\n",
+                   "Specs: vertexCacheSize=%u%s",
 				   Hardware->vertexCacheSize,
 				   (vertexCacheSize == 0) ? " (default)" : "");
 
@@ -258,10 +260,18 @@ _GetChipSpecs(
 						  : (Hardware->chipModel == gcv400) ? 32
 						  : 64;
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-				   "Specs: registerMax=%u%s\n",
+                   "Specs: registerMax=%u%s",
 				   Hardware->registerMax,
 				   (registerMax == 0) ? " (default)" : "");
 
+
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] streamCount = %d\n", Hardware->streamCount);
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] registerMax = %d\n", Hardware->registerMax);
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] threadCount = %d\n", Hardware->threadCount);
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] shaderCoreCount = %d\n", Hardware->shaderCoreCount);
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] vertexCacheSize = %d\n", Hardware->vertexCacheSize);
+	gckOS_Log(_GFX_LOG_NOTIFY_,"[galcore] vertexOutputBufferSize = %d\n", Hardware->vertexOutputBufferSize);
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
@@ -314,20 +324,22 @@ gckHARDWARE_Construct(
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 	gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
 
+	/* Enable the GPU. */
+    gcmkONERROR(gckOS_SetGPUPower(Os, gcvTRUE, gcvTRUE));
+    gcmkONERROR(gckOS_WriteRegister(Os, 0x00000, 0));
+
 	/* Identify the hardware. */
-	gcmkONERROR(
-		_IdentifyHardware(Os,
-						  &chipModel,
-						  &chipRevision,
-						  &chipFeatures,
-						  &chipMinorFeatures0,
-						  &chipMinorFeatures1));
-
-	/* Allocate the gckHARDWARE object. */
-	gcmkONERROR(
-		gckOS_Allocate(Os,
-					   gcmSIZEOF(struct _gckHARDWARE),
-					   (gctPOINTER *) &hardware));
+    gcmkONERROR(_IdentifyHardware(Os,
+                                  &chipModel,
+                                  &chipRevision,
+                                  &chipFeatures,
+                                  &chipMinorFeatures0,
+                                  &chipMinorFeatures1));
+
+    /* Allocate the gckHARDWARE object. */
+    gcmkONERROR(gckOS_Allocate(Os,
+                               gcmSIZEOF(struct _gckHARDWARE),
+                               (gctPOINTER *) &hardware));
 
 	/* Initialize the gckHARDWARE object. */
 	hardware->object.type = gcvOBJ_HARDWARE;
@@ -342,10 +354,11 @@ gckHARDWARE_Construct(
 	hardware->powerBaseAddress   = (  (chipModel == gcv300)
 								   && (chipRevision < 0x2000)
 								   ) ? 0x100 : 0x00;
+    hardware->powerMutex         = gcvNULL;
+    hardware->recMutexPower      = gcvNULL;
 
 	/* Get chip specs. */
-	gcmkONERROR(
-		_GetChipSpecs(hardware));
+    gcmkONERROR(_GetChipSpecs(hardware));
 
 	/* Determine whether bug fixes #1 are present. */
 	hardware->extraEventStates = ((((gctUINT32) (chipMinorFeatures1)) >> (0 ? 3:3) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) == (0x0 & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))));
@@ -354,13 +367,16 @@ gckHARDWARE_Construct(
 	hardware->bigEndian = (*(gctUINT8 *)&data == 0xff);
 
 	/* Initialize the fast clear. */
-	gcmkONERROR(
-		gckHARDWARE_SetFastClear(hardware, -1, -1));
+    gcmkONERROR(gckHARDWARE_SetFastClear(hardware, -1, -1));
 
 	/* Set power state to ON. */
 	hardware->chipPowerState = gcvPOWER_ON;
     hardware->lastWaitLink   = ~0U;
 	hardware->hang = gcvFALSE;
+ 
+    gcmkONERROR(gckOS_CreateMutex(Os, &hardware->powerMutex));
+
+    gcmkONERROR(gckOS_CreateRecMutex(Os, &hardware->recMutexPower));
 
 	/* Return pointer to the gckHARDWARE object. */
 	*Hardware = hardware;
@@ -370,10 +386,24 @@ gckHARDWARE_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Roll back. */
+    if (hardware != gcvNULL && hardware->recMutexPower != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteRecMutex(Os, hardware->recMutexPower));
+        hardware->recMutexPower = gcvNULL;
+    }
+    
+    if (hardware != gcvNULL && hardware->powerMutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Os, hardware->powerMutex));
+        hardware->powerMutex = gcvNULL;
+    }
+
 	if (hardware != gcvNULL)
 	{
 		gcmkVERIFY_OK(gckOS_Free(Os, hardware));
+        hardware = gcvNULL;
 	}
 
 	/* Return the status. */
@@ -401,18 +431,41 @@ gckHARDWARE_Destroy(
     IN gckHARDWARE Hardware
     )
 {
+    gceSTATUS status;
+
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-	gcmkTRACE(gcvLEVEL_VERBOSE,
-			 "gckHARDWARE_Destroy: Hardware=0x%x",
-			 Hardware);
-
+    if(Hardware->recMutexPower != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteRecMutex(Hardware->os, Hardware->recMutexPower));
+        Hardware->recMutexPower = gcvNULL;
+    }
+    
+    /* Destroy the power mutex. */
+    if(Hardware->powerMutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Hardware->os, Hardware->powerMutex));
+        Hardware->powerMutex = gcvNULL;
+    }
+    
     /* Mark the object as unknown. */
 	Hardware->object.type = gcvOBJ_UNKNOWN;
 
     /* Free the object. */
-	return gckOS_Free(Hardware->os, Hardware);
+    gcmkONERROR(gckOS_Free(Hardware->os, Hardware));
+    Hardware = gcvNULL;
+
+    /* Success. */
+    gcmkFOOTER();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
@@ -437,68 +490,70 @@ gckHARDWARE_InitializeHardware(
 {
 	gceSTATUS status;
 	gctUINT32 baseAddress;
+    gctUINT32 chipRev;
 
 	gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
+    /* Read the chip revision register. */
+    gcmkONERROR(gckOS_ReadRegister(Hardware->os,
+                                   0x00024,
+                                   &chipRev));
+
+    if (chipRev != Hardware->chipRevision)
+    {
+        /* Chip is not there! */
+        gcmkONERROR(gcvSTATUS_CONTEXT_LOSSED);
+    }
+
 	/* Disable isolate GPU bit. */
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00000,
-							((((gctUINT32) (0x00000100)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)))));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x00000,
+                                    ((((gctUINT32) (0x00000100)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)))));
 
-	/* Reset memory counters. */
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x0003C,
-							~0U));
+    /* Reset memory counters. */
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x0003C,
+                                    ~0U));
 
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x0003C,
-							0));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x0003C,
+                                    0));
 
 	/* Get the system's physical base address. */
-	gcmkONERROR(
-		gckOS_GetBaseAddress(Hardware->os, &baseAddress));
+    gcmkONERROR(gckOS_GetBaseAddress(Hardware->os, &baseAddress));
 
 	/* Program the base addesses. */
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x0041C,
-							baseAddress));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x0041C,
+                                    baseAddress));
 
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00418,
-							baseAddress));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x00418,
+                                    baseAddress));
 
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00420,
-							baseAddress));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x00420,
+                                    baseAddress));
 
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00428,
-							baseAddress));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x00428,
+                                    baseAddress));
 
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00424,
-							baseAddress));
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                    0x00424,
+                                    baseAddress));
 
-#if !VIVANTE_PROFILER
-	{
-		gctUINT32 data;
+#if !VIVANTE_PROFILER && MRVL_ENABLE_CLOCK_GATING
+    {
+        gctUINT32 data;
 
-		gcmkONERROR(
-			gckOS_ReadRegister(Hardware->os,
-							   Hardware->powerBaseAddress +
-							   0x00100,
-							   &data));
+        gcmkONERROR(gckOS_ReadRegister(Hardware->os,
+                                       Hardware->powerBaseAddress +
+                                       0x00100,
+                                       &data));
 
 		/* Enable clock gating. */
 		data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
@@ -512,22 +567,22 @@ gckHARDWARE_InitializeHardware(
 			data = ((((gctUINT32) (data)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
 		}
 
-		gcmkONERROR(
-			gckOS_WriteRegister(Hardware->os,
-								Hardware->powerBaseAddress +
-								0x00100,
-								data));
+        gcmkONERROR(gckOS_WriteRegister(Hardware->os,
+                                        Hardware->powerBaseAddress
+                                        + 0x00100,
+                                        data));
 
-		/* Disable PE clock gating on revs 4.6 and up when HZ is present. */
-		if ((Hardware->chipRevision >= 0x4600)
-		&&  (Hardware->chipRevision <  0x5000)
+        /* Disable PE clock gating on revs < 5.0 when HZ is present without a
+        ** bug fix. */
+        if ((Hardware->chipRevision < 0x5000)
+        &&  ((((gctUINT32) (Hardware->chipMinorFeatures1)) >> (0 ? 9:9) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1)))))) == (0x0 & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1)))))))
 		&&  ((((gctUINT32) (Hardware->chipMinorFeatures0)) >> (0 ? 27:27) & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1)))))) == (0x1 & ((gctUINT32) ((((1 ? 27:27) - (0 ? 27:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:27) - (0 ? 27:27) + 1)))))))
 		)
 		{
 			gcmkONERROR(
 				gckOS_ReadRegister(Hardware->os,
-								   Hardware->powerBaseAddress +
-								   0x00104,
+                                   Hardware->powerBaseAddress
+                                   + 0x00104,
 								   &data));
 
 			/* Disable PE clock gating. */
@@ -535,10 +590,10 @@ gckHARDWARE_InitializeHardware(
 
 			gcmkONERROR(
 				gckOS_WriteRegister(Hardware->os,
-									Hardware->powerBaseAddress +
-									0x00104,
+                                    Hardware->powerBaseAddress
+                                    + 0x00104,
 									data));
-	}
+        }
 	}
 #endif
 
@@ -558,6 +613,7 @@ gckHARDWARE_InitializeHardware(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the error. */
 	gcmkFOOTER();
 	return status;
@@ -657,18 +713,18 @@ gckHARDWARE_QueryMemory(
     }
 
     /* Success. */
-    gcmkFOOTER_ARG("*InternalSize=%lu *InternalBaseAddress=%08x "
-			   "*InternalAlignment=%08x *ExternalSize=%lu "
-			   "*ExternalBaseAddress=%08x *ExtenalAlignment=%08x "
-			   "*HorizontalTileSize=%u *VerticalTileSize=%u",
-			   gcmOPT_VALUE(InternalSize),
-			   gcmOPT_VALUE(InternalBaseAddress),
-			   gcmOPT_VALUE(InternalAlignment),
-			   gcmOPT_VALUE(ExternalSize),
-			   gcmOPT_VALUE(ExternalBaseAddress),
-			   gcmOPT_VALUE(ExternalAlignment),
-			   gcmOPT_VALUE(HorizontalTileSize),
-			   gcmOPT_VALUE(VerticalTileSize));
+    gcmkFOOTER_ARG("*InternalSize=%lu *InternalBaseAddress=0x%08x "
+                   "*InternalAlignment=0x%08x *ExternalSize=%lu "
+                   "*ExternalBaseAddress=0x%08x *ExtenalAlignment=0x%08x "
+    			   "*HorizontalTileSize=%u *VerticalTileSize=%u",
+    			   gcmOPT_VALUE(InternalSize),
+    			   gcmOPT_VALUE(InternalBaseAddress),
+    			   gcmOPT_VALUE(InternalAlignment),
+    			   gcmOPT_VALUE(ExternalSize),
+    			   gcmOPT_VALUE(ExternalBaseAddress),
+    			   gcmOPT_VALUE(ExternalAlignment),
+    			   gcmOPT_VALUE(HorizontalTileSize),
+    			   gcmOPT_VALUE(VerticalTileSize));
     return gcvSTATUS_OK;
 }
 
@@ -724,7 +780,7 @@ gckHARDWARE_QueryChipIdentity(
     /* Return chip model. */
     if (ChipModel != gcvNULL)
     {
-	*ChipModel = Hardware->chipModel;
+    	*ChipModel = Hardware->chipModel;
     }
 
     /* Return revision number. */
@@ -736,13 +792,13 @@ gckHARDWARE_QueryChipIdentity(
     /* Return feature set. */
     if (ChipFeatures != gcvNULL)
     {
-	gctUINT32 features = Hardware->chipFeatures;
+    	gctUINT32 features = Hardware->chipFeatures;
 
 		if (( ((((gctUINT32) (features)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) ))
 		{
 			/* Override fast clear by command line. */
 			features = ((((gctUINT32) (features)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (Hardware->allowFastClear) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)));
-		}
+   		}
 
 		if (( ((((gctUINT32) (features)) >> (0 ? 5:5)) & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1)))))) ))
 		{
@@ -761,7 +817,7 @@ gckHARDWARE_QueryChipIdentity(
 			features = ((((gctUINT32) (features)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)));
 		}
 
-		*ChipFeatures = features;
+   		*ChipFeatures = features;
     }
 
     /* Return minor feature set. */
@@ -777,11 +833,11 @@ gckHARDWARE_QueryChipIdentity(
 	}
 
     /* Success. */
-    gcmkFOOTER_ARG("*ChipModel=%x *ChipRevision=%x *ChipFeatures=%08x "
-			   "*ChipMinorFeatures=%08x *ChipMinorFeatures1=%08x",
-			   gcmOPT_VALUE(ChipModel), gcmOPT_VALUE(ChipRevision),
-			   gcmOPT_VALUE(ChipFeatures), gcmOPT_VALUE(ChipMinorFeatures),
-			   gcmOPT_VALUE(ChipMinorFeatures1));
+    gcmkFOOTER_ARG("*ChipModel=0x%x *ChipRevision=0x%x *ChipFeatures=0x%08x "
+                   "*ChipMinorFeatures=0x%08x *ChipMinorFeatures1=0x%08x",
+    			   gcmOPT_VALUE(ChipModel), gcmOPT_VALUE(ChipRevision),
+    			   gcmOPT_VALUE(ChipFeatures), gcmOPT_VALUE(ChipMinorFeatures),
+    			   gcmOPT_VALUE(ChipMinorFeatures1));
     return gcvSTATUS_OK;
 }
 
@@ -981,7 +1037,7 @@ gckHARDWARE_ConvertFormat(
 
     /* Success. */
     gcmkFOOTER_ARG("*BitsPerPixel=%u *BytesPerTile=%u",
-			   gcmOPT_VALUE(BitsPerPixel), gcmOPT_VALUE(BytesPerTile));
+    			   gcmOPT_VALUE(BitsPerPixel), gcmOPT_VALUE(BytesPerTile));
     return gcvSTATUS_OK;
 }
 
@@ -1086,7 +1142,7 @@ gckHARDWARE_Execute(
     gctUINT32 address = 0, control;
 
     gcmkHEADER_ARG("Hardware=0x%x Logical=0x%x Bytes=%lu",
-			   Hardware, Logical, Bytes);
+    			   Hardware, Logical, Bytes);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
@@ -1140,6 +1196,7 @@ gckHARDWARE_Execute(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1204,7 +1261,7 @@ gckHARDWARE_WaitLink(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
 	/* Compute number of bytes required. */
 	bytes = gcmALIGN(Offset + 16, 8) - Offset;
@@ -1269,6 +1326,7 @@ gckHARDWARE_WaitLink(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1314,7 +1372,7 @@ gckHARDWARE_End(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
     if (Logical != gcvNULL)
     {
@@ -1331,7 +1389,7 @@ gckHARDWARE_End(
 		gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE, "0x%x: END", Logical);
 
 		/* Make sure the CPU writes out the data to memory. */
-		gcmkVERIFY_OK(
+		gcmkONERROR(
 			gckOS_MemoryBarrier(Hardware->os, Logical));
     }
 
@@ -1346,6 +1404,7 @@ gckHARDWARE_End(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1391,7 +1450,7 @@ gckHARDWARE_Nop(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
     if (Logical != gcvNULL)
     {
@@ -1418,6 +1477,7 @@ gckHARDWARE_Nop(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1467,7 +1527,7 @@ gckHARDWARE_Wait(
 
 	/* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
     if (Logical != gcvNULL)
     {
@@ -1496,6 +1556,7 @@ gckHARDWARE_Wait(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1553,7 +1614,7 @@ gckHARDWARE_Event(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
     gcmkVERIFY_ARGUMENT(Event < 32);
 
 	/* Determine the size of the command. */
@@ -1587,8 +1648,8 @@ gckHARDWARE_Event(
 
 		/* Append EVENT(Event, destiantion). */
         logical[0] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ? 31:27) - (0 ? 31:27) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-			   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E01) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-			   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
+        		   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E01) & ((gctUINT32) ((((1 ? 15:0) - (0 ? 15:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
+        		   | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 25:16) - (0 ? 25:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
 
         logical[1] = ((((gctUINT32) (destination)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0))) | (((gctUINT32) ((gctUINT32) (Event) & ((gctUINT32) ((((1 ? 4:0) - (0 ? 4:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)));
 
@@ -1633,6 +1694,7 @@ gckHARDWARE_Event(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1684,7 +1746,7 @@ gckHARDWARE_PipeSelect(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-	gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+	gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
 	/* Append a PipeSelect. */
 	if (Logical != gcvNULL)
@@ -1755,6 +1817,7 @@ gckHARDWARE_PipeSelect(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1813,7 +1876,7 @@ gckHARDWARE_Link(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_ARGUMENT((Logical == gcvNULL) || (Bytes != gcvNULL));
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
     if (Logical != gcvNULL)
     {
@@ -1827,17 +1890,20 @@ gckHARDWARE_Link(
 		gcmkONERROR(
 			gckHARDWARE_ConvertLogical(Hardware, FetchAddress, &address));
 
+        logical[1] = address;
+        
         if(Hardware->hang)
         {
-            /* simulate GPU hangs only once */
-            logical[1] = address & 0xffffff00;
-            Hardware->hang = gcvFALSE;
+            static gctUINT32 count = 0;
+            
+            if( ( ++count % 50 ) == 0 )
+            {
+                /* simulate GPU hangs only once */
+                logical[1] = address & 0xffffff00;
+                gcmkPRINT("@@@pollute link chain \n");
+            }
         }
-        else
-        {
-            logical[1] = address;
-        }
-
+        
         /* Make sure the address got written before the LINK command. */
         gcmkONERROR(
 			gckOS_MemoryBarrier(Hardware->os, logical + 1));
@@ -1874,6 +1940,7 @@ gckHARDWARE_Link(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1966,8 +2033,8 @@ gckHARDWARE_AlignToTile(
 
     /* Success. */
     gcmkFOOTER_ARG("*Width=%u *Height=%u *SuperTiled=%d",
-			   gcmOPT_VALUE(Width), gcmOPT_VALUE(Height),
-			   gcmOPT_VALUE(SuperTiled));
+    			   gcmOPT_VALUE(Width), gcmOPT_VALUE(Height),
+    			   gcmOPT_VALUE(SuperTiled));
     return gcvSTATUS_OK;
 }
 
@@ -2013,7 +2080,7 @@ gckHARDWARE_UpdateQueueTail(
 
     /* Notify gckKERNEL object of change. */
     gcmkONERROR(
-	gckKERNEL_Notify(Hardware->kernel,
+    	gckKERNEL_Notify(Hardware->kernel,
 						 gcvNOTIFY_COMMAND_QUEUE,
 						 gcvFALSE));
 
@@ -2022,6 +2089,7 @@ gckHARDWARE_UpdateQueueTail(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -2055,7 +2123,7 @@ gckHARDWARE_ConvertLogical(
     OUT gctUINT32 * Address
     )
 {
-    gctUINT32 address;
+    gctUINT32 address = 0;
     gceSTATUS status;
 
     gcmkHEADER_ARG("Hardware=0x%x Logical=0x%x", Hardware, Logical);
@@ -2065,6 +2133,9 @@ gckHARDWARE_ConvertLogical(
     gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
     gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
+    if (Logical == gcvNULL || Address == gcvNULL)
+        return gcvSTATUS_INVALID_ARGUMENT;
+    
 	/* Convert logical address into a physical address. */
 	gcmkONERROR(
 		gckOS_GetPhysicalAddress(Hardware->os, Logical, &address));
@@ -2173,15 +2244,19 @@ gckHARDWARE_Interrupt(
 	if (InterruptValid)
 	{
 		/* Read AQIntrAcknowledge register. */
-		gcmkVERIFY_OK(
-			gckOS_ReadRegister(Hardware->os,
+        gcmkONERROR(
+			gckOS_DirectReadRegister(Hardware->os,
 							   0x00010,
 							   &data));
-
+        
+#if gcdDEBUG && VIVANTE_POWER_MANAGE
 		if (data & 0x80000000)
 		{
-			gcmkTRACE(gcvLEVEL_ERROR, "AXI Bus Error detected!");
+            gcmkONERROR(gckOS_Broadcast(Hardware->os,
+                                        Hardware,
+                                        gcvBROADCAST_AXI_BUS_ERROR));
 		}
+#endif
 
 		if (data == 0)
 		{
@@ -2200,6 +2275,11 @@ gckHARDWARE_Interrupt(
 		status = gckEVENT_Notify(event, 0);
 	}
 
+OnError:
+    if (!gcmIS_SUCCESS(status))
+    {
+        gcmkLOG_ERROR_STATUS();
+    }
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -2262,8 +2342,8 @@ gckHARDWARE_QueryCommandBuffer(
 
     /* Success. */
     gcmkFOOTER_ARG("*Alignment=%lu *ReservedHead=%lu *ReservedTail=%lu",
-			   gcmOPT_VALUE(Alignment), gcmOPT_VALUE(ReservedHead),
-			   gcmOPT_VALUE(ReservedTail));
+    			   gcmOPT_VALUE(Alignment), gcmOPT_VALUE(ReservedHead),
+    			   gcmOPT_VALUE(ReservedTail));
     return gcvSTATUS_OK;
 }
 
@@ -2314,7 +2394,7 @@ gckHARDWARE_QuerySystemMemory(
 
     /* Success. */
     gcmkFOOTER_ARG("*SystemSize=%lu *SystemBaseAddress=%lu",
-			   gcmOPT_VALUE(SystemSize), gcmOPT_VALUE(SystemBaseAddress));
+    			   gcmOPT_VALUE(SystemSize), gcmOPT_VALUE(SystemBaseAddress));
     return gcvSTATUS_OK;
 }
 
@@ -2399,6 +2479,7 @@ gckHARDWARE_SetMMU(
 	return status;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -2444,7 +2525,6 @@ gckHARDWARE_FlushMMU(
 	gcmkONERROR(
 		gckCOMMAND_Reserve(Hardware->kernel->command,
 						   8,
-						   gcvFALSE,
 						   (gctPOINTER *) &buffer,
 						   &bufferSize));
 
@@ -2458,13 +2538,14 @@ gckHARDWARE_FlushMMU(
 				   "0x%x: FLUSH MMU", buffer);
 
 	gcmkONERROR(
-		gckCOMMAND_Execute(Hardware->kernel->command, 8, gcvFALSE));
+        gckCOMMAND_Execute(Hardware->kernel->command, 8));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -2560,6 +2641,7 @@ gckHARDWARE_GetIdle(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -2584,6 +2666,7 @@ gckHARDWARE_Flush(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkVERIFY_ARGUMENT((Logical != gcvNULL) || (Bytes != gcvNULL));
 
 	/* Get current pipe. */
 	pipe = Hardware->kernel->command->pipeSelect;
@@ -2672,21 +2755,21 @@ gckHARDWARE_SetFastClear(
     gceSTATUS status;
 
     gcmkHEADER_ARG("Hardware=0x%x Enable=%d Compression=%d",
-			   Hardware, Enable, Compression);
+    			   Hardware, Enable, Compression);
 
 	/* Only process if fast clear is available. */
     if (( ((((gctUINT32) (Hardware->chipFeatures)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) ))
     {
-	if (Enable == -1)
-	{
-		/* Determine automatic value for fast clear. */
-	    Enable = (Hardware->chipModel != gcv500)
+    	if (Enable == -1)
+    	{
+	    	/* Determine automatic value for fast clear. */
+    	    Enable = (Hardware->chipModel != gcv500)
 				   | (Hardware->chipRevision >= 3);
-	}
+    	}
 
 #if MRVL_DISABLE_FASTCLEAR
 		Enable = 0;
-#endif
+#endif 
 
 		if (Compression == -1)
 		{
@@ -2697,18 +2780,18 @@ gckHARDWARE_SetFastClear(
 
 		/* Read AQMemoryDebug register. */
         gcmkONERROR(
-		gckOS_ReadRegister(Hardware->os, 0x00414, &debug));
+        	gckOS_ReadRegister(Hardware->os, 0x00414, &debug));
 
 		/* Set fast clear bypass. */
-	debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (Enable==0) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
+    	debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20))) | (((gctUINT32) ((gctUINT32) (Enable==0) & ((gctUINT32) ((((1 ? 20:20) - (0 ? 20:20) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)));
 
 		/* Set copression bypass. */
-	debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression==0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
+    	debug = ((((gctUINT32) (debug)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21))) | (((gctUINT32) ((gctUINT32) (Compression==0) & ((gctUINT32) ((((1 ? 21:21) - (0 ? 21:21) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)));
 
 		/* Write back AQMemoryDebug register. */
-	gcmkONERROR(
+    	gcmkONERROR(
 			gckOS_WriteRegister(Hardware->os,
-						0x00414,
+				    	    	0x00414,
 								debug));
 
 		/* Store fast clear and comprersison flags. */
@@ -2731,12 +2814,18 @@ OnError:
 
 typedef enum
 {
-	gcvPOWER_FLAG_INITIALIZE      = 1 << 0,
-	gcvPOWER_FLAG_STALL           = 1 << 1,
-	gcvPOWER_FLAG_STOP            = 1 << 2,
-	gcvPOWER_FLAG_START           = 1 << 3,
-	gcvPOWER_FLAG_RELEASE_CONTEXT = 1 << 4,
-	gcvPOWER_FLAG_DELAY           = 1 << 5,
+    gcvPOWER_FLAG_INITIALIZE    = 1 << 0,
+    gcvPOWER_FLAG_STALL         = 1 << 1,
+    gcvPOWER_FLAG_STOP          = 1 << 2,
+    gcvPOWER_FLAG_START         = 1 << 3,
+    gcvPOWER_FLAG_RELEASE       = 1 << 4,
+    gcvPOWER_FLAG_DELAY         = 1 << 5,
+    gcvPOWER_FLAG_SAVE            = 1 << 6,
+    gcvPOWER_FLAG_ACQUIRE       = 1 << 7,
+    gcvPOWER_FLAG_PWR_OFF       = 1 << 28,
+    gcvPOWER_FLAG_PWR_ON        = 1 << 29,
+    gcvPOWER_FLAG_CLK_OFF       = 1 << 30,
+    gcvPOWER_FLAG_CLK_ON        = 1 << 31,
 }
 gcePOWER_FLAGS;
 
@@ -2761,69 +2850,76 @@ gckHARDWARE_SetPowerManagementState(
     IN gceCHIPPOWERSTATE State
     )
 {
+#if !gcdNO_POWER_MANAGEMENT
 	gceSTATUS status;
-	gckCOMMAND command;
+    gckCOMMAND command = gcvNULL;
+    gckOS os;
 	gctUINT flag, clock;
-	gctPOINTER buffer;
-	gctSIZE_T bytes, requested;
-	gctBOOL acquired = gcvFALSE;
+	gctBOOL semaAcquired = gcvFALSE;
+    gctBOOL mutexAcquired = gcvFALSE;
+    gctBOOL stall = gcvTRUE;
 
 	/* State transition flags. */
 	static const gctUINT flags[4][4] =
 	{
-		/* gcvPOWER_ON		*/
-		{	/* ON      */ 0,
-			/* OFF     */ gcvPOWER_FLAG_STALL |
-						  gcvPOWER_FLAG_STOP,
-			/* IDLE    */ gcvPOWER_FLAG_STALL,
-			/* SUSPEND */ gcvPOWER_FLAG_STALL |
-						  gcvPOWER_FLAG_STOP,
-		},
-
-		/* gcvPOWER_OFF		*/
-		{	/* ON      */ gcvPOWER_FLAG_INITIALIZE      |
-						  gcvPOWER_FLAG_START           |
-						  gcvPOWER_FLAG_RELEASE_CONTEXT |
-						  gcvPOWER_FLAG_DELAY,
-			/* OFF     */ 0,
-			/* IDLE    */ gcvPOWER_FLAG_INITIALIZE |
-						  gcvPOWER_FLAG_START      |
-						  gcvPOWER_FLAG_DELAY,
-			/* SUSPEND */ gcvPOWER_FLAG_INITIALIZE,
-		},
-
-		/* gcvPOWER_IDLE	*/
-		{	/* ON      */ gcvPOWER_FLAG_RELEASE_CONTEXT,
-			/* OFF     */ gcvPOWER_FLAG_STOP,
-			/* IDLE    */ 0,
-			/* SUSPEND */ gcvPOWER_FLAG_STOP,
-		},
-
-		/* gcvPOWER_SUSPEND */
-		{	/* ON      */ gcvPOWER_FLAG_START           |
-						  gcvPOWER_FLAG_RELEASE_CONTEXT |
-						  gcvPOWER_FLAG_DELAY,
-			/* OFF     */ 0,
-			/* IDLE    */ gcvPOWER_FLAG_START |
-						  gcvPOWER_FLAG_DELAY,
-			/* SUSPEND */ 0,
+        /* gcvPOWER_ON           */
+        {   /* ON                */ 0,
+            /* OFF               */ gcvPOWER_FLAG_ACQUIRE |
+                                    gcvPOWER_FLAG_STALL   |
+                                    gcvPOWER_FLAG_STOP    |
+                                    gcvPOWER_FLAG_PWR_OFF |
+                                    gcvPOWER_FLAG_CLK_OFF,
+            /* IDLE              */ 0,
+            /* SUSPEND           */ gcvPOWER_FLAG_STALL   |
+                                    gcvPOWER_FLAG_STOP    |
+                                    gcvPOWER_FLAG_CLK_OFF,
+        },
+
+        /* gcvPOWER_OFF          */
+        {   /* ON                */ gcvPOWER_FLAG_INITIALIZE |
+                                    gcvPOWER_FLAG_START      |
+                                    gcvPOWER_FLAG_RELEASE    |
+                                    gcvPOWER_FLAG_DELAY      |
+                                    gcvPOWER_FLAG_PWR_ON     |
+                                    gcvPOWER_FLAG_CLK_ON,
+            /* OFF               */ 0,
+            /* IDLE              */ 0,
+            /* SUSPEND           */ 0,
+        },
+
+        /* gcvPOWER_IDLE         */
+        {   /* ON                */ 0,
+            /* OFF               */ 0,
+            /* IDLE              */ 0,
+            /* SUSPEND           */ 0,
+        },
+
+        /* gcvPOWER_SUSPEND      */
+        {   /* ON                */ gcvPOWER_FLAG_START   |
+                                    gcvPOWER_FLAG_DELAY   |
+                                    gcvPOWER_FLAG_CLK_ON,
+            /* OFF               */ gcvPOWER_FLAG_SAVE |
+                                    gcvPOWER_FLAG_ACQUIRE |
+                                    gcvPOWER_FLAG_PWR_OFF,
+            /* IDLE              */ 0,
+            /* SUSPEND           */ 0,
 		},
 	};
 
 	/* Clocks. */
 	static const gctUINT clocks[4] =
 	{
-		/* gcvPOWER_ON      */
+        /* gcvPOWER_ON */
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))|
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))|
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (64) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)))|
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) ,
-		/* gcvPOWER_OFF     */
-		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))|
-		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))|
-		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)))|
-		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) ,
-		/* gcvPOWER_IDLE    */
+        /* gcvPOWER_OFF */
+        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))|
+        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))|
+        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)))|
+        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) ,
+        /* gcvPOWER_IDLE */
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))|
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))|
 		((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 8:2) - (0 ? 8:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)))|
@@ -2839,15 +2935,30 @@ gckHARDWARE_SetPowerManagementState(
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
+    /* Get the gckOS object pointer. */
+    os = Hardware->os;
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+
+    gcmkONERROR(gckOS_AcquireRecMutex(os, Hardware->recMutexPower, gcvINFINITE));
+    mutexAcquired = gcvTRUE;
+
+    if ( (Hardware->chipPowerState == gcvPOWER_OFF)
+        && (State == gcvPOWER_SUSPEND) )
+    {
+        State = gcvPOWER_OFF;
+    }
+    
 	/* Grab control flags and clock. */
 	flag  = flags[Hardware->chipPowerState][State];
 	clock = clocks[State];
 
 	if (flag == 0)
 	{
-	/* Save new power state. */
-	Hardware->chipPowerState = State;
-
+    	/* Save new power state. */
+    	Hardware->chipPowerState = State;
+        
+        gcmkVERIFY_OK(gckOS_ReleaseRecMutex(os, Hardware->recMutexPower));
+        
 		/* No need to do anything. */
 		gcmkFOOTER_NO();
 		return gcvSTATUS_OK;
@@ -2856,138 +2967,143 @@ gckHARDWARE_SetPowerManagementState(
 	gcmkASSERT(Hardware->kernel          != gcvNULL);
 	gcmkASSERT(Hardware->kernel->command != gcvNULL);
 	command = Hardware->kernel->command;
-
-	if (flag & gcvPOWER_FLAG_INITIALIZE)
+    
+    if (flag & (gcvPOWER_FLAG_CLK_ON | gcvPOWER_FLAG_PWR_ON))
 	{
-		/* Initialize hardware. */
-		gcmkONERROR(
-			gckHARDWARE_InitializeHardware(Hardware));
-
-		gcmkONERROR(
-			gckHARDWARE_SetFastClear(Hardware,
-									 Hardware->allowFastClear,
-									 Hardware->allowCompression));
-
-		/* Force the command queue to reload the next context. */
-		command->currentContext = 0;
+        gckOS_SetConstraint(os,
+                        (flag & gcvPOWER_FLAG_CLK_ON) ? gcvTRUE : gcvFALSE,
+                        (flag & gcvPOWER_FLAG_PWR_ON) ? gcvTRUE : gcvFALSE);
+        
+        gckOS_ClockOn(os, 
+                        (flag & gcvPOWER_FLAG_CLK_ON) ? gcvTRUE : gcvFALSE,
+                        (flag & gcvPOWER_FLAG_PWR_ON) ? gcvTRUE : gcvFALSE,
+                        0); 
 	}
+    
+    if(flag & gcvPOWER_FLAG_CLK_ON)
+    {
+        gckOS_ResumeInterrupt(os);
+    }
 
-	if (flag & gcvPOWER_FLAG_STALL)
-	{
-		/* Acquire the context switching mutex so nothing else can be
-		** committed. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Hardware->os,
-							   command->mutexContext,
-							   gcvINFINITE));
-
-		acquired = gcvTRUE;
-
-		/* Get the size of the flush command. */
-		gcmkONERROR(
-			gckHARDWARE_Flush(Hardware,
-							  (gceKERNEL_FLUSH) ~0,
-							  gcvNULL,
-							  &requested));
-
-		/* Reserve space in the command queue. */
-		gcmkONERROR(
-			gckCOMMAND_Reserve(command, requested, gcvFALSE, &buffer, &bytes));
-
-		/* Append a flush. */
-		gcmkONERROR(
-			gckHARDWARE_Flush(Hardware,
-							  (gceKERNEL_FLUSH) ~0,
-							  buffer,
-							  &bytes));
-
-		/* Execute the command queue. */
-		acquired = gcvFALSE;
-		gcmkONERROR(
-			gckCOMMAND_Execute(command, requested, gcvFALSE));
+    if ((flag & gcvPOWER_FLAG_STALL) && stall)
+    {
+        gctBOOL idle;
 
-		/* Wait to finish all commands. */
-		gcmkONERROR(
-			gckCOMMAND_Stall(command));
-	}
+        /* Check for idle. */
+        gcmkONERROR(gckHARDWARE_QueryIdle(Hardware, &idle));
 
+        if (!idle)
+        {
+            status = gcvSTATUS_CHIP_NOT_READY;
+            goto OnError;
+        }
+    }
+    if (flag & gcvPOWER_FLAG_ACQUIRE)
+    {
+        /* Acquire the power management semaphore. */
+        gcmkONERROR(gckOS_AcquireSemaphore(os, command->powerSemaphore));
+        semaAcquired = gcvTRUE;
+    }
 	if (flag & gcvPOWER_FLAG_STOP)
 	{
 		/* Stop the command parser. */
-		gcmkONERROR(
-			gckCOMMAND_Stop(command));
-
-		/* Grab the command queue mutex so nothing can get access to the
-		** command queue. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Hardware->os,
-							   command->mutexQueue,
-							   gcvINFINITE));
+        gcmkONERROR(gckCOMMAND_Stop(command));
 	}
 
-	/* Write the clock control register. */
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00000,
-							clock));
-
-	/* Done loading the frequency scaler. */
-	gcmkONERROR(
-		gckOS_WriteRegister(Hardware->os,
-							0x00000,
-							((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
-
-	if (flag & gcvPOWER_FLAG_DELAY)
-	{
-		/* Wait for the specified amount of time to settle coming back from
-		** power-off or suspend state. */
-		gcmkONERROR(
-			gckOS_Delay(Hardware->os, gcdPOWER_CONTROL_DELAY));
-	}
-	else
+    if (flag & (gcvPOWER_FLAG_CLK_ON | gcvPOWER_FLAG_CLK_OFF) )
+    {
+    	/* Write the clock control register. */
+        gcmkONERROR(gckOS_WriteRegister(os,
+                                        0x00000,
+                                        clock));
+
+        /* Done loading the frequency scaler. */
+        gcmkONERROR(gckOS_WriteRegister(os,
+                                        0x00000,
+                                        ((((gctUINT32) (clock)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 9:9) - (0 ? 9:9) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
+    }
+    
+    if (flag & gcvPOWER_FLAG_INITIALIZE)
 	{
-		/* Wait for the smallest amount of time to settle the clock divider. */
+        /* Initialize hardware. */
 		gcmkONERROR(
-			gckOS_Delay(Hardware->os, 0));
-	}
+            gckHARDWARE_InitializeHardware(Hardware));
 
-	if (flag & gcvPOWER_FLAG_START)
-	{
-		/* Release the command mutex queue. */
 		gcmkONERROR(
-			gckOS_ReleaseMutex(Hardware->os, command->mutexQueue));
+            gckHARDWARE_SetFastClear(Hardware,
+                                     Hardware->allowFastClear,
+                                     Hardware->allowCompression));
 
-		/* Start the command processor. */
-		gcmkONERROR(
-			gckCOMMAND_Start(command));
+        /* Force the command queue to reload the next context. */
+        command->currentContext = 0;
 	}
 
-	if (flag & gcvPOWER_FLAG_RELEASE_CONTEXT)
-	{
-		/* Release the context switching mutex. */
-		gcmkONERROR(
-			gckOS_ReleaseMutex(Hardware->os, command->mutexContext));
+    if(flag & gcvPOWER_FLAG_CLK_OFF)
+    {
+        gckOS_SuspendInterrupt(os);
+    }
+    
+    if (flag & (gcvPOWER_FLAG_CLK_OFF | gcvPOWER_FLAG_PWR_OFF))
+    {  
+        gckOS_ClockOff(os, 
+                        (flag & gcvPOWER_FLAG_CLK_OFF) ? gcvTRUE : gcvFALSE,
+                        (flag & gcvPOWER_FLAG_PWR_OFF) ? gcvTRUE : gcvFALSE);
+        
+        gckOS_UnSetConstraint(os, 
+                        (flag & gcvPOWER_FLAG_CLK_OFF) ? gcvTRUE : gcvFALSE,
+                        (flag & gcvPOWER_FLAG_PWR_OFF) ? gcvTRUE : gcvFALSE);
 	}
 
-	/* Save new power state. */
+    if (flag & gcvPOWER_FLAG_START)
+    {
+        /* Start the command processor. */
+        gcmkONERROR(gckCOMMAND_Start(command));
+    }
+
+    if (flag & gcvPOWER_FLAG_RELEASE)
+    {
+        /* Release the power management semaphore. */
+        gcmkONERROR(gckOS_ReleaseSemaphore(os, command->powerSemaphore));
+    }
+
+    /* Save the new power state. */
 	Hardware->chipPowerState = State;
 
+    gcmkVERIFY_OK(gckOS_ReleaseRecMutex(os, Hardware->recMutexPower));
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
-	if (acquired)
-	{
-		/* Release command queue. */
-		gcmkVERIFY_OK(gckCOMMAND_Release(command));
-	}
+    if(status < 0)
+    {
+        gcmkLOG_ERROR_ARGS("status=%d, semaAcquired=%d, mutexAcquired=%d",
+                            status, semaAcquired, mutexAcquired);
+    }
+
+    if (semaAcquired)
+    {
+        /* Release semaphore. */
+        gcmkVERIFY_OK(
+            gckOS_ReleaseSemaphore(Hardware->os, command->powerSemaphore));
+    }
 
+    if (mutexAcquired)
+    {
+        gcmkVERIFY_OK(gckOS_ReleaseRecMutex(os, Hardware->recMutexPower));
+    }
+    
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
+#else
+    /* Do nothing */
+    return gcvSTATUS_OK;
+#endif
 }
 
+
 /*******************************************************************************
 **
 **	gckHARDWARE_QueryPowerManagementState
@@ -3038,33 +3154,45 @@ gckHARDWARE_QueryIdle(
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
     gcmkVERIFY_ARGUMENT(IsIdle != gcvNULL);
 
+    /* We are idle when the power is not ON. */
+    if (Hardware->chipPowerState != gcvPOWER_ON)
+    {
+        *IsIdle = gcvTRUE;
+    }
+
+    else
+    {
+    /* Read the current FE address. */
+    gcmkONERROR(gckOS_ReadRegister(Hardware->os,
+                                   0x00664,
+                                   &address));
+
     /* Read idle register. */
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00004, &idle));
 
     /* Pipe must be idle. */
-    if ((( ((((gctUINT32) (idle)) >> (0 ? 1:1)) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1)))))) )!=1)
+    /* if ((( ((((gctUINT32) (idle)) >> (0 ? 1:1)) & ((gctUINT32) ((((1 ? 1:1) - (0 ? 1:1) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 1:1) - (0 ? 1:1) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 3:3)) & ((gctUINT32) ((((1 ? 3:3) - (0 ? 3:3) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:3) - (0 ? 3:3) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 4:4)) & ((gctUINT32) ((((1 ? 4:4) - (0 ? 4:4) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 4:4) - (0 ? 4:4) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 5:5)) & ((gctUINT32) ((((1 ? 5:5) - (0 ? 5:5) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 5:5) - (0 ? 5:5) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 6:6)) & ((gctUINT32) ((((1 ? 6:6) - (0 ? 6:6) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 6:6) - (0 ? 6:6) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 7:7)) & ((gctUINT32) ((((1 ? 7:7) - (0 ? 7:7) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 7:7) - (0 ? 7:7) + 1)))))) )!=1)
     ||  (( ((((gctUINT32) (idle)) >> (0 ? 2:2)) & ((gctUINT32) ((((1 ? 2:2) - (0 ? 2:2) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 2:2) - (0 ? 2:2) + 1)))))) )!=1)
-    )
+    ) */
+    /* 
+        For GC800 or higher, there are more modules like VG IM FP TS, we need 
+        to check more bits 
+    */
+    if( (idle & 0x7FFFFFFE) != 0x7FFFFFFE )
     {
         /* Something is busy. */
         *IsIdle = gcvFALSE;
     }
-
     else
     {
-        /* Read the current FE address. */
-        gcmkONERROR(gckOS_ReadRegister(Hardware->os,
-                                       0x00664,
-                                       &address));
-
         /* Test if address is inside the last WAIT/LINK sequence. */
         if ((address >= Hardware->lastWaitLink)
-        &&  (address <  Hardware->lastWaitLink + 16)
+            &&  (address <= Hardware->lastWaitLink + 16)
         )
         {
             /* FE is in last WAIT/LINK and the pipe is idle. */
@@ -3076,6 +3204,7 @@ gckHARDWARE_QueryIdle(
             *IsIdle = gcvFALSE;
         }
     }
+    }
 
     /* Success. */
     gcmkFOOTER_NO();
@@ -3167,7 +3296,7 @@ gckHARDWARE_ProfileEngine2D(
 
 		/* Reset counter. */
 		gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
-		gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
+		gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) 
 )));
 	}
 
@@ -3198,25 +3327,25 @@ gckHARDWARE_QueryProfileRegisters(
 
     /* Read the counters. */
     gcmkONERROR(
-	gckOS_ReadRegister(Hardware->os,
-					   0x00040,
-					   &profiler->gpuTotalRead64BytesPerFrame));
+    	gckOS_ReadRegister(Hardware->os,
+    					   0x00040,
+    					   &profiler->gpuTotalRead64BytesPerFrame));
     gcmkONERROR(
-	gckOS_ReadRegister(Hardware->os,
-					   0x00044,
-					   &profiler->gpuTotalWrite64BytesPerFrame));
+    	gckOS_ReadRegister(Hardware->os,
+    					   0x00044,
+    					   &profiler->gpuTotalWrite64BytesPerFrame));
     gcmkONERROR(
-	gckOS_ReadRegister(Hardware->os,
-					   0x00438,
-					   &profiler->gpuCyclesCounter));
+    	gckOS_ReadRegister(Hardware->os,
+    					   0x00438,
+    					   &profiler->gpuCyclesCounter));
 
     /* Reset counters. */
     gcmkONERROR(
-	gckOS_WriteRegister(Hardware->os, 0x0003C, 1));
+    	gckOS_WriteRegister(Hardware->os, 0x0003C, 1));
     gcmkONERROR(
-	gckOS_WriteRegister(Hardware->os, 0x0003C, 0));
+    	gckOS_WriteRegister(Hardware->os, 0x0003C, 0));
     gcmkONERROR(
-	gckOS_WriteRegister(Hardware->os, 0x00438, 0));
+    	gckOS_WriteRegister(Hardware->os, 0x00438, 0));
 
     /* PE */
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
@@ -3228,7 +3357,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00454, &profiler->pe_pixel_count_drawn_by_depth_pipe));
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
-    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) 
 )));
 
     /* SH */
@@ -3249,7 +3378,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (14) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x0045C, &profiler->pxl_texld_inst_counter));
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) )));
-    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24)))
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00470, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) 
 )));
 
     /* PA */
@@ -3266,7 +3395,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (8) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00460, &profiler->pa_culled_counter));
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) )));
-    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) 
 )));
 
     /* SE */
@@ -3275,7 +3404,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00464, &profiler->se_culled_lines_count));
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) )));
-    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)))
+    gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) 
 )));
 
     /* RA */
@@ -3292,7 +3421,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (10) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00448, &profiler->ra_prefetch_cache_miss_counter));
 	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) )));
-	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16)))
+	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:16) - (0 ? 19:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:16) - (0 ? 19:16) + 1))))))) << (0 ? 19:16))) 
 )));
 
     /* TX */
@@ -3315,7 +3444,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (9) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x0044C, &profiler->tx_cache_miss_texel_count));
 	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) )));
-	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24)))
+	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00474, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 27:24) - (0 ? 27:24) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 27:24) - (0 ? 27:24) + 1))))))) << (0 ? 27:24))) 
 )));
 
     /* MC */
@@ -3326,7 +3455,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (3) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x00468, &profiler->mc_total_write_req_8B_from_pipeline));
 	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) )));
-	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
+	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 3:0) - (0 ? 3:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0))) 
 )));
 
     /* HI */
@@ -3337,7 +3466,7 @@ gckHARDWARE_QueryProfileRegisters(
     gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (2) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) )));
     gcmkONERROR(gckOS_ReadRegister(Hardware->os, 0x0046C, &profiler->hi_axi_cycles_write_data_stalled));
 	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (15) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) )));
-	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)))
+	gcmkONERROR(gckOS_WriteRegister(Hardware->os, 0x00478, (  ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 11:8) - (0 ? 11:8) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8))) 
 )));
 
     /* Success. */
@@ -3359,126 +3488,133 @@ gckHARDWARE_Reset(
 	gceSTATUS status;
 	gctUINT32 control, idle;
 	gckCOMMAND command;
+    gctBOOL acquired = gcvFALSE;
 
-	gcmkHEADER_ARG("Hardware=0x%x", Hardware);
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-	gcmkASSERT(Hardware->kernel != gcvNULL);
-	command = Hardware->kernel->command;
-	gcmkASSERT(command != gcvNULL);
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
+    gcmkASSERT(Hardware->kernel != gcvNULL);
+    command = Hardware->kernel->command;
+    gcmkASSERT(command != gcvNULL);
 
-	if (Hardware->chipRevision < 0x4600)
-	{
-		/* Not supported - we need the isolation bit. */
-		gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-	}
+    if (Hardware->chipRevision < 0x4600)
+    {
+        /* Not supported - we need the isolation bit. */
+        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+    }
 
-	if (Hardware->chipPowerState == gcvPOWER_ON)
-	{
-		/* Grab the context mutex. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Hardware->os,
-							   command->mutexContext,
-							   gcvINFINITE));
-	}
+    if (Hardware->chipPowerState == gcvPOWER_ON)
+    {
+        /* Acquire the power management semaphore. */
+        gcmkONERROR(
+            gckOS_AcquireSemaphore(Hardware->os, command->powerSemaphore));
+        acquired = gcvTRUE;
+    }
 
-	if ((Hardware->chipPowerState == gcvPOWER_ON)
-	||  (Hardware->chipPowerState == gcvPOWER_IDLE)
-	)
-	{
-		/* Stop the command processor. */
-		gcmkONERROR(
-			gckCOMMAND_Stop(command));
+    if ((Hardware->chipPowerState == gcvPOWER_ON)
+    ||  (Hardware->chipPowerState == gcvPOWER_IDLE)
+    )
+    {
+        /* Stop the command processor. */
+        gcmkONERROR(
+            gckCOMMAND_Stop(command));
 
-		/* Grab the queue mutex. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Hardware->os,
-							   command->mutexQueue,
-							   gcvINFINITE));
-	}
+        /* Grab the queue mutex. */
+        gcmkONERROR(
+            gckOS_AcquireMutex(Hardware->os,
+                               command->mutexQueue,
+                               gcvINFINITE));
+    }
 
-	/* Read register. */
-	gcmkONERROR(
-		gckOS_ReadRegister(Hardware->os,
-						   0x00000,
-						   &control));
+    /* Read register. */
+    gcmkONERROR(
+        gckOS_ReadRegister(Hardware->os,
+                           0x00000,
+                           &control));
 
-	for (;;)
-	{
-		/* Isolate the GPU. */
-		control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+    for (;;)
+    {
+        /* Isolate the GPU. */
+        control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
 
-		gcmkONERROR(
-			gckOS_WriteRegister(Hardware->os,
-								0x00000,
-								control));
+        gcmkONERROR(
+            gckOS_WriteRegister(Hardware->os,
+                                0x00000,
+                                control));
 
-		/* Set soft reset. */
-		gcmkONERROR(
-			gckOS_WriteRegister(Hardware->os,
-								0x00000,
-								((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)))));
+        /* Set soft reset. */
+        gcmkONERROR(
+            gckOS_WriteRegister(Hardware->os,
+                                0x00000,
+                                ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)))));
 
-		/* Wait for reset. */
-		gcmkONERROR(
-			gckOS_Delay(Hardware->os, 1));
+        /* Wait for reset. */
+        gcmkONERROR(
+            gckOS_Delay(Hardware->os, 1));
 
-		/* Reset soft reset bit. */
-		gcmkONERROR(
-			gckOS_WriteRegister(Hardware->os,
-								0x00000,
-								((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)))));
+        /* Reset soft reset bit. */
+        gcmkONERROR(
+            gckOS_WriteRegister(Hardware->os,
+                                0x00000,
+                                ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 12:12) - (0 ? 12:12) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)))));
 
-		/* Reset GPU isolation. */
-		control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
+        /* Reset GPU isolation. */
+        control = ((((gctUINT32) (control)) & ~(((gctUINT32) (((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ? 19:19) - (0 ? 19:19) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)));
 
-		gcmkONERROR(
-			gckOS_WriteRegister(Hardware->os,
-								0x00000,
-								control));
+        gcmkONERROR(
+            gckOS_WriteRegister(Hardware->os,
+                                0x00000,
+                                control));
 
-		/* Read idle register. */
-		gcmkONERROR(
-			gckOS_ReadRegister(Hardware->os,
-							   0x00004,
-							   &idle));
+        /* Read idle register. */
+        gcmkONERROR(
+            gckOS_ReadRegister(Hardware->os,
+                               0x00004,
+                               &idle));
 
-		if (( ((((gctUINT32) (idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) )==0)
-		{
-			continue;
-		}
+        if (( ((((gctUINT32) (idle)) >> (0 ? 0:0)) & ((gctUINT32) ((((1 ? 0:0) - (0 ? 0:0) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 0:0) - (0 ? 0:0) + 1)))))) )==0)
+        {
+            continue;
+        }
 
-		/* Read reset register. */
-		gcmkONERROR(
-			gckOS_ReadRegister(Hardware->os,
-							   0x00000,
-							   &control));
+        /* Read reset register. */
+        gcmkONERROR(
+            gckOS_ReadRegister(Hardware->os,
+                               0x00000,
+                               &control));
 
-		if ((( ((((gctUINT32) (control)) >> (0 ? 16:16)) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) )==0)
-		||  (( ((((gctUINT32) (control)) >> (0 ? 17:17)) & ((gctUINT32) ((((1 ? 17:17) - (0 ? 17:17) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 17:17) - (0 ? 17:17) + 1)))))) )==0)
-		)
-		{
-			continue;
-		}
+        if ((( ((((gctUINT32) (control)) >> (0 ? 16:16)) & ((gctUINT32) ((((1 ? 16:16) - (0 ? 16:16) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 16:16) - (0 ? 16:16) + 1)))))) )==0)
+        ||  (( ((((gctUINT32) (control)) >> (0 ? 17:17)) & ((gctUINT32) ((((1 ? 17:17) - (0 ? 17:17) + 1) == 32) ? ~0 : (~(~0 << ((1 ? 17:17) - (0 ? 17:17) + 1)))))) )==0)
+        )
+        {
+            continue;
+        }
 
-		/* GPU is idle. */
-		break;
-	}
+        /* GPU is idle. */
+        break;
+    }
 
-	/* Force an OFF to ON power switch. */
-	Hardware->chipPowerState = gcvPOWER_OFF;
-	gcmkONERROR(
-		gckHARDWARE_SetPowerManagementState(Hardware, gcvPOWER_ON));
+    /* Force an OFF to ON power switch. */
+    Hardware->chipPowerState = gcvPOWER_OFF;
+    gcmkONERROR(
+        gckHARDWARE_SetPowerManagementState(Hardware, gcvPOWER_ON));
 
-	/* Success. */
-	gcmkFOOTER_NO();
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 
 OnError:
-	/* Return the error. */
-	gcmkFOOTER();
-	return status;
+    if (acquired)
+    {
+        /* Release the power management semaphore. */
+        gcmkVERIFY_OK(
+            gckOS_ReleaseSemaphore(Hardware->os, command->powerSemaphore));
+    }
+
+    /* Return the error. */
+    gcmkFOOTER();
+    return status;
 }
 
 gceSTATUS
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.h
index 64aee03..e960780 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/gc_hal_kernel_hardware.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -32,38 +32,42 @@ extern "C" {
 struct _gckHARDWARE
 {
     /* Object. */
-    gcsOBJECT	    	    	object;
+    gcsOBJECT                   object;
 
     /* Pointer to gctKERNEL object. */
-    gckKERNEL	    	    	kernel;
+    gckKERNEL                   kernel;
 
     /* Pointer to gctOS object. */
-    gckOS   	    	    	os;
+    gckOS                       os;
 
     /* Chip characteristics. */
-    gceCHIPMODEL    	    	chipModel;
-    gctUINT32	    	    	chipRevision;
-    gctUINT32	    	    	chipFeatures;
-	gctUINT32	    	    	chipMinorFeatures0;
-	gctUINT32	    	    	chipMinorFeatures1;
-    gctBOOL 	    	    	allowFastClear;
-	gctBOOL						allowCompression;
-	gctUINT32					powerBaseAddress;
-	gctBOOL						extraEventStates;
-
-	gctUINT32					streamCount;
-	gctUINT32					registerMax;
-	gctUINT32					threadCount;
-	gctUINT32					shaderCoreCount;
-	gctUINT32					vertexCacheSize;
-	gctUINT32					vertexOutputBufferSize;
-
-	/* Big endian */
-	gctBOOL						bigEndian;
+    gceCHIPMODEL                chipModel;
+    gctUINT32                   chipRevision;
+    gctUINT32                   chipFeatures;
+    gctUINT32                   chipMinorFeatures0;
+    gctUINT32                   chipMinorFeatures1;
+    gctBOOL                     allowFastClear;
+    gctBOOL                     allowCompression;
+    gctUINT32                   powerBaseAddress;
+    gctBOOL                     extraEventStates;
+
+    gctUINT32                   streamCount;
+    gctUINT32                   registerMax;
+    gctUINT32                   threadCount;
+    gctUINT32                   shaderCoreCount;
+    gctUINT32                   vertexCacheSize;
+    gctUINT32                   vertexOutputBufferSize;
+
+    /* Big endian */
+    gctBOOL                     bigEndian;
 
     /* Chip status */
-    gceCHIPPOWERSTATE			chipPowerState;
+    gctPOINTER                  powerMutex;
+    gctUINT32                   powerProcess;
+    gctUINT32                   powerThread;
+    gceCHIPPOWERSTATE           chipPowerState;
     gctUINT32                   lastWaitLink;
+    gckRecursiveMutex           recMutexPower;
 
     /* force GC to hang once */
 	gctBOOL						hang;
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/makefile.linux b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/makefile.linux
index 763950e..ca9f433 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/makefile.linux
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/arch/unified/hal/kernel/makefile.linux
@@ -1,21 +1,21 @@
 ##############################################################################
-#
+#  
 #    Copyright (C) 2005 - 2010 by Vivante Corp.
-#
+#  
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
 #    the Free Software Foundation; either version 2 of the license, or
 #    (at your option) any later version.
-#
+#  
 #    This program is distributed in the hope that it will be useful,
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#    GNU General Public Lisence for more details.
-#
+#    GNU General Public License for more details.
+#  
 #    You should have received a copy of the GNU General Public License
 #    along with this program; if not write to the Free Software
 #    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-#
+#  
 ##############################################################################
 
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/common.target b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/common.target
index 14a8dba..d28664d 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/common.target
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/common.target
@@ -1,9 +1,9 @@
 ##############################################################################
 #  
-#    Copyright (C) 2005 - 2010 by Vivante Corp.
+#    Copyright (C) 2005 - 2010 by Vivante Corp.
 #  
 #    This program is free software; you can redistribute it and/or modify
-#    it under the terms of the GNU General Public License as published by
+#    it under the terms of the GNU General Public License as published by
 #    the Free Software Foundation; either version 2 of the license, or
 #    (at your option) any later version.
 #  
@@ -21,7 +21,8 @@
 
 ################################################################################
 # Define a shortcut for the main target.
-SO_SUFFIX = .1
+#SO_SUFFIX = .1
+SO_SUFFIX =
 TARGET_OUTPUT = $(OBJ_DIR)/$(TARGET_NAME)
 
 ################################################################################
@@ -31,7 +32,7 @@ all: $(TARGET_OUTPUT)
 
 clean:
 	@rm -f $(PREREQUISITES)
-	@rm -rf $(OBJ_DIR)/* $(OBJ_DIR)
+	@rm -rf $(OBJ_DIR)/* $(OBJ_DIR)
 	@rm -rf $(CLEAN_EXTRA)
 
 install: $(TARGET_OUTPUT)
@@ -52,37 +53,44 @@ else
     PREREQUISITES	:= $(PREREQUISITES)_r
 endif
 
-MAKEFILE_NAME	= makefile.linux
+MAKEFILE_NAME	= makefile.linux
 
 ifeq ($(STATIC_LINK),1)
-ifneq ($(USE_ARMCC), 1)
+ifneq ($(USE_ARMCC), 1)
   PFLAGS += -static
-else
-  PFLAGS += -L--no_search_dynamic_libraries
-endif
+else
+  PFLAGS += -L--no_search_dynamic_libraries
+endif
 endif
 
 ifeq ($(PROGRAM), 1)
 $(TARGET_OUTPUT): $(PREREQUISITES) $(OBJECTS)
-ifeq ($(SRC_CXX),)
+ifeq ($(SRC_CXX),)
 	$(CC) $(PFLAGS) $(OBJECTS) $(LIBS) -o $(TARGET_OUTPUT)
-else
+else
 	$(CXX) $(PFLAGS) $(OBJECTS) $(LIBS) -o $(TARGET_OUTPUT)
-endif
-
-ifneq ($(USE_ARMCC), 1)
-ifneq ($(DEBUG), 1)
+endif
+
+ifneq ($(USE_ARMCC), 1)
+ifneq ($(DEBUG), 1)
 	$(STRIP) $(TARGET_OUTPUT)
-endif
-endif
+endif
+endif
 endif
 
 ifeq ($(DYNAMIC), 1)
-ifeq ($(USE_ARMCC), 1)
-LFLAGS += --shared -L--soname=,$(TARGET_NAME)$(SO_SUFFIX)
-else
-LFLAGS += -Wall -shared -Wl,-soname,$(TARGET_NAME)$(SO_SUFFIX)
-endif
+ifeq ($(USE_ARMCC), 1)
+LFLAGS += --shared -L--soname=,$(TARGET_NAME)$(SO_SUFFIX)
+else
+LFLAGS += --shared -L--soname=,$(TARGET_NAME)
+endif
+else
+ifeq ($(CONFIG_DOVE_GPU), 1)
+LFLAGS += -Wall -shared -Wl,-soname,$(TARGET_NAME)$(SO_SUFFIX)
+else
+LFLAGS += -Wall -shared -Wl,-soname,$(TARGET_NAME)
+endif
+endif
 $(TARGET_OUTPUT): $(PREREQUISITES) $(OBJECTS)
 	$(CC) $(LFLAGS) $(OBJECTS) $(LIBS) -o $(TARGET_OUTPUT)
 endif
@@ -90,19 +98,19 @@ endif
 ifeq ($(STATIC), 1)
 $(TARGET_OUTPUT): $(PREREQUISITES) $(OBJECTS)
 	$(AR) -r $(TARGET_OUTPUT) $(OBJECTS)
-ifneq ($(USE_ARMCC), 1)
+ifneq ($(USE_ARMCC), 1)
 	$(RANLIB) $(TARGET_OUTPUT)
 endif
-endif
+endif
 
 $(PREREQUISITES): $(MAKEFILE_NAME)
 	@-mkdir -p $(OBJ_DIR)
 	@-touch $(PREREQUISITES)
 
 $(OBJ_DIR)/%.o: %.c $(PREREQUISITES)
-	@mkdir -p $(OBJ_DIR)
+	@mkdir -p $(OBJ_DIR)
 	$(CC) -c $(CFLAGS) -o $@ $<
 
 $(OBJ_DIR)/%.o: %.cpp $(PREREQUISITES)
-	@mkdir -p $(OBJ_DIR)
+	@mkdir -p $(OBJ_DIR)
 	$(CXX) -c $(CFLAGS) -o $@ $<
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/config b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/config
index d4f9ccb..22fda3c 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/config
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/config
@@ -22,3 +22,6 @@
 ARCH_TYPE	?= arm
 SDK_DIR		?= $(AQROOT)/build/sdk
 USE_3D_VG	= 1
+USE_PROFILER ?= 0
+USE_MRVL_PROFILER ?= 0
+    
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal.h
index cc37c3d..e9ce46f 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -33,9 +33,39 @@
 extern "C" {
 #endif
 
+/* the number of profiling nodes */
+#define NUM_PROFILE_NODES           100
+
+/* temporarily place gralloc defination here, should be moved to android header file later */
+#define GRALLOC_USAGE_GLES20_RENDER      0x10000000
+
+/* BSP idle profile Macros */
+#if ENABLE_BSP_IDLE_PROFILE
+/*
+dev_id:     1 vpu  0 gpu
+State:      1 run   0 idle
+Start:      2 init  1 start  0 stop
+*/
+#define BSP_IDLE_PROFILE(dev_id,state,start) \
+do { \
+    if(1) \
+        gcmkPRINT("--->%s\t\tstart_profile(0,%d,%d)\t%s\n", \
+        __FUNCTION__,state,start,(start==1)?(state?"busy-time":"\tidle-time"):"init"); \
+    start_profile(dev_id,state,start); \
+} while(0);
+#define BSP_IDLE_PROFILE_INIT                 BSP_IDLE_PROFILE(0, 0, 2)
+#define BSP_IDLE_PROFILE_CALC_BUSY_TIME       BSP_IDLE_PROFILE(0, 1, 1)
+#define BSP_IDLE_PROFILE_CALC_IDLE_TIME       BSP_IDLE_PROFILE(0, 0, 1)
+#else /* Disable bsp_idle_profile or OTHER PLATFORMs */
+#define BSP_IDLE_PROFILE_INIT
+#define BSP_IDLE_PROFILE_CALC_BUSY_TIME
+#define BSP_IDLE_PROFILE_CALC_IDLE_TIME
+#endif
+
 /******************************************************************************\
 ******************************* Alignment Macros *******************************
 \******************************************************************************/
+#define GC_NOP_COMMAND      0x18000000
 
 #define gcmALIGN(n, align) \
 ( \
@@ -74,6 +104,7 @@ typedef enum _gceOBJECT_TYPE
 	gcvOBJ_COMMAND				= gcmCC('C','M','D',' '),
 	gcvOBJ_COMMANDBUFFER		= gcmCC('C','M','D','B'),
 	gcvOBJ_CONTEXT				= gcmCC('C','T','X','T'),
+	gcvOBJ_CONTEXTBUFFER		= gcmCC('C','T','X','B'),
 	gcvOBJ_DEVICE				= gcmCC('D','E','V',' '),
 	gcvOBJ_DUMP					= gcmCC('D','U','M','P'),
 	gcvOBJ_EVENT				= gcmCC('E','V','N','T'),
@@ -120,6 +151,8 @@ typedef struct _gcsKERNEL_SETTINGS
 }
 gcsKERNEL_SETTINGS;
 
+typedef struct _gckHARDWARE *       gckHARDWARE;
+
 /*******************************************************************************
 **
 **	gcmVERIFY_OBJECT
@@ -174,6 +207,26 @@ gcsKERNEL_SETTINGS;
 
 typedef struct _gckOS			* gckOS;
 
+/*!
+*********************************************************************
+*   \struct _gckRecursiveMutex
+*   \brief
+*       Data structure for recursive lock.
+*********************************************************************
+*/
+typedef struct _gckRecursiveMutex *	gckRecursiveMutex;
+struct _gckRecursiveMutex
+{
+	/* Thread lock the mutex. */
+    gctINT32					pThread;
+	/* Lock times. */
+    gctUINT32                   nReference;
+	/* Access mutex. */
+	gctPOINTER					accMutex;
+	/* Underly mutex. */
+	gctPOINTER					undMutex;
+};
+
 /* Construct a new gckOS object. */
 gceSTATUS
 gckOS_Construct(
@@ -199,6 +252,10 @@ gckOS_QueryVideoMemory(
 	OUT gctSIZE_T * ContiguousSize
 	);
 
+/*Simulate allocate memory random fail */
+gctBOOL 
+gckOS_ForceMemAllocFail(gckOS Os);
+
 /* Allocate memory from the heap. */
 gceSTATUS
 gckOS_Allocate(
@@ -349,7 +406,7 @@ gceSTATUS
 gckOS_MapPhysical(
 	IN gckOS Os,
 	IN gctUINT32 Physical,
-	IN gctUINT32 OriginalLogical,
+	IN gctUINT32 OriginalLogical,	
 	IN gctSIZE_T Bytes,
 	OUT gctPOINTER * Logical
 	);
@@ -370,6 +427,14 @@ gckOS_ReadRegister(
 	OUT gctUINT32 * Data
 	);
 
+/* Read data from a register directly without mutex protection. */
+gceSTATUS 
+gckOS_DirectReadRegister(
+	IN gckOS Os,
+	IN gctUINT32 Address,
+	OUT gctUINT32 * Data
+	);
+
 /* Write data to a hardware register. */
 gceSTATUS
 gckOS_WriteRegister(
@@ -433,6 +498,35 @@ gckOS_ReleaseMutex(
 	IN gctPOINTER Mutex
 	);
 
+/* Create a new recursive mutex. */
+gceSTATUS
+gckOS_CreateRecMutex(
+	IN gckOS Os,
+	OUT gckRecursiveMutex *Mutex
+	);
+
+/* Delete a recursive mutex. */
+gceSTATUS
+gckOS_DeleteRecMutex(
+	IN gckOS Os,
+	IN gckRecursiveMutex Mutex
+	);
+
+/* Acquire a recursive mutex. */
+gceSTATUS
+gckOS_AcquireRecMutex(
+	IN gckOS Os,
+	IN gckRecursiveMutex Mutex,
+	IN gctUINT32 Timeout
+	);
+
+/* Release a recursive mutex. */
+gceSTATUS
+gckOS_ReleaseRecMutex(
+	IN gckOS Os,
+	IN gckRecursiveMutex Mutex
+	);
+
 /* Atomically exchange a pair of 32-bit values. */
 gceSTATUS
 gckOS_AtomicExchange(
@@ -451,6 +545,138 @@ gckOS_AtomicExchangePtr(
     OUT gctPOINTER * OldValue
 	);
 
+/* Update video memory usage. */
+gceSTATUS
+gckOS_UpdateVidMemUsage(
+	IN gckOS Os,
+    IN gctBOOL IsAllocated,
+	IN gctSIZE_T Bytes
+	);
+
+/*******************************************************************************
+**
+**  gckOS_AtomConstruct
+**
+**  Create an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**  OUTPUT:
+**
+**      gctPOINTER * Atom
+**          Pointer to a variable receiving the constructed atom.
+*/
+gceSTATUS
+gckOS_AtomConstruct(
+    IN gckOS Os,
+    OUT gctPOINTER * Atom
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomDestroy
+**
+**  Destroy an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom to destroy.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_AtomDestroy(
+    IN gckOS Os,
+    OUT gctPOINTER Atom
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomGet
+**
+**  Get the 32-bit value protected by an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the value of the atom.
+*/
+gceSTATUS
+gckOS_AtomGet(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomIncrement
+**
+**  Atomically increment the 32-bit integer value inside an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
+*/
+gceSTATUS
+gckOS_AtomIncrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomDecrement
+**
+**  Atomically decrement the 32-bit integer value inside an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
+*/
+gceSTATUS
+gckOS_AtomDecrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
 /* Delay a number of microseconds. */
 gceSTATUS
 gckOS_Delay(
@@ -458,6 +684,12 @@ gckOS_Delay(
 	IN gctUINT32 Delay
 	);
 
+/* Delay a number of microseconds. */
+gceSTATUS gckOS_Udelay(
+	IN gckOS Os,
+	IN gctUINT32 Delay
+	);
+
 /* Memory barrier. */
 gceSTATUS
 gckOS_MemoryBarrier(
@@ -485,20 +717,41 @@ gckOS_UnmapUserPointer(
 
 gceSTATUS
 gckOS_ClockOff(
-    void
+    IN gckOS Os,
+    IN gctBOOL disableClk,
+    IN gctBOOL disablePwr
 	);
 
 gceSTATUS
 gckOS_ClockOn(
+    IN gckOS Os,
+    IN gctBOOL enableClk,
+    IN gctBOOL enablePwr,
 	IN gctUINT64 Frequency
 	);
+	
+gceSTATUS
+gckOS_PowerOff(
+	IN gckOS Os
+	);
 
 gceSTATUS
-gckOS_Reset(
+gckOS_PowerOn(
 	IN gckOS Os
 	);
 
 gceSTATUS
+gckOS_PowerOffWhenIdle(
+	IN gckOS Os,
+	IN gctBOOL needProfile
+	);
+
+gceSTATUS
+gckOS_Reset(
+ 	IN gckOS Os
+ 	);
+
+gceSTATUS
 gckOS_SetConstraint(
 	IN gckOS Os,
 	IN gctBOOL enableDVFM,
@@ -518,7 +771,7 @@ gckOS_NotifyIdle(
 	IN gctBOOL Idle
 	);
 
-gctUINT32
+gctUINT32 
 gckOS_GetTicks(
     void
     );
@@ -527,7 +780,15 @@ gceSTATUS
 gckOS_IdleProfile(
     IN gckOS Os,
     IN OUT gctUINT32* Timeslice,
-    OUT gctUINT32* IdleTime
+    OUT gctUINT32* IdleTime,
+    OUT gctUINT32* StateSwitchTimes
+    );
+
+gceSTATUS gckOS_DumpToFile(
+    IN gckOS Os,
+    IN gctCONST_STRING filename,
+    IN gctPOINTER logical,
+    IN gctSIZE_T size
     );
 
 #ifdef __QNXNTO__
@@ -596,6 +857,48 @@ gckOS_DeviceControl(
 	IN gctSIZE_T OutputBufferSize
 	);
 
+gceSTATUS gckOS_FreeProcessResource(IN gckOS os, gctUINT32 pid);
+
+/*******************************************************************************
+**
+**  gckOS_GetProcessID
+**
+**  Get current process ID.
+**
+**  INPUT:
+**
+**      Nothing.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR ProcessID
+**          Pointer to the variable that receives the process ID.
+*/
+gceSTATUS
+gckOS_GetProcessID(
+    OUT gctUINT32_PTR ProcessID
+    );
+
+/*******************************************************************************
+**
+**  gckOS_GetThreadID
+**
+**  Get current thread ID.
+**
+**  INPUT:
+**
+**      Nothing.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR ThreadID
+**          Pointer to the variable that receives the thread ID.
+*/
+gceSTATUS
+gckOS_GetThreadID(
+    OUT gctUINT32_PTR ThreadID
+    );
+
 /******************************************************************************\
 ********************************** Signal Object *********************************
 \******************************************************************************/
@@ -641,6 +944,14 @@ gckOS_WaitSignal(
 	IN gctUINT32 Wait
 	);
 
+/* Wait for a signal. */
+gceSTATUS
+gckOS_WaitSignalNoInterruptible(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctUINT32 Wait
+	);
+
 /* Map a user signal to the kernel space. */
 gceSTATUS
 gckOS_MapSignal(
@@ -650,6 +961,13 @@ gckOS_MapSignal(
 	OUT gctSIGNAL * MappedSignal
 	);
 
+/* UnMap a user signal */
+gceSTATUS
+gckOS_UnMapSignal(
+	IN gckOS Os,
+	IN gctSIGNAL MappedSignal
+	);
+
 /* Map user memory. */
 gceSTATUS
 gckOS_MapUserMemory(
@@ -675,7 +993,7 @@ gceSTATUS
 gcoOS_FlushCache(
     int fd,
     int offset,
-    int size
+    int size 
     );
 #endif
 #if !USE_NEW_LINUX_SIGNAL
@@ -684,6 +1002,7 @@ gceSTATUS
 gckOS_CreateUserSignal(
 	IN gckOS Os,
 	IN gctBOOL ManualReset,
+	IN gceSIGNAL_TYPE SignalType,
 	OUT gctINT * SignalID
 	);
 
@@ -780,6 +1099,96 @@ gckOS_SetDebugFile(
 	IN gctCONST_STRING FileName
 	);
 
+/*******************************************************************************
+** Broadcast interface.
+*/
+
+typedef enum _gceBROADCAST
+{
+    /* GPU might be idle. */
+    gcvBROADCAST_GPU_IDLE,
+
+    /* A commit is going to happen. */
+    gcvBROADCAST_GPU_COMMIT,
+
+    /* GPU seems to be stuck. */
+    gcvBROADCAST_GPU_STUCK,
+
+    /* First process gets attached. */
+    gcvBROADCAST_FIRST_PROCESS,
+
+    /* Last process gets detached. */
+    gcvBROADCAST_LAST_PROCESS,
+
+    /* AXI bus error. */
+    gcvBROADCAST_AXI_BUS_ERROR,
+}
+gceBROADCAST;
+
+gceSTATUS
+gckOS_Broadcast(
+    IN gckOS Os,
+    IN gckHARDWARE Hardware,
+    IN gceBROADCAST Reason
+    );
+
+/*******************************************************************************
+**
+**  gckOS_SetGPUPower
+**
+**  Set the power of the GPU on or off.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.?
+**
+**      gctBOOL Power
+**          gcvTRUE to turn on the power, or gcvFALSE to turn off the power.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_SetGPUPower(
+    IN gckOS Os,
+    IN gctBOOL Clock,
+    IN gctBOOL Power
+    );
+
+/*******************************************************************************
+** Semaphores.
+*/
+
+/* Create a new semaphore. */
+gceSTATUS
+gckOS_CreateSemaphore(
+    IN gckOS Os,
+    OUT gctPOINTER * Semaphore
+    );
+
+/* Delete a semahore. */
+gceSTATUS
+gckOS_DestroySemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/* Acquire a semahore. */
+gceSTATUS
+gckOS_AcquireSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/* Release a semahore. */
+gceSTATUS
+gckOS_ReleaseSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
 /******************************************************************************\
 ********************************* gckHEAP Object ********************************
 \******************************************************************************/
@@ -842,7 +1251,6 @@ gckHEAP_Test(
 
 typedef struct _gckVIDMEM *			gckVIDMEM;
 typedef union  _gcuVIDMEM_NODE *	gcuVIDMEM_NODE_PTR;
-typedef struct _gckHARDWARE *		gckHARDWARE;
 typedef struct _gckKERNEL *			gckKERNEL;
 
 /* Construct a new gckVIDMEM object. */
@@ -970,6 +1378,10 @@ typedef enum _gceKERNEL_FLUSH
 	gcvFLUSH_DEPTH				= 0x02,
 	gcvFLUSH_TEXTURE			= 0x04,
 	gcvFLUSH_2D					= 0x08,
+    gcvFLUSH_ALL                = gcvFLUSH_COLOR
+                                | gcvFLUSH_DEPTH
+                                | gcvFLUSH_TEXTURE
+                                | gcvFLUSH_2D,
 }
 gceKERNEL_FLUSH;
 
@@ -1066,6 +1478,26 @@ gckKERNEL_QuerySettings(
 	OUT gcsKERNEL_SETTINGS * Settings
 	);
 
+/*******************************************************************************
+**
+**  gckKERNEL_Recovery
+**
+**  Try to recover the GPU from a fatal error.
+**
+**  INPUT:
+**
+**      gckKERNEL Kernel
+**          Pointer to an gckKERNEL object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckKERNEL_Recovery(
+    IN gckKERNEL Kernel
+    );
+
 /******************************************************************************\
 ******************************* gckHARDWARE Object *****************************
 \******************************************************************************/
@@ -1444,8 +1876,7 @@ gceSTATUS
 gckEVENT_Signal(
 	IN gckEVENT Event,
 	IN gctSIGNAL Signal,
-	IN gceKERNEL_WHERE FromWhere,
-	IN gctBOOL Locking
+	IN gceKERNEL_WHERE FromWhere
 	);
 
 /* Schedule an Unlock event. */
@@ -1460,8 +1891,7 @@ gckEVENT_Unlock(
 gceSTATUS
 gckEVENT_Submit(
 	IN gckEVENT Event,
-	IN gctBOOL Wait,
-	IN gctBOOL Locking
+	IN gctBOOL Wait
 	);
 
 struct _gcsQUEUE;
@@ -1480,6 +1910,7 @@ gckEVENT_Notify(
 	IN gctBOOL IsReset
 	);
 
+
 /* Event callback routine. */
 gceSTATUS
 gckEVENT_Interrupt(
@@ -1537,7 +1968,6 @@ gceSTATUS
 gckCOMMAND_Reserve(
 	IN gckCOMMAND Command,
 	IN gctSIZE_T RequestedBytes,
-	IN gctBOOL Locking,
 	OUT gctPOINTER * Buffer,
 	OUT gctSIZE_T * BufferSize
 	);
@@ -1552,8 +1982,7 @@ gckCOMMAND_Release(
 gceSTATUS
 gckCOMMAND_Execute(
 	IN gckCOMMAND Command,
-	IN gctSIZE_T RequstedBytes,
-	IN gctBOOL Locking
+	IN gctSIZE_T RequstedBytes
 	);
 
 /* Stall the command queue. */
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_base.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_base.h
index 608962c..df39e8e 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_base.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_base.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -137,6 +137,33 @@ typedef enum _gceHOW
 }
 gceHOW;
 
+typedef enum _gceSIGNAL_TYPE
+{
+    gcvSIGNAL_NOPE              = 0x0,
+    gcvSIGNAL_CONTEXT_GCU       = 0x1,
+    gcvSIGNAL_CONTEXT           = 0x2,
+    gcvSIGNAL_FENCE_GCU         = 0x3,
+    gcvSIGNAL_FENCE             = 0x4,
+    gcvSIGNAL_DISPLAY_START     = 0x5,
+    gcvSIGNAL_DISPLAY_STOP      = 0x6,
+    gcvSIGNAL_WORKER_THREAD     = 0x7,
+    gcvSIGNAL_SYNC              = 0x8,
+    gcvSIGNAL_SURFACE           = 0x9,
+    gcvSIGNAL_TEXTURE           = 0x10,
+    gcvSIGNAL_STREAM            = 0x11,
+    gcvSIGNAL_INDEX_GROUP       = 0x12,
+    gcvSIGNAL_RESERVE_MEM_GROUP = 0x13,
+    gcvSIGNAL_CMD_BUFFER        = 0x14,
+    gcvSIGNAL_CONTEXT_BUFFER    = 0x15,
+    gcvSIGNAL_INDEX_DYNAMIC     = 0x16,
+    gcvSIGNAL_STREAM_DYNAMIC    = 0x17,
+    gcvSIGNAL_STALL             = 0x18,
+    gcvSIGNAL_RESERVED
+}
+gceSIGNAL_TYPE;
+
+#define gcmSIGNAL_OFFSET        16
+
 /******************************************************************************\
 ********************************* gcoHAL Object *********************************
 \******************************************************************************/
@@ -249,14 +276,6 @@ gcoHAL_Commit(
     IN gctBOOL Stall
     );
 
-gceSTATUS
-gcoHAL_Commit2(
-    IN gcoHAL Hal,
-    IN gctBOOL Stall,
-    IN gctPOINTER Buffer,
-    IN gctUINT32 Size
-    );
-
 /* Query the tile capabilities. */
 gceSTATUS
 gcoHAL_QueryTiled(
@@ -326,9 +345,9 @@ gcoHAL_ScheduleEvent(
 /* Destroy a surface. */
 gceSTATUS
 gcoHAL_DestroySurface(
-	IN gcoHAL Hal,
-	IN gcoSURF Surface
-	);
+    IN gcoHAL Hal,
+    IN gcoSURF Surface
+    );
 
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
@@ -687,7 +706,7 @@ gcoOS_SetProfileSetting(
         IN gctBOOL Enable,
         IN gctCONST_STRING FileName
     );
-gctINT32
+gctINT32 
 gcoOS_GetMilliTime(
     void
     );
@@ -709,7 +728,7 @@ gcoOS_SetProfileSetting(
 */
 typedef enum _apiBenchIndex  {
 	APIBENCH_INDEX_FRAME,
-    APIBENCH_INDEX_DRAWARRAY,
+    APIBENCH_INDEX_DRAWARRAY,    
 	APIBENCH_INDEX_DRAWELEMENTS,
 	APIBENCH_INDEX_BUILDSTREAM,
 	APIBENCH_INDEX_INDEXBUFFER,
@@ -719,8 +738,8 @@ typedef enum _apiBenchIndex  {
     APIBENCH_INDEX_UPDATESTATE1,
 	APIBENCH_INDEX_SWAPBUFFERS,
 	APIBENCH_INDEX_DRAWIMAGE,
-	APIBENCH_INDEX_SWTEXTUREUPLOAD,
-	APIBENCH_INDEX_DIRECTTEXTURE,
+	APIBENCH_INDEX_SWTEXTUREUPLOAD,	
+	APIBENCH_INDEX_DIRECTTEXTURE,	
 	APIBENCH_INDEX_GLEGLIMAGETEXTURE,
 	APIBENCH_INDEX_DRAWTEX,
 	APIBENCH_INDEX_BUFFERDATA,
@@ -771,7 +790,7 @@ typedef struct _gcoTIMER
 	gctUINT32				start;
 	gctUINT32				end;
 	gctUINT32				totalTime;
-	gctUINT32				count;
+	gctUINT32				count;	
 }gcoTIMER;
 
  /*  global structure for api bench */
@@ -973,6 +992,7 @@ gceSTATUS
 gcoOS_CreateSignal(
     IN gcoOS Os,
     IN gctBOOL ManualReset,
+    IN gceSIGNAL_TYPE SignalType,
     OUT gctSIGNAL * Signal
     );
 
@@ -1415,6 +1435,12 @@ gcoSURF_ComputeColorMask(
     OUT gctUINT32_PTR ColorMask
     );
 
+/* Check the surface is renderable or not. */
+gceSTATUS
+gcoSURF_IsRenderable(
+	IN 	gcoSURF Surface
+	);
+
 /* Flush the surface. */
 gceSTATUS
 gcoSURF_Flush(
@@ -1476,6 +1502,13 @@ gcoSURF_ReferenceSurface(
     IN gcoSURF Surface
     );
 
+/* Decrease reference count of the surface. */
+gceSTATUS
+gcoSURF_DereferenceSurface(
+    IN gcoSURF Surface
+    );
+
+
 /* Get surface reference count. */
 gceSTATUS
 gcoSURF_QueryReferenceCount(
@@ -1490,6 +1523,13 @@ gcoSURF_SetOrientation(
     IN gceORIENTATION Orientation
     );
 
+/* Set surface resolve offset */
+gceSTATUS
+gcoSURF_SetFace(
+    IN gcoSURF Surface,
+    IN gctUINT  Face
+    );
+
 /* Query surface orientation. */
 gceSTATUS
 gcoSURF_QueryOrientation(
@@ -1504,7 +1544,6 @@ int gcoOS_DumpBMP(
                   IN gctINT dumpWidth,
                   IN gctINT dumpHeight,
                   IN gctINT dumpStride,
-                  IN gctINT dumpBpp,
                   IN gceSURF_FORMAT format,
                   IN gceORIENTATION orientation,
                   IN gctCONST_STRING fileName
@@ -1514,12 +1553,11 @@ int gcoOS_DumpBMP(
 /* Dump surface to a BMP file. */
 gceSTATUS
 gcoSURF_DumpSurface(
-	IN gcoSURF Surface,
+	IN gcoSURF Surface, 
 	IN gctBOOL bCheckOrientation,
 	IN gctCONST_STRING fileName
 	);
 
-
 /******************************************************************************\
 ********************************* gcoDUMP Object ********************************
 \******************************************************************************/
@@ -2059,14 +2097,13 @@ gckOS_Print(
 **
 **      ...         Optional arguments.
 */
-
 #if gcdDUMP
-gceSTATUS
-gcfDump(
-    IN gcoOS Os,
-    IN gctCONST_STRING String,
-    ...
-    );
+    gceSTATUS
+    gcfDump(
+        IN gcoOS Os,
+        IN gctCONST_STRING String,
+        ...
+        );
 #  define gcmDUMP               gcfDump
 #elif gcdHAS_ELLIPSES
 #  define gcmDUMP(...)
@@ -2101,13 +2138,13 @@ gcfDump(
 */
 
 #if gcdDUMP
-geSTATUS
-gcfDumpData(
-    IN gcoOS Os,
-    IN gctSTRING Tag,
-    IN gctPOINTER Logical,
-    IN gctSIZE_T Bytes
-    );
+    gceSTATUS
+    gcfDumpData(
+        IN gcoOS Os,
+        IN gctSTRING Tag,
+        IN gctPOINTER Logical,
+        IN gctSIZE_T Bytes
+        );
 #  define gcmDUMP_DATA          gcfDumpData
 #elif gcdHAS_ELLIPSES
 #  define gcmDUMP_DATA(...)
@@ -2149,7 +2186,8 @@ gcfDumpData(
 */
 
 #if gcdDUMP
-void gcfDumpBuffer(
+gceSTATUS
+gcfDumpBuffer(
     IN gcoOS Os,
     IN gctSTRING Tag,
     IN gctUINT32 Physical,
@@ -2177,6 +2215,100 @@ void gcfDumpBuffer(
 
 /*******************************************************************************
 **
+**  gcmDUMP_API
+**
+**      Print a dump message for a high level API prefixed by the function name.
+**
+**  ARGUMENTS:
+**
+**      gctSTRING   Message.
+**
+**      ...         Optional arguments.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpApi(
+        IN gctCONST_STRING String,
+        ...
+        );
+#   define gcmDUMP_API           gcfDumpApi
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api(
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+#  define gcmDUMP_API           __dummy_dump_api
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API_ARRAY
+**
+**      Print an array of data.
+**
+**  ARGUMENTS:
+**
+**      gctUINT32_PTR   Pointer to array.
+**      gctUINT32       Size.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpArray(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Size
+    );
+#   define gcmDUMP_API_ARRAY        gcfDumpArray
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API_ARRAY(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api_array(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Size
+        )
+    {
+    }
+#   define gcmDUMP_API_ARRAY        __dummy_dump_api_array
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API_ARRAY_TOKEN
+**
+**      Print an array of data terminated by a token.
+**
+**  ARGUMENTS:
+**
+**      gctUINT32_PTR   Pointer to array.
+**      gctUINT32       Termination.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpArrayToken(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Termination
+    );
+#   define gcmDUMP_API_ARRAY_TOKEN  gcfDumpArrayToken
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API_ARRAY_TOKEN(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api_array_token(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Termination
+        )
+    {
+    }
+#   define gcmDUMP_API_ARRAY_TOKEN  __dummy_dump_api_array_token
+#endif
+
+/*******************************************************************************
+**
 **  gcmTRACE_RELEASE
 **
 **      Print a message to the shader debugger.
@@ -2327,8 +2459,9 @@ gckOS_Verify(
         } \
         while (gcvFALSE)
 #else
-#   define gcmVERIFY_OK(func)       func
-#   define gcmkVERIFY_OK(func)      func
+#   define gcmVERIFY_OK(func) func
+
+#   define gcmkVERIFY_OK(func) func
 #endif
 
 /*******************************************************************************
@@ -2405,9 +2538,9 @@ gckOS_Verify(
         status = func; \
         if (gcmIS_ERROR(status)) \
         { \
-            prefix##TRACE(gcvLEVEL_ERROR, \
-                #prefix "ONERROR: status=%d @ %s(%d) in " __FILE__, \
-                status, __FUNCTION__, __LINE__); \
+            prefix##LOG(_GFX_LOG_ERROR_, \
+                "[GC_" #prefix "ONERROR\t] %s(%d): status=%d", \
+                __FUNCTION__, __LINE__, status); \
             goto OnError; \
         } \
     } \
@@ -2415,6 +2548,7 @@ gckOS_Verify(
 #define gcmONERROR(func)            _gcmONERROR(gcm, func)
 #define gcmkONERROR(func)           _gcmONERROR(gcmk, func)
 
+
 /*******************************************************************************
 **
 **  gcmVERIFY_LOCK
@@ -2563,32 +2697,81 @@ gckOS_Verify(
        } \
        while (gcvFALSE)
 #   define gcmVERIFY_ARGUMENT_RETURN(arg, value) \
-				_gcmVERIFY_ARGUMENT_RETURN(gcm, arg, value)
+                _gcmVERIFY_ARGUMENT_RETURN(gcm, arg, value)
 #   define gcmkVERIFY_ARGUMENT_RETURN(arg, value) \
-				_gcmVERIFY_ARGUMENT_RETURN(gcmk, arg, value)
+                _gcmVERIFY_ARGUMENT_RETURN(gcmk, arg, value)
 #else
 #   define gcmVERIFY_ARGUMENT_RETURN(arg, value)
 #   define gcmkVERIFY_ARGUMENT_RETURN(arg, value)
 #endif
-void gcoOS_Log(IN unsigned int filter, IN char* msg,
+void gcoOS_Log(IN unsigned int filter, IN const char* msg, 
 			...
 			);
 
-void gckOS_Log(IN unsigned int filter, IN char* msg,
+void gckOS_Log(IN unsigned int filter, IN const char* msg, 
 			...
 			);
 
 void gcoOS_SetLogFilter(IN unsigned int filter);
 
+void gckOS_SetLogFilter(IN unsigned int filter);
+
+#define gcmLOG                  gcoOS_Log
+#define gcmkLOG                 gckOS_Log
+
+#define _gcmLOG_STATUS(prefix, tag, filter) \
+    do \
+    { \
+        prefix##LOG(filter, \
+            "[GC_" #tag "\t] %s@%d: status=%d\n", \
+            __FUNCTION__, __LINE__, status); \
+    } \
+    while (gcvFALSE)
+
+#define gcmLOG_WARNING_STATUS()         _gcmLOG_STATUS(gcm, WARNING, _GFX_LOG_WARNING_)
+#define gcmLOG_ERROR_STATUS()           _gcmLOG_STATUS(gcm, ERR_RETURN, _GFX_LOG_ERROR_)
+
+#define gcmkLOG_WARNING_STATUS()        _gcmLOG_STATUS(gcmk, WARNING, _GFX_LOG_WARNING_)
+#define gcmkLOG_ERROR_STATUS()          _gcmLOG_STATUS(gcmk, ERR_RETURN, _GFX_LOG_ERROR_)
+
+#if gcdHAS_ELLIPSES
+#define _gcmLOG_ARGS(prefix, tag, filter, TEXT, ...) \
+    do \
+    { \
+        prefix##LOG(filter, \
+            "[GC_" #tag "\t] %s@%d: " TEXT "\n", \
+            __FUNCTION__, __LINE__, ##__VA_ARGS__); \
+    } \
+    while (gcvFALSE)
+
+#define gcmLOG_WARNING_ARGS(TEXT, ...)   _gcmLOG_ARGS(gcm, WARNING, _GFX_LOG_WARNING_, TEXT, ##__VA_ARGS__)
+#define gcmLOG_ERROR_ARGS(TEXT, ...)     _gcmLOG_ARGS(gcm, ERR_RETURN, _GFX_LOG_ERROR_, TEXT, ##__VA_ARGS__)
+
+#define gcmkLOG_WARNING_ARGS(TEXT, ...)  _gcmLOG_ARGS(gcmk, WARNING, _GFX_LOG_WARNING_, TEXT, ##__VA_ARGS__)
+#define gcmkLOG_ERROR_ARGS(TEXT, ...)    _gcmLOG_ARGS(gcmk, ERR_RETURN, _GFX_LOG_ERROR_, TEXT, ##__VA_ARGS__)
+#else
+     gcmINLINE static void
+     __dummy_log_args(
+         IN gctCONST_STRING Text,
+         ...
+         )
+     {
+     }
+#define gcmLOG_WARNING_ARGS             __dummy_log_args
+#define gcmLOG_ERROR_ARGS               __dummy_log_args
+#define gcmkLOG_WARNING_ARGS            __dummy_log_args
+#define gcmkLOG_ERROR_ARGS              __dummy_log_args
+#endif
 
  /*  Logging service  */
+#define _GFX_LOG_NONE_          0x00000000
 #define _GFX_LOG_ERROR_         0x00000001
 #define _GFX_LOG_WARNING_       0x00000002
 #define _GFX_LOG_EGL_API_       0x00000004
 #define _GFX_LOG_NATIVE_API_    0x00000008
 #define _GFX_LOG_OES_API_       0x00000010
 #define _GFX_LOG_VG_API_        0x00000020
-#define _GFX_LOG_CONFIG_        0x00000040
+#define _GFX_LOG_CONFIG_        0x00000040  
 #define _GFX_LOG_INFO_          0x00000080
 #define _GFX_LOG_NOTIFY_        0x00000100
 #define _GFX_LOG_ALL_           0xffffffff
@@ -2607,21 +2790,21 @@ void gcoOS_SetLogFilter(IN unsigned int filter);
 #else
 #define OES11_API_LOG(x)
 #endif
-#define OES11_LOG(x)            gcoOS_Log x
+#define OES11_LOG(x)            gcoOS_Log x                   
 
 #if MRVL_ENABLE_OES2_API_LOG
 #define OES20_API_LOG(x)		gcoOS_Log x
 #else
 #define OES20_API_LOG(x)
 #endif
-#define OES20_LOG               gcoOS_Log x
+#define OES20_LOG(x)            gcoOS_Log x
 
 #if MRVL_ENABLE_OVG_API_LOG
 #define OVG_API_LOG(x)		    gcoOS_Log x
 #else
 #define OVG_API_LOG(x)
 #endif
-#define OVG_LOG(x)              gcoOS_Log x
+#define OVG_LOG(x)              gcoOS_Log x               
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_compiler.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_compiler.h
index 0160155..6bc96b2 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_compiler.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_compiler.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_driver.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_driver.h
index 1a58506..bd60d95 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_driver.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_driver.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -97,7 +97,7 @@ typedef enum _gceHAL_COMMAND_CODES
 
     gcvHAL_GET_BASE_ADDRESS,
 
-    gcvHAL_SET_IDLE,
+    gcvHAL_SET_IDLE, /* reserved */
 
     /* Queries. */
     gcvHAL_QUERY_KERNEL_SETTINGS,
@@ -113,6 +113,9 @@ typedef enum _gceHAL_COMMAND_CODES
 
     /* Cache stuff. */
     gcvHAL_CACHE,
+
+    gcvHAL_GC_OFF,
+    gcvHAL_GC_ON
 }
 gceHAL_COMMAND_CODES;
 
@@ -426,6 +429,9 @@ typedef struct _gcsHAL_INTERFACE
             /* Reset mode. */
             IN gctBOOL                  manualReset;
 
+            /* Signal ID. */
+            IN gceSIGNAL_TYPE           signalType;
+
             /* Wait timedout. */
             IN gctUINT32                wait;
 
@@ -449,7 +455,7 @@ typedef struct _gcsHAL_INTERFACE
 
 #if defined(__QNXNTO__)
             /* Client pulse side-channel connection ID. Set by client in gcoOS_CreateSignal. */
-            IN gctINT32     			coid;
+            IN gctINT32                 coid;
 
             /* Set by server. */
             IN gctINT32                 rcvid;
@@ -459,11 +465,11 @@ typedef struct _gcsHAL_INTERFACE
         }
         Signal;
 
-		/* gcvHAL_WRITE_DATA. */
-		struct _gcsHAL_WRITE_DATA
-		{
-			/* Address to write data to. */
-			IN gctUINT32				address;
+        /* gcvHAL_WRITE_DATA. */
+        struct _gcsHAL_WRITE_DATA
+        {
+            /* Address to write data to. */
+            IN gctUINT32                address;
 
 			IN  gctPOINTER			kernelAddress;
             /* Data to write. */
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_dump.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_dump.h
index 0975c5e..2264b60 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_dump.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_dump.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_engine.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_engine.h
index 45b386d..3fc88f7 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_engine.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_engine.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -432,6 +432,18 @@ gcoINDEX_GetIndexRange(
 	OUT gctUINT32 * MinimumIndex,
 	OUT gctUINT32 * MaximumIndex
 	);
+/* Convert Index32 to Index16*/
+gceSTATUS
+gcoINDEX_CovertFrom32To16(
+	IN gcoINDEX Index,
+    OUT gcoINDEX* Index16
+	);
+/* Convert Index32 to Index16*/
+gceSTATUS
+gcoINDEX_CovertFrom32To16(
+	IN gcoINDEX Index,
+    OUT gcoINDEX* Index16
+	);
 
 /* Dynamic buffer management. */
 gceSTATUS
@@ -992,6 +1004,15 @@ gco3D_SetCentroids(
 	IN gctUINT32	Index,
 	IN gctPOINTER	Centroids
 	);
+
+/*Get 3D engine status*/
+gceSTATUS
+gco3D_Get3DStatus(
+	IN 	gco3D Engine,
+	OUT gctBOOL_PTR*   Idle,
+	OUT gctINT_PTR     Count,
+	OUT gctINT_PTR	  CurrentCmdIndex
+	);
 /*----------------------------------------------------------------------------*/
 /*-------------------------- gco3D Fragment Processor ------------------------*/
 
@@ -1165,6 +1186,22 @@ gcoTEXTURE_Destroy(
 	IN gcoTEXTURE Texture
 	);
 
+/*Destroy a texture level*/
+gceSTATUS
+gcoTEXTURE_DestroyLevel(
+	IN gcoTEXTURE Texture,
+	IN gctINT         Level
+	);
+
+/*check texture surface can be reuse*/
+gctBOOL gcoTEXTURE_BConsistent(
+	IN gcoTEXTURE Texture,
+	IN gctINT Level,
+	IN gctSIZE_T Width,
+	IN gctSIZE_T Height,
+	IN gceSURF_FORMAT Format
+	);
+
 /* Upload data to an gcoTEXTURE object. */
 gceSTATUS
 gcoTEXTURE_Upload(
@@ -1180,6 +1217,19 @@ gcoTEXTURE_Upload(
 
 /* Upload data to an gcoTEXTURE object. */
 gceSTATUS
+gcoTEXTURE_Upload_Linear(
+	IN gcoTEXTURE Texture,
+	IN gceTEXTURE_FACE Face,
+	IN gctUINT Width,
+	IN gctUINT Height,
+	IN gctUINT Slice,
+	IN gctCONST_POINTER Memory,
+	IN gctINT Stride,
+	IN gceSURF_FORMAT Format
+	);
+
+/* Upload data to an gcoTEXTURE object. */
+gceSTATUS
 gcoTEXTURE_UploadSub(
 	IN gcoTEXTURE Texture,
 	IN gctUINT MipMap,
@@ -1194,6 +1244,22 @@ gcoTEXTURE_UploadSub(
 	IN gceSURF_FORMAT Format
 	);
 
+gceSTATUS
+gcoTEXTURE_UploadSub_Linear(
+	IN gcoTEXTURE Texture,
+	IN gctUINT MipMap,
+	IN gceTEXTURE_FACE Face,
+	IN gctUINT X,
+	IN gctUINT Y,
+	IN gctUINT Width,
+	IN gctUINT Height,
+	IN gctUINT Slice,
+	IN gctCONST_POINTER Memory,
+	IN gctINT Stride,
+	IN gceSURF_FORMAT Format
+	);
+
+
 /* Upload compressed data to an gcoTEXTURE object. */
 gceSTATUS
 gcoTEXTURE_UploadCompressed(
@@ -1291,6 +1357,11 @@ gcoTEXTURE_SetBorderColorF(
 	IN gctFLOAT Alpha
 	);
 
+gctBOOL
+gcoTEXTURE_IsSupportMipMap(
+	IN gcoTEXTURE Texture
+	);
+
 gceSTATUS
 gcoTEXTURE_SetMinFilter(
 	IN gcoTEXTURE Texture,
@@ -1348,7 +1419,8 @@ gcoTEXTURE_SetLODMaxF(
 gceSTATUS
 gcoTEXTURE_Bind(
 	IN gcoTEXTURE Texture,
-	IN gctINT Sampler
+	IN gctINT Sampler,
+	IN gctUINT Param
 	);
 
 gceSTATUS
@@ -1479,9 +1551,15 @@ gcoSTREAM_DestroyReserveMemory(
     IN gcoHAL Hal);
 
 gceSTATUS
-gcoSTREAM_GetReserveMemory(
+gcoSTREAM_GetReserveMemIndexOffset(
     IN gcoHAL Hal,
-    IN gctUINT32 requestSize,
+    OUT gctUINT32 * reserveMemoryIndex,
+    OUT gctUINT32 * reserveMemoryOffset);
+
+gceSTATUS
+gcoSTREAM_GetReserveMemory(
+    IN gcoHAL Hal, 
+    IN gctUINT32 requestSize, 
     IN gcoSTREAM stream,
     IN gcoINDEX index
     );
@@ -1512,6 +1590,8 @@ typedef struct _gcsSTREAM_INFO
 	gctSIZE_T			size;
 	gctCONST_POINTER	data;
 	gctUINT				stride;
+    gctUINT             offset;
+    gcoSTREAM           stream;
 }
 gcsSTREAM_INFO, * gcsSTREAM_INFO_PTR;
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_enum.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_enum.h
index 1510e72..d0361af 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_enum.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_enum.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -31,256 +31,263 @@ extern "C" {
 /* Chip models. */
 typedef enum _gceCHIPMODEL
 {
-	gcv300  = 0x0300,
-	gcv400  = 0x0400,
-	gcv410  = 0x0410,
-	gcv450  = 0x0450,
-	gcv500  = 0x0500,
-	gcv530  = 0x0530,
-	gcv600  = 0x0600,
-	gcv700  = 0x0700,
-	gcv800  = 0x0800,
-	gcv860  = 0x0860,
-	gcv1000 = 0x1000,
+    gcv300  = 0x0300,
+    gcv400  = 0x0400,
+    gcv410  = 0x0410,
+    gcv450  = 0x0450,
+    gcv500  = 0x0500,
+    gcv530  = 0x0530,
+    gcv600  = 0x0600,
+    gcv700  = 0x0700,
+    gcv800  = 0x0800,
+    gcv860  = 0x0860,
+    gcv1000 = 0x1000,
 }
 gceCHIPMODEL;
 
 /* Chip features. */
 typedef enum _gceFEATURE
 {
-	gcvFEATURE_PIPE_2D,
-	gcvFEATURE_PIPE_3D,
-	gcvFEATURE_PIPE_VG,
-	gcvFEATURE_DC,
-	gcvFEATURE_HIGH_DYNAMIC_RANGE,
-	gcvFEATURE_MODULE_CG,
-	gcvFEATURE_MIN_AREA,
-	gcvFEATURE_BUFFER_INTERLEAVING,
-	gcvFEATURE_BYTE_WRITE_2D,
-	gcvFEATURE_ENDIANNESS_CONFIG,
-	gcvFEATURE_DUAL_RETURN_BUS,
-	gcvFEATURE_DEBUG_MODE,
-	gcvFEATURE_YUY2_RENDER_TARGET,
-	gcvFEATURE_FRAGMENT_PROCESSOR,
-	gcvFEATURE_2DPE20,
-	gcvFEATURE_FAST_CLEAR,
-	gcvFEATURE_YUV420_TILER,
-	gcvFEATURE_YUY2_AVERAGING,
-	gcvFEATURE_FLIP_Y,
-	gcvFEATURE_EARLY_Z,
-	gcvFEATURE_Z_COMPRESSION,
-	gcvFEATURE_MSAA,
-	gcvFEATURE_SPECIAL_ANTI_ALIASING,
-	gcvFEATURE_SPECIAL_MSAA_LOD,
-	gcvFEATURE_422_TEXTURE_COMPRESSION,
-	gcvFEATURE_DXT_TEXTURE_COMPRESSION,
-	gcvFEATURE_ETC1_TEXTURE_COMPRESSION,
-	gcvFEATURE_CORRECT_TEXTURE_CONVERTER,
-	gcvFEATURE_TEXTURE_8K,
-	gcvFEATURE_SCALER,
-	gcvFEATURE_YUV420_SCALER,
-	gcvFEATURE_SHADER_HAS_W,
-	gcvFEATURE_SHADER_HAS_SIGN,
-	gcvFEATURE_SHADER_HAS_FLOOR,
-	gcvFEATURE_SHADER_HAS_CEIL,
-	gcvFEATURE_SHADER_HAS_SQRT,
-	gcvFEATURE_SHADER_HAS_TRIG,
-	gcvFEATURE_VAA,
-	gcvFEATURE_HZ,
-	gcvFEATURE_CORRECT_STENCIL,
-	gcvFEATURE_VG20,
-	gcvFEATURE_VG_FILTER,
-	gcvFEATURE_VG21,
-	gcvFEATURE_VG_DOUBLE_BUFFER,
-	gcvFEATURE_MC20,
+    gcvFEATURE_PIPE_2D,
+    gcvFEATURE_PIPE_3D,
+    gcvFEATURE_PIPE_VG,
+    gcvFEATURE_DC,
+    gcvFEATURE_HIGH_DYNAMIC_RANGE,
+    gcvFEATURE_MODULE_CG,
+    gcvFEATURE_MIN_AREA,
+    gcvFEATURE_BUFFER_INTERLEAVING,
+    gcvFEATURE_BYTE_WRITE_2D,
+    gcvFEATURE_ENDIANNESS_CONFIG,
+    gcvFEATURE_DUAL_RETURN_BUS,
+    gcvFEATURE_DEBUG_MODE,
+    gcvFEATURE_YUY2_RENDER_TARGET,
+    gcvFEATURE_FRAGMENT_PROCESSOR,
+    gcvFEATURE_2DPE20,
+    gcvFEATURE_FAST_CLEAR,
+    gcvFEATURE_YUV420_TILER,
+    gcvFEATURE_YUY2_AVERAGING,
+    gcvFEATURE_FLIP_Y,
+    gcvFEATURE_EARLY_Z,
+    gcvFEATURE_Z_COMPRESSION,
+    gcvFEATURE_MSAA,
+    gcvFEATURE_SPECIAL_ANTI_ALIASING,
+    gcvFEATURE_SPECIAL_MSAA_LOD,
+    gcvFEATURE_422_TEXTURE_COMPRESSION,
+    gcvFEATURE_DXT_TEXTURE_COMPRESSION,
+    gcvFEATURE_ETC1_TEXTURE_COMPRESSION,
+    gcvFEATURE_CORRECT_TEXTURE_CONVERTER,
+    gcvFEATURE_TEXTURE_8K,
+    gcvFEATURE_SCALER,
+    gcvFEATURE_YUV420_SCALER,
+    gcvFEATURE_SHADER_HAS_W,
+    gcvFEATURE_SHADER_HAS_SIGN,
+    gcvFEATURE_SHADER_HAS_FLOOR,
+    gcvFEATURE_SHADER_HAS_CEIL,
+    gcvFEATURE_SHADER_HAS_SQRT,
+    gcvFEATURE_SHADER_HAS_TRIG,
+    gcvFEATURE_VAA,
+    gcvFEATURE_HZ,
+    gcvFEATURE_CORRECT_STENCIL,
+    gcvFEATURE_VG20,
+    gcvFEATURE_VG_FILTER,
+    gcvFEATURE_VG21,
+    gcvFEATURE_VG_DOUBLE_BUFFER,
+    gcvFEATURE_MC20,
+    gcvFEATURE_SUPER_TILED,
 }
 gceFEATURE;
 
 /* Chip Power Status. */
 typedef enum _gceCHIPPOWERSTATE
 {
-	gcvPOWER_ON,
-	gcvPOWER_OFF,
-	gcvPOWER_IDLE,
-	gcvPOWER_SUSPEND,
+    gcvPOWER_ON,
+    gcvPOWER_OFF,
+    gcvPOWER_IDLE,
+    gcvPOWER_SUSPEND,
+    gcvPOWER_SUSPEND_ATPOWERON,
+    gcvPOWER_OFF_ATPOWERON,
+    gcvPOWER_IDLE_BROADCAST,
+    gcvPOWER_SUSPEND_BROADCAST,
+    gcvPOWER_OFF_BROADCAST,
+    gcvPOWER_OFF_RECOVERY,
 }
 gceCHIPPOWERSTATE;
 
 /* Surface types. */
 typedef enum _gceSURF_TYPE
 {
-	gcvSURF_TYPE_UNKNOWN,
-	gcvSURF_INDEX,
-	gcvSURF_VERTEX,
-	gcvSURF_TEXTURE,
-	gcvSURF_RENDER_TARGET,
-	gcvSURF_DEPTH,
-	gcvSURF_BITMAP,
-	gcvSURF_TILE_STATUS,
-	gcvSURF_MASK,
-	gcvSURF_SCISSOR,
-	gcvSURF_HIERARCHICAL_DEPTH,
-	gcvSURF_NUM_TYPES, /* Make sure this is the last one! */
-
-	/* Combinations. */
-	gcvSURF_NO_TILE_STATUS = 0x100,
-	gcvSURF_RENDER_TARGET_NO_TILE_STATUS = gcvSURF_RENDER_TARGET
-										 | gcvSURF_NO_TILE_STATUS,
-	gcvSURF_DEPTH_NO_TILE_STATUS = gcvSURF_DEPTH
-								 | gcvSURF_NO_TILE_STATUS,
+    gcvSURF_TYPE_UNKNOWN,
+    gcvSURF_INDEX,
+    gcvSURF_VERTEX,
+    gcvSURF_TEXTURE,
+    gcvSURF_RENDER_TARGET,
+    gcvSURF_DEPTH,
+    gcvSURF_BITMAP,
+    gcvSURF_TILE_STATUS,
+    gcvSURF_MASK,
+    gcvSURF_SCISSOR,
+    gcvSURF_HIERARCHICAL_DEPTH,
+    gcvSURF_NUM_TYPES, /* Make sure this is the last one! */
+
+    /* Combinations. */
+    gcvSURF_NO_TILE_STATUS = 0x100,
+    gcvSURF_RENDER_TARGET_NO_TILE_STATUS = gcvSURF_RENDER_TARGET
+                                         | gcvSURF_NO_TILE_STATUS,
+    gcvSURF_DEPTH_NO_TILE_STATUS = gcvSURF_DEPTH
+                                 | gcvSURF_NO_TILE_STATUS,
 }
 gceSURF_TYPE;
 
 typedef enum _gceSURF_COLOR_TYPE
 {
-	gcvSURF_COLOR_UNKNOWN,
-	gcvSURF_COLOR_LINEAR		= 0x01,
-	gcvSURF_COLOR_ALPHA_PRE		= 0x02,
+    gcvSURF_COLOR_UNKNOWN,
+    gcvSURF_COLOR_LINEAR        = 0x01,
+    gcvSURF_COLOR_ALPHA_PRE     = 0x02,
 }
 gceSURF_COLOR_TYPE;
 
 /* Rotation. */
 typedef enum _gceSURF_ROTATION
 {
-	gcvSURF_0_DEGREE,
-	gcvSURF_90_DEGREE,
-	gcvSURF_180_DEGREE,
-	gcvSURF_270_DEGREE
+    gcvSURF_0_DEGREE,
+    gcvSURF_90_DEGREE,
+    gcvSURF_180_DEGREE,
+    gcvSURF_270_DEGREE
 }
 gceSURF_ROTATION;
 
 /* Surface formats. */
 typedef enum _gceSURF_FORMAT
 {
-	/* Unknown format. */
-	gcvSURF_UNKNOWN,
-
-	/* Palettized formats. */
-	gcvSURF_INDEX1				= 100,
-	gcvSURF_INDEX4,
-	gcvSURF_INDEX8,
-
-	/* RGB formats. */
-	gcvSURF_A2R2G2B2			= 200,
-	gcvSURF_R3G3B2,
-	gcvSURF_A8R3G3B2,
-	gcvSURF_X4R4G4B4,
-	gcvSURF_A4R4G4B4,
-	gcvSURF_R4G4B4A4,
-	gcvSURF_X1R5G5B5,
-	gcvSURF_A1R5G5B5,
-	gcvSURF_R5G5B5A1,
-	gcvSURF_R5G6B5,
-	gcvSURF_R8G8B8,
-	gcvSURF_X8R8G8B8,
-	gcvSURF_A8R8G8B8,
-	gcvSURF_R8G8B8A8,
-	gcvSURF_G8R8G8B8,
-	gcvSURF_R8G8B8G8,
-	gcvSURF_X2R10G10B10,
-	gcvSURF_A2R10G10B10,
-	gcvSURF_X12R12G12B12,
-	gcvSURF_A12R12G12B12,
-	gcvSURF_X16R16G16B16,
-	gcvSURF_A16R16G16B16,
-	gcvSURF_R8G8B8X8,
-	gcvSURF_R5G5B5X1,
-	gcvSURF_R4G4B4X4,
-
-	/* BGR formats. */
-	gcvSURF_A4B4G4R4			= 300,
-	gcvSURF_A1B5G5R5,
-	gcvSURF_B5G6R5,
-	gcvSURF_B8G8R8,
-	gcvSURF_X8B8G8R8,
-	gcvSURF_A8B8G8R8,
-	gcvSURF_A2B10G10R10,
-	gcvSURF_A16B16G16R16,
-	gcvSURF_G16R16,
-	gcvSURF_B4G4R4A4,
-	gcvSURF_B5G5R5A1,
-	gcvSURF_B8G8R8X8,
-	gcvSURF_B8G8R8A8,
-	gcvSURF_X4B4G4R4,
-	gcvSURF_X1B5G5R5,
-	gcvSURF_B4G4R4X4,
-	gcvSURF_B5G5R5X1,
-
-	/* Compressed formats. */
-	gcvSURF_DXT1				= 400,
-	gcvSURF_DXT2,
-	gcvSURF_DXT3,
-	gcvSURF_DXT4,
-	gcvSURF_DXT5,
-	gcvSURF_CXV8U8,
-	gcvSURF_ETC1,
-
-	/* YUV formats. */
-	gcvSURF_YUY2				= 500,
-	gcvSURF_UYVY,
-	gcvSURF_YV12,
-	gcvSURF_I420,
-	gcvSURF_NV12,
-	gcvSURF_NV21,
-	gcvSURF_NV16,
-	gcvSURF_NV61,
-	gcvSURF_YVYU,
-	gcvSURF_VYUY,
-
-	/* Depth formats. */
-	gcvSURF_D16					= 600,
-	gcvSURF_D24S8,
-	gcvSURF_D32,
-	gcvSURF_D24X8,
-
-	/* Alpha formats. */
-	gcvSURF_A4					= 700,
-	gcvSURF_A8,
-	gcvSURF_A12,
-	gcvSURF_A16,
-	gcvSURF_A32,
-	gcvSURF_A1,
-
-	/* Luminance formats. */
-	gcvSURF_L4					= 800,
-	gcvSURF_L8,
-	gcvSURF_L12,
-	gcvSURF_L16,
-	gcvSURF_L32,
-	gcvSURF_L1,
-
-	/* Alpha/Luminance formats. */
-	gcvSURF_A4L4				= 900,
-	gcvSURF_A2L6,
-	gcvSURF_A8L8,
-	gcvSURF_A4L12,
-	gcvSURF_A12L12,
-	gcvSURF_A16L16,
-
-	/* Bump formats. */
-	gcvSURF_L6V5U5				= 1000,
-	gcvSURF_V8U8,
-	gcvSURF_X8L8V8U8,
-	gcvSURF_Q8W8V8U8,
-	gcvSURF_A2W10V10U10,
-	gcvSURF_V16U16,
-	gcvSURF_Q16W16V16U16,
-
-	/* Floating point formats. */
-	gcvSURF_R16F				= 1100,
-	gcvSURF_G16R16F,
-	gcvSURF_A16B16G16R16F,
-	gcvSURF_R32F,
-	gcvSURF_G32R32F,
-	gcvSURF_A32B32G32R32F,
+    /* Unknown format. */
+    gcvSURF_UNKNOWN,
+
+    /* Palettized formats. */
+    gcvSURF_INDEX1              = 100,
+    gcvSURF_INDEX4,
+    gcvSURF_INDEX8,
+
+    /* RGB formats. */
+    gcvSURF_A2R2G2B2            = 200,
+    gcvSURF_R3G3B2,
+    gcvSURF_A8R3G3B2,
+    gcvSURF_X4R4G4B4,
+    gcvSURF_A4R4G4B4,
+    gcvSURF_R4G4B4A4,
+    gcvSURF_X1R5G5B5,
+    gcvSURF_A1R5G5B5,
+    gcvSURF_R5G5B5A1,
+    gcvSURF_R5G6B5,
+    gcvSURF_R8G8B8,
+    gcvSURF_X8R8G8B8,
+    gcvSURF_A8R8G8B8,
+    gcvSURF_R8G8B8A8,
+    gcvSURF_G8R8G8B8,
+    gcvSURF_R8G8B8G8,
+    gcvSURF_X2R10G10B10,
+    gcvSURF_A2R10G10B10,
+    gcvSURF_X12R12G12B12,
+    gcvSURF_A12R12G12B12,
+    gcvSURF_X16R16G16B16,
+    gcvSURF_A16R16G16B16,
+    gcvSURF_R8G8B8X8,
+    gcvSURF_R5G5B5X1,
+    gcvSURF_R4G4B4X4,
+
+    /* BGR formats. */
+    gcvSURF_A4B4G4R4            = 300,
+    gcvSURF_A1B5G5R5,
+    gcvSURF_B5G6R5,
+    gcvSURF_B8G8R8,
+    gcvSURF_X8B8G8R8,
+    gcvSURF_A8B8G8R8,
+    gcvSURF_A2B10G10R10,
+    gcvSURF_A16B16G16R16,
+    gcvSURF_G16R16,
+    gcvSURF_B4G4R4A4,
+    gcvSURF_B5G5R5A1,
+    gcvSURF_B8G8R8X8,
+    gcvSURF_B8G8R8A8,
+    gcvSURF_X4B4G4R4,
+    gcvSURF_X1B5G5R5,
+    gcvSURF_B4G4R4X4,
+    gcvSURF_B5G5R5X1,
+
+    /* Compressed formats. */
+    gcvSURF_DXT1                = 400,
+    gcvSURF_DXT2,
+    gcvSURF_DXT3,
+    gcvSURF_DXT4,
+    gcvSURF_DXT5,
+    gcvSURF_CXV8U8,
+    gcvSURF_ETC1,
+
+    /* YUV formats. */
+    gcvSURF_YUY2                = 500,
+    gcvSURF_UYVY,
+    gcvSURF_YV12,
+    gcvSURF_I420,
+    gcvSURF_NV12,
+    gcvSURF_NV21,
+    gcvSURF_NV16,
+    gcvSURF_NV61,
+    gcvSURF_YVYU,
+    gcvSURF_VYUY,
+
+    /* Depth formats. */
+    gcvSURF_D16                 = 600,
+    gcvSURF_D24S8,
+    gcvSURF_D32,
+    gcvSURF_D24X8,
+
+    /* Alpha formats. */
+    gcvSURF_A4                  = 700,
+    gcvSURF_A8,
+    gcvSURF_A12,
+    gcvSURF_A16,
+    gcvSURF_A32,
+    gcvSURF_A1,
+
+    /* Luminance formats. */
+    gcvSURF_L4                  = 800,
+    gcvSURF_L8,
+    gcvSURF_L12,
+    gcvSURF_L16,
+    gcvSURF_L32,
+    gcvSURF_L1,
+
+    /* Alpha/Luminance formats. */
+    gcvSURF_A4L4                = 900,
+    gcvSURF_A2L6,
+    gcvSURF_A8L8,
+    gcvSURF_A4L12,
+    gcvSURF_A12L12,
+    gcvSURF_A16L16,
+
+    /* Bump formats. */
+    gcvSURF_L6V5U5              = 1000,
+    gcvSURF_V8U8,
+    gcvSURF_X8L8V8U8,
+    gcvSURF_Q8W8V8U8,
+    gcvSURF_A2W10V10U10,
+    gcvSURF_V16U16,
+    gcvSURF_Q16W16V16U16,
+
+    /* Floating point formats. */
+    gcvSURF_R16F                = 1100,
+    gcvSURF_G16R16F,
+    gcvSURF_A16B16G16R16F,
+    gcvSURF_R32F,
+    gcvSURF_G32R32F,
+    gcvSURF_A32B32G32R32F,
 
 #if 0
-	/* FIXME: remove HDR support for now. */
-	/* HDR formats. */
-	gcvSURF_HDR7E3				= 1200,
-	gcvSURF_HDR6E4,
-	gcvSURF_HDR5E5,
-	gcvSURF_HDR6E5,
+    /* FIXME: remove HDR support for now. */
+    /* HDR formats. */
+    gcvSURF_HDR7E3              = 1200,
+    gcvSURF_HDR6E4,
+    gcvSURF_HDR5E5,
+    gcvSURF_HDR6E5,
 #endif
 }
 gceSURF_FORMAT;
@@ -288,243 +295,267 @@ gceSURF_FORMAT;
 /* Pixel swizzle modes. */
 typedef enum _gceSURF_SWIZZLE
 {
-	gcvSURF_NOSWIZZLE,
-	gcvSURF_ARGB,
-	gcvSURF_ABGR,
-	gcvSURF_RGBA,
-	gcvSURF_BGRA
+    gcvSURF_NOSWIZZLE,
+    gcvSURF_ARGB,
+    gcvSURF_ABGR,
+    gcvSURF_RGBA,
+    gcvSURF_BGRA
 }
 gceSURF_SWIZZLE;
 
 /* Transparency modes. */
 typedef enum _gceSURF_TRANSPARENCY
 {
-	/* Valid only for PE 1.0 */
-	gcvSURF_OPAQUE,
-	gcvSURF_SOURCE_MATCH,
-	gcvSURF_SOURCE_MASK,
-	gcvSURF_PATTERN_MASK,
+    /* Valid only for PE 1.0 */
+    gcvSURF_OPAQUE,
+    gcvSURF_SOURCE_MATCH,
+    gcvSURF_SOURCE_MASK,
+    gcvSURF_PATTERN_MASK,
 }
 gceSURF_TRANSPARENCY;
 
 /* Transparency modes. */
 typedef enum _gce2D_TRANSPARENCY
 {
-	/* Valid only for PE 2.0 */
-	gcv2D_OPAQUE,
-	gcv2D_KEYED,
-	gcv2D_MASKED
+    /* Valid only for PE 2.0 */
+    gcv2D_OPAQUE,
+    gcv2D_KEYED,
+    gcv2D_MASKED
 }
 gce2D_TRANSPARENCY;
 
 /* Mono packing modes. */
 typedef enum _gceSURF_MONOPACK
 {
-	gcvSURF_PACKED8,
-	gcvSURF_PACKED16,
-	gcvSURF_PACKED32,
-	gcvSURF_UNPACKED,
+    gcvSURF_PACKED8,
+    gcvSURF_PACKED16,
+    gcvSURF_PACKED32,
+    gcvSURF_UNPACKED,
 }
 gceSURF_MONOPACK;
 
 /* Blending modes. */
 typedef enum _gceSURF_BLEND_MODE
 {
-	/* Porter-Duff blending modes.                   */
-	/*                         Fsrc      Fdst        */
-	gcvBLEND_CLEAR,         /* 0         0           */
-	gcvBLEND_SRC,           /* 1         0           */
-	gcvBLEND_DST,           /* 0         1           */
-	gcvBLEND_SRC_OVER_DST,  /* 1         1 - Asrc    */
-	gcvBLEND_DST_OVER_SRC,  /* 1 - Adst  1           */
-	gcvBLEND_SRC_IN_DST,    /* Adst      0           */
-	gcvBLEND_DST_IN_SRC,    /* 0         Asrc        */
-	gcvBLEND_SRC_OUT_DST,   /* 1 - Adst  0           */
-	gcvBLEND_DST_OUT_SRC,   /* 0         1 - Asrc    */
-	gcvBLEND_SRC_ATOP_DST,  /* Adst      1 - Asrc    */
-	gcvBLEND_DST_ATOP_SRC,  /* 1 - Adst  Asrc        */
-	gcvBLEND_SRC_XOR_DST,   /* 1 - Adst  1 - Asrc    */
-
-	/* Special blending modes.                       */
-	gcvBLEND_SET,           /* DST = 1               */
-	gcvBLEND_SUB            /* DST = DST * (1 - SRC) */
+    /* Porter-Duff blending modes.                   */
+    /*                         Fsrc      Fdst        */
+    gcvBLEND_CLEAR,         /* 0         0           */
+    gcvBLEND_SRC,           /* 1         0           */
+    gcvBLEND_DST,           /* 0         1           */
+    gcvBLEND_SRC_OVER_DST,  /* 1         1 - Asrc    */
+    gcvBLEND_DST_OVER_SRC,  /* 1 - Adst  1           */
+    gcvBLEND_SRC_IN_DST,    /* Adst      0           */
+    gcvBLEND_DST_IN_SRC,    /* 0         Asrc        */
+    gcvBLEND_SRC_OUT_DST,   /* 1 - Adst  0           */
+    gcvBLEND_DST_OUT_SRC,   /* 0         1 - Asrc    */
+    gcvBLEND_SRC_ATOP_DST,  /* Adst      1 - Asrc    */
+    gcvBLEND_DST_ATOP_SRC,  /* 1 - Adst  Asrc        */
+    gcvBLEND_SRC_XOR_DST,   /* 1 - Adst  1 - Asrc    */
+
+    /* Special blending modes.                       */
+    gcvBLEND_SET,           /* DST = 1               */
+    gcvBLEND_SUB            /* DST = DST * (1 - SRC) */
 }
 gceSURF_BLEND_MODE;
 
 /* Per-pixel alpha modes. */
 typedef enum _gceSURF_PIXEL_ALPHA_MODE
 {
-	gcvSURF_PIXEL_ALPHA_STRAIGHT,
-	gcvSURF_PIXEL_ALPHA_INVERSED
+    gcvSURF_PIXEL_ALPHA_STRAIGHT,
+    gcvSURF_PIXEL_ALPHA_INVERSED
 }
 gceSURF_PIXEL_ALPHA_MODE;
 
 /* Global alpha modes. */
 typedef enum _gceSURF_GLOBAL_ALPHA_MODE
 {
-	gcvSURF_GLOBAL_ALPHA_OFF,
-	gcvSURF_GLOBAL_ALPHA_ON,
-	gcvSURF_GLOBAL_ALPHA_SCALE
+    gcvSURF_GLOBAL_ALPHA_OFF,
+    gcvSURF_GLOBAL_ALPHA_ON,
+    gcvSURF_GLOBAL_ALPHA_SCALE
 }
 gceSURF_GLOBAL_ALPHA_MODE;
 
 /* Color component modes for alpha blending. */
 typedef enum _gceSURF_PIXEL_COLOR_MODE
 {
-	gcvSURF_COLOR_STRAIGHT,
-	gcvSURF_COLOR_MULTIPLY
+    gcvSURF_COLOR_STRAIGHT,
+    gcvSURF_COLOR_MULTIPLY
 }
 gceSURF_PIXEL_COLOR_MODE;
 
 /* Color component modes for alpha blending. */
 typedef enum _gce2D_PIXEL_COLOR_MULTIPLY_MODE
 {
-	gcv2D_COLOR_MULTIPLY_DISABLE,
-	gcv2D_COLOR_MULTIPLY_ENABLE
+    gcv2D_COLOR_MULTIPLY_DISABLE,
+    gcv2D_COLOR_MULTIPLY_ENABLE
 }
 gce2D_PIXEL_COLOR_MULTIPLY_MODE;
 
 /* Color component modes for alpha blending. */
 typedef enum _gce2D_GLOBAL_COLOR_MULTIPLY_MODE
 {
-	gcv2D_GLOBAL_COLOR_MULTIPLY_DISABLE,
-	gcv2D_GLOBAL_COLOR_MULTIPLY_ALPHA,
-	gcv2D_GLOBAL_COLOR_MULTIPLY_COLOR
+    gcv2D_GLOBAL_COLOR_MULTIPLY_DISABLE,
+    gcv2D_GLOBAL_COLOR_MULTIPLY_ALPHA,
+    gcv2D_GLOBAL_COLOR_MULTIPLY_COLOR
 }
 gce2D_GLOBAL_COLOR_MULTIPLY_MODE;
 
 /* Alpha blending factor modes. */
 typedef enum _gceSURF_BLEND_FACTOR_MODE
 {
-	gcvSURF_BLEND_ZERO,
-	gcvSURF_BLEND_ONE,
-	gcvSURF_BLEND_STRAIGHT,
-	gcvSURF_BLEND_INVERSED,
-	gcvSURF_BLEND_COLOR,
-	gcvSURF_BLEND_COLOR_INVERSED,
-	gcvSURF_BLEND_SRC_ALPHA_SATURATED
+    gcvSURF_BLEND_ZERO,
+    gcvSURF_BLEND_ONE,
+    gcvSURF_BLEND_STRAIGHT,
+    gcvSURF_BLEND_INVERSED,
+    gcvSURF_BLEND_COLOR,
+    gcvSURF_BLEND_COLOR_INVERSED,
+    gcvSURF_BLEND_SRC_ALPHA_SATURATED
 }
 gceSURF_BLEND_FACTOR_MODE;
 
 /* Alpha blending porter duff rules. */
 typedef enum _gce2D_PORTER_DUFF_RULE
 {
-	gcvPD_CLEAR,
-	gcvPD_SRC,
-	gcvPD_SRC_OVER,
-	gcvPD_DST_OVER,
-	gcvPD_SRC_IN,
-	gcvPD_DST_IN,
-	gcvPD_SRC_OUT,
-	gcvPD_DST_OUT,
-	gcvPD_SRC_ATOP,
-	gcvPD_DST_ATOP,
-	gcvPD_ADD,
-	gcvPD_XOR,
-	gcvPD_DST
+    gcvPD_CLEAR,
+    gcvPD_SRC,
+    gcvPD_SRC_OVER,
+    gcvPD_DST_OVER,
+    gcvPD_SRC_IN,
+    gcvPD_DST_IN,
+    gcvPD_SRC_OUT,
+    gcvPD_DST_OUT,
+    gcvPD_SRC_ATOP,
+    gcvPD_DST_ATOP,
+    gcvPD_ADD,
+    gcvPD_XOR,
+    gcvPD_DST
 }
 gce2D_PORTER_DUFF_RULE;
 
 /* Alpha blending factor modes. */
 typedef enum _gce2D_YUV_COLOR_MODE
 {
-	gcv2D_YUV_601,
-	gcv2D_YUV_709
+    gcv2D_YUV_601,
+    gcv2D_YUV_709
 }
 gce2D_YUV_COLOR_MODE;
 
 /* 2D Rotation and flipping. */
 typedef enum _gce2D_ORIENTATION
 {
-	gcv2D_0_DEGREE,
-	gcv2D_90_DEGREE,
-	gcv2D_180_DEGREE,
-	gcv2D_270_DEGREE,
-	gcv2D_X_FLIP,
-	gcv2D_Y_FLIP
+    gcv2D_0_DEGREE,
+    gcv2D_90_DEGREE,
+    gcv2D_180_DEGREE,
+    gcv2D_270_DEGREE,
+    gcv2D_X_FLIP,
+    gcv2D_Y_FLIP
 }
 gce2D_ORIENTATION;
 
 typedef enum _gce2D_COMMAND
 {
-	gcv2D_CLEAR,
-	gcv2D_LINE,
-	gcv2D_BLT,
-	gcv2D_STRETCH,
-	gcv2D_HOR_FILTER,
-	gcv2D_VER_FILTER,
+    gcv2D_CLEAR,
+    gcv2D_LINE,
+    gcv2D_BLT,
+    gcv2D_STRETCH,
+    gcv2D_HOR_FILTER,
+    gcv2D_VER_FILTER,
 }
 gce2D_COMMAND;
 
 /* Texture functions. */
 typedef enum _gceTEXTURE_FUNCTION
 {
-	gcvTEXTURE_DUMMY = 0,
-	gcvTEXTURE_REPLACE = 0,
-	gcvTEXTURE_MODULATE,
-	gcvTEXTURE_ADD,
-	gcvTEXTURE_ADD_SIGNED,
-	gcvTEXTURE_INTERPOLATE,
-	gcvTEXTURE_SUBTRACT,
-	gcvTEXTURE_DOT3
+    gcvTEXTURE_DUMMY = 0,
+    gcvTEXTURE_REPLACE = 0,
+    gcvTEXTURE_MODULATE,
+    gcvTEXTURE_ADD,
+    gcvTEXTURE_ADD_SIGNED,
+    gcvTEXTURE_INTERPOLATE,
+    gcvTEXTURE_SUBTRACT,
+    gcvTEXTURE_DOT3
 }
 gceTEXTURE_FUNCTION;
 
 /* Texture sources. */
 typedef enum _gceTEXTURE_SOURCE
 {
-	gcvCOLOR_FROM_TEXTURE,
-	gcvCOLOR_FROM_CONSTANT_COLOR,
-	gcvCOLOR_FROM_PRIMARY_COLOR,
-	gcvCOLOR_FROM_PREVIOUS_COLOR
+    gcvCOLOR_FROM_TEXTURE,
+    gcvCOLOR_FROM_CONSTANT_COLOR,
+    gcvCOLOR_FROM_PRIMARY_COLOR,
+    gcvCOLOR_FROM_PREVIOUS_COLOR
 }
 gceTEXTURE_SOURCE;
 
 /* Texture source channels. */
 typedef enum _gceTEXTURE_CHANNEL
 {
-	gcvFROM_COLOR,
-	gcvFROM_ONE_MINUS_COLOR,
-	gcvFROM_ALPHA,
-	gcvFROM_ONE_MINUS_ALPHA
+    gcvFROM_COLOR,
+    gcvFROM_ONE_MINUS_COLOR,
+    gcvFROM_ALPHA,
+    gcvFROM_ONE_MINUS_ALPHA
 }
 gceTEXTURE_CHANNEL;
 
 /* Filter types. */
 typedef enum _gceFILTER_TYPE
 {
-	gcvFILTER_SYNC,
-	gcvFILTER_BLUR,
-	gcvFILTER_USER
+    gcvFILTER_SYNC,
+    gcvFILTER_BLUR,
+    gcvFILTER_USER
 }
 gceFILTER_TYPE;
 
 /* Filter pass types. */
 typedef enum _gceFILTER_PASS_TYPE
 {
-	gcvFILTER_HOR_PASS,
-	gcvFILTER_VER_PASS
+    gcvFILTER_HOR_PASS,
+    gcvFILTER_VER_PASS
 }
 gceFILTER_PASS_TYPE;
 
 /* Endian hints. */
 typedef enum _gceENDIAN_HINT
 {
-	gcvENDIAN_NO_SWAP			= 0,
-	gcvENDIAN_SWAP_WORD,
-	gcvENDIAN_SWAP_DWORD,
+    gcvENDIAN_NO_SWAP           = 0,
+    gcvENDIAN_SWAP_WORD,
+    gcvENDIAN_SWAP_DWORD
 }
 gceENDIAN_HINT;
 
+/* Endian hints. */
+typedef enum _gceTILING
+{
+    gcvLINEAR,
+    gcvTILED,
+    gcvSUPERTILED
+}
+gceTILING;
+
+typedef enum _gceSAMPLERDIRTY
+{
+    gcvSAMPLER_MIN_FILTER_DIRTY,
+    gcvSAMPLER_MAG_FILTER_DIRTY,
+    gcvSAMPLER_WRAPR_DIRTY_DIRTY,
+    gcvSAMPLER_WRAPS_DIRTY_DIRTY,
+    gcvSAMPLER_WRAPT_DIRTY_DIRTY,
+    gcvSAMPLER_LODMINX_DIRTY,
+    gcvSAMPLER_LODBIASX_DIRTY,
+    gcvSAMPLER_BORDERCOLOR_DIRTY,
+    gcvSAMPLER_MIPMAP_DIRTY,
+    gcvSAMPLER_ALL_DIRTY
+}
+gceSAMPLERDIRTY;
 /******************************************************************************\
 ****************************** Object Declarations *****************************
 \******************************************************************************/
 
-typedef struct _gcoCONTEXT *		gcoCONTEXT;
-typedef struct _gcoCMDBUF *			gcoCMDBUF;
-typedef struct _gcoQUEUE *			gcoQUEUE;
-typedef struct _gcsHAL_INTERFACE *	gcsHAL_INTERFACE_PTR;
-typedef struct gcs2D_PROFILE *  	gcs2D_PROFILE_PTR;
+typedef struct _gcoCONTEXT *        gcoCONTEXT;
+typedef struct _gcoCTXBUF *			gcoCTXBUF;
+typedef struct _gcoCMDBUF *         gcoCMDBUF;
+typedef struct _gcoQUEUE *          gcoQUEUE;
+typedef struct _gcsHAL_INTERFACE *  gcsHAL_INTERFACE_PTR;
+typedef struct gcs2D_PROFILE *      gcs2D_PROFILE_PTR;
 
 #ifdef __cplusplus
 }
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_mem.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_mem.h
index f43d61e..e3c4433 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_mem.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_mem.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_options.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_options.h
index 3d23576..29bdced 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_options.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_options.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -122,7 +122,15 @@
 #define gcdDUMP						0
 
 /*
-	gcdDUMP_IN_KERNEL
+    gcdDUMP_API
+
+        When set to 1, a high level dump of the EGL and GL/VG APs's are
+        captured.
+*/
+#define gcdDUMP_API                 0
+
+/*
+    gcdDUMP_IN_KERNEL
 
 		When set to 1, all dumps will happen in the kernel.  This is handy if
 		you want the kernel to dump its command buffers as well and the data
@@ -220,6 +228,83 @@
 */
 #define MRVL_TAVOR_PV2_DISABLE_YFLIP        0
 
+/*
+    gcdNO_POWER_MANAGEMENT
+
+    This define disables the power management code.
+*/
+#ifndef gcdNO_POWER_MANAGEMENT
+#   define gcdNO_POWER_MANAGEMENT           0
+#endif
+
+/*
+    VIVANTE_POWER_MANAGE
+
+    This define enable the vivante power management code.
+*/
+#ifndef VIVANTE_POWER_MANAGE
+#   define VIVANTE_POWER_MANAGE             1
+#endif
+/*
+    gcdFPGA_BUILD
+
+    This define enables work arounds for FPGA images.
+*/
+#if !defined(gcdFPGA_BUILD)
+#   define gcdFPGA_BUILD                    0
+#endif
+
+/*
+    gcdGPU_TIMEOUT
+
+    This define specified the number of milliseconds the system will wait before
+    it broadcasts the GPU is stuck.  In other words, it will define the timeout
+    of any operation that needs to wait for the GPU.
+
+    If the value is 0, no timeout will be checked for.
+*/
+#if !defined(gcdGPU_TIMEOUT)
+#   define gcdGPU_TIMEOUT                   0
+#endif
+
+/*
+ * MACRO definition of MRVL
+ */
+#ifdef CONFIG_CPU_PXA910
+#define MRVL_PLATFORM_TD                    1
+#else
+#define MRVL_PLATFORM_TD                    0
+#endif
+
+#ifdef CONFIG_PXA95x
+#define MRVL_PLATFORM_MG1                   1
+#else
+#define MRVL_PLATFORM_MG1                   0
+#endif
+
+#ifdef CONFIG_CPU_MMP2
+#define MRVL_PLATFORM_MMP2                  1
+#else
+#define MRVL_PLATFORM_MMP2                  0
+#endif
+
+#if (defined CONFIG_DVFM) && (defined CONFIG_DVFM_PXA910)
+#define MRVL_CONFIG_DVFM_TD                 1
+#else
+#define MRVL_CONFIG_DVFM_TD                 0
+#endif
+
+#ifdef CONFIG_PXA95x
+#define MRVL_CONFIG_DVFM_MG1                1
+#else
+#define MRVL_CONFIG_DVFM_MG1                0
+#endif
+
+#if (defined CONFIG_DVFM) && (defined CONFIG_DVFM_MMP2)
+#define MRVL_CONFIG_DVFM_MMP2               1
+#else
+#define MRVL_CONFIG_DVFM_MMP2               0
+#endif
 
 /*
     MRVL_LOW_POWER_MODE_DEBUG
@@ -233,13 +318,14 @@
 
 /*
     MRVL_SWAP_BUFFER_IN_EVERY_DRAW
-    
+
     This define force swapbuffer after every drawElement/drawArray.
 */
 #define MRVL_SWAP_BUFFER_IN_EVERY_DRAW      0
 
-#define MRVL_BENCH							0
-
+#ifndef MRVL_BENCH
+#   define MRVL_BENCH						0
+#endif
 
 #define MRVL_EANBLE_COMPRESSION_DXT         0
 
@@ -256,11 +342,17 @@
 #define MRVL_DISABLE_SWAP_THREAD			1
 
 /* API log enable */
-#define MRVL_ENABLE_API_LOG				    0
-#define MRVL_ENABLE_EGL_API_LOG			    0
-#define MRVL_ENABLE_OES1_API_LOG			0
-#define MRVL_ENABLE_OES2_API_LOG			0
-#define MRVL_ENABLE_OVG_API_LOG			    0
+#define MRVL_ENABLE_ERROR_LOG               1
+#define MRVL_ENABLE_API_LOG                 0
+#define MRVL_ENABLE_EGL_API_LOG             0
+#define MRVL_ENABLE_OES1_API_LOG            0
+#define MRVL_ENABLE_OES2_API_LOG            0
+#define MRVL_ENABLE_OVG_API_LOG             0
+
+/* enable it can dump logs to file
+ * for android can stop dump by "setprop marvell.graphics.dump_log 0"
+*/
+#define MRVL_DUMP_LOG_TO_FILE               0
 
 /* Optimization for Eclair UI */
 #define MRVL_OPTI_ANDROID_IMAGE             1
@@ -272,15 +364,81 @@
 
 #define MRVL_OPTI_COMPOSITOR                1
 #define MRVL_OPTI_COMPOSITOR_DEBUG          0
+#define MRVL_READ_PIXEL_2D                  1
+#define MRVL_2D_SKIP_CONTEXT                0
+#define MRVL_2D_FORCE_FILTER_UPLOAD			1
+
 
 #define MRVL_OPTI_STREAM_FAST_PATH          1
 #define MRVL_OPTI_USE_RESERVE_MEMORY        1
 
+/* Enable user mode heap allocation
+ * if enable, all internal structure should be allocated from pre-allocated heap
+ * if disable, all internal structure should be allocated by malloc directly
+ */
+#define MRVL_ENABLE_USERMODE_HEAP_ALLOCATION   0
+
+
 /* Enable a timer thread to check the status of GC periodically */
 #define MRVL_TIMER                          0
 
-/* Enable silent reset */
-#define MRVL_SILENT_RESET                   0
+/* Enable a idle profiling thread to turn off GC when idle */
+#if (MRVL_PLATFORM_TD || MRVL_PLATFORM_MG1 || MRVL_PLATFORM_MMP2) && (defined ANDROID)
+#define MRVL_PROFILE_THREAD                 1
+#else
+#define MRVL_PROFILE_THREAD                 0
+#endif
+
+/* Enable a guard thread to check the status of GC */
+#if (MRVL_PLATFORM_TD || MRVL_PLATFORM_MG1) && (defined ANDROID)
+#define MRVL_GUARD_THREAD                   1
+#define MRVL_PRINT_CMD_BUFFER               1
+#else
+#define MRVL_GUARD_THREAD                   0
+#define MRVL_PRINT_CMD_BUFFER               0
+#endif
+
+/* Power -- Enable clock gating */
+#define MRVL_ENABLE_CLOCK_GATING            1
+
+/* Power -- Enable frequency scaling */
+#define MRVL_ENABLE_FREQ_SCALING            1
+
+/* Enable dvfm control for certain platform */
+#if MRVL_CONFIG_DVFM_MG1 || MRVL_CONFIG_DVFM_MMP2
+#define MRVL_CONFIG_ENABLE_DVFM             1
+#else
+#define MRVL_CONFIG_ENABLE_DVFM             0
+#endif
+
+/* Separate GC clk and power on/off */
+#if (MRVL_PLATFORM_TD || MRVL_PLATFORM_MG1)
+#define SEPARATE_CLOCK_AND_POWER            1
+#define KEEP_POWER_ON                       0
+#else
+#define SEPARATE_CLOCK_AND_POWER            0
+#endif
+
+/* Enable control of AXI bus clock */
+#if MRVL_PLATFORM_MG1
+#define MRVL_CONFIG_AXICLK_CONTROL          1
+#else
+#define MRVL_CONFIG_AXICLK_CONTROL          0
+#endif
+
+/* Enable early-suspend related functions */
+#if (defined CONFIG_HAS_EARLYSUSPEND) && (defined CONFIG_EARLYSUSPEND)
+#define MRVL_CONFIG_ENABLE_EARLYSUSPEND     1
+#else
+#define MRVL_CONFIG_ENABLE_EARLYSUSPEND     0
+#endif
+
+/* Enable BSP runtime or idle profile */
+#if (defined CONFIG_PXA910_DVFM_STATS)
+#define ENABLE_BSP_IDLE_PROFILE             1
+#else
+#define ENABLE_BSP_IDLE_PROFILE             0
+#endif
 
 /* Force surface format RGBA8888*/
 #define MRVL_FORCE_8888                     0
@@ -290,37 +448,86 @@
 #define MRVL_PRESERVE_CMD_BUFFER            1
 
 /*
-    MRVL_PRINT_CMD_BUFFER
+	Record texture in command buffer for it idle or not
+*/
+#define MRVL_TEXTURE_USED_LIST              0
 
-    This define enable print cmd buffer and link chain code
+/*
+	simple wait vsync
 */
-#define MRVL_PRINT_CMD_BUFFER               0
+#define MRVL_SIMPLE_WAIT_VSYNC				0
+
+/*
+ * 	to decrese mov instruction
+ */
+#define MRVL_OPTIMIZE_LIGHT_MOV				0
+
+/*
+ *      for eglSwapInterval in Android
+ */
+#define MRVL_ANDROID_VSYNC_INTERVAL         1
+
+/*      for speed up texture lookup
+ *
+ */
+#define MRVL_OPT_TEXTURE_LOOKUP             1
+
+/*
+ *      skip unnecessary texture attribute validate
+ */
+#define MRVL_TEXTURE_VALIDATE_OPT           1
 
 /*
-    POWER_OFF_GC_WHEN_IDLE
-    This enable idle-power-off strategy on TD
+ *      New Back Copy Propagation Optimization
+ */
+#define MRVL_NEW_BCP_OPT                    1
+
+/*
+ *      VBO dirty patch Optimization
+ */
+#define MRVL_VBO_DIRTY_PATCH                1
+
+/*
+ *      Pre-allocated context buffers and reuse them
+ */
+#define MRVL_PRE_ALLOCATE_CTX_BUFFER		1
+
+#if MRVL_PRE_ALLOCATE_CTX_BUFFER
+/*	Minimal number of context buffers.
+*	Can't be less than 2, or it can't get the signal when wait.
 */
-#define POWER_OFF_GC_WHEN_IDLE  1
+#define gcdCTXBUF_SIZE_MIN					2
+/*
+*	Number of context buffers to use per client by default.
+*/
+#define gcdCTXBUF_SIZE_DEFAULT				10
+#endif
+
+/*
+ *  Remove image texture surface to save video memory on 2d path.
+ */
+#define MRVL_MEM_OPT                        1
 
 /*
     Definitions for vendor, renderer and version strings
 */
+
 #define _VENDOR_STRING_             "Marvell Technology Group Ltd"
 
-#define _EGL_VERSION_STRING_        "EGL 1.3 Ver0.8.0.1998";      
+#define _EGL_VERSION_STRING_        "EGL 1.3";
 
 #if defined(COMMON_LITE)
-#define _OES11_VERSION_STRING_      "OpenGL ES-CL 1.1 Ver0.8.0.1998";
+#define _OES11_VERSION_STRING_      "OpenGL ES-CL 1.1";
 #else
-#define _OES11_VERSION_STRING_      "OpenGL ES-CM 1.1 Ver0.8.0.1998";
+#define _OES11_VERSION_STRING_      "OpenGL ES-CM 1.1";
 #endif
 
-#define _OES20_VERSION_STRING_      "OpenGL ES 2.0 Ver0.8.0.1998";
-#define _GLSL_ES_VERSION_STRING_    "OpenGL ES GLSL ES 1.00 Ver0.8.0.1998"
+#define _OES20_VERSION_STRING_      "OpenGL ES 2.0";
+#define _GLSL_ES_VERSION_STRING_    "OpenGL ES GLSL ES 1.00"
 
-#define _OPENVG_VERSION_STRING_     "OpenVG 1.1 Ver0.8.0.1998"
+#define _OPENVG_VERSION_STRING_     "OpenVG 1.1"
 
-#define _GAL_VERSION_STRING_        "GAL Ver0.8.0.1998"
+#define _GC_VERSION_STRING_        "GC Ver0.8.0.3184"
 
 #endif /* __gc_hal_options_h_ */
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_profiler.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_profiler.h
index 56aa40b..8fe1f55 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_profiler.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_profiler.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_raster.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_raster.h
index 08770d4..23485a2 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_raster.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_raster.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -235,6 +235,21 @@ gco2D_Destroy(
 	IN gco2D Hardware
 	);
 
+
+/* Start and end of gco2D draws */
+gceSTATUS
+gco2D_Begin(
+	IN gco2D Engine,
+	IN gctUINT cmdSize
+	);
+
+gceSTATUS
+gco2D_End(
+	IN gco2D Engine
+	);
+
+
+
 /* Sets the maximum number of brushes in the brush cache. */
 gceSTATUS
 gco2D_SetBrushLimit(
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_types.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_types.h
index fa8dfc9..34d126a 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_types.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/inc/gc_hal_types.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -105,7 +105,7 @@ extern "C" {
 #define gcvFALSE				0
 #define gcvTRUE					1
 
-#define gcvINFINITE				((gctUINT32) ~0)
+#define gcvINFINITE				((gctUINT32) ~0U)
 
 typedef int						gctBOOL;
 typedef gctBOOL *				gctBOOL_PTR;
@@ -277,6 +277,7 @@ typedef enum _gceSTATUS
 	gcvSTATUS_NOT_FOUND				=	-19,
 	gcvSTATUS_NOT_ALIGNED			=	-20,
 	gcvSTATUS_INVALID_REQUEST		=	-21,
+	gcvSTATUS_GPU_NOT_RESPONDING	=	-22,
 
 	/* Linker errors. */
 	gcvSTATUS_GLOBAL_TYPE_MISMATCH	=	-1000,
@@ -482,6 +483,63 @@ gceSTATUS;
 #define gcmABS(x)				(((x) < 0)    ? -(x) :  (x))
 #define gcmNEG(x)				(((x) < 0)    ?  (x) : -(x))
 
+
+#define gcmUNALIGNMENT(X) ((gctUINT32)(X) & (sizeof (gctUINT32) - 1))
+
+#define gcmMEMCPY_BYTE(dst,src,size) \
+    {\
+        gctUINT32 i = 0; \
+        for(i = 0; i < size; i++)\
+        {\
+            *((gctUINT8 *)dst+i) = *((gctUINT8*)src+i);\
+        }\
+    }
+
+/* Optimize memory copy. 
+       For 4,8,12,16 bytes copy, use unsigned int assignment instead of calling memcopy.
+       ATTENTION: no break in switch branch.
+*/
+#define gcmMEMCPY_DWORD(dst,src,size) \
+    switch(size) \
+    {\
+        case 16:\
+            *((gctUINT32 *)dst + 3) = *((gctUINT32 *)src + 3);\
+        case 12:\
+            *((gctUINT32 *)dst + 2) = *((gctUINT32 *)src + 2);\
+        case 8:\
+            *((gctUINT32 *)dst + 1) = *((gctUINT32 *)src + 1);\
+        case 4:\
+            *((gctUINT32 *)dst) = *((gctUINT32 *)src);\
+            break;\
+        default:\
+            gcmMEMCPY_BYTE(dst,src,size);\
+            break;\
+    }
+    
+/* 
+ * gcmMEMCPY. 
+ *
+ * gcmMEMCPY is for normal size(> 16 bytes) memory copy
+ * gcmMEMCPY_DWORD is for size <=16 bytes
+ * Note: if you do not know the size, just use gcmMEMCPY
+*/
+#define gcmMEMCPY(dst,src,size)                 \
+    {                                           \
+        gctUINT32 *pDst = (gctUINT32 *)dst;     \
+        gctUINT32 *pSrc = (gctUINT32 *)src;     \
+        gctUINT32 Size  = size;                 \
+        while(Size >= gcmSIZEOF(gctUINT32) * 4) \
+        {                                       \
+            pDst[0] = pSrc[0];                  \
+            pDst[1] = pSrc[1];                  \
+            pDst[2] = pSrc[2];                  \
+            pDst[3] = pSrc[3];                  \
+            pDst += 4;                          \
+            pSrc += 4;                          \
+            Size -= (gcmSIZEOF(gctUINT32) * 4); \
+        }                                       \
+        gcmMEMCPY_DWORD(pDst,pSrc,Size)         \
+    }
 /*******************************************************************************
 **
 **	gcmPTR2INT
@@ -534,7 +592,7 @@ gceSTATUS;
 ( \
 	gcmPTR2INT(& (((struct s *) 0)->field)) \
 )
-
+    
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.c
index 67d379d..b9fd49a 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -98,8 +98,9 @@ gckKERNEL_Construct(
 	/* Save context. */
 	kernel->context = Context;
 
-	/* No clients attached. */
-	kernel->clients = 0;
+    /* Construct atom holding number of clients. */
+    kernel->atomClients = gcvNULL;
+    gcmkONERROR(gckOS_AtomConstruct(Os, &kernel->atomClients));
 #if gcdSECURE_USER
     kernel->cacheSlots     = 0;
     kernel->cacheTimeStamp = 0;
@@ -151,28 +152,42 @@ gckKERNEL_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
-	if (kernel->event != gcvNULL)
+	if (kernel != gcvNULL)
 	{
-		gcmkVERIFY_OK(gckEVENT_Destroy(kernel->event));
-	}
-
-	if (kernel->command != gcvNULL)
-	{
-		gcmkVERIFY_OK(gckCOMMAND_Destroy(kernel->command));
-	}
-
-	if (kernel->hardware != gcvNULL)
-	{
-		gcmkVERIFY_OK(gckHARDWARE_Destroy(kernel->hardware));
-	}
+    	if (kernel->event != gcvNULL)
+	    {
+    	    gcmkVERIFY_OK(gckEVENT_Destroy(kernel->event));
+            kernel->event = gcvNULL;
+    	}
+
+   	 	if (kernel->command != gcvNULL)
+    	{
+		    gcmkVERIFY_OK(gckCOMMAND_Destroy(kernel->command));
+            kernel->command = gcvNULL;
+    	}
+
+    	if (kernel->hardware != gcvNULL)
+    	{
+        	gcmkVERIFY_OK(gckHARDWARE_Destroy(kernel->hardware));
+            kernel->hardware = gcvNULL;
+    	}
+
+        if (kernel->atomClients != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_AtomDestroy(Os, kernel->atomClients));
+            kernel->atomClients = gcvNULL;
+        }
 
-    kernel->version = _GAL_VERSION_STRING_;
+    kernel->version = _GC_VERSION_STRING_;
 
 #if MRVL_LOW_POWER_MODE_DEBUG
 	gcmkVERIFY_OK(
 		gckOS_Free(Os, kernel->kernelMSG));
+    kernel->kernelMSG = gcvNULL;
 #endif
-	gcmkVERIFY_OK(gckOS_Free(Os, kernel));
+   	gcmkVERIFY_OK(gckOS_Free(Os, kernel));
+    kernel = gcvNULL;
+	}
 
 	/* Return the error. */
 	gcmkFOOTER();
@@ -207,27 +222,50 @@ gckKERNEL_Destroy(
 
 
 	/* Destroy the gckMMU object. */
-	gcmkVERIFY_OK(gckMMU_Destroy(Kernel->mmu));
-
+    if(Kernel->mmu != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckMMU_Destroy(Kernel->mmu));
+        Kernel->mmu = gcvNULL;
+    }
+    
 	/* Destroy the gckEVENT object. */
-	gcmkVERIFY_OK(gckEVENT_Destroy(Kernel->event));
+    if(Kernel->event != gcvNULL)
+    {    	
+        gcmkVERIFY_OK(gckEVENT_Destroy(Kernel->event));
+        Kernel->event = gcvNULL;
+    }
 
 	/* Destroy the gckCOMMNAND object. */
-	gcmkVERIFY_OK(gckCOMMAND_Destroy(Kernel->command));
+    if(Kernel->command != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckCOMMAND_Destroy(Kernel->command));
+        Kernel->command = gcvNULL;
+    }
 
-	/* Destroy the gckHARDWARE object. */
-	gcmkVERIFY_OK(gckHARDWARE_Destroy(Kernel->hardware));
+    /* Destroy the gckHARDWARE object. */
+    if(Kernel->hardware != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckHARDWARE_Destroy(Kernel->hardware));
+        Kernel->hardware = gcvNULL;
+    }
 
+    /* Detsroy the client atom. */
+    if(Kernel->atomClients != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Kernel->os, Kernel->atomClients));
+        Kernel->atomClients = gcvNULL;
+    }
 	/* Mark the gckKERNEL object as unknown. */
 	Kernel->object.type = gcvOBJ_UNKNOWN;
 
 #if MRVL_LOW_POWER_MODE_DEBUG
     gcmkVERIFY_OK(
 		gckOS_Free(Kernel->os, Kernel->kernelMSG));
+    Kernel->kernelMSG = gcvNULL;
 #endif
 	/* Free the gckKERNEL object. */
 	gcmkVERIFY_OK(gckOS_Free(Kernel->os, Kernel));
-
+    Kernel = gcvNULL;
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
@@ -791,6 +829,8 @@ gckKERNEL_Dispatch(
 
 #if !USE_NEW_LINUX_SIGNAL
 	case gcvHAL_USER_SIGNAL:
+     	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_KERNEL,
+				   "Dispatching gcvHAL_USER_SIGNAL %d", Interface->u.UserSignal.command);
 		/* Dispatch depends on the user signal subcommands. */
 		switch(Interface->u.UserSignal.command)
 		{
@@ -799,6 +839,7 @@ gckKERNEL_Dispatch(
 			gcmkONERROR(
 				gckOS_CreateUserSignal(Kernel->os,
 									   Interface->u.UserSignal.manualReset,
+                                       Interface->u.UserSignal.signalType,
 									   &Interface->u.UserSignal.id));
 			break;
 
@@ -840,11 +881,18 @@ gckKERNEL_Dispatch(
 		break;
 
     case gcvHAL_QUERY_POWER_MANAGEMENT_STATE:
+        /* Chip is not idle. */
+        Interface->u.QueryPowerManagement.isIdle = gcvFALSE;
+
 		/* Query the power management state. */
-		gcmkONERROR(
-			gckHARDWARE_QueryPowerManagementState(
-				Kernel->hardware,
-				&Interface->u.QueryPowerManagement.state));
+        gcmkONERROR(gckHARDWARE_QueryPowerManagementState(
+            Kernel->hardware,
+            &Interface->u.QueryPowerManagement.state));
+
+        /* Query the idle state. */
+        gcmkONERROR(
+            gckHARDWARE_QueryIdle(Kernel->hardware,
+                                  &Interface->u.QueryPowerManagement.isIdle));
         break;
 
     case gcvHAL_READ_REGISTER:
@@ -974,7 +1022,7 @@ gckKERNEL_Dispatch(
                                       Interface->u.Cache.bytes);
         }
 		break;
-
+    	
 	default:
 		/* Invalid command. */
 		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -1008,6 +1056,7 @@ gckKERNEL_AttachProcess(
 	)
 {
 	gceSTATUS status;
+    gctINT32 old;
 
 	gcmkHEADER_ARG("Kernel=0x%x Attach=%d", Kernel, Attach);
 
@@ -1016,29 +1065,25 @@ gckKERNEL_AttachProcess(
 
 	if (Attach)
 	{
-		if (Kernel->clients == 0)
-		{
-			/* First client attached, switch to ON power state. */
-			gcmkONERROR(
-				gckHARDWARE_SetPowerManagementState(Kernel->hardware,
-													gcvPOWER_ON));
-		}
+        /* Increment the number of clients attached. */
+        gcmkONERROR(
+            gckOS_AtomIncrement(Kernel->os, Kernel->atomClients, &old));
 
-		/* Increment the number of clients attached. */
-		Kernel->clients += 1;
-	}
+        if (old == 0)
+        {
+            /* gcmkONERROR(gckHARDWARE_SetPowerManagementState(Kernel->hardware, gcvPOWER_ON)); */
+        }
+    }
 
 	else
 	{
 		/* Decrement the number of clients attached. */
-		Kernel->clients -= 1;
+        gcmkONERROR(
+            gckOS_AtomDecrement(Kernel->os, Kernel->atomClients, &old));
 
-		if (Kernel->clients == 0)
+        if (old == 1)
 		{
-			/* Last client detached, switch to SUSPEND power state. */
-			gcmkONERROR(
-				gckHARDWARE_SetPowerManagementState(Kernel->hardware,
-													gcvPOWER_SUSPEND));
+            gcmkONERROR(gckHARDWARE_SetPowerManagementState(Kernel->hardware, gcvPOWER_OFF));
 
             /* Flush the debug cache. */
             gcmkPRINT("$$FLUSH$$");
@@ -1154,9 +1199,90 @@ gckKERNEL_MapLogicalToPhysical(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
     /* Return the status. */
     gcmkFOOTER();
     return status;
 }
 #endif
 
+/*******************************************************************************
+**
+**  gckKERNEL_Recovery
+**
+**  Try to recover the GPU from a fatal error.
+**
+**  INPUT:
+**
+**      gckKERNEL Kernel
+**          Pointer to an gckKERNEL object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckKERNEL_Recovery(
+    IN gckKERNEL Kernel
+    )
+{
+    gceSTATUS status;
+    gckEVENT event;
+    gckHARDWARE hardware;
+#if gcdSECURE_USER
+    gctUINT32 processID;
+#endif
+
+    gcmkHEADER_ARG("Kernel=0x%x", Kernel);
+
+    /* Validate the arguemnts. */
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+
+    /* Grab gckEVENT object. */
+    event = Kernel->event;
+    gcmkVERIFY_OBJECT(event, gcvOBJ_EVENT);
+
+    /* Grab gckHARDWARE object. */
+    hardware = Kernel->hardware;
+    gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
+
+    /* Handle all outstanding events now. */
+    event->pending = ~0U;
+    gcmkONERROR(gckEVENT_Notify(event, 1));
+
+    /* Again in case more events got submitted. */
+    event->pending = ~0U;
+    gcmkONERROR(gckEVENT_Notify(event, 2));
+
+#if gcdSECURE_USER
+    /* Flush the secure mapping cache. */
+    gcmkONERROR(gckOS_GetProcessID(&processID));
+    gcmkONERROR(gckKERNEL_MapLogicalToPhysical(Kernel, processID, gcvNULL));
+#endif
+
+    /* Try issuing a soft reset for the GPU. */
+    status = gckHARDWARE_Reset(hardware);
+    if (status == gcvSTATUS_NOT_SUPPORTED)
+    {
+        /* Switch to OFF power.  The next submit should return the GPU to ON
+        ** state. */
+        gcmkONERROR(
+            gckHARDWARE_SetPowerManagementState(hardware,
+                                                gcvPOWER_OFF_RECOVERY));
+    }
+    else
+    {
+        /* Bail out on reset error. */
+        gcmkONERROR(status);
+    }
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.h
index e3720d1..8daa449 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -50,43 +50,43 @@ gckLOGICAL_CACHE;
 /* gckKERNEL object. */
 struct _gckKERNEL
 {
-	/* Object. */
-	gcsOBJECT					object;
+    /* Object. */
+    gcsOBJECT                   object;
 
-	/* Pointer to gckOS object. */
-	gckOS						os;
+    /* Pointer to gckOS object. */
+    gckOS                       os;
 
-	/* Pointer to gckHARDWARE object. */
-	gckHARDWARE					hardware;
+    /* Pointer to gckHARDWARE object. */
+    gckHARDWARE                 hardware;
 
-	/* Pointer to gckCOMMAND object. */
-	gckCOMMAND					command;
+    /* Pointer to gckCOMMAND object. */
+    gckCOMMAND                  command;
 
-	/* Pointer to gckEVENT object. */
-	gckEVENT					event;
+    /* Pointer to gckEVENT object. */
+    gckEVENT                    event;
 
-	/* Pointer to context. */
-	gctPOINTER					context;
+    /* Pointer to context. */
+    gctPOINTER                  context;
 
-	/* Pointer to gckMMU object. */
-	gckMMU						mmu;
+    /* Pointer to gckMMU object. */
+    gckMMU                      mmu;
 
-	/* Number of attached clients. */
-	gctUINT						clients;
+    /* Arom holding number of clients. */
+    gctPOINTER                  atomClients;
 
 	/* Require to notify idle status */
 	gctBOOL						notifyIdle;
 
 #if VIVANTE_PROFILER
-	/* Enable profiling */
-	gctBOOL						profileEnable;
+    /* Enable profiling */
+    gctBOOL                     profileEnable;
 
-	/* The profile file name */
-	gctCHAR						profileFileName[gcdMAX_PROFILE_FILE_NAME];
+    /* The profile file name */
+    gctCHAR                     profileFileName[gcdMAX_PROFILE_FILE_NAME];
 #endif
 
 #if gcdSECURE_USER
-	gckLOGICAL_CACHE			cache[gcdSECURE_CACHE_SLOTS];
+    gckLOGICAL_CACHE            cache[gcdSECURE_CACHE_SLOTS];
     gctUINT                     cacheSlots;
     gctUINT64                   cacheTimeStamp;
 #endif
@@ -100,88 +100,97 @@ struct _gckKERNEL
     char*                       kernelMSG;
     /* The length of kernelMSG */
     gctINT32                    msgLen;
-#endif
+#endif    
 };
 
-#define gcdCOMMAND_QUEUES		2
+#define gcdCOMMAND_QUEUES       2
 
 /* gckCOMMAND object. */
 struct _gckCOMMAND
 {
-	/* Object. */
-	gcsOBJECT					object;
+    /* Object. */
+    gcsOBJECT                   object;
+
+    /* Pointer to required object. */
+    gckKERNEL                   kernel;
+    gckOS                       os;
 
-	/* Pointer to required object. */
-	gckKERNEL					kernel;
-	gckOS						os;
+    /* Number of bytes per page. */
+    gctSIZE_T                   pageSize;
 
-	/* Number of bytes per page. */
-	gctSIZE_T					pageSize;
+    /* Current pipe select. */
+    gctUINT32                   pipeSelect;
 
-	/* Current pipe select. */
-	gctUINT32					pipeSelect;
+    /* Command queue running flag. */
+    gctBOOL                     running;
 
-	/* Command queue running flag. */
-	gctBOOL						running;
+    /* Idle flag and commit stamp. */
+    gctBOOL                     idle;
+    gctUINT64                   commitStamp;
 
-	/* Idle flag and commit stamp. */
-	gctBOOL						idle;
-	gctUINT64					commitStamp;
+    /* Command queue mutex. */
+    gctPOINTER                  mutexQueue;
 
-	/* Command queue mutex. */
-	gctPOINTER					mutexQueue;
+    /* Context switching mutex. */
+    gctPOINTER                  mutexContext;
 
-	/* Context switching mutex. */
-	gctPOINTER					mutexContext;
+    /* Command queue power semaphore. */
+    gctPOINTER                  powerSemaphore;
 
-	/* Current command queue. */
-	struct _gcskCOMMAND_QUEUE
-	{
-		gctSIGNAL				signal;
-		gctPHYS_ADDR			physical;
-		gctPOINTER				logical;
-	}
-	queues[gcdCOMMAND_QUEUES];
+    /* Current command queue. */
+    struct _gcskCOMMAND_QUEUE
+    {
+        gctSIGNAL               signal;
+        gctPHYS_ADDR            physical;
+        gctPOINTER              logical;
+    }
+    queues[gcdCOMMAND_QUEUES];
 
-	gctPHYS_ADDR				physical;
-	gctPOINTER					logical;
-	gctINT						index;
-	gctUINT32					offset;
+    gctPHYS_ADDR                physical;
+    gctPOINTER                  logical;
+    gctINT                      index;
+    gctUINT32                   offset;
 
-	/* The command queue is new. */
-	gctBOOL						newQueue;
-	gctBOOL						submit;
+    /* The command queue is new. */
+    gctBOOL                     newQueue;
+    gctBOOL                     submit;
 
-	/* Context counter used for unique ID. */
-	gctUINT64					contextCounter;
+    /* Context counter used for unique ID. */
+    gctUINT64                   contextCounter;
 
-	/* Current context ID. */
-	gctUINT64					currentContext;
+    /* Current context ID. */
+    gctUINT64                   currentContext;
 
-	/* Pointer to last WAIT command. */
-	gctPOINTER					wait;
-	gctSIZE_T					waitSize;
+    /* Pointer to last WAIT command. */
+    gctPOINTER                  wait;
+    gctSIZE_T                   waitSize;
 
-	/* Command buffer alignment. */
-	gctSIZE_T					alignment;
-	gctSIZE_T					reservedHead;
-	gctSIZE_T					reservedTail;
+    /* Command buffer alignment. */
+    gctSIZE_T                   alignment;
+    gctSIZE_T                   reservedHead;
+    gctSIZE_T                   reservedTail;
+
+    /* Commit counter. */
+    gctPOINTER                  atomCommit;
+    
+    /* Dump command buffer and link chain when GC hangs */
+    gctBOOL                     dumpCmdBuf;
 };
 
-typedef struct _gcsEVENT *		gcsEVENT_PTR;
+typedef struct _gcsEVENT *      gcsEVENT_PTR;
 
 /* Structure holding one event to be processed. */
 typedef struct _gcsEVENT
 {
-	/* Pointer to next event in queue. */
-	gcsEVENT_PTR				next;
+    /* Pointer to next event in queue. */
+    gcsEVENT_PTR                next;
 
-	/* Event information. */
-	gcsHAL_INTERFACE			event;
+    /* Event information. */
+    gcsHAL_INTERFACE            event;
 
 #ifdef __QNXNTO__
-	/* Kernel. */
-	gckKERNEL                   kernel;
+    /* Kernel. */
+    gckKERNEL                   kernel;
 #endif
 }
 gcsEVENT;
@@ -189,204 +198,211 @@ gcsEVENT;
 /* Structure holding a list of events to be processed by an interrupt. */
 typedef struct _gcsEVENT_QUEUE
 {
-	/* Time stamp. */
-	gctUINT64					stamp;
+    /* Time stamp. */
+    gctUINT64                   stamp;
+
+    /* Source of the event. */
+    gceKERNEL_WHERE             source;
 
-	/* Source of the event. */
-	gceKERNEL_WHERE				source;
+    /* Pointer to head of event queue. */
+    gcsEVENT_PTR                head;
 
-	/* Pointer to head of event queue. */
-	gcsEVENT_PTR				head;
+    /* Pointer to tail of event queue. */
+    gcsEVENT_PTR                tail;
 
-	/* Pointer to tail of event queue. */
-	gcsEVENT_PTR				tail;
+    /* Process ID owning the event queue. */
+    gctUINT32                   processID;
 }
 gcsEVENT_QUEUE;
 
 /* gckEVENT object. */
 struct _gckEVENT
 {
-	/* The object. */
-	gcsOBJECT					object;
+    /* The object. */
+    gcsOBJECT                   object;
 
-	/* Pointer to required objects. */
-	gckOS						os;
-	gckKERNEL					kernel;
+    /* Pointer to required objects. */
+    gckOS                       os;
+    gckKERNEL                   kernel;
 
-	/* Time stamp. */
-	gctUINT64					stamp;
-	gctUINT64					lastCommitStamp;
+    /* Time stamp. */
+    gctUINT64                   stamp;
+    gctUINT64                   lastCommitStamp;
 
-	/* Queue mutex. */
-	gctPOINTER					mutexQueue;
+    /* Queue mutex. */
+    gctPOINTER                  mutexQueue;
 
-	/* Array of event queues. */
-	gcsEVENT_QUEUE				queues[31];
-	gctUINT8                    lastID;
+    /* Event counter */
+    gctPOINTER                  atomEventRef;
 
-	/* Pending events. */
-	volatile gctUINT			pending;
+    /* Array of event queues. */
+    gcsEVENT_QUEUE              queues[31];
+    gctUINT8                    lastID;
 
-	/* List of free event structures and its mutex. */
-	gcsEVENT_PTR				freeList;
-	gctSIZE_T					freeCount;
-	gctPOINTER					freeMutex;
+    /* Pending events. */
+    volatile gctUINT            pending;
 
-	/* Events queued to be added to an event queue and its mutex. */
-	gcsEVENT_QUEUE				list;
-	gctPOINTER					listMutex;
+    /* List of free event structures and its mutex. */
+    gcsEVENT_PTR                freeList;
+    gctSIZE_T                   freeCount;
+    gctPOINTER                  freeMutex;
+
+    /* Events queued to be added to an event queue and its mutex. */
+    gcsEVENT_QUEUE              list;
+    gctPOINTER                  listMutex;
 };
 
 /* gcuVIDMEM_NODE structure. */
 typedef union _gcuVIDMEM_NODE
 {
-	/* Allocated from gckVIDMEM. */
-	struct _gcsVIDMEM_NODE_VIDMEM
-	{
-		/* Owner of this node. */
-		gckVIDMEM				memory;
+    /* Allocated from gckVIDMEM. */
+    struct _gcsVIDMEM_NODE_VIDMEM
+    {
+        /* Owner of this node. */
+        gckVIDMEM               memory;
 
-		/* Dual-linked list of nodes. */
-		gcuVIDMEM_NODE_PTR		next;
-		gcuVIDMEM_NODE_PTR		prev;
+        /* Dual-linked list of nodes. */
+        gcuVIDMEM_NODE_PTR      next;
+        gcuVIDMEM_NODE_PTR      prev;
 
-		/* Dual linked list of free nodes. */
-		gcuVIDMEM_NODE_PTR		nextFree;
-		gcuVIDMEM_NODE_PTR		prevFree;
+        /* Dual linked list of free nodes. */
+        gcuVIDMEM_NODE_PTR      nextFree;
+        gcuVIDMEM_NODE_PTR      prevFree;
 
-		/* Information for this node. */
-		gctUINT32				offset;
-		gctSIZE_T				bytes;
-		gctUINT32				alignment;
+        /* Information for this node. */
+        gctUINT32               offset;
+        gctSIZE_T               bytes;
+        gctUINT32               alignment;
 
 #ifdef __QNXNTO__
-		/* Client/server vaddr (mapped using mmap_join). */
-		gctPOINTER				logical;
+        /* Client/server vaddr (mapped using mmap_join). */
+        gctPOINTER              logical;
 
-		/* Unique handle of the caller process channel. */
-		gctHANDLE				handle;
+        /* Unique handle of the caller process channel. */
+        gctHANDLE               handle;
 #endif
 
-		/* Locked counter. */
-		gctINT32				locked;
+        /* Locked counter. */
+        gctINT32                locked;
 
-		/* Memory pool. */
-		gcePOOL					pool;
-		gctUINT32				physical;
-	}
-	VidMem;
+        /* Memory pool. */
+        gcePOOL                 pool;
+        gctUINT32               physical;
+    }
+    VidMem;
 
-	/* Allocated from gckOS. */
-	struct _gcsVIDMEM_NODE_VIRTUAL
-	{
-		/* Pointer to gckKERNEL object. */
-		gckKERNEL				kernel;
+    /* Allocated from gckOS. */
+    struct _gcsVIDMEM_NODE_VIRTUAL
+    {
+        /* Pointer to gckKERNEL object. */
+        gckKERNEL               kernel;
 
-		/* Information for this node. */
-		gctBOOL					contiguous;
-		gctPHYS_ADDR			physical;
-		gctSIZE_T				bytes;
-		gctPOINTER				logical;
+        /* Information for this node. */
+        gctBOOL                 contiguous;
+        gctPHYS_ADDR            physical;
+        gctSIZE_T               bytes;
+        gctPOINTER              logical;
 
-		/* Page table information. */
-		gctSIZE_T				pageCount;
-		gctPOINTER				pageTable;
-		gctUINT32				address;
+        /* Page table information. */
+        gctSIZE_T               pageCount;
+        gctPOINTER              pageTable;
+        gctUINT32               address;
 
-		/* Mutex. */
-		gctPOINTER				mutex;
+        /* Mutex. */
+        gctPOINTER              mutex;
 
-		/* Locked counter. */
-		gctINT32				locked;
+        /* Locked counter. */
+        gctINT32                locked;
 
 #ifdef __QNXNTO__
-		/* Single linked list of nodes. */
-		gcuVIDMEM_NODE_PTR      next;
+        /* Single linked list of nodes. */
+        gcuVIDMEM_NODE_PTR      next;
 
-		/* PID of the caller process channel. */
-		gctUINT32				userPID;
+        /* PID of the caller process channel. */
+        gctUINT32               userPID;
 
-		/* Unique handle of the caller process channel. */
-		gctHANDLE				handle;
+        /* Unique handle of the caller process channel. */
+        gctHANDLE               handle;
 
-		/* Unlock pending flag. */
-		gctBOOL					unlockPending;
+        /* Unlock pending flag. */
+        gctBOOL                 unlockPending;
 
-		/* Free pending flag. */
-		gctBOOL                 freePending;
+        /* Free pending flag. */
+        gctBOOL                 freePending;
 #else
-		/* Pending flag. */
-		gctBOOL					pending;
+        /* Pending flag. */
+        gctBOOL                 pending;
 #endif
-	}
-	Virtual;
+    }
+    Virtual;
 }
 gcuVIDMEM_NODE;
 
 /* gckVIDMEM object. */
 struct _gckVIDMEM
 {
-	/* Object. */
-	gcsOBJECT					object;
+    /* Object. */
+    gcsOBJECT                   object;
 
-	/* Pointer to gckOS object. */
-	gckOS						os;
+    /* Pointer to gckOS object. */
+    gckOS                       os;
 
-	/* Information for this video memory heap. */
-	gctUINT32					baseAddress;
-	gctSIZE_T					bytes;
-	gctSIZE_T					freeBytes;
+    /* Information for this video memory heap. */
+    gctUINT32                   baseAddress;
+    gctSIZE_T                   bytes;
+    gctSIZE_T                   freeBytes;
 
-	/* Mapping for each type of surface. */
-	gctINT						mapping[gcvSURF_NUM_TYPES];
+    /* Mapping for each type of surface. */
+    gctINT                      mapping[gcvSURF_NUM_TYPES];
 
-	/* Sentinel nodes for up to 8 banks. */
-	gcuVIDMEM_NODE				sentinel[8];
+    /* Sentinel nodes for up to 8 banks. */
+    gcuVIDMEM_NODE              sentinel[8];
 
-	/* Allocation threshold. */
-	gctSIZE_T					threshold;
+    /* Allocation threshold. */
+    gctSIZE_T                   threshold;
 
     /* The heap mutex. */
-    gctPOINTER					mutex;
+    gctPOINTER                  mutex;
 };
 
 /* gckMMU object. */
 struct _gckMMU
 {
-	/* The object. */
-	gcsOBJECT					object;
+    /* The object. */
+    gcsOBJECT                   object;
 
-	/* Pointer to gckOS object. */
-	gckOS						os;
+    /* Pointer to gckOS object. */
+    gckOS                       os;
 
-	/* Pointer to gckHARDWARE object. */
-	gckHARDWARE					hardware;
+    /* Pointer to gckHARDWARE object. */
+    gckHARDWARE                 hardware;
 
-	/* The page table mutex. */
-	gctPOINTER					pageTableMutex;
+    /* The page table mutex. */
+    gctPOINTER                  pageTableMutex;
 
-	/* Page table information. */
-	gctSIZE_T					pageTableSize;
-	gctPHYS_ADDR				pageTablePhysical;
-	gctUINT32_PTR				pageTableLogical;
-	gctUINT32					pageTableEntries;
+    /* Page table information. */
+    gctSIZE_T                   pageTableSize;
+    gctPHYS_ADDR                pageTablePhysical;
+    gctUINT32_PTR               pageTableLogical;
+    gctUINT32                   pageTableEntries;
+	gctINT32					pageTableUsedEntries;
 
-	/* Free entries. */
-	gctUINT32					heapList;
-	gctBOOL						freeNodes;
+    /* Free entries. */
+    gctUINT32                   heapList;
+    gctBOOL                     freeNodes;
 
 #ifdef __QNXNTO__
-	/* Single linked list of all allocated nodes. */
-	gctPOINTER                  nodeMutex;
-	gcuVIDMEM_NODE_PTR          nodeList;
+    /* Single linked list of all allocated nodes. */
+    gctPOINTER                  nodeMutex;
+    gcuVIDMEM_NODE_PTR          nodeList;
 #endif
 };
 
 gceSTATUS
 gckKERNEL_AttachProcess(
-	IN gckKERNEL Kernel,
-	IN gctBOOL Attach
-	);
+    IN gckKERNEL Kernel,
+    IN gctBOOL Attach
+    );
 
 #if gcdSECURE_USER
 gceSTATUS
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_command.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_command.c
index c96c221..68d0f9d 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_command.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_command.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -43,20 +43,30 @@
 typedef struct _gcsRECORD_INFO * gcsRECORD_INFO_PTR;
 typedef struct _gcsRECORD_INFO
 {
-	gctUINT		count;
-	gctUINT		index;
-	gctUINT		tail;
+	gctUINT		    count;
+	gctUINT		    index;
+	gctUINT		    tail;
 }
 gcsRECORD_INFO;
 
+typedef enum _gceDUMPLOCATION
+{
+    gcvDUMP_NEW_QUEUE,
+    gcvDUMP_COMMIT,
+    gcvDUMP_EXECUTE,
+    gcvDUMP_STALL,
+    gcvDUMP_CMD,
+    gcvDUMP_EVENT,
+}
+gceDUMPLOCATION;
+
 typedef struct _gcsCMDBUF_RECORD * gcsCMDBUF_RECORD_PTR;
 typedef struct _gcsCMDBUF_RECORD
 {
-	gctUINT32_PTR	logical;
-	gctUINT		address;
-	gctUINT		size;
-	gctBOOL		context;
-	gctBOOL		queue;
+	gctPOINTER      logical;
+	gctUINT32		address;
+	gctSIZE_T		size;
+	gceDUMPLOCATION	location;
 }
 gcsCMDBUF_RECORD;
 
@@ -64,13 +74,13 @@ typedef struct _gcsLINK_RECORD * gcsLINK_RECORD_PTR;
 typedef struct _gcsLINK_RECORD
 {
 	gctUINT32_PTR	fromLogical;
-	gctUINT32	fromAddress;
+	gctUINT32	    fromAddress;
 	gctUINT32_PTR	toLogical;
-	gctUINT32	toAddress;
+	gctUINT32	    toAddress;
 }
 gcsLINK_RECORD;
 
-#define gcdRECORD_COUNT 1000
+#define gcdRECORD_COUNT 100
 
 static gctUINT _cmdQueueCount;
 
@@ -98,33 +108,38 @@ static void _AdvanceRecord(
 
 static void _AddCmdBuffer(
 	gckCOMMAND Command,
-	gctUINT32_PTR Logical,
+	gctUINT8_PTR Logical,
 	gctSIZE_T Size,
-	gctBOOL Context,
-	gctBOOL Queue
+	gceDUMPLOCATION Location
 	)
 {
 	gctUINT address;
 	gcsCMDBUF_RECORD_PTR record;
 
+    if(!Command->dumpCmdBuf)
+        return;
+
 	_AdvanceRecord(&_cmdInfo);
 
-	if (Queue)
+	if (Location == gcvDUMP_NEW_QUEUE)
 	{
 		_cmdQueueCount += 1;
 	}
 
-	gckHARDWARE_ConvertLogical(
-		Command->kernel->hardware, Logical, &address
-		);
+    gckHARDWARE_ConvertLogical(
+        Command->kernel->hardware, Logical, &address
+        );
+
+    if (Logical == gcvNULL)
+    {
+        address = ~0x00000000;
+    }
 
 	record = &_cmdRecord[_cmdInfo.index];
 
-	record->logical = Logical;
 	record->address = address;
 	record->size    = Size;
-	record->context = Context;
-	record->queue   = Queue;
+	record->location= Location;
 }
 
 static void _AddLink(
@@ -136,15 +151,28 @@ static void _AddLink(
 	gctUINT from, to;
 	gcsLINK_RECORD_PTR record;
 
+    if(!Command->dumpCmdBuf)
+        return;
+    
 	_AdvanceRecord(&_lnkInfo);
 
-	gckHARDWARE_ConvertLogical(
-		Command->kernel->hardware, From, &from
-		);
+    gckHARDWARE_ConvertLogical(
+        Command->kernel->hardware, From, &from
+        );
 
-	gckHARDWARE_ConvertLogical(
-		Command->kernel->hardware, To, &to
-		);
+    if (From == gcvNULL)
+    {
+        from = ~0x00000000;
+    }
+
+    gckHARDWARE_ConvertLogical(
+        Command->kernel->hardware, To, &to
+        );
+    
+    if (To == gcvNULL)
+    {
+        to = ~0x00000000;
+    }
 
 	record = &_lnkRecord[_lnkInfo.index];
 
@@ -154,13 +182,13 @@ static void _AddLink(
 	record->toAddress   = to;
 }
 
-static gcsCMDBUF_RECORD_PTR _FindCmdBuffer(
+static gctUINT _FindCmdBuffer(
 	gctUINT Address
 	)
 {
 	gctUINT i, j, first, last;
 
-	i = _cmdInfo.tail;
+	i = (_cmdInfo.tail - 1 + _cmdInfo.count) % gcdRECORD_COUNT;
 
 	for (j = 0; j < _cmdInfo.count; j += 1)
 	{
@@ -169,63 +197,142 @@ static gcsCMDBUF_RECORD_PTR _FindCmdBuffer(
 
 		if ((Address >= first) && (Address < last))
 		{
-			return &_cmdRecord[i];
+			return i;
 		}
 
-		i = (i + 1) % gcdRECORD_COUNT;
+		i = (i - 1 + gcdRECORD_COUNT) % gcdRECORD_COUNT;
 	}
 
-	return gcvNULL;
+	return gcdRECORD_COUNT;
 }
 
-static void _PrintBuffer(
-	gctUINT32_PTR Logical,
-	gctUINT Address,
-	gctUINT Size
+static void
+_PrintBuffer(
+    IN gckCOMMAND Command,
+    IN gctPOINTER Pointer,
+    IN gctSIZE_T Bytes,
+    IN gctUINT Address
+    )
+{
+    gctUINT32_PTR data = (gctUINT32_PTR) Pointer;
+    gctUINT32 address;
+    gctUINT32 printAddr;
+
+    if(Pointer == gcvNULL)
+    {
+        gcmkPRINT("@[kernel.command NULL pointer]");
+        return;
+    }
+    
+    gckOS_GetPhysicalAddress(Command->os, Pointer, &address);
+
+    gcmkPRINT("@[kernel.command %08X %08X", address, Bytes);
+
+    printAddr = address;
+    
+    while (Bytes >= 8*4)
+    {
+        if( (Address >= printAddr) && (Address < printAddr + 32))
+        {
+            gctINT i,j;
+            
+            i = (Address - printAddr)/4;
+            j = (Address - printAddr)%4;
+            gcmkPRINT("  GPU stop @ below data[%d], bytes[%d]", i, j);
+        }
+        
+        gcmkPRINT("  [%08X-%08X]: %08X %08X %08X %08X %08X %08X %08X %08X", 
+                    printAddr, printAddr + 32,
+                    data[0], data[1], data[2], data[3], data[4], data[5], data[6],
+                    data[7]);
+        
+        data        += 8;
+        Bytes       -= 32;
+        printAddr   += 32;
+    }
+
+    if( (Address >= printAddr) && (Address < printAddr + 32))
+    {
+        gctINT i,j;
+        
+        i = (Address - printAddr)/4;
+        j = (Address - printAddr)%4;
+        gcmkPRINT("  GPU stop @ below data[%d], bytes[%d]", i, j);
+    }
+            
+    switch (Bytes)
+    {
+    case 7*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X %08X %08X %08X %08X %08X", printAddr,
+                  data[0], data[1], data[2], data[3], data[4], data[5], data[6]);
+        break;
+
+    case 6*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X %08X %08X %08X %08X", printAddr,
+                  data[0], data[1], data[2], data[3], data[4], data[5]);
+        break;
+
+    case 5*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X %08X %08X %08X", printAddr,
+                  data[0], data[1], data[2], data[3], data[4]);
+        break;
+
+    case 4*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X %08X %08X", printAddr, data[0], data[1], data[2], data[3]);
+        break;
+
+    case 3*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X %08X", printAddr, data[0], data[1], data[2]);
+        break;
+
+    case 2*4:
+        gcmkPRINT("  [%08X-        ]: %08X %08X", printAddr, data[0], data[1]);
+        break;
+
+    case 1*4:
+        gcmkPRINT("  [%08X-        ]: %08X", printAddr, data[0]);
+        break;
+
+    default:
+        break;
+    }
+
+    gcmkPRINT("] -- command");
+}
+
+void _PrintLinkChain(
+	gckCOMMAND Command
 	)
 {
-	gctUINT i;
-	gctUINT value;
+	gctUINT i, j;
+    
+	gcmkPRINT("\nLink chain:\n\n");
 
-	for (i = 0; i < Size; i += 4)
-	{
-		value = * Logical;
-		Logical += 1;
+	i = _lnkInfo.tail;
 
-		if ((i % 16) == 0)
-		{
-			gcmTRACE(0, "0x%08X: ", Address + i);
-		}
+	for (j = 0; j < _lnkInfo.count; j += 1)
+	{
+		gcmkPRINT("  LINK 0x%08X --> 0x%08X\n",
+			_lnkRecord[i].fromAddress,
+			_lnkRecord[i].toAddress
+			);
 
-		if (i + 4 < Size)
-		{
-			if (((i + 4) % 16) == 0)
-			{
-				gcmTRACE(0, "0x%08X,\n", value);
-			}
-			else
-			{
-				gcmTRACE(0, "0x%08X, ", value);
-			}
-		}
-		else
-		{
-			gcmTRACE(0, "0x%08X\n", value);
-		}
+		i = (i + 1) % gcdRECORD_COUNT;
 	}
 }
 
-static void _PrintCmdBuffer(
+gceSTATUS
+_PrintCmdBuffer(
 	gckCOMMAND Command,
 	gctUINT Address
 	)
 {
-	gctUINT i, j, first, last;
+    gceSTATUS status;
+	gctUINT i, j, first, last, bufIndex;
 	gcsCMDBUF_RECORD_PTR buffer;
 	gctUINT address;
-
-	gcmTRACE(0,
-		"\n%s(%d):\n"
+    
+	gcmkPRINT("\n%s(%d):\n"
 		"  number of buffers stored %d;\n"
 		"  buffer list:\n\n",
 		__FUNCTION__, __LINE__, _cmdInfo.count
@@ -238,93 +345,138 @@ static void _PrintCmdBuffer(
 		first = _cmdRecord[i].address;
 		last  = first + _cmdRecord[i].size;
 
-		gcmTRACE(0,
-			"  0x%08X-0x%08X%s%s\n",
+		gcmkPRINT("  0x%08X-0x%08X Location:%d\n",
 			first,
 			last,
-			_cmdRecord[i].context ? " context" : "",
-			_cmdRecord[i].queue   ? " queue"   : ""
+			_cmdRecord[i].location
 			);
 
 		i = (i + 1) % gcdRECORD_COUNT;
 	}
 
-	buffer = _FindCmdBuffer(Address);
+	bufIndex = _FindCmdBuffer(Address);
 
-	if (buffer == gcvNULL)
+	if (bufIndex == gcdRECORD_COUNT)
 	{
-		gcmTRACE(0,
-			"\n*** buffer not found for the specified location ***\n"
-			);
+		gcmkPRINT("\n*** buffer not found for the specified location ***\n");
 	}
 	else
 	{
+        buffer = &_cmdRecord[bufIndex];
 		first = buffer->address;
 		last  = first + buffer->size;
 
-		gcmTRACE(0,
-			"\n%s(%d): buffer found 0x%08X-0x%08X%s%s:\n\n",
+		gcmkPRINT("\n%s(%d): buffer found 0x%08X-0x%08X Location:%d:\n\n",
 			__FUNCTION__, __LINE__,
 			first,
 			last,
-			buffer->context ? " context" : "",
-			buffer->context ? " queue"   : ""
+			buffer->location
 			);
-
-		_PrintBuffer(buffer->logical, buffer->address, buffer->size);
+        
+        gckOS_MapPhysical(Command->os, buffer->address, 0, buffer->size, &buffer->logical);
+        _PrintBuffer(Command, buffer->logical, buffer->size, Address);
+        
+        gckOS_DumpToFile(Command->os, 
+                        "/data/dumpGC_CMDBUF.bin", 
+                        buffer->logical,
+                        buffer->size);
+        
+        gckOS_UnmapPhysical(Command->os, buffer->logical, buffer->size);
 	}
 
-	gckHARDWARE_ConvertLogical(
-		Command->kernel->hardware, Command->logical, &address
-		);
+    gcmkONERROR(
+        gckHARDWARE_ConvertLogical(Command->kernel->hardware, Command->logical, &address)
+        );
 
 	first = address;
 	last  = first + Command->pageSize;
 
-	gcmTRACE(0,
-		"\nCommand queue N%d: 0x%08X-0x%08X:\n\n",
+	gcmkPRINT("\nCommand queue N%d: 0x%08X-0x%08X:\n\n",
 		_cmdQueueCount,
 		first,
 		last
 		);
 
-	_PrintBuffer(Command->logical, address, Command->pageSize);
+    _PrintBuffer(Command, Command->logical, Command->pageSize, Address);
+
+    gckOS_DumpToFile(Command->os, 
+                    "/data/dumpGC_CMDQUE.bin", 
+                    Command->logical,
+                    Command->pageSize);
+
+    _PrintLinkChain(Command);
+
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    return status;
 }
 
-static void _PrintLinkChain(
-	void
+gceSTATUS
+_PrintAllCmdBuffer(
+	gckCOMMAND Command
 	)
 {
-	gctUINT i, j;
-
-	gcmTRACE(0, "\nLink chain:\n\n");
+    gceSTATUS status;
+	gctUINT i, j, first, last;
+	gcsCMDBUF_RECORD_PTR buffer;
+	gctUINT address;
+    
+	gcmkPRINT("\n%s(%d):\n"
+		"  number of buffers stored %d;\n"
+		"  buffer list:\n\n",
+		__FUNCTION__, __LINE__, _cmdInfo.count
+		);
 
-	i = _lnkInfo.tail;
+	i = _cmdInfo.tail;
 
-	for (j = 0; j < _lnkInfo.count; j += 1)
+	for (j = 0; j < _cmdInfo.count; j += 1)
 	{
-		gcmTRACE(0,
-			"  LINK 0x%08X --> 0x%08X\n",
-			_lnkRecord[i].fromAddress,
-			_lnkRecord[i].toAddress
+		first = _cmdRecord[i].address;
+		last  = first + _cmdRecord[i].size;
+
+		gcmkPRINT("  0x%08X-0x%08X Location:%d\n",
+			first,
+			last,
+			_cmdRecord[i].location
 			);
 
+        {
+    		buffer = &_cmdRecord[i];
+            
+            gckOS_MapPhysical(Command->os, buffer->address, 0, buffer->size, &buffer->logical);
+            _PrintBuffer(Command, buffer->logical, buffer->size, 0xFFFFFFFF);
+            gckOS_UnmapPhysical(Command->os, buffer->logical, buffer->size);
+	    }
+
 		i = (i + 1) % gcdRECORD_COUNT;
 	}
+
+    gcmkONERROR(
+        gckHARDWARE_ConvertLogical(Command->kernel->hardware, Command->logical, &address)
+        );
+
+	first = address;
+	last  = first + Command->pageSize;
+
+	gcmkPRINT("\nCommand queue N%d: 0x%08X-0x%08X:\n\n",
+		_cmdQueueCount,
+		first,
+		last
+		);
+
+    _PrintBuffer(Command, Command->logical, Command->pageSize, 0xFFFFFFFF);
+
+    _PrintLinkChain(Command);
+
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    return status;
 }
 #endif
-/*
-#define MRVL_DUMP_COMMAND
-*/
-#ifdef MRVL_DUMP_COMMAND
-#include <linux/types.h>
-#include <linux/stat.h>
-#include <linux/fcntl.h>
-#include <linux/unistd.h>
-#include <linux/uaccess.h>
-#include <linux/fs.h>
-#include "gc_hal_kernel.h"
-#endif
 
 #if gcdDUMP_COMMAND
 static void
@@ -337,36 +489,9 @@ _DumpCommand(
     gctUINT32_PTR data = (gctUINT32_PTR) Pointer;
     gctUINT32 address;
 
-#ifdef MRVL_DUMP_COMMAND
-	struct file* pDump_Cmd = 0;
-
-	mm_segment_t old_fs;
-
-	pDump_Cmd = filp_open("./dump_cmd.bin",O_WRONLY | O_CREAT | O_APPEND,0644);
-
-	if (pDump_Cmd == 0)
-	{
-		gcmkPRINT("open file dump_cmd.bin failed!\n");
-
-		return;
-	}
-
-	old_fs = get_fs();
-
-	set_fs(KERNEL_DS);
-
-	pDump_Cmd->f_op->write(pDump_Cmd,Pointer,Bytes,&pDump_Cmd->f_pos);
-
-	set_fs(old_fs);
-	
-	filp_close(pDump_Cmd,0);
-
-	return;
-#endif
-
     gckOS_GetPhysicalAddress(Command->os, Pointer, &address);
 
-    gcmkPRINT("@[kernel.command %08X %08X", address, Bytes);
+    gcmkPRINT("@[kernel.command %08X %08X %08X", Pointer, address, Bytes);
     while (Bytes >= 8*4)
     {
         gcmkPRINT("  %08X %08X %08X %08X %08X %08X %08X %08X",
@@ -433,14 +558,13 @@ _DumpCommand(
 */
 static gceSTATUS
 _NewQueue(
-    IN OUT gckCOMMAND Command,
-	IN gctBOOL Locking
+    IN OUT gckCOMMAND Command
     )
 {
     gceSTATUS status;
 	gctINT currentIndex, newIndex;
 
-	gcmkHEADER_ARG("Command=0x%x Locking=%d", Command, Locking);
+    gcmkHEADER_ARG("Command=0x%x", Command);
 
 	/* Switch to the next command buffer. */
 	currentIndex = Command->index;
@@ -451,21 +575,16 @@ _NewQueue(
 #if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.waitsignal]");
 #endif
+#if MRVL_PRINT_CMD_BUFFER
+    _AddCmdBuffer(
+        Command, gcvNULL, 0, gcvDUMP_NEW_QUEUE);
+#endif
 
 	gcmkONERROR(
 		gckOS_WaitSignal(Command->os,
 						 Command->queues[newIndex].signal,
 						 gcvINFINITE));
-
-    if (currentIndex >= 0)
-    {
-        /* Mark the command queue as available. */
-        gcmkONERROR(gckEVENT_Signal(Command->kernel->event,
-                                    Command->queues[currentIndex].signal,
-                                    gcvKERNEL_PIXEL,
-									Locking));
-    }
-
+    
     /* Update gckCOMMAND object with new command queue. */
 	Command->index    = newIndex;
     Command->newQueue = gcvTRUE;
@@ -475,6 +594,10 @@ _NewQueue(
 
     if (currentIndex >= 0)
     {
+        /* Mark the command queue as available. */
+        gcmkONERROR(gckEVENT_Signal(Command->kernel->event,
+                                    Command->queues[currentIndex].signal,
+                                    /*gcvKERNEL_COMMAND*/gcvKERNEL_PIXEL));
         /* Submit the event queue. */
         Command->submit = gcvTRUE;
     }
@@ -484,6 +607,7 @@ _NewQueue(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("index=%d, curIdx=%d, submit=%d", Command->index, currentIndex, Command->submit);
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -537,14 +661,17 @@ gckCOMMAND_Construct(
 					   (gctPOINTER *) &command));
 
 	/* Initialize the gckCOMMAND object.*/
-	command->object.type  = gcvOBJ_COMMAND;
-	command->kernel       = Kernel;
-	command->os           = os;
-	command->mutexQueue   = gcvNULL;
-	command->mutexContext = gcvNULL;
+    command->object.type    = gcvOBJ_COMMAND;
+    command->kernel         = Kernel;
+    command->os             = os;
+    command->mutexQueue     = gcvNULL;
+    command->mutexContext   = gcvNULL;
+    command->powerSemaphore = gcvNULL;
+    command->atomCommit     = gcvNULL;
 
     /* No command queues created yet. */
 	command->index = 0;
+    
 	for (i = 0; i < gcdCOMMAND_QUEUES; ++i)
 	{
 		command->queues[i].signal  = gcvNULL;
@@ -569,6 +696,13 @@ gckCOMMAND_Construct(
 	gcmkONERROR(
 		gckOS_CreateMutex(os, &command->mutexContext));
 
+    /* Create the power management semaphore. */
+    gcmkONERROR(
+        gckOS_CreateSemaphore(os, &command->powerSemaphore));
+
+    /* Create the commit atom. */
+    gcmkONERROR(gckOS_AtomConstruct(os, &command->atomCommit));
+
 	/* Get the page size from teh OS. */
 	gcmkONERROR(
 		gckOS_GetPageSize(os, &command->pageSize));
@@ -607,6 +741,9 @@ gckCOMMAND_Construct(
 	/* Commit stamp is zero. */
 	command->commitStamp = 0;
 
+    /* Don't dump command buffer and link chain by default */
+    command->dumpCmdBuf = gcvFALSE;
+
     /* Return pointer to the gckCOMMAND object. */
 	*Command = command;
 
@@ -618,14 +755,32 @@ OnError:
 	/* Roll back. */
 	if (command != gcvNULL)
 	{
+	    /* Destroy the commit atom. */
+        if (command->atomCommit != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_AtomDestroy(os, command->atomCommit));
+            command->atomCommit = gcvNULL;
+        }
+
+        /* Destroy the power management semaphore. */
+        if (command->powerSemaphore != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_DestroySemaphore(os, command->powerSemaphore));
+            command->powerSemaphore = gcvNULL;
+        }
+
+        /* Delete the context switching mutex. */
 		if (command->mutexContext != gcvNULL)
 		{
 			gcmkVERIFY_OK(gckOS_DeleteMutex(os, command->mutexContext));
+            command->mutexContext = gcvNULL;
 		}
 
+        /* Delete the command queue mutex. */
 		if (command->mutexQueue != gcvNULL)
 		{
 			gcmkVERIFY_OK(gckOS_DeleteMutex(os, command->mutexQueue));
+            command->mutexQueue = gcvNULL;
 		}
 
 		for (i = 0; i < gcdCOMMAND_QUEUES; ++i)
@@ -634,21 +789,30 @@ OnError:
 			{
 				gcmkVERIFY_OK(
 					gckOS_DestroySignal(os, command->queues[i].signal));
+
+                command->queues[i].signal = gcvNULL;
 			}
 
-			if (command->queues[i].logical != gcvNULL)
+			if (command->queues[i].physical != gcvNULL ||
+                command->queues[i].logical != gcvNULL
+                )
 			{
 				gcmkVERIFY_OK(
 					gckOS_FreeNonPagedMemory(os,
 											 command->pageSize,
 											 command->queues[i].physical,
 											 command->queues[i].logical));
+                command->queues[i].physical = gcvNULL;
+                command->queues[i].logical  = gcvNULL;
 			}
 		}
 
 		gcmkVERIFY_OK(gckOS_Free(os, command));
+
+        command = gcvNULL;
 	}
 
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -675,34 +839,66 @@ gckCOMMAND_Destroy(
 	)
 {
 	gctINT i;
-
+	gceSTATUS status;
 	gcmkHEADER_ARG("Command=0x%x", Command);
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Command, gcvOBJ_COMMAND);
 
 	/* Stop the command queue. */
-	gcmkVERIFY_OK(gckCOMMAND_Stop(Command));
+	gcmkONERROR(gckCOMMAND_Stop(Command));
 
 	for (i = 0; i < gcdCOMMAND_QUEUES; ++i)
 	{
-		gcmkASSERT(Command->queues[i].signal != gcvNULL);
-		gcmkVERIFY_OK(
-			gckOS_DestroySignal(Command->os, Command->queues[i].signal));
+		if (Command->queues[i].signal != gcvNULL)
+		{
+			gcmkVERIFY_OK(
+				gckOS_DestroySignal(Command->os, Command->queues[i].signal));
 
-		gcmkASSERT(Command->queues[i].logical != gcvNULL);
-		gcmkVERIFY_OK(
-			gckOS_FreeNonPagedMemory(Command->os,
-									 Command->pageSize,
-									 Command->queues[i].physical,
-									 Command->queues[i].logical));
+            Command->queues[i].signal = gcvNULL;
+		}
+
+		if (Command->queues[i].physical != gcvNULL ||
+            Command->queues[i].logical != gcvNULL)
+		{
+			gcmkVERIFY_OK(
+				gckOS_FreeNonPagedMemory(Command->os,
+										 Command->pageSize,
+										 Command->queues[i].physical,
+										 Command->queues[i].logical));
+            
+            Command->queues[i].physical = gcvNULL;
+            Command->queues[i].logical  = gcvNULL;
+		}
 	}
 
     /* Delete the context switching mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexContext));
+	if (Command->mutexContext != gcvNULL)
+	{
+		gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexContext));
+        Command->mutexContext = gcvNULL;
+	}
+
+    /* Delete the Command queue mutex. */
+	if (Command->mutexQueue != gcvNULL)
+	{
+		gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexQueue));
+        Command->mutexQueue = gcvNULL;
+	}
 
-    /* Delete the command queue mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Command->os, Command->mutexQueue));
+    /* Destroy the power management semaphore. */
+    if (Command->powerSemaphore != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DestroySemaphore(Command->os, Command->powerSemaphore));
+        Command->powerSemaphore = gcvNULL;
+    }
+
+    /* Destroy the commit atom. */
+    if (Command->atomCommit != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Command->os, Command->atomCommit));
+        Command->atomCommit = gcvNULL;
+    }
 
 	/* Mark object as unknown. */
 	Command->object.type = gcvOBJ_UNKNOWN;
@@ -710,9 +906,17 @@ gckCOMMAND_Destroy(
 	/* Free the gckCOMMAND object. */
 	gcmkVERIFY_OK(gckOS_Free(Command->os, Command));
 
+    Command = gcvNULL;
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
+    
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
 }
 
 /*******************************************************************************
@@ -758,13 +962,7 @@ gckCOMMAND_Start(
 	if (Command->logical == gcvNULL)
 	{
 		/* Start at beginning of a new queue. */
-		gcmkONERROR(_NewQueue(Command, gcvFALSE));
-        
-#if MRVL_PRINT_CMD_BUFFER
-        _AddCmdBuffer(
-            Command, Command->logical, Command->pageSize, gcvFALSE, gcvTRUE
-            );
-#endif
+        gcmkONERROR(_NewQueue(Command));
 	}
 
 	/* Start at beginning of page. */
@@ -780,6 +978,12 @@ gckCOMMAND_Start(
 							 &Command->wait,
 							 &Command->waitSize));
 
+    /* Flush the cache for the wait/link. */
+    gcmkONERROR(gckOS_CacheFlush(Command->os,
+                                 gcvNULL,
+                                 Command->logical,
+                                 bytes));
+
     /* Adjust offset. */
     Command->offset   = bytes;
 	Command->newQueue = gcvFALSE;
@@ -806,6 +1010,7 @@ gckCOMMAND_Start(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -833,7 +1038,7 @@ gckCOMMAND_Stop(
 {
     gckHARDWARE hardware;
 	gceSTATUS status;
-	gctUINT32 idle;
+    gctUINT32 idle;
 
 	gcmkHEADER_ARG("Command=0x%x", Command);
 
@@ -858,9 +1063,23 @@ gckCOMMAND_Stop(
 						&Command->waitSize));
 
 	/* Wait for idle. */
-	gcmkONERROR(
-		gckHARDWARE_GetIdle(hardware, gcvTRUE, &idle));
 
+	while (1)
+	{
+		/* Read register. */
+		gcmkONERROR(
+			gckOS_ReadRegister(hardware->os, 0x00004, &idle));
+
+		/* Wait for FE idle. */
+		if (idle & 0x1)
+		{        
+			break;
+		}
+
+		/* Wait a little. */
+		gcmkVERIFY_OK(gckOS_Udelay(hardware->os, 1));
+	}
+    
 	/* Command queue is no longer running. */
 	Command->running = gcvFALSE;
 
@@ -869,6 +1088,7 @@ gckCOMMAND_Stop(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, Command=0x%08x", status, Command);
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -923,16 +1143,18 @@ _AddMap(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, map=0x%08x", status, map);
 	if (gcmIS_ERROR(status) && (map != gcvNULL))
 	{
 		/* Roll back on error. */
 		gcmkVERIFY_OK(gckOS_Free(Os, map));
+        map = gcvNULL;
 	}
 
 	/* Return the status. */
 	return status;
 }
-
+#define LATE_NOTIFY_BUSY 0
 /*******************************************************************************
 **
 **	gckCOMMAND_Commit
@@ -964,7 +1186,7 @@ gckCOMMAND_Commit(
 {
     gcoCMDBUF commandBuffer;
     gcoCONTEXT context;
-	gckHARDWARE hardware;
+    gckHARDWARE hardware = gcvNULL;
 	gceSTATUS status;
 	gctPOINTER initialLink, link;
 	gctSIZE_T bytes, initialSize, lastRun;
@@ -976,7 +1198,7 @@ gckCOMMAND_Commit(
 	gctSIZE_T fetchSize;
 	gctUINT8_PTR logical;
 	gcsMAPPED_PTR stack = gcvNULL;
-	gctINT acquired = 0;
+	gctBOOL acquired = gcvFALSE;
 #if gcdSECURE_USER
 	gctUINT32_PTR hint;
 #endif
@@ -984,6 +1206,10 @@ gckCOMMAND_Commit(
     gctPOINTER dataPointer;
     gctSIZE_T dataBytes;
 #endif
+#if MRVL_PRINT_CMD_BUFFER
+    gctPOINTER dumpLogical;
+    gctSIZE_T dumpSize;
+#endif
     gctPOINTER flushPointer;
     gctSIZE_T flushSize;
 
@@ -1018,13 +1244,30 @@ gckCOMMAND_Commit(
 	hardware = Command->kernel->hardware;
 	gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
 
-	/* Acquire the context switching mutex. */
+	/* Grab the mutex. */
 	gcmkONERROR(
-		gckOS_AcquireMutex(Command->os,
-						   Command->mutexContext,
+		gckOS_AcquireRecMutex(Command->os,
+						   hardware->recMutexPower,
 						   gcvINFINITE));
+	acquired = gcvTRUE;
 
-	++acquired;
+#if !LATE_NOTIFY_BUSY
+    gcmkONERROR(gckHARDWARE_SetPowerManagementState(hardware, gcvPOWER_ON));
+
+	if (Command->kernel->notifyIdle)
+	{
+		/* Increase the commit stamp */
+		Command->commitStamp++;
+
+		/* Set busy if idle */
+		if (Command->idle)
+		{
+			Command->idle = gcvFALSE;
+
+			gcmkVERIFY_OK(gckOS_NotifyIdle(Command->os, gcvFALSE));
+		}
+	}
+#endif
 
 	/* Reserved slot in the context or command buffer. */
 	gcmkONERROR(
@@ -1102,12 +1345,6 @@ gckCOMMAND_Commit(
 		/* Save initial link pointer. */
         initialLink = logical;
 		initialSize = context->bufferSize;
-        
-#if MRVL_PRINT_CMD_BUFFER
-		_AddCmdBuffer(
-			Command, initialLink, initialSize, gcvTRUE, gcvFALSE
-			);
-#endif
 
         /* Save initial buffer to flush. */
         flushPointer = initialLink;
@@ -1219,12 +1456,6 @@ gckCOMMAND_Commit(
 		initialSize = commandBuffer->offset
 					- commandBuffer->startOffset
 					+ Command->reservedTail;
-        
-#if MRVL_PRINT_CMD_BUFFER
-		_AddCmdBuffer(
-			Command, initialLink, initialSize, gcvFALSE, gcvFALSE
-			);
-#endif
 
         /* Save initial buffer to flush. */
         flushPointer = initialLink;
@@ -1246,6 +1477,11 @@ gckCOMMAND_Commit(
     dataBytes   = initialSize;
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+    dumpLogical  = initialLink;
+    dumpSize     = initialSize;
+#endif
+
 	/* Loop through all remaining command buffers. */
 	if (buffer != gcvNULL)
 	{
@@ -1256,11 +1492,6 @@ gckCOMMAND_Commit(
 					buffer->offset + Command->reservedTail,
 					(gctPOINTER *) &logical,
 					&stack));
-#if MRVL_PRINT_CMD_BUFFER
-		_AddCmdBuffer(
-			Command, (gctUINT32_PTR)logical, buffer->offset + Command->reservedTail, gcvFALSE, gcvFALSE
-			);
-#endif
 
 #if gcdSECURE_USER
 		/* Map the hint table. */
@@ -1314,7 +1545,7 @@ gckCOMMAND_Commit(
 							 + Command->reservedTail,
 							 &bytes));
 #if MRVL_PRINT_CMD_BUFFER
-	_AddLink(Command, link, (gctUINT32_PTR)logical);
+	    _AddLink(Command, link, (gctUINT32_PTR)logical);
 #endif
 
         /* Flush the initial buffer. */
@@ -1336,6 +1567,14 @@ gckCOMMAND_Commit(
                     + Command->reservedTail;
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+		_AddCmdBuffer(
+			Command, dumpLogical, dumpSize, gcvDUMP_CMD);
+        dumpLogical  = logical + buffer->startOffset;
+        dumpSize     = buffer->offset - buffer->startOffset
+                    + Command->reservedTail;
+#endif
+
 		/* Save pointer to next link. */
         link = logical + buffer->offset;
 	}
@@ -1351,13 +1590,8 @@ gckCOMMAND_Commit(
 
 	lastRun = bytes;
 
-	/* Grab the command queue mutex. */
-	gcmkONERROR(
-		gckOS_AcquireMutex(Command->os,
-						   Command->mutexQueue,
-						   gcvINFINITE));
-
-	++acquired;
+#if LATE_NOTIFY_BUSY
+    gcmkONERROR(gckHARDWARE_SetPowerManagementState(hardware, gcvPOWER_ON));
 
 	if (Command->kernel->notifyIdle)
 	{
@@ -1372,6 +1606,7 @@ gckCOMMAND_Commit(
 			gcmkVERIFY_OK(gckOS_NotifyIdle(Command->os, gcvFALSE));
 		}
 	}
+#endif
 
 	/* Compute number of bytes left in current command queue. */
 	bytes = Command->pageSize - Command->offset;
@@ -1379,7 +1614,7 @@ gckCOMMAND_Commit(
 	if (bytes < lastRun)
 	{
         /* Create a new command queue. */
-		gcmkONERROR(_NewQueue(Command, gcvTRUE));
+        gcmkONERROR(_NewQueue(Command));
 
 		/* Adjust run size with any extra commands inserted. */
 		lastRun += Command->offset;
@@ -1409,6 +1644,10 @@ gckCOMMAND_Commit(
     _DumpCommand(Command, (gctUINT8 *) Command->logical + offset, bytes);
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+	_AddCmdBuffer(Command, (gctUINT8 *) Command->logical + offset, bytes, gcvDUMP_CMD);
+#endif
+
 	/* Adjust offset. */
 	offset += bytes;
 
@@ -1448,6 +1687,10 @@ gckCOMMAND_Commit(
     _DumpCommand(Command, dataPointer, dataBytes);
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+	_AddCmdBuffer(Command, dumpLogical, dumpSize, gcvDUMP_CMD);
+#endif
+
 	/* Execute the entire sequence. */
 	gcmkONERROR(
 		gckHARDWARE_Link(hardware,
@@ -1466,6 +1709,10 @@ gckCOMMAND_Commit(
     _DumpCommand(Command, Command->wait, Command->waitSize);
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+	_AddCmdBuffer(Command, Command->wait, Command->waitSize, gcvDUMP_CMD);
+#endif
+
 	/* Update command queue offset. */
 	Command->offset   = offset;
 	Command->newQueue = gcvFALSE;
@@ -1488,19 +1735,15 @@ gckCOMMAND_Commit(
     gcmkPRINT("@[kernel.commit]");
 #endif
 
-    /* Release the command queue mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexQueue));
-    --acquired;
-
-    /* Release the context switching mutex. */
-    gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexContext));
-    --acquired;
+    /* Release the mutex. */
+    gcmkONERROR(gckOS_ReleaseRecMutex(Command->os, hardware->recMutexPower));
+    acquired = gcvFALSE;
 
     /* Submit events if asked for. */
     if (Command->submit)
     {
         /* Submit events. */
-        status = gckEVENT_Submit(Command->kernel->event, gcvFALSE, gcvFALSE);
+        status = gckEVENT_Submit(Command->kernel->event, gcvFALSE);
 
         if (gcmIS_SUCCESS(status))
         {
@@ -1519,18 +1762,17 @@ gckCOMMAND_Commit(
     status = gcvSTATUS_OK;
 
 OnError:
-	if (acquired > 1)
-	{
-		/* Release the command queue mutex. */
-		gcmkVERIFY_OK(
-			gckOS_ReleaseMutex(Command->os, Command->mutexQueue));
-	}
-
-	if (acquired > 0)
+    if (!gcmIS_SUCCESS(status))
+    {
+        gcmkLOG_ERROR_ARGS("status=%d, acquired=%d",
+                            status, acquired);
+    }
+    
+	if (acquired)
 	{
-		/* Release the context switching mutex. */
+		/* Release the mutex. */
 		gcmkVERIFY_OK(
-			gckOS_ReleaseMutex(Command->os, Command->mutexContext));
+			gckOS_ReleaseRecMutex(Command->os, hardware->recMutexPower));
 	}
 
 	/* Unmap all mapped pointers. */
@@ -1582,7 +1824,6 @@ gceSTATUS
 gckCOMMAND_Reserve(
     IN gckCOMMAND Command,
     IN gctSIZE_T RequestedBytes,
-	IN gctBOOL Locking,
     OUT gctPOINTER * Buffer,
     OUT gctSIZE_T * BufferSize
     )
@@ -1591,22 +1832,36 @@ gckCOMMAND_Reserve(
     gctSIZE_T requiredBytes, bytes;
     gctBOOL acquired = gcvFALSE;
 
-    gcmkHEADER_ARG("Command=0x%x RequestedBytes=%lu Locking=%d",
-					Command, RequestedBytes, Locking);
+    gcmkHEADER_ARG("Command=0x%x RequestedBytes=%lu", Command, RequestedBytes);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Command, gcvOBJ_COMMAND);
+    
+    /* Grab the mutex. */
+    gcmkONERROR(
+        gckOS_AcquireRecMutex(Command->os,
+                           Command->kernel->hardware->recMutexPower,
+                           gcvINFINITE));
+    acquired = gcvTRUE;
 
-	if (!Locking)
+#if !LATE_NOTIFY_BUSY
+    gcmkONERROR(gckHARDWARE_SetPowerManagementState(Command->kernel->hardware, gcvPOWER_ON)); 
+
+    if (Command->kernel->notifyIdle)
 	{
-	    /* Grab the conmmand queue mutex. */
-    	gcmkONERROR(
-        	gckOS_AcquireMutex(Command->os,
-            	               Command->mutexQueue,
-                	           gcvINFINITE));
-	    acquired = gcvTRUE;
-	}
+		/* Increase the commit stamp */
+		Command->commitStamp++;
+
+		/* Set busy if idle */
+		if (Command->idle)
+		{
+			Command->idle = gcvFALSE;
 
+			gcmkVERIFY_OK(gckOS_NotifyIdle(Command->os, gcvFALSE));
+		}
+	}
+#endif
+    
 	/* Compute number of bytes required for WAIT/LINK. */
 	gcmkONERROR(
 		gckHARDWARE_WaitLink(Command->kernel->hardware,
@@ -1626,7 +1881,7 @@ gckCOMMAND_Reserve(
 	if (bytes < requiredBytes)
 	{
         /* Create a new command queue. */
-        gcmkONERROR(_NewQueue(Command, gcvTRUE));
+        gcmkONERROR(_NewQueue(Command));
 
 		/* Recompute number of bytes available in command queue. */
 		bytes = Command->pageSize - Command->offset;
@@ -1638,6 +1893,30 @@ gckCOMMAND_Reserve(
 		}
 	}
 
+    /* Fill hole in command queue with value NOP */
+    {
+        gctSIZE_T alignBytes = gcmALIGN(RequestedBytes, Command->alignment) - RequestedBytes;
+
+        if (alignBytes > 0)
+        {
+            gctSIZE_T reserved = alignBytes;
+            gctUINT8_PTR nop   = (gctUINT8_PTR) Command->logical + Command->offset + RequestedBytes;
+
+            while (reserved > 0)
+            {
+                gctSIZE_T size = sizeof(gctUINT32);
+                gctUINT32_PTR ptr = (gctUINT32_PTR) nop;
+
+                if (reserved < size)
+                    break;
+
+                *ptr = GC_NOP_COMMAND;
+                reserved -= size;
+                nop      += size;
+            }
+        }
+    }
+
 	/* Return pointer to empty slot command queue. */
 	*Buffer = (gctUINT8 *) Command->logical + Command->offset;
 
@@ -1649,11 +1928,15 @@ gckCOMMAND_Reserve(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d, requiredBytes=%d",
+                        status, acquired, requiredBytes);
+
+
     if (acquired)
     {
-        /* Release command queue mutex on error. */
+        /* Release mutex on error. */
         gcmkVERIFY_OK(
-        	gckOS_ReleaseMutex(Command->os, Command->mutexQueue));
+        	gckOS_ReleaseRecMutex(Command->os, Command->kernel->hardware->recMutexPower));
     }
 
     /* Return status. */
@@ -1689,9 +1972,15 @@ gckCOMMAND_Release(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Command, gcvOBJ_COMMAND);
 
-    /* Release the command queue mutex. */
-    status = gckOS_ReleaseMutex(Command->os, Command->mutexQueue);
+    /* Release the mutex. */
+    gcmkONERROR(gckOS_ReleaseRecMutex(Command->os, Command->kernel->hardware->recMutexPower));
 
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1720,8 +2009,7 @@ gckCOMMAND_Release(
 gceSTATUS
 gckCOMMAND_Execute(
     IN gckCOMMAND Command,
-    IN gctSIZE_T RequestedBytes,
-	IN gctBOOL Locking
+    IN gctSIZE_T RequestedBytes
     )
 {
     gctUINT32 offset;
@@ -1731,12 +2019,16 @@ gckCOMMAND_Execute(
     gctPOINTER wait;
     gctSIZE_T waitBytes;
 
-    gcmkHEADER_ARG("Command=0x%x RequestedBytes=%lu Locking=%d",
-					Command, RequestedBytes, Locking);
+    gctBOOL queueReleased = gcvFALSE;
+
+    gcmkHEADER_ARG("Command=0x%x RequestedBytes=%lu", Command, RequestedBytes);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Command, gcvOBJ_COMMAND);
 
+#if LATE_NOTIFY_BUSY
+    gcmkONERROR(gckHARDWARE_SetPowerManagementState(Command->kernel->hardware, gcvPOWER_ON)); 
+
 	if (Command->kernel->notifyIdle)
 	{
 		/* Increase the commit stamp */
@@ -1750,7 +2042,8 @@ gckCOMMAND_Execute(
 			gcmkVERIFY_OK(gckOS_NotifyIdle(Command->os, gcvFALSE));
 		}
 	}
-    
+#endif
+
 	/* Compute offset for WAIT/LINK. */
 	offset = Command->offset + RequestedBytes;
 
@@ -1789,6 +2082,10 @@ gckCOMMAND_Execute(
     _DumpCommand(Command, address, bytes);
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+	_AddCmdBuffer(Command, address, bytes, gcvDUMP_EVENT);
+#endif
+
     /* Convert the last WAIT into a LINK. */
     gcmkONERROR(gckHARDWARE_Link(Command->kernel->hardware,
                                  Command->wait,
@@ -1809,6 +2106,10 @@ gckCOMMAND_Execute(
     _DumpCommand(Command, Command->wait, 8);
 #endif
 
+#if MRVL_PRINT_CMD_BUFFER
+	_AddCmdBuffer(Command, Command->wait, 8, gcvDUMP_EVENT);
+#endif
+
 	/* Update the pointer to the last WAIT. */
 	Command->wait     = wait;
 	Command->waitSize = waitBytes;
@@ -1827,18 +2128,15 @@ gckCOMMAND_Execute(
     gcmkPRINT("@[kernel.execute]");
 #endif
 
-	if (!Locking)
-	{
-	    /* Release the command queue mutex. */
-    	gcmkONERROR(
-        	gckOS_ReleaseMutex(Command->os, Command->mutexQueue));
-	}
-
+    /* Release the mutex. */
+    gcmkONERROR(gckOS_ReleaseRecMutex(Command->os, Command->kernel->hardware->recMutexPower));
+    queueReleased = gcvTRUE;
+    
     /* Submit events if asked for. */
     if (Command->submit)
     {
         /* Submit events. */
-        status = gckEVENT_Submit(Command->kernel->event, gcvFALSE, gcvFALSE);
+        status = gckEVENT_Submit(Command->kernel->event, gcvFALSE);
 
         if (gcmIS_SUCCESS(status))
         {
@@ -1858,10 +2156,15 @@ gckCOMMAND_Execute(
     return gcvSTATUS_OK;
 
 OnError:
-	/* Release the command queue mutex. */
-	gcmkVERIFY_OK(
-    	gckOS_ReleaseMutex(Command->os, Command->mutexQueue));
+    gcmkLOG_ERROR_ARGS("status=%d, queueReleased=%d",
+                        status, queueReleased);
 
+    /* Release the mutex. */
+    if (!queueReleased)
+    {
+        gcmkVERIFY_OK(
+            gckOS_ReleaseRecMutex(Command->os, Command->kernel->hardware->recMutexPower));
+    }
     /* Return the status. */
     gcmkFOOTER();
     return status;
@@ -1893,7 +2196,9 @@ gckCOMMAND_Stall(
     gckEVENT event;
     gceSTATUS status;
 	gctSIGNAL signal = gcvNULL;
-
+#if VIVANTE_POWER_MANAGE
+    gctUINT timer = 0;
+#endif
 	gcmkHEADER_ARG("Command=0x%x", Command);
 
     /* Verify the arguments. */
@@ -1924,11 +2229,10 @@ gckCOMMAND_Stall(
     /* Append the EVENT command to trigger the signal. */
     gcmkONERROR(gckEVENT_Signal(event,
                                 signal,
-                                gcvKERNEL_PIXEL,
-								gcvFALSE));
+                                gcvKERNEL_PIXEL));
 
     /* Submit the event queue. */
-	gcmkONERROR(gckEVENT_Submit(event, gcvTRUE, gcvFALSE));
+    gcmkONERROR(gckEVENT_Submit(event, gcvTRUE));
 
 #if gcdDUMP_COMMAND
     gcmkPRINT("@[kernel.stall]");
@@ -1943,7 +2247,7 @@ gckCOMMAND_Stall(
 	do
 	{
 		/* Wait for the signal. */
-		status = gckOS_WaitSignal(os, signal, gcvINFINITE);
+		status = gckOS_WaitSignalNoInterruptible(os, signal, gcvINFINITE);
 
 		if (status == gcvSTATUS_TIMEOUT)
 		{
@@ -1951,7 +2255,7 @@ gckCOMMAND_Stall(
 			gctUINT32 idle;
 
 			/* IDLE */
-			gckOS_ReadRegister(Command->os, 0x0004, &idle);
+			gcmkONERROR(gckOS_ReadRegister(Command->os, 0x0004, &idle));
                 
 			gcmkTRACE(gcvLEVEL_ERROR,
 					  "%s(%d): idle=%08x",
@@ -1960,65 +2264,17 @@ gckCOMMAND_Stall(
                             __FUNCTION__, __LINE__, idle);                
 #endif 
 
-#if MRVL_PRINT_CMD_BUFFER
-            {
-    			gctUINT i;
-                gctUINT32 idle;
-    			gctUINT32 intAck;
-    			gctUINT32 prevAddr = 0;
-    			gctUINT32 currAddr;
-    			gctBOOL changeDetected;
-
-    			changeDetected = gcvFALSE;
-
-                /* IDLE */
-			    gckOS_ReadRegister(Command->os, 0x0004, &idle);
-                
-				/* INT ACK */
-				gckOS_ReadRegister(Command->os, 0x0010, &intAck);
-
-				/* DMA POS */
-				for (i = 0; i < 300; i += 1)
-				{
-					gckOS_ReadRegister(Command->os, 0x0664, &currAddr);
-
-					if ((i > 0) && (prevAddr != currAddr))
-					{
-						changeDetected = gcvTRUE;
-					}
-
-					prevAddr = currAddr;
-				}
-
-				gcmTRACE(0,
-					"\n%s(%d):\n"
-					"  idle = 0x%08X\n"
-					"  int  = 0x%08X\n"
-					"  dma  = 0x%08X (change=%d)\n",
-					__FUNCTION__, __LINE__,
-					idle,
-					intAck,
-					currAddr,
-					changeDetected
-					);
-                
-				_PrintCmdBuffer(Command, currAddr);
-				_PrintLinkChain();
-            }
-#endif
-
-
 #if MRVL_LOW_POWER_MODE_DEBUG
             	{
                 	int i = 0;
                 
-                	printk(">>>>>>>>>>>>galDevice->kernel->kernelMSG\n");
-                	printk("galDevice->kernel->msgLen=%d\n",Command->kernel->msgLen);
+                	gcmkPRINT(">>>>>>>>>>>>galDevice->kernel->kernelMSG\n");
+                	gcmkPRINT("galDevice->kernel->msgLen=%d\n",Command->kernel->msgLen);
                 
                 	for(i=0;i<Command->kernel->msgLen;i+=1024)
                 	{
                     		Command->kernel->kernelMSG[i+1023] = '\0';
-            	    		printk("%s\n",(char*)Command->kernel->kernelMSG + i);
+            	    		gcmkPRINT("%s\n",(char*)Command->kernel->kernelMSG + i);
                 	}
             	}
 #endif
@@ -2026,7 +2282,7 @@ gckCOMMAND_Stall(
             gctUINT32 reg_cmdbuf_fetch;
             gctUINT32 reg_intr;
 
-            gcmkVERIFY_OK(
+            gcmkONERROR(
                     gckOS_ReadRegister(Command->kernel->hardware->os, 0x0664, &reg_cmdbuf_fetch));
 
             if (idle == 0x7FFFFFFE)
@@ -2038,7 +2294,7 @@ gckCOMMAND_Stall(
                  * Note that reading interrupt register clears it.
                  * That's why we don't read it in all cases.
                  */
-                gcmkVERIFY_OK(
+                gcmkONERROR(
                         gckOS_ReadRegister(Command->kernel->hardware->os, 0x10, &reg_intr));
 
                 slogf(
@@ -2056,25 +2312,55 @@ gckCOMMAND_Stall(
                     idle, reg_cmdbuf_fetch);
             }
 #endif
-			gcmkVERIFY_OK(
+			gcmkONERROR(
 				gckOS_MemoryBarrier(os, gcvNULL));
+#if VIVANTE_POWER_MANAGE
+            /* Advance timer. */
+            timer += 250;
+#endif
 		}
+    }
+    
+#if !VIVANTE_POWER_MANAGE
+    while (gcmIS_ERROR(status));
+#else
+    while (gcmIS_ERROR(status)
+#if gcdGPU_TIMEOUT
+           && (timer < gcdGPU_TIMEOUT)
+#endif
+           );
+    /* Bail out on timeout. */
+    if (gcmIS_ERROR(status))
+    {
+        /* Broadcast the stuck GPU. */
+        gcmkONERROR(gckOS_Broadcast(os,
+                                    Command->kernel->hardware,
+                                    gcvBROADCAST_GPU_STUCK));
 
+        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
 	}
-	while (gcmIS_ERROR(status));
+#endif
 
 	/* Delete the signal. */
-	gcmkVERIFY_OK(gckOS_DestroySignal(os, signal));
+	gcmkONERROR(gckOS_DestroySignal(os, signal));
+    signal = gcvNULL;
 
     /* Success. */
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
+#if VIVANTE_POWER_MANAGE
+    gcmkLOG_ERROR_ARGS("status=%d, signal=0x%08x, timer=%d", status, signal, timer);
+#else
+    gcmkLOG_ERROR_ARGS("status=%d, signal=0x%08x", status, signal);
+#endif
     /* Free the signal. */
     if (signal != gcvNULL)
     {
     	gcmkVERIFY_OK(gckOS_DestroySignal(os, signal));
+
+        signal = gcvNULL;
     }
 
     /* Return the status. */
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_event.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_event.c
index b78215d..b92b043 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_event.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_event.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -64,8 +64,8 @@ _GetEvent(
 
 	/* Grab the queue mutex. */
 	gcmkONERROR(gckOS_AcquireMutex(Event->os,
-							   Event->mutexQueue,
-						   gcvINFINITE));
+	        	   				   Event->mutexQueue,
+    				    		   gcvINFINITE));
 	acquired = gcvTRUE;
 
 	/* Walk through all events. */
@@ -111,7 +111,63 @@ OnError:
 	gcmkFOOTER();
 	return status;
 }
+#if VIVANTE_POWER_MANAGE
+static gceSTATUS
+_IsEmpty(
+    IN gckEVENT Event,
+    OUT gctBOOL_PTR IsEmpty
+    )
+{
+    gceSTATUS status;
+    gctSIZE_T i;
+
+    gcmkHEADER_ARG("Event=0x%x", Event);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
+    gcmkVERIFY_ARGUMENT(IsEmpty != gcvNULL);
 
+    /* Assume the event queue is empty. */
+    *IsEmpty = gcvTRUE;
+
+    /* Walk the event queue. */
+    for (i = 0; i < gcmCOUNTOF(Event->queues); ++i)
+    {
+        /* Check whether this event is in use. */
+        if (Event->queues[i].head != gcvNULL)
+        {
+            /* The event is in use, hence the queue is not empty. */
+            *IsEmpty = gcvFALSE;
+            break;
+        }
+    }
+
+    /* Try acquiring the mutex. */
+    status = gckOS_AcquireMutex(Event->os, Event->mutexQueue, 0);
+    if (status == gcvSTATUS_TIMEOUT)
+    {
+        /* Timeout - queue is no longer empty. */
+        *IsEmpty = gcvFALSE;
+    }
+    else
+    {
+        /* Bail out on error. */
+        gcmkONERROR(status);
+
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Event->os, Event->mutexQueue));
+    }
+
+    /* Success. */
+    gcmkFOOTER_ARG("*IsEmpty=%d", gcmOPT_VALUE(IsEmpty));
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+#endif
 /******************************************************************************\
 ******************************* gckEVENT API Code *******************************
 \******************************************************************************/
@@ -173,6 +229,11 @@ gckEVENT_Construct(
 	event->listMutex   = gcvNULL;
 	event->lastID      = 0;
 
+    /* Construct atom holding number of event counts. */
+    event->atomEventRef= gcvNULL;
+    gcmkONERROR(
+        gckOS_AtomConstruct(os, &event->atomEventRef));
+    
 	/* Create the mutexes. */
 	gcmkONERROR(
 		gckOS_CreateMutex(os, &event->mutexQueue));
@@ -216,22 +277,32 @@ gckEVENT_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Roll back. */
 	if (event != gcvNULL)
 	{
+        if (event->atomEventRef != gcvNULL)
+        {
+            gcmkVERIFY_OK(gckOS_AtomDestroy(os, event->atomEventRef));
+            event->atomEventRef = gcvNULL;
+        }
+
 		if (event->mutexQueue != gcvNULL)
 		{
 			gcmkVERIFY_OK(gckOS_DeleteMutex(os, event->mutexQueue));
+            event->mutexQueue = gcvNULL;
 		}
 
 		if (event->freeMutex != gcvNULL)
 		{
 			gcmkVERIFY_OK(gckOS_DeleteMutex(os, event->freeMutex));
+            event->freeMutex = gcvNULL;
 		}
 
 		if (event->listMutex != gcvNULL)
 		{
 			gcmkVERIFY_OK(gckOS_DeleteMutex(os, event->listMutex));
+            event->listMutex = gcvNULL;
 		}
 
 		while (event->freeList != gcvNULL)
@@ -241,8 +312,10 @@ OnError:
 
 			gcmkVERIFY_OK(gckOS_Free(os, record));
 		}
-
+        event->freeList = gcvNULL;
+        
 		gcmkVERIFY_OK(gckOS_Free(os, event));
+        event = gcvNULL;
 	}
 
 	/* Return the status. */
@@ -277,8 +350,19 @@ gckEVENT_Destroy(
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
 
+    /* Detsroy the event counts atom. */
+    if (Event->atomEventRef != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_AtomDestroy(Event->os, Event->atomEventRef));
+        Event->atomEventRef = gcvNULL;
+    }
+
     /* Delete the queue mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->mutexQueue));
+	if (Event->mutexQueue != gcvNULL)
+	{
+		gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->mutexQueue));
+        Event->mutexQueue = gcvNULL;
+	}
 
 	/* Free all free events. */
 	while (Event->freeList != gcvNULL)
@@ -289,8 +373,15 @@ gckEVENT_Destroy(
 		gcmkVERIFY_OK(gckOS_Free(Event->os, record));
 	}
 
+    Event->freeList = gcvNULL;
+    
+
 	/* Delete the free mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->freeMutex));
+    if(Event->freeMutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->freeMutex));
+        Event->freeMutex = gcvNULL;
+    }
 
 	/* Free all pending events. */
 	while (Event->list.head != gcvNULL)
@@ -304,15 +395,23 @@ gckEVENT_Destroy(
 		gcmkVERIFY_OK(gckOS_Free(Event->os, record));
 	}
 
-	/* Delete the list mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->listMutex));
+    Event->list.head =  gcvNULL;
 
+	/* Delete the list mutex. */
+    if(Event->listMutex != gcvNULL)
+	{
+	    gcmkVERIFY_OK(gckOS_DeleteMutex(Event->os, Event->listMutex));
+        Event->listMutex = gcvNULL;
+    }
+    
 	/* Mark the gckEVENT object as unknown. */
 	Event->object.type = gcvOBJ_UNKNOWN;
 
 	/* Free the gckEVENT object. */
 	gcmkVERIFY_OK(gckOS_Free(Event->os, Event));
 
+    Event = gcvNULL;
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
@@ -348,6 +447,8 @@ gckEVENT_AllocateRecord(
 
 			if (gcmIS_ERROR(status))
 			{
+                gcmkLOG_WARNING_ARGS("status=%d, i=%d, Out of memory allocating event records",
+                                        status, i);
 				gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_EVENT,
 							   "Out of memory allocating event records.");
 				break;
@@ -366,6 +467,7 @@ gckEVENT_AllocateRecord(
 
 			/* Release the mutex. */
 			gcmkONERROR(gckOS_ReleaseMutex(Event->os, Event->freeMutex));
+            acquired = gcvFALSE;
 		}
 	}
 
@@ -379,12 +481,14 @@ gckEVENT_AllocateRecord(
 
 	/* Release the mutex. */
 	gcmkONERROR(gckOS_ReleaseMutex(Event->os, Event->freeMutex));
+	acquired = gcvFALSE;
 
 	/* Success. */
 	gcmkFOOTER_ARG("*Record=0x%x", gcmOPT_POINTER(Record));
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	/* Roll back. */
 	if (acquired)
 	{
@@ -428,6 +532,7 @@ gckEVENT_FreeRecord(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	/* Roll back. */
 	if (acquired)
 	{
@@ -443,16 +548,15 @@ static gceSTATUS
 gckEVENT_AddList(
 	IN gckEVENT Event,
 	IN gcsHAL_INTERFACE_PTR Interface,
-	IN gceKERNEL_WHERE FromWhere,
-	IN gctBOOL Locking
+    IN gceKERNEL_WHERE FromWhere
 	)
 {
 	gceSTATUS status;
 	gctBOOL acquired = gcvFALSE;
 	gcsEVENT_PTR record = gcvNULL;
 
-	gcmkHEADER_ARG("Event=0x%x Interface=0x%x FromWhere=%d Locking=%d",
-                   Event, Interface, FromWhere, Locking);
+    gcmkHEADER_ARG("Event=0x%x Interface=0x%x FromWhere=%d",
+                   Event, Interface, FromWhere);
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
@@ -468,7 +572,7 @@ gckEVENT_AddList(
 		)
 		{
 			/* No match - auto-submit the list. */
-			status = gckEVENT_Submit(Event, gcvFALSE, Locking);
+            status = gckEVENT_Submit(Event, gcvFALSE);
 
 			if (status == gcvSTATUS_OUT_OF_RESOURCES)
 			{
@@ -540,6 +644,7 @@ gckEVENT_AddList(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d, record=0x%08x", status, acquired, record);
 	/* Roll back. */
 	if (acquired)
 	{
@@ -608,13 +713,14 @@ gckEVENT_FreeNonPagedMemory(
 	iface.u.FreeNonPagedMemory.logical  = Logical;
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -672,13 +778,14 @@ gckEVENT_FreeContiguousMemory(
 	iface.u.FreeContiguousMemory.logical  = Logical;
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -723,13 +830,14 @@ gckEVENT_FreeVideoMemory(
 	iface.u.FreeVideoMemory.node = VideoMemory;
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -751,20 +859,20 @@ OnError:
 **
 **      gceKERNEL_WHERE FromWhere
 **          Place in the pipe where the event needs to be generated.
+**
 */
 gceSTATUS
 gckEVENT_Signal(
 	IN gckEVENT Event,
 	IN gctSIGNAL Signal,
-	IN gceKERNEL_WHERE FromWhere,
-	IN gctBOOL Locking
+    IN gceKERNEL_WHERE FromWhere
 	)
 {
 	gceSTATUS status;
 	gcsHAL_INTERFACE iface;
 
-	gcmkHEADER_ARG("Event=0x%x Signal=0x%x FromWhere=%d Locking=%d",
-                   Event, Signal, FromWhere, Locking);
+    gcmkHEADER_ARG("Event=0x%x Signal=0x%x FromWhere=%d",
+                   Event, Signal, FromWhere);
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
@@ -782,13 +890,14 @@ gckEVENT_Signal(
 #endif
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, Locking));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -840,19 +949,19 @@ gckEVENT_Unlock(
 	iface.u.UnlockVideoMemory.asynchroneous = 0;
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+    gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
 }
 
-#define ENABLE_GC_IDLE_EVENT 1
 gceSTATUS
 gckEVENT_Commit(
 	IN gckEVENT Event,
@@ -866,13 +975,14 @@ gckEVENT_Commit(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
-
+    
     if(Queue == gcvNULL)
     {
-#if ENABLE_GC_IDLE_EVENT
-	/* Try to set idle */
-	gcmkVERIFY_OK(gckEVENT_TryToSetIdle(Event));
-    return gcvSTATUS_OK;
+#if !VIVANTE_POWER_MANAGE
+    	/* Try to set idle */
+    	gcmkVERIFY_OK(gckEVENT_TryToSetIdle(Event));
+    	gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
 #endif
     }
 
@@ -886,7 +996,7 @@ gckEVENT_Commit(
 										 (gctPOINTER *) &record));
 
 		/* Append event record to event queue. */
-		gcmkONERROR(gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL, gcvFALSE));
+        gcmkONERROR(gckEVENT_AddList(Event, &record->iface, gcvKERNEL_PIXEL));
 
 		/* Next record in the queue. */
 		next = record->next;
@@ -903,13 +1013,14 @@ gckEVENT_Commit(
 	}
 
 	/* Submit the event list. */
-	gcmkONERROR(gckEVENT_Submit(Event, gcvTRUE, gcvFALSE));
+    gcmkONERROR(gckEVENT_Submit(Event, gcvTRUE));
 
 	/* Success */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, record=0x%08x, Queue=0x%08x", status, record, Queue);
 	/* Roll back. */
 	if (record == gcvNULL)
 	{
@@ -951,15 +1062,18 @@ gckEVENT_Notify(
 {
 	gceSTATUS status = gcvSTATUS_OK;
 	gctINT i;
-	gcsEVENT_QUEUE * queue;
+	gcsEVENT_QUEUE * queue = gcvNULL;
 	gctUINT mask = 0;
 	gctBOOL acquired = gcvFALSE;
+    gctBOOL cmdAcquired = gcvFALSE;
 #ifdef __QNXNTO__
 	gcuVIDMEM_NODE_PTR node;
 #endif
     gctUINT pending;
     gctBOOL suspended = gcvFALSE;
-
+#if VIVANTE_POWER_MANAGE
+    gctBOOL empty = gcvFALSE, idle = gcvFALSE;
+#endif
 	gcmkHEADER_ARG("Event=0x%x", Event);
 
 	/* Verify the arguments. */
@@ -1022,8 +1136,9 @@ gckEVENT_Notify(
 
 		if (queue == gcvNULL)
 		{
+            gcmkLOG_WARNING_ARGS("Queue is null,interrupts 0x%08x are not pending", pending);
 			gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_EVENT,
-						   "Interrupts 0x08x are not pending.", pending);
+						   "Interrupts 0x%08x are not pending.", pending);
 
 			break;
 		}
@@ -1036,6 +1151,8 @@ gckEVENT_Notify(
 			&&  (Event->queues[i].source == queue->source)
 			)
 			{
+                gcmkLOG_WARNING_ARGS("Event %d lost (stamp %llu)",
+                                    i, Event->queues[i].stamp);
 				gcmkTRACE(gcvLEVEL_ERROR,
 						  "Event %d lost (stamp %llu)",
 						  i, Event->queues[i].stamp);
@@ -1056,6 +1173,8 @@ gckEVENT_Notify(
 
 			event       = queue->head;
 
+            gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
+                "event->event.command: %d", event->event.command);
 			/* Dispatch on event type. */
 			switch (event->event.command)
 			{
@@ -1069,7 +1188,7 @@ gckEVENT_Notify(
 				break;
 
 			case gcvHAL_FREE_CONTIGUOUS_MEMORY:
-				/* Unmap the user memory. */
+                /* Unmap the user memory. */
 				status = gckOS_FreeContiguous(
 							Event->os,
 							event->event.u.FreeContiguousMemory.physical,
@@ -1103,7 +1222,7 @@ gckEVENT_Notify(
 				gcmkERR_BREAK(
 					gckOS_MapPhysical(Event->os,
 									  event->event.u.WriteData.address,
-									  gcmPTR2INT(event->event.u.WriteData.kernelAddress),
+	  								  gcmPTR2INT(event->event.u.WriteData.kernelAddress),
 									  gcmSIZEOF(gctUINT32),
 									  &logical));
 
@@ -1116,7 +1235,7 @@ gckEVENT_Notify(
 				/* Unmap the physical memory. */
 				gcmkERR_BREAK(
 					gckOS_UnmapPhysical(Event->os,
-									logical,
+    									logical,
 										gcmSIZEOF(gctUINT32)));
 #else
 				/* Write data. */
@@ -1189,26 +1308,32 @@ gckEVENT_Notify(
 										  event->event.u.UnmapUserMemory.address);
 				break;
 
-		case gcvHAL_SET_IDLE:
+    		case gcvHAL_SET_IDLE:
 				if(!IsReset)
 				{
-				/* Grab the conmmand queue mutex. */
-				gcmkVERIFY_OK(gckOS_AcquireMutex(Event->os,
-												Event->kernel->command->mutexQueue,
-												gcvINFINITE));
-
-				/* Set idle if no new commitments */
-				if (Event->lastCommitStamp == Event->kernel->command->commitStamp)
-				{
+        			/* Grab the mutex. */
+        			gcmkONERROR(gckOS_AcquireRecMutex(Event->os,
+        											Event->kernel->hardware->recMutexPower,
+        											gcvINFINITE));
+                    cmdAcquired = gcvTRUE;
+                    
+                    gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_EVENT,
+                        "lastCommitStamp=%llu  commitStamp=%llu",
+                        Event->lastCommitStamp, Event->kernel->command->commitStamp);
+                    
+        			/* Set idle if no new commitments */
+        			if (Event->lastCommitStamp == Event->kernel->command->commitStamp)
+        			{
                         if(Event->kernel->command->idle == gcvFALSE)
                         {
-					Event->kernel->command->idle = gcvTRUE;
-					gcmkVERIFY_OK(gckOS_NotifyIdle(Event->os, gcvTRUE));
+            				Event->kernel->command->idle = gcvTRUE;
+            				gcmkVERIFY_OK(gckOS_NotifyIdle(Event->os, gcvTRUE));
                         }
-				}
+        			}
 
-				/* Release the command queue mutex. */
-				gcmkVERIFY_OK(gckOS_ReleaseMutex(Event->os, Event->kernel->command->mutexQueue));
+        			/* Release the mutex. */
+        			gcmkVERIFY_OK(gckOS_ReleaseRecMutex(Event->os, Event->kernel->hardware->recMutexPower));
+                    cmdAcquired = gcvFALSE;
 				}
                 break;
 
@@ -1252,19 +1377,58 @@ gckEVENT_Notify(
         suspended = gcvFALSE;
 	}
 
-#if ENABLE_GC_IDLE_EVENT
     if(!IsReset)
     {
-	/* Try to set idle */
-	gcmkVERIFY_OK(gckEVENT_TryToSetIdle(Event));
-    }
+#if VIVANTE_POWER_MANAGE
+		/* Grab the mutex. */
+		gcmkONERROR(gckOS_AcquireRecMutex(Event->os,
+										Event->kernel->hardware->recMutexPower,
+										gcvINFINITE));
+        cmdAcquired = gcvTRUE;
+        
+        /* Check whether the event queue is empty. */
+        gcmkONERROR(_IsEmpty(Event, &empty));
+
+        if (empty)
+        {
+            /* Query whether the hardware is idle. */
+            gcmkONERROR(gckHARDWARE_QueryIdle(Event->kernel->hardware, &idle));
+
+            if (idle)
+            {
+                if(Event->kernel->command->idle == gcvFALSE)
+                {
+    				Event->kernel->command->idle = gcvTRUE;
+    				gcmkVERIFY_OK(gckOS_NotifyIdle(Event->os, gcvTRUE));
+                }
+            }
+        }
+        
+    	/* Release the mutex. */
+		gcmkVERIFY_OK(gckOS_ReleaseRecMutex(Event->os, Event->kernel->hardware->recMutexPower));
+        cmdAcquired = gcvFALSE;
+#else
+        {
+        	/* Try to set idle */
+        	gcmkVERIFY_OK(gckEVENT_TryToSetIdle(Event));
+        }
 #endif
+    }
+
+    {
+        gctINT32 old = 0;
+        /* Increment the number of event counts. */
+        gcmkONERROR(
+            gckOS_AtomIncrement(Event->kernel->os, Event->atomEventRef, &old));
+    }
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d, suspended=%d, queue=0x%08x",
+                        status, acquired, suspended, queue);
 	if (acquired)
 	{
 		/* Release mutex. */
@@ -1277,6 +1441,12 @@ OnError:
         gcmkVERIFY_OK(gckOS_ResumeInterrupt(Event->os));
     }
 
+    if (cmdAcquired)
+    {
+        /* Release the command queue mutex. */
+		gcmkVERIFY_OK(gckOS_ReleaseRecMutex(Event->os, Event->kernel->hardware->recMutexPower));
+    }
+
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -1285,18 +1455,20 @@ OnError:
 gceSTATUS
 gckEVENT_Submit(
 	IN gckEVENT Event,
-	IN gctBOOL Wait,
-	IN gctBOOL Locking
+    IN gctBOOL Wait
 	)
 {
 	gctUINT8 id = 0xFF;
 	gctSIZE_T bytes;
 	gctPOINTER buffer;
 	gceSTATUS status;
-	gctBOOL acquired = gcvTRUE;
+    gctBOOL acquired = gcvFALSE;
 	gctBOOL reserved = gcvFALSE;
+#if gcdGPU_TIMEOUT
+    gctUINT32 timer = 0;
+#endif
 
-	gcmkHEADER_ARG("Event=0x%x Wait=%d Locking=%d", Event, Wait, Locking);
+    gcmkHEADER_ARG("Event=0x%x Wait=%d", Event, Wait);
 
 	/* Only process if we have events queued. */
 	if (Event->list.head != gcvNULL)
@@ -1304,26 +1476,37 @@ gckEVENT_Submit(
 	    for (;;)
 	    {
 		    /* Allocate an event ID. */
-		status = _GetEvent(Event, &id, Event->list.source);
+    		status = _GetEvent(Event, &id, Event->list.source);
 
-		if (gcmIS_ERROR(status))
-		{
+    		if (gcmIS_ERROR(status))
+    		{
 				/* Out of resources? */
                 if (Wait && (status == gcvSTATUS_OUT_OF_RESOURCES))
                 {
 					/* Delay a while. */
                     gcmkONERROR(gckOS_Delay(Event->os, 1));
+
+#if gcdGPU_TIMEOUT && VIVANTE_POWER_MANAGE
+                    if (++timer >= gcdGPU_TIMEOUT)
+                    {
+                        gcmkONERROR(gckOS_Broadcast(Event->os,
+                                                    Event->kernel->hardware,
+                                                    gcvBROADCAST_GPU_STUCK));
+
+                        gcmkONERROR(gcvSTATUS_GPU_NOT_RESPONDING);
+                }
+#endif
                 }
                 else
                 {
                     gcmkONERROR(status);
                 }
-		}
-		else
-		{
+    		}
+    		else
+    		{
 				/* Got en event ID. */
-			break;
-		}
+        		break;
+    		}
         }
 
 		gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_EVENT, "Using id=%d", id);
@@ -1338,6 +1521,9 @@ gckEVENT_Submit(
 		Event->queues[id].source = Event->list.source;
 		Event->queues[id].head   = Event->list.head;
 
+        /* Get process ID. */
+        gcmkONERROR(gckOS_GetProcessID(&Event->queues[id].processID));
+
 		/* Mark event list as empty. */
 		Event->list.head = gcvNULL;
 
@@ -1361,7 +1547,6 @@ gckEVENT_Submit(
 		/* Reserve space in the command queue. */
 		gcmkONERROR(gckCOMMAND_Reserve(Event->kernel->command,
 									   bytes,
-									   Locking,
 									   &buffer,
 									   &bytes));
 		reserved = gcvTRUE;
@@ -1374,7 +1559,7 @@ gckEVENT_Submit(
 									  &bytes));
 
 		/* Execute the hardware event. */
-		gcmkONERROR(gckCOMMAND_Execute(Event->kernel->command, bytes, Locking));
+        gcmkONERROR(gckCOMMAND_Execute(Event->kernel->command, bytes));
 		reserved = gcvFALSE;
 #endif
 	}
@@ -1384,13 +1569,15 @@ gckEVENT_Submit(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d, reserved=%d, eventId=%d",
+                        status, acquired, reserved, id);
 	if (acquired)
 	{
 		/* Need to unroll the mutex acquire. */
 		gcmkVERIFY_OK(gckOS_ReleaseMutex(Event->os, Event->listMutex));
 	}
 
-	if (!Locking && reserved)
+    if (reserved)
 	{
 		/* Need to release the command buffer. */
 		gcmkVERIFY_OK(gckCOMMAND_Release(Event->kernel->command));
@@ -1451,36 +1638,44 @@ gckEVENT_SetIdle(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
+	gcmkHEADER_ARG("Event=0x%x CommandBuffer=0x%x CommandSize=0x%x FromWhere=%d Wait=%d",
+                    Event, CommandBuffer, CommandSize, FromWhere, Wait);
 
 	/* Create an event. */
 	iface.command = gcvHAL_SET_IDLE;
 
 	/* Append it to the queue. */
-	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere, gcvFALSE));
+	gcmkONERROR(gckEVENT_AddList(Event, &iface, FromWhere));
 
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
 }
 
-
+#define ENABLE_COMMITSTAMP_CHECK    0
 gceSTATUS
 gckEVENT_TryToSetIdle(
 	IN gckEVENT Event
 	)
 {
-	gctINT i;
+	gctINT i = -1;
 	gctBOOL setIdle;
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Event, gcvOBJ_EVENT);
+	gcmkHEADER_ARG("Event=0x%x", Event);
 
-	if (!Event->kernel->notifyIdle) return gcvSTATUS_OK;
+	if (!Event->kernel->notifyIdle)
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
 
 	/* Initialize the flag */
 	setIdle = gcvFALSE;
@@ -1493,7 +1688,13 @@ gckEVENT_TryToSetIdle(
 	/* Suspend interrupt */
 	gcmkVERIFY_OK(gckOS_SuspendInterrupt(Event->os));
 
+    /*
+        FIXME: this check may cause system enter into idle status every 120 seconds in home screen scenario on TD,
+               Temp solution -- disable this.
+    */
+#if ENABLE_COMMITSTAMP_CHECK
 	if (Event->lastCommitStamp != Event->kernel->command->commitStamp)
+#endif
 	{
 		setIdle = gcvTRUE;
 
@@ -1507,7 +1708,7 @@ gckEVENT_TryToSetIdle(
 			}
 		}
 	}
-
+    
 	/* Resume interrupt */
 	gcmkVERIFY_OK(gckOS_ResumeInterrupt(Event->os));
 
@@ -1517,6 +1718,11 @@ gckEVENT_TryToSetIdle(
 	/* Issue an event to set idle if necessary */
 	if (setIdle)
 	{
+        /* Grab the conmmand queue mutex. */
+        gcmkVERIFY_OK(
+        	gckOS_AcquireMutex(Event->kernel->command->os,
+    						   Event->kernel->command->mutexQueue,
+    						   gcvINFINITE)); 
 
 		/* Append the EVENT command to write data into the boolean. */
 		gcmkVERIFY_OK(gckEVENT_SetIdle(Event,
@@ -1524,22 +1730,17 @@ gckEVENT_TryToSetIdle(
 									0,
 									gcvKERNEL_PIXEL,
 									gcvTRUE));
-
-        /* Grab the conmmand queue mutex. */
-        gcmkVERIFY_OK(
-		gckOS_AcquireMutex(Event->kernel->command->os,
-						   Event->kernel->command->mutexQueue,
-						   gcvINFINITE));
-
+        
 		Event->lastCommitStamp = Event->kernel->command->commitStamp + 1;
-
+        
         /* Release the command queue mutex. */
         gcmkVERIFY_OK(
-		gckOS_ReleaseMutex(Event->kernel->command->os, Event->kernel->command->mutexQueue));
-
+        	gckOS_ReleaseMutex(Event->kernel->command->os, Event->kernel->command->mutexQueue));
+        
 	}
 
 	/* Success. */
+	gcmkFOOTER_ARG("i=%d setIdle=%d", i, setIdle);
 	return gcvSTATUS_OK;
 }
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_heap.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_heap.c
index 733982b..78e95fd 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_heap.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_heap.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -163,6 +163,7 @@ _CompactKernelHeap(
 	IN gckHEAP Heap
 	)
 {
+    gceSTATUS status;
 	gcskHEAP_PTR heap, next;
 	gctPOINTER p;
 	gcskHEAP_PTR freeList = gcvNULL;
@@ -281,7 +282,7 @@ _CompactKernelHeap(
 			gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HEAP,
 						   "Freeing heap 0x%x (%lu bytes)",
 						   heap, heap->size + gcmSIZEOF(gcskHEAP));
-			gcmkVERIFY_OK(gckOS_FreeMemory(Heap->os, heap));
+			gcmkONERROR(gckOS_FreeMemory(Heap->os, heap));
 		}
 
 		/* Acquire the mutex again. */
@@ -292,6 +293,12 @@ _CompactKernelHeap(
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;    
 }
 
 /*******************************************************************************
@@ -372,11 +379,13 @@ gckHEAP_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, *Heap=0x%08x", status, Heap);
 	/* Roll back. */
 	if (heap != gcvNULL)
 	{
 		/* Free the heap structure. */
-		gcmkVERIFY_OK(gckOS_FreeMemory(Os, heap));
+		gcmkERR_RETURN(gckOS_FreeMemory(Os, heap));
+        heap = gcvNULL;
 	}
 
 	/* Return the status. */
@@ -404,6 +413,7 @@ gckHEAP_Destroy(
 	IN gckHEAP Heap
 	)
 {
+	gceSTATUS status;
 	gcskHEAP_PTR heap;
 #if gcdDEBUG
 	gctSIZE_T leaked = 0;
@@ -422,14 +432,19 @@ gckHEAP_Destroy(
 #endif
 
 		/* Free the heap. */
-		gcmkVERIFY_OK(gckOS_FreeMemory(Heap->os, heap));
+		gcmkONERROR(gckOS_FreeMemory(Heap->os, heap));
 	}
 
 	/* Free the mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(Heap->os, Heap->mutex));
-
+    if(Heap->mutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Heap->os, Heap->mutex));
+        Heap->mutex = gcvNULL;
+    }
+    
 	/* Free the heap structure. */
-	gcmkVERIFY_OK(gckOS_FreeMemory(Heap->os, Heap));
+    gcmkONERROR(gckOS_FreeMemory(Heap->os, Heap));
+    Heap = gcvNULL;
 
 	/* Success. */
 #if gcdDEBUG
@@ -438,6 +453,12 @@ gckHEAP_Destroy(
 	gcmkFOOTER_NO();
 #endif
 	return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
 }
 
 /*******************************************************************************
@@ -717,6 +738,7 @@ UseNode:
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -727,7 +749,8 @@ OnError:
 	if (memory != gcvNULL)
 	{
 		/* Free the heap memory. */
-		gckOS_FreeMemory(Heap->os, memory);
+		gcmkERR_RETURN(gckOS_FreeMemory(Heap->os, memory));
+        memory =  gcvNULL;
 	}
 
 	/* Return the status. */
@@ -1044,7 +1067,7 @@ OnError:
 	/* Roll back. */
 	if (nodes != gcvNULL)
 	{
-		gcmkVERIFY_OK(
+		gcmkERR_RETURN(
 			gckOS_FreeMemory(Heap->os, nodes));
 	}
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_mmu.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_mmu.c
index f9c7a9a..a4f8e2e 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_mmu.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_mmu.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -178,6 +178,7 @@ _Collect(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the staus. */
 	return status;
 }
@@ -275,6 +276,9 @@ gckMMU_Construct(
 	gcmkONERROR(
 		gckHARDWARE_SetMMU(hardware, (gctPOINTER) mmu->pageTableLogical));
 
+	/* Reset used page table entries. */
+	mmu->pageTableUsedEntries = 0;
+
 	/* Return the gckMMU object pointer. */
 	*Mmu = mmu;
 
@@ -283,6 +287,7 @@ gckMMU_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Roll back. */
 	if (mmu != gcvNULL)
 	{
@@ -294,6 +299,7 @@ OnError:
 									 mmu->pageTablePhysical,
 									 (gctPOINTER) mmu->pageTableLogical,
 									 mmu->pageTableSize));
+            mmu->pageTableLogical = gcvNULL;
 		}
 
 		if (mmu->pageTableMutex != gcvNULL)
@@ -301,6 +307,7 @@ OnError:
 			/* Delete the mutex. */
 			gcmkVERIFY_OK(
 				gckOS_DeleteMutex(os, mmu->pageTableMutex));
+            mmu->pageTableMutex = gcvNULL;
 		}
 
 #ifdef __QNXNTO__
@@ -309,6 +316,7 @@ OnError:
 			/* Delete the mutex. */
 			gcmkVERIFY_OK(
 				gckOS_DeleteMutex(os, mmu->nodeMutex));
+            mmu->nodeMutex = gcvNULL;
 		}
 #endif
 
@@ -317,6 +325,8 @@ OnError:
 
 		/* Free the allocates memory. */
 		gcmkVERIFY_OK(gckOS_Free(os, mmu));
+
+        mmu = gcvNULL;
 	}
 
 	/* Return the status. */
@@ -363,19 +373,33 @@ gckMMU_Destroy(
 #endif
 
 	/* Free the page table. */
-	gcmkVERIFY_OK(
-		gckOS_FreeContiguous(Mmu->os,
-							 Mmu->pageTablePhysical,
-							 (gctPOINTER) Mmu->pageTableLogical,
-							 Mmu->pageTableSize));
+    if(Mmu->pageTableLogical != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+    		gckOS_FreeContiguous(Mmu->os,
+    							 Mmu->pageTablePhysical,
+    							 (gctPOINTER) Mmu->pageTableLogical,
+    							 Mmu->pageTableSize));
+        Mmu->pageTableLogical = gcvNULL;
+    }
 
 #ifdef __QNXNTO__
-	/* Delete the node list mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(Mmu->os, Mmu->nodeMutex));
+		if (Mmu->nodeMutex != gcvNULL)
+		{
+			/* Delete the mutex. */
+			gcmkVERIFY_OK(
+				gckOS_DeleteMutex(Mmu->os, Mmu->nodeMutex));
+            Mmu->nodeMutex = gcvNULL;
+		}
 #endif
 
-	/* Delete the page table mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(Mmu->os, Mmu->pageTableMutex));
+    if (Mmu->pageTableMutex != gcvNULL)
+	{
+		/* Delete the mutex. */
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(Mmu->os, Mmu->pageTableMutex));
+        Mmu->pageTableMutex = gcvNULL;
+	}
 
 	/* Mark the gckMMU object as unknown. */
 	Mmu->object.type = gcvOBJ_UNKNOWN;
@@ -383,6 +407,8 @@ gckMMU_Destroy(
 	/* Free the gckMMU object. */
 	gcmkVERIFY_OK(gckOS_Free(Mmu->os, Mmu));
 
+    Mmu = gcvNULL;
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
@@ -553,15 +579,20 @@ gckMMU_AllocatePages(
 		*Address = address;
 	}
 
+	/* Update used pageTable entries. */
+	Mmu->pageTableUsedEntries += PageCount;
+
 	/* Release the mutex. */
 	gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
 
 	/* Success. */
 	gcmkFOOTER_ARG("*PageTable=0x%x *Address=%08x",
 				   *PageTable, gcmOPT_VALUE(Address));
+	
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, mutex=%d", status, mutex);
 	if (mutex)
 	{
 		/* Release the mutex. */
@@ -629,6 +660,9 @@ gckMMU_FreePages(
 	/* We have free nodes. */
 	Mmu->freeNodes = gcvTRUE;
 
+	/* Update used pageTable entries. */
+	Mmu->pageTableUsedEntries -= PageCount;
+
 	/* Success. */
 	gcmkFOOTER_NO();
 	return gcvSTATUS_OK;
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_precomp.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_precomp.h
index d710a20..0379a75 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_precomp.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_precomp.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_video_memory.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_video_memory.c
index 010b90e..ab57b59 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_video_memory.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/gc_hal_kernel_video_memory.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -23,7 +23,7 @@
 
 #include "gc_hal_kernel_precomp.h"
 
-#define _GC_OBJ_ZONE	gcvZONE_VIDMEM
+#define _GC_OBJ_ZONE    gcvZONE_VIDMEM
 
 /******************************************************************************\
 ******************************* Private Functions ******************************
@@ -31,137 +31,137 @@
 
 /*******************************************************************************
 **
-**	_Split
+**  _Split
 **
-**	Split a node on the required byte boundary.
+**  Split a node on the required byte boundary.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to an gckOS object.
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to the node to split.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to the node to split.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes to keep in the node.
+**      gctSIZE_T Bytes
+**          Number of bytes to keep in the node.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 **
-**	RETURNS:
+**  RETURNS:
 **
-**		gctBOOL
-**			gcvTRUE if the node was split successfully, or gcvFALSE if there is an
-**			error.
+**      gctBOOL
+**          gcvTRUE if the node was split successfully, or gcvFALSE if there is an
+**          error.
 **
 */
 static gctBOOL
 _Split(
-	IN gckOS Os,
-	IN gcuVIDMEM_NODE_PTR Node,
-	IN gctSIZE_T Bytes
-	)
+    IN gckOS Os,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctSIZE_T Bytes
+    )
 {
-	gcuVIDMEM_NODE_PTR node;
+    gcuVIDMEM_NODE_PTR node;
 
-	/* Make sure the byte boundary makes sense. */
-	if ((Bytes <= 0) || (Bytes > Node->VidMem.bytes))
-	{
-		return gcvFALSE;
-	}
+    /* Make sure the byte boundary makes sense. */
+    if ((Bytes <= 0) || (Bytes > Node->VidMem.bytes))
+    {
+        return gcvFALSE;
+    }
 
-	/* Allocate a new gcuVIDMEM_NODE object. */
-	if (gcmIS_ERROR(gckOS_Allocate(Os,
-								   gcmSIZEOF(gcuVIDMEM_NODE),
-								   (gctPOINTER *) &node)))
-	{
-		/* Error. */
-		return gcvFALSE;
-	}
+    /* Allocate a new gcuVIDMEM_NODE object. */
+    if (gcmIS_ERROR(gckOS_Allocate(Os,
+                                   gcmSIZEOF(gcuVIDMEM_NODE),
+                                   (gctPOINTER *) &node)))
+    {
+        /* Error. */
+        return gcvFALSE;
+    }
 
-	/* Initialize gcuVIDMEM_NODE structure. */
-	node->VidMem.offset    = Node->VidMem.offset + Bytes;
-	node->VidMem.bytes     = Node->VidMem.bytes  - Bytes;
-	node->VidMem.alignment = 0;
-	node->VidMem.locked    = 0;
-	node->VidMem.memory    = Node->VidMem.memory;
-	node->VidMem.pool      = Node->VidMem.pool;
-	node->VidMem.physical  = Node->VidMem.physical;
+    /* Initialize gcuVIDMEM_NODE structure. */
+    node->VidMem.offset    = Node->VidMem.offset + Bytes;
+    node->VidMem.bytes     = Node->VidMem.bytes  - Bytes;
+    node->VidMem.alignment = 0;
+    node->VidMem.locked    = 0;
+    node->VidMem.memory    = Node->VidMem.memory;
+    node->VidMem.pool      = Node->VidMem.pool;
+    node->VidMem.physical  = Node->VidMem.physical;
 #ifdef __QNXNTO__
-	node->VidMem.logical   = gcvNULL;
-	node->VidMem.handle    = 0;
+    node->VidMem.logical   = gcvNULL;
+    node->VidMem.handle    = 0;
 #endif
 
-	/* Insert node behind specified node. */
-	node->VidMem.next = Node->VidMem.next;
-	node->VidMem.prev = Node;
-	Node->VidMem.next = node->VidMem.next->VidMem.prev = node;
+    /* Insert node behind specified node. */
+    node->VidMem.next = Node->VidMem.next;
+    node->VidMem.prev = Node;
+    Node->VidMem.next = node->VidMem.next->VidMem.prev = node;
 
-	/* Insert free node behind specified node. */
-	node->VidMem.nextFree = Node->VidMem.nextFree;
-	node->VidMem.prevFree = Node;
-	Node->VidMem.nextFree = node->VidMem.nextFree->VidMem.prevFree = node;
+    /* Insert free node behind specified node. */
+    node->VidMem.nextFree = Node->VidMem.nextFree;
+    node->VidMem.prevFree = Node;
+    Node->VidMem.nextFree = node->VidMem.nextFree->VidMem.prevFree = node;
 
-	/* Adjust size of specified node. */
-	Node->VidMem.bytes = Bytes;
+    /* Adjust size of specified node. */
+    Node->VidMem.bytes = Bytes;
 
-	/* Success. */
-	return gcvTRUE;
+    /* Success. */
+    return gcvTRUE;
 }
 
 /*******************************************************************************
 **
-**	_Merge
+**  _Merge
 **
-**	Merge two adjacent nodes together.
+**  Merge two adjacent nodes together.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to an gckOS object.
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to the first of the two nodes to merge.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to the first of the two nodes to merge.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 **
 */
 static gceSTATUS
 _Merge(
-	IN gckOS Os,
-	IN gcuVIDMEM_NODE_PTR Node
-	)
+    IN gckOS Os,
+    IN gcuVIDMEM_NODE_PTR Node
+    )
 {
-	gcuVIDMEM_NODE_PTR node;
+    gcuVIDMEM_NODE_PTR node;
 
-	/* Save pointer to next node. */
-	node = Node->VidMem.next;
+    /* Save pointer to next node. */
+    node = Node->VidMem.next;
 
-	/* This is a good time to make sure the heap is not corrupted. */
-	if (Node->VidMem.offset + Node->VidMem.bytes != node->VidMem.offset)
-	{
-		/* Corrupted heap. */
-		gcmkASSERT(
-			Node->VidMem.offset + Node->VidMem.bytes == node->VidMem.offset);
-		return gcvSTATUS_HEAP_CORRUPTED;
-	}
+    /* This is a good time to make sure the heap is not corrupted. */
+    if (Node->VidMem.offset + Node->VidMem.bytes != node->VidMem.offset)
+    {
+        /* Corrupted heap. */
+        gcmkASSERT(
+            Node->VidMem.offset + Node->VidMem.bytes == node->VidMem.offset);
+        return gcvSTATUS_HEAP_CORRUPTED;
+    }
 
-	/* Adjust byte count. */
-	Node->VidMem.bytes += node->VidMem.bytes;
+    /* Adjust byte count. */
+    Node->VidMem.bytes += node->VidMem.bytes;
 
-	/* Unlink next node from linked list. */
-	Node->VidMem.next     = node->VidMem.next;
-	Node->VidMem.nextFree = node->VidMem.nextFree;
+    /* Unlink next node from linked list. */
+    Node->VidMem.next     = node->VidMem.next;
+    Node->VidMem.nextFree = node->VidMem.nextFree;
 
-	Node->VidMem.next->VidMem.prev         =
-	Node->VidMem.nextFree->VidMem.prevFree = Node;
+    Node->VidMem.next->VidMem.prev         =
+    Node->VidMem.nextFree->VidMem.prevFree = Node;
 
-	/* Free next node. */
-	return gckOS_Free(Os, node);
+    /* Free next node. */
+    return gckOS_Free(Os, node);
 }
 
 /******************************************************************************\
@@ -170,795 +170,802 @@ _Merge(
 
 /*******************************************************************************
 **
-**	gckVIDMEM_ConstructVirtual
+**  gckVIDMEM_ConstructVirtual
 **
-**	Construct a new gcuVIDMEM_NODE union for virtual memory.
+**  Construct a new gcuVIDMEM_NODE union for virtual memory.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckKERNEL Kernel
-**			Pointer to an gckKERNEL object.
+**      gckKERNEL Kernel
+**          Pointer to an gckKERNEL object.
 **
-**		gctSIZE_T Bytes
-**			Number of byte to allocate.
+**      gctSIZE_T Bytes
+**          Number of byte to allocate.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gcuVIDMEM_NODE_PTR * Node
-**			Pointer to a variable that receives the gcuVIDMEM_NODE union pointer.
+**      gcuVIDMEM_NODE_PTR * Node
+**          Pointer to a variable that receives the gcuVIDMEM_NODE union pointer.
 */
 gceSTATUS
 gckVIDMEM_ConstructVirtual(
-	IN gckKERNEL Kernel,
-	IN gctBOOL Contiguous,
-	IN gctSIZE_T Bytes,
+    IN gckKERNEL Kernel,
+    IN gctBOOL Contiguous,
+    IN gctSIZE_T Bytes,
 #ifdef __QNXNTO__
-	IN gctHANDLE Handle,
+    IN gctHANDLE Handle,
 #endif
-	OUT gcuVIDMEM_NODE_PTR * Node
-	)
+    OUT gcuVIDMEM_NODE_PTR * Node
+    )
 {
-	gckOS os;
-	gceSTATUS status;
-	gcuVIDMEM_NODE_PTR node = gcvNULL;
+    gckOS os;
+    gceSTATUS status;
+    gcuVIDMEM_NODE_PTR node = gcvNULL;
 
-	gcmkHEADER_ARG("Kernel=0x%x Bytes=%lu", Kernel, Bytes);
+    gcmkHEADER_ARG("Kernel=0x%x Bytes=%lu", Kernel, Bytes);
 
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
-	gcmkVERIFY_ARGUMENT(Bytes > 0);
-	gcmkVERIFY_ARGUMENT(Node != gcvNULL);
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Node != gcvNULL);
 #ifdef __QNXNTO__
-	gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
 #endif
 
-	/* Extract the gckOS object pointer. */
-	os = Kernel->os;
-	gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
-
-	/* Allocate an gcuVIDMEM_NODE union. */
-	gcmkONERROR(
-		gckOS_Allocate(os, gcmSIZEOF(gcuVIDMEM_NODE), (gctPOINTER *) &node));
-
-	/* Initialize gcuVIDMEM_NODE union for virtual memory. */
-	node->Virtual.kernel        = Kernel;
-	node->Virtual.contiguous 	= Contiguous;
-	node->Virtual.locked        = 0;
-	node->Virtual.logical       = gcvNULL;
-	node->Virtual.pageTable     = gcvNULL;
-	node->Virtual.mutex         = gcvNULL;
+    /* Extract the gckOS object pointer. */
+    os = Kernel->os;
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+
+    /* Allocate an gcuVIDMEM_NODE union. */
+    gcmkONERROR(
+        gckOS_Allocate(os, gcmSIZEOF(gcuVIDMEM_NODE), (gctPOINTER *) &node));
+
+    /* Initialize gcuVIDMEM_NODE union for virtual memory. */
+    node->Virtual.kernel        = Kernel;
+    node->Virtual.contiguous    = Contiguous;
+    node->Virtual.locked        = 0;
+    node->Virtual.logical       = gcvNULL;
+    node->Virtual.pageTable     = gcvNULL;
+    node->Virtual.mutex         = gcvNULL;
 #ifdef __QNXNTO__
-	node->Virtual.next          = gcvNULL;
-	node->Virtual.unlockPending = gcvFALSE;
-	node->Virtual.freePending   = gcvFALSE;
-	node->Virtual.handle        = Handle;
+    node->Virtual.next          = gcvNULL;
+    node->Virtual.unlockPending = gcvFALSE;
+    node->Virtual.freePending   = gcvFALSE;
+    node->Virtual.handle        = Handle;
 #else
-	node->Virtual.pending       = gcvFALSE;
+    node->Virtual.pending       = gcvFALSE;
 #endif
 
-	/* Create the mutex. */
-	gcmkONERROR(
-		gckOS_CreateMutex(os, &node->Virtual.mutex));
+    /* Create the mutex. */
+    gcmkONERROR(
+        gckOS_CreateMutex(os, &node->Virtual.mutex));
 
-	/* Allocate the virtual memory. */
-	gcmkONERROR(
-		gckOS_AllocatePagedMemoryEx(os,
-									node->Virtual.contiguous,
-									node->Virtual.bytes = Bytes,
-									&node->Virtual.physical));
+    /* Allocate the virtual memory. */
+    gcmkONERROR(
+        gckOS_AllocatePagedMemoryEx(os,
+                                    node->Virtual.contiguous,
+                                    node->Virtual.bytes = Bytes,
+                                    &node->Virtual.physical));
 
 #ifdef __QNXNTO__
-	/* Register. */
-	gckMMU_InsertNode(Kernel->mmu, node);
+    /* Register. */
+    gckMMU_InsertNode(Kernel->mmu, node);
 #endif
 
-	/* Return pointer to the gcuVIDMEM_NODE union. */
-	*Node = node;
+    /* Return pointer to the gcuVIDMEM_NODE union. */
+    *Node = node;
 
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				   "Created virtual node 0x%x for %u bytes @ 0x%x",
-				   node, Bytes, node->Virtual.physical);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                   "Created virtual node 0x%x for %u bytes @ 0x%x",
+                   node, Bytes, node->Virtual.physical);
 
-	/* Success. */
-	gcmkFOOTER_ARG("*Node=0x%x", *Node);
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_ARG("*Node=0x%x", *Node);
+    return gcvSTATUS_OK;
 
 OnError:
-	/* Roll back. */
-	if (node != gcvNULL)
-	{
-		if (node->Virtual.mutex != gcvNULL)
-		{
-			/* Destroy the mutex. */
-			gcmkVERIFY_OK(gckOS_DeleteMutex(os, node->Virtual.mutex));
-		}
-
-		/* Free the structure. */
-		gcmkVERIFY_OK(gckOS_Free(os, node));
-	}
+    gcmkLOG_ERROR_ARGS("status=%d, node=0x%08x", status, node);
+    /* Roll back. */
+    if (node != gcvNULL)
+    {
+        if (node->Virtual.mutex != gcvNULL)
+        {
+            /* Destroy the mutex. */
+            gcmkVERIFY_OK(gckOS_DeleteMutex(os, node->Virtual.mutex));
+            node->Virtual.mutex= gcvNULL;
+        }
+
+        /* Free the structure. */
+        gcmkVERIFY_OK(gckOS_Free(os, node));
+        node = gcvNULL;
+    }
 
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_DestroyVirtual
+**  gckVIDMEM_DestroyVirtual
 **
-**	Destroy an gcuVIDMEM_NODE union for virtual memory.
+**  Destroy an gcuVIDMEM_NODE union for virtual memory.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to a gcuVIDMEM_NODE union.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to a gcuVIDMEM_NODE union.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 */
 gceSTATUS
 gckVIDMEM_DestroyVirtual(
-	IN gcuVIDMEM_NODE_PTR Node
-	)
+    IN gcuVIDMEM_NODE_PTR Node
+    )
 {
-	gckOS os;
-
-	gcmkHEADER_ARG("Node=0x%x", Node);
+    gckOS os;
+	gceSTATUS status;
+    gcmkHEADER_ARG("Node=0x%x", Node);
 
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
 
-	/* Extact the gckOS object pointer. */
-	os = Node->Virtual.kernel->os;
-	gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+    /* Extact the gckOS object pointer. */
+    os = Node->Virtual.kernel->os;
+    gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
 #ifdef __QNXNTO__
     /* Unregister. */
-	gcmkVERIFY_OK(
-	        gckMMU_RemoveNode(Node->Virtual.kernel->mmu, Node));
-
-	/* Free virtual memory. */
-	gcmkVERIFY_OK(
-	        gckOS_FreePagedMemory(os,
-	                              Node->Virtual.physical,
-	                              Node->Virtual.bytes));
+    gcmkVERIFY_OK(
+            gckMMU_RemoveNode(Node->Virtual.kernel->mmu, Node));
+
+    /* Free virtual memory. */
+    gcmkVERIFY_OK(
+            gckOS_FreePagedMemory(os,
+                                  Node->Virtual.physical,
+                                  Node->Virtual.bytes));
 #endif
 
-	/* Delete the mutex. */
-	gcmkVERIFY_OK(gckOS_DeleteMutex(os, Node->Virtual.mutex));
+    /* Delete the mutex. */
+    if(Node->Virtual.mutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(os, Node->Virtual.mutex));
+    }
 
-	if (Node->Virtual.pageTable != gcvNULL)
+    if (Node->Virtual.pageTable != gcvNULL)
 	{
 		/* Free the pages. */
-		gcmkVERIFY_OK(gckMMU_FreePages(Node->Virtual.kernel->mmu,
+		gcmkONERROR(gckMMU_FreePages(Node->Virtual.kernel->mmu,
 									   Node->Virtual.pageTable,
 									   Node->Virtual.pageCount));
 	}
 
-	/* Delete the gcuVIDMEM_NODE union. */
-	gcmkVERIFY_OK(gckOS_Free(os, Node));
 
-	/* Success. */
-	gcmkFOOTER_NO();
-	return gcvSTATUS_OK;
+    /* Delete the gcuVIDMEM_NODE union. */
+    gcmkVERIFY_OK(gckOS_Free(os, Node));
+    Node = gcvNULL;
+
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+    
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Construct
+**  gckVIDMEM_Construct
 **
-**	Construct a new gckVIDMEM object.
+**  Construct a new gckVIDMEM object.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to an gckOS object.
 **
-**		gctUINT32 BaseAddress
-**			Base address for the video memory heap.
+**      gctUINT32 BaseAddress
+**          Base address for the video memory heap.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes in the video memory heap.
+**      gctSIZE_T Bytes
+**          Number of bytes in the video memory heap.
 **
-**		gctSIZE_T Threshold
-**			Minimum number of bytes beyond am allocation before the node is
-**			split.  Can be used as a minimum alignment requirement.
+**      gctSIZE_T Threshold
+**          Minimum number of bytes beyond am allocation before the node is
+**          split.  Can be used as a minimum alignment requirement.
 **
-**		gctSIZE_T BankSize
-**			Number of bytes per physical memory bank.  Used by bank
-**			optimization.
+**      gctSIZE_T BankSize
+**          Number of bytes per physical memory bank.  Used by bank
+**          optimization.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gckVIDMEM * Memory
-**			Pointer to a variable that will hold the pointer to the gckVIDMEM
-**			object.
+**      gckVIDMEM * Memory
+**          Pointer to a variable that will hold the pointer to the gckVIDMEM
+**          object.
 */
 gceSTATUS
 gckVIDMEM_Construct(
-	IN gckOS Os,
-	IN gctUINT32 BaseAddress,
-	IN gctSIZE_T Bytes,
-	IN gctSIZE_T Threshold,
-	IN gctSIZE_T BankSize,
-	OUT gckVIDMEM * Memory
-	)
+    IN gckOS Os,
+    IN gctUINT32 BaseAddress,
+    IN gctSIZE_T Bytes,
+    IN gctSIZE_T Threshold,
+    IN gctSIZE_T BankSize,
+    OUT gckVIDMEM * Memory
+    )
 {
-	gckVIDMEM memory = gcvNULL;
-	gceSTATUS status;
-	gcuVIDMEM_NODE_PTR node;
-	gctINT i, banks = 0;
-
-	gcmkHEADER_ARG("Os=0x%x BaseAddress=%08x Bytes=%lu Threshold=%lu "
-				   "BankSize=%lu",
-				   Os, BaseAddress, Bytes, Threshold, BankSize);
-
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Bytes > 0);
-	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
-
-	/* Allocate the gckVIDMEM object. */
-	gcmkONERROR(
-		gckOS_Allocate(Os,
-					   gcmSIZEOF(struct _gckVIDMEM),
-					   (gctPOINTER *) &memory));
-
-	/* Initialize the gckVIDMEM object. */
-	memory->object.type = gcvOBJ_VIDMEM;
-	memory->os          = Os;
-
-	/* Set video memory heap information. */
-	memory->baseAddress = BaseAddress;
-	memory->bytes       = Bytes;
-	memory->freeBytes   = Bytes;
-	memory->threshold   = Threshold;
-	memory->mutex       = gcvNULL;
-
-	BaseAddress = 0;
-
-	/* Walk all possible banks. */
-	for (i = 0; i < gcmCOUNTOF(memory->sentinel); ++i)
-	{
-		gctSIZE_T bytes;
-
-		if (BankSize == 0)
-		{
-			/* Use all bytes for the first bank. */
-			bytes = Bytes;
-		}
-		else
-		{
-			/* Compute number of bytes for this bank. */
-			bytes = gcmALIGN(BaseAddress + 1, BankSize) - BaseAddress;
-
-			if (bytes > Bytes)
-			{
-				/* Make sure we don't exceed the total number of bytes. */
-				bytes = Bytes;
-			}
-		}
-
-		if (bytes == 0)
-		{
-			/* Mark heap is not used. */
-			memory->sentinel[i].VidMem.next     =
-			memory->sentinel[i].VidMem.prev     =
-			memory->sentinel[i].VidMem.nextFree =
-			memory->sentinel[i].VidMem.prevFree = gcvNULL;
-			continue;
-		}
-
-		/* Allocate one gcuVIDMEM_NODE union. */
-		gcmkONERROR(
-			gckOS_Allocate(Os,
-						   gcmSIZEOF(gcuVIDMEM_NODE),
-						   (gctPOINTER *) &node));
-
-		/* Initialize gcuVIDMEM_NODE union. */
-		node->VidMem.memory    = memory;
-
-		node->VidMem.next      =
-		node->VidMem.prev      =
-		node->VidMem.nextFree  =
-		node->VidMem.prevFree  = &memory->sentinel[i];
-
-		node->VidMem.offset    = BaseAddress;
-		node->VidMem.bytes     = bytes;
-		node->VidMem.alignment = 0;
-		node->VidMem.physical  = 0;
-		node->VidMem.pool      = gcvPOOL_UNKNOWN;
-
-		node->VidMem.locked    = 0;
+    gckVIDMEM memory = gcvNULL;
+    gceSTATUS status;
+    gcuVIDMEM_NODE_PTR node;
+    gctINT i, banks = 0;
+
+    gcmkHEADER_ARG("Os=0x%x BaseAddress=%08x Bytes=%lu Threshold=%lu "
+                   "BankSize=%lu",
+                   Os, BaseAddress, Bytes, Threshold, BankSize);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+
+    /* Allocate the gckVIDMEM object. */
+    gcmkONERROR(
+        gckOS_Allocate(Os,
+                       gcmSIZEOF(struct _gckVIDMEM),
+                       (gctPOINTER *) &memory));
+
+    /* Initialize the gckVIDMEM object. */
+    memory->object.type = gcvOBJ_VIDMEM;
+    memory->os          = Os;
+
+    /* Set video memory heap information. */
+    memory->baseAddress = BaseAddress;
+    memory->bytes       = Bytes;
+    memory->freeBytes   = Bytes;
+    memory->threshold   = Threshold;
+    memory->mutex       = gcvNULL;
+
+    BaseAddress = 0;
+
+    /* Walk all possible banks. */
+    for (i = 0; i < gcmCOUNTOF(memory->sentinel); ++i)
+    {
+        gctSIZE_T bytes;
+
+        if (BankSize == 0)
+        {
+            /* Use all bytes for the first bank. */
+            bytes = Bytes;
+        }
+        else
+        {
+            /* Compute number of bytes for this bank. */
+            bytes = gcmALIGN(BaseAddress + 1, BankSize) - BaseAddress;
+
+            if (bytes > Bytes)
+            {
+                /* Make sure we don't exceed the total number of bytes. */
+                bytes = Bytes;
+            }
+        }
+
+        if (bytes == 0)
+        {
+            /* Mark heap is not used. */
+            memory->sentinel[i].VidMem.next     =
+            memory->sentinel[i].VidMem.prev     =
+            memory->sentinel[i].VidMem.nextFree =
+            memory->sentinel[i].VidMem.prevFree = gcvNULL;
+            continue;
+        }
+
+        /* Allocate one gcuVIDMEM_NODE union. */
+        gcmkONERROR(
+            gckOS_Allocate(Os,
+                           gcmSIZEOF(gcuVIDMEM_NODE),
+                           (gctPOINTER *) &node));
+
+        /* Initialize gcuVIDMEM_NODE union. */
+        node->VidMem.memory    = memory;
+
+        node->VidMem.next      =
+        node->VidMem.prev      =
+        node->VidMem.nextFree  =
+        node->VidMem.prevFree  = &memory->sentinel[i];
+
+        node->VidMem.offset    = BaseAddress;
+        node->VidMem.bytes     = bytes;
+        node->VidMem.alignment = 0;
+        node->VidMem.physical  = 0;
+        node->VidMem.pool      = gcvPOOL_UNKNOWN;
+
+        node->VidMem.locked    = 0;
 
 #ifdef __QNXNTO__
         node->VidMem.logical   = gcvNULL;
         node->VidMem.handle    = 0;
 #endif
 
-		/* Initialize the linked list of nodes. */
-		memory->sentinel[i].VidMem.next     =
-		memory->sentinel[i].VidMem.prev     =
-		memory->sentinel[i].VidMem.nextFree =
-		memory->sentinel[i].VidMem.prevFree = node;
+        /* Initialize the linked list of nodes. */
+        memory->sentinel[i].VidMem.next     =
+        memory->sentinel[i].VidMem.prev     =
+        memory->sentinel[i].VidMem.nextFree =
+        memory->sentinel[i].VidMem.prevFree = node;
 
-		/* Mark sentinel. */
-		memory->sentinel[i].VidMem.bytes = 0;
+        /* Mark sentinel. */
+        memory->sentinel[i].VidMem.bytes = 0;
 
-		/* Adjust address for next bank. */
-		BaseAddress += bytes;
-		Bytes       -= bytes;
-		banks       ++;
-	}
+        /* Adjust address for next bank. */
+        BaseAddress += bytes;
+        Bytes       -= bytes;
+        banks       ++;
+    }
 
-	/* Assign all the bank mappings. */
-	memory->mapping[gcvSURF_RENDER_TARGET]      = banks - 1;
-	memory->mapping[gcvSURF_BITMAP]             = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_DEPTH]              = banks - 1;
-	memory->mapping[gcvSURF_HIERARCHICAL_DEPTH] = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_TEXTURE]            = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_VERTEX]             = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_INDEX]              = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_TILE_STATUS]        = banks - 1;
-	if (banks > 1) --banks;
-	memory->mapping[gcvSURF_TYPE_UNKNOWN]       = 0;
-
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] INDEX:         bank %d",
-				  memory->mapping[gcvSURF_INDEX]);
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] VERTEX:        bank %d",
-				  memory->mapping[gcvSURF_VERTEX]);
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] TEXTURE:       bank %d",
-				  memory->mapping[gcvSURF_TEXTURE]);
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] RENDER_TARGET: bank %d",
-				  memory->mapping[gcvSURF_RENDER_TARGET]);
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] DEPTH:         bank %d",
-				  memory->mapping[gcvSURF_DEPTH]);
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				  "[GALCORE] TILE_STATUS:   bank %d",
-				  memory->mapping[gcvSURF_TILE_STATUS]);
-
-	/* Allocate the mutex. */
-	gcmkONERROR(gckOS_CreateMutex(Os, &memory->mutex));
-
-	/* Return pointer to the gckVIDMEM object. */
-	*Memory = memory;
-
-	/* Success. */
-	gcmkFOOTER_ARG("*Memory=0x%x", *Memory);
-	return gcvSTATUS_OK;
+    /* Assign all the bank mappings. */
+    memory->mapping[gcvSURF_RENDER_TARGET]      = banks - 1;
+    memory->mapping[gcvSURF_BITMAP]             = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_DEPTH]              = banks - 1;
+    memory->mapping[gcvSURF_HIERARCHICAL_DEPTH] = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_TEXTURE]            = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_VERTEX]             = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_INDEX]              = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_TILE_STATUS]        = banks - 1;
+    if (banks > 1) --banks;
+    memory->mapping[gcvSURF_TYPE_UNKNOWN]       = 0;
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] INDEX:         bank %d",
+                  memory->mapping[gcvSURF_INDEX]);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] VERTEX:        bank %d",
+                  memory->mapping[gcvSURF_VERTEX]);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] TEXTURE:       bank %d",
+                  memory->mapping[gcvSURF_TEXTURE]);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] RENDER_TARGET: bank %d",
+                  memory->mapping[gcvSURF_RENDER_TARGET]);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] DEPTH:         bank %d",
+                  memory->mapping[gcvSURF_DEPTH]);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                  "[GALCORE] TILE_STATUS:   bank %d",
+                  memory->mapping[gcvSURF_TILE_STATUS]);
+
+    /* Allocate the mutex. */
+    gcmkONERROR(gckOS_CreateMutex(Os, &memory->mutex));
+
+    /* Return pointer to the gckVIDMEM object. */
+    *Memory = memory;
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Memory=0x%x", *Memory);
+    return gcvSTATUS_OK;
 
 OnError:
-	/* Roll back. */
-	if (memory != gcvNULL)
-	{
-		if (memory->mutex != gcvNULL)
-		{
-			/* Delete the mutex. */
-			gcmkVERIFY_OK(gckOS_DeleteMutex(Os, memory->mutex));
-		}
-
-		for (i = 0; i < banks; ++i)
-		{
-			/* Free the heap. */
-			gcmkASSERT(memory->sentinel[i].VidMem.next != gcvNULL);
-			gcmkVERIFY_OK(gckOS_Free(Os, memory->sentinel[i].VidMem.next));
-		}
-
-		/* Free the object. */
-		gcmkVERIFY_OK(gckOS_Free(Os, memory));
-	}
+    gcmkLOG_ERROR_ARGS("status=%d, memory=0x%08x", status, memory);
+    /* Roll back. */
+    if (memory != gcvNULL)
+    {
+        if (memory->mutex != gcvNULL)
+        {
+            /* Delete the mutex. */
+            gcmkVERIFY_OK(gckOS_DeleteMutex(Os, memory->mutex));
+            memory->mutex = gcvNULL;
+        }
+
+        for (i = 0; i < banks; ++i)
+        {
+            /* Free the heap. */
+            gcmkASSERT(memory->sentinel[i].VidMem.next != gcvNULL);
+            gcmkVERIFY_OK(gckOS_Free(Os, memory->sentinel[i].VidMem.next));
+        }
+
+        /* Free the object. */
+        gcmkVERIFY_OK(gckOS_Free(Os, memory));
+
+        memory = gcvNULL;
+    }
 
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Destroy
+**  gckVIDMEM_Destroy
 **
-**	Destroy an gckVIDMEM object.
+**  Destroy an gckVIDMEM object.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckVIDMEM Memory
-**			Pointer to an gckVIDMEM object to destroy.
+**      gckVIDMEM Memory
+**          Pointer to an gckVIDMEM object to destroy.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 */
 gceSTATUS
 gckVIDMEM_Destroy(
-	IN gckVIDMEM Memory
-	)
+    IN gckVIDMEM Memory
+    )
 {
-	gcuVIDMEM_NODE_PTR node, next;
-	gctINT i;
+    gcuVIDMEM_NODE_PTR node, next;
+    gctINT i;
 
-	gcmkHEADER_ARG("Memory=0x%x", Memory);
+    gcmkHEADER_ARG("Memory=0x%x", Memory);
 
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
 
-	/* Walk all sentinels. */
-	for (i = 0; i < gcmCOUNTOF(Memory->sentinel); ++i)
-	{
-		/* Bail out of the heap is not used. */
-		if (Memory->sentinel[i].VidMem.next == gcvNULL)
-		{
-			break;
-		}
-
-		/* Walk all the nodes until we reach the sentinel. */
-		for (node = Memory->sentinel[i].VidMem.next;
-			 node->VidMem.bytes != 0;
-			 node = next)
-		{
-			/* Save pointer to the next node. */
-			next = node->VidMem.next;
-
-			/* Free the node. */
-			gcmkVERIFY_OK(gckOS_Free(Memory->os, node));
-		}
-	}
+    /* Walk all sentinels. */
+    for (i = 0; i < gcmCOUNTOF(Memory->sentinel); ++i)
+    {
+        /* Bail out of the heap is not used. */
+        if (Memory->sentinel[i].VidMem.next == gcvNULL)
+        {
+            break;
+        }
+
+        /* Walk all the nodes until we reach the sentinel. */
+        for (node = Memory->sentinel[i].VidMem.next;
+             node->VidMem.bytes != 0;
+             node = next)
+        {
+            /* Save pointer to the next node. */
+            next = node->VidMem.next;
+
+            /* Free the node. */
+            gcmkVERIFY_OK(gckOS_Free(Memory->os, node));
+        }
+    }
 
     /* Free the mutex. */
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Memory->os, Memory->mutex));
-
-	/* Mark the object as unknown. */
-	Memory->object.type = gcvOBJ_UNKNOWN;
+    if(Memory->mutex != gcvNULL)
+    {
+        gcmkVERIFY_OK(gckOS_DeleteMutex(Memory->os, Memory->mutex));
+        Memory->mutex = gcvNULL;
+    }
+    
+    /* Mark the object as unknown. */
+    Memory->object.type = gcvOBJ_UNKNOWN;
 
-	/* Free the gckVIDMEM object. */
-	gcmkVERIFY_OK(gckOS_Free(Memory->os, Memory));
+    /* Free the gckVIDMEM object. */
+    gcmkVERIFY_OK(gckOS_Free(Memory->os, Memory));
+    Memory = gcvNULL;
 
-	/* Success. */
-	gcmkFOOTER_NO();
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Allocate
+**  gckVIDMEM_Allocate
 **
-**	Allocate rectangular memory from the gckVIDMEM object.
+**  Allocate rectangular memory from the gckVIDMEM object.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckVIDMEM Memory
-**			Pointer to an gckVIDMEM object.
+**      gckVIDMEM Memory
+**          Pointer to an gckVIDMEM object.
 **
-**		gctUINT Width
-**			Width of rectangle to allocate.  Make sure the width is properly
-**			aligned.
+**      gctUINT Width
+**          Width of rectangle to allocate.  Make sure the width is properly
+**          aligned.
 **
-**		gctUINT Height
-**			Height of rectangle to allocate.  Make sure the height is properly
-**			aligned.
+**      gctUINT Height
+**          Height of rectangle to allocate.  Make sure the height is properly
+**          aligned.
 **
-**		gctUINT Depth
-**			Depth of rectangle to allocate.  This equals to the number of
-**			rectangles to allocate contiguously (i.e., for cubic maps and volume
-**			textures).
+**      gctUINT Depth
+**          Depth of rectangle to allocate.  This equals to the number of
+**          rectangles to allocate contiguously (i.e., for cubic maps and volume
+**          textures).
 **
-**		gctUINT BytesPerPixel
-**			Number of bytes per pixel.
+**      gctUINT BytesPerPixel
+**          Number of bytes per pixel.
 **
-**		gctUINT32 Alignment
-**			Byte alignment for allocation.
+**      gctUINT32 Alignment
+**          Byte alignment for allocation.
 **
-**		gceSURF_TYPE Type
-**			Type of surface to allocate (use by bank optimization).
+**      gceSURF_TYPE Type
+**          Type of surface to allocate (use by bank optimization).
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gcuVIDMEM_NODE_PTR * Node
-**			Pointer to a variable that will hold the allocated memory node.
+**      gcuVIDMEM_NODE_PTR * Node
+**          Pointer to a variable that will hold the allocated memory node.
 */
-
-#undef MRVL_DEBUG_VMEM
-
-#ifdef MRVL_DEBUG_VMEM
-#include <linux/module.h>
-
-gctSIZE_T total_alloc_vmem;
-gctSIZE_T total_free_vmem;
-gctSIZE_T total_used_vmem;
-#endif
-
 gceSTATUS
 gckVIDMEM_Allocate(
-	IN gckVIDMEM Memory,
-	IN gctUINT Width,
-	IN gctUINT Height,
-	IN gctUINT Depth,
-	IN gctUINT BytesPerPixel,
-	IN gctUINT32 Alignment,
-	IN gceSURF_TYPE Type,
+    IN gckVIDMEM Memory,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Depth,
+    IN gctUINT BytesPerPixel,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
 #ifdef __QNXNTO__
-	IN gctHANDLE Handle,
+    IN gctHANDLE Handle,
 #endif
-	OUT gcuVIDMEM_NODE_PTR * Node
-	)
+    OUT gcuVIDMEM_NODE_PTR * Node
+    )
 {
-	gctSIZE_T bytes;
-	gceSTATUS status;
+    gctSIZE_T bytes;
+    gceSTATUS status;
 
-	gcmkHEADER_ARG("Memory=0x%x Width=%u Height=%u Depth=%u BytesPerPixel=%u "
-				   "Alignment=%u Type=%d",
-				   Memory, Width, Height, Depth, BytesPerPixel, Alignment,
-				   Type);
-
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
-	gcmkVERIFY_ARGUMENT(Width > 0);
-	gcmkVERIFY_ARGUMENT(Height > 0);
-	gcmkVERIFY_ARGUMENT(Depth > 0);
-	gcmkVERIFY_ARGUMENT(BytesPerPixel > 0);
-	gcmkVERIFY_ARGUMENT(Node != gcvNULL);
+    gcmkHEADER_ARG("Memory=0x%x Width=%u Height=%u Depth=%u BytesPerPixel=%u "
+                   "Alignment=%u Type=%d",
+                   Memory, Width, Height, Depth, BytesPerPixel, Alignment,
+                   Type);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
+    gcmkVERIFY_ARGUMENT(Width > 0);
+    gcmkVERIFY_ARGUMENT(Height > 0);
+    gcmkVERIFY_ARGUMENT(Depth > 0);
+    gcmkVERIFY_ARGUMENT(BytesPerPixel > 0);
+    gcmkVERIFY_ARGUMENT(Node != gcvNULL);
 #ifdef __QNXNTO__
-	gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
 #endif
 
-	/* Compute linear size. */
-	bytes = Width * Height * Depth * BytesPerPixel;
+    if(gckOS_ForceMemAllocFail(Memory->os))
+        return gcvSTATUS_OUT_OF_MEMORY;
 
-#ifdef MRVL_DEBUG_VMEM
-/*	total_used_vmem += bytes;*/
-	total_alloc_vmem += bytes;
-
-	printk("total allocate  vmem : %ld\n",total_alloc_vmem);
-#endif
+    /* Compute linear size. */
+    bytes = Width * Height * Depth * BytesPerPixel;
 
-	/* Allocate through linear function. */
+    /* Allocate through linear function. */
 #ifdef __QNXNTO__
-	gcmkONERROR(
-		gckVIDMEM_AllocateLinear(Memory, bytes, Alignment, Type, Handle, Node));
+    gcmkONERROR(
+        gckVIDMEM_AllocateLinear(Memory, bytes, Alignment, Type, Handle, Node));
 #else
-	gcmkONERROR(
-		gckVIDMEM_AllocateLinear(Memory, bytes, Alignment, Type, Node));
+    gcmkONERROR(
+        gckVIDMEM_AllocateLinear(Memory, bytes, Alignment, Type, Node));
 #endif
 
-	/* Success. */
-	gcmkFOOTER_ARG("*Node=0x%x", *Node);
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_ARG("*Node=0x%x", *Node);
+    return gcvSTATUS_OK;
 
 OnError:
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 static gcuVIDMEM_NODE_PTR
 _FindNode(
-	IN gckVIDMEM Memory,
-	IN gctINT Bank,
-	IN gctSIZE_T Bytes,
-	IN OUT gctUINT32_PTR Alignment
-	)
+    IN gckVIDMEM Memory,
+    IN gctINT Bank,
+    IN gctSIZE_T Bytes,
+    IN OUT gctUINT32_PTR Alignment
+    )
 {
-	gcuVIDMEM_NODE_PTR node;
-	gctUINT32 alignment;
-
-	/* Walk all free nodes until we have one that is big enough or we have
-	   reached the sentinel. */
-	for (node = Memory->sentinel[Bank].VidMem.nextFree;
-		 node->VidMem.bytes != 0;
-		 node = node->VidMem.nextFree)
-	{
-		/* Compute number of bytes to skip for alignment. */
-		alignment = (*Alignment == 0)
-				  ? 0
-				  : (*Alignment - (node->VidMem.offset % *Alignment));
-
-		if (alignment == *Alignment)
-		{
-			/* Node is already aligned. */
-			alignment = 0;
-		}
-
-		if (node->VidMem.bytes >= Bytes + alignment)
-		{
-			/* This node is big enough. */
-			*Alignment = alignment;
-			return node;
-		}
-	}
+    gcuVIDMEM_NODE_PTR node;
+    gctUINT32 alignment;
+
+    /* Walk all free nodes until we have one that is big enough or we have
+       reached the sentinel. */
+    for (node = Memory->sentinel[Bank].VidMem.nextFree;
+         node->VidMem.bytes != 0;
+         node = node->VidMem.nextFree)
+    {
+        /* Compute number of bytes to skip for alignment. */
+        alignment = (*Alignment == 0)
+                  ? 0
+                  : (*Alignment - (node->VidMem.offset % *Alignment));
+
+        if (alignment == *Alignment)
+        {
+            /* Node is already aligned. */
+            alignment = 0;
+        }
+
+        if (node->VidMem.bytes >= Bytes + alignment)
+        {
+            /* This node is big enough. */
+            *Alignment = alignment;
+            return node;
+        }
+    }
 
-	/* Not enough memory. */
-	return gcvNULL;
+    /* Not enough memory. */
+    return gcvNULL;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_AllocateLinear
+**  gckVIDMEM_AllocateLinear
 **
-**	Allocate linear memory from the gckVIDMEM object.
+**  Allocate linear memory from the gckVIDMEM object.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckVIDMEM Memory
-**			Pointer to an gckVIDMEM object.
+**      gckVIDMEM Memory
+**          Pointer to an gckVIDMEM object.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes to allocate.
+**      gctSIZE_T Bytes
+**          Number of bytes to allocate.
 **
-**		gctUINT32 Alignment
-**			Byte alignment for allocation.
+**      gctUINT32 Alignment
+**          Byte alignment for allocation.
 **
-**		gceSURF_TYPE Type
-**			Type of surface to allocate (use by bank optimization).
+**      gceSURF_TYPE Type
+**          Type of surface to allocate (use by bank optimization).
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gcuVIDMEM_NODE_PTR * Node
-**			Pointer to a variable that will hold the allocated memory node.
+**      gcuVIDMEM_NODE_PTR * Node
+**          Pointer to a variable that will hold the allocated memory node.
 */
 gceSTATUS
 gckVIDMEM_AllocateLinear(
-	IN gckVIDMEM Memory,
-	IN gctSIZE_T Bytes,
-	IN gctUINT32 Alignment,
-	IN gceSURF_TYPE Type,
+    IN gckVIDMEM Memory,
+    IN gctSIZE_T Bytes,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
 #ifdef __QNXNTO__
-	IN gctHANDLE Handle,
+    IN gctHANDLE Handle,
 #endif
-	OUT gcuVIDMEM_NODE_PTR * Node
-	)
+    OUT gcuVIDMEM_NODE_PTR * Node
+    )
 {
     gceSTATUS status;
-	gcuVIDMEM_NODE_PTR node;
-	gctUINT32 alignment;
-	gctINT bank, i;
-	gctBOOL acquired = gcvFALSE;
-
-	gcmkHEADER_ARG("Memory=0x%x Bytes=%lu Alignment=%u Type=%d",
-				   Memory, Bytes, Alignment, Type);
-
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
-	gcmkVERIFY_ARGUMENT(Bytes > 0);
-	gcmkVERIFY_ARGUMENT(Node != gcvNULL);
+    gcuVIDMEM_NODE_PTR node;
+    gctUINT32 alignment;
+    gctINT bank, i;
+    gctBOOL acquired = gcvFALSE;
+
+    gcmkHEADER_ARG("Memory=0x%x Bytes=%lu Alignment=%u Type=%d",
+                   Memory, Bytes, Alignment, Type);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Node != gcvNULL);
 #ifdef __QNXNTO__
-	gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Handle != gcvNULL);
 #endif
 
     /* Acquire the mutex. */
     gcmkONERROR(
-    	gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
+        gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
 
     acquired = gcvTRUE;
 
-	if (Bytes > Memory->freeBytes)
-	{
-		/* Not enough memory. */
-		gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
-	}
-
-#ifdef MRVL_DEBUG_VMEM
-/*	total_used_vmem += Bytes;*/
-	total_alloc_vmem += Bytes;
+    if (Bytes > Memory->freeBytes)
+    {
+		gcmkLOG_WARNING_ARGS("Not enough video memory, Bytes=%d, Memory->freeBytes=%d", Bytes, Memory->freeBytes);
+        /* Not enough memory. */
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
 
-	printk("total allocate  vmem : %ld\n",total_alloc_vmem);
-#endif
+    /* Find the default bank for this surface type. */
+    gcmkASSERT((gctINT) Type < gcmCOUNTOF(Memory->mapping));
+    bank      = Memory->mapping[Type];
+    alignment = Alignment;
 
-	/* Find the default bank for this surface type. */
-	gcmkASSERT((gctINT) Type < gcmCOUNTOF(Memory->mapping));
-	bank      = Memory->mapping[Type];
-	alignment = Alignment;
+    /* Find a free node in the default bank. */
+    node = _FindNode(Memory, bank, Bytes, &alignment);
 
-	/* Find a free node in the default bank. */
-	node = _FindNode(Memory, bank, Bytes, &alignment);
+    /* Out of memory? */
+    if (node == gcvNULL)
+    {
+        /* Walk all lower banks. */
+        for (i = bank - 1; i >= 0; --i)
+        {
+            /* Find a free node inside the current bank. */
+            node = _FindNode(Memory, i, Bytes, &alignment);
+            if (node != gcvNULL)
+            {
+                break;
+            }
+        }
+    }
 
-	/* Out of memory? */
-	if (node == gcvNULL)
-	{
-		/* Walk all lower banks. */
-		for (i = bank - 1; i >= 0; --i)
-		{
-			/* Find a free node inside the current bank. */
-			node = _FindNode(Memory, i, Bytes, &alignment);
-			if (node != gcvNULL)
-			{
-				break;
-			}
-		}
-	}
+    if (node == gcvNULL)
+    {
+        /* Walk all upper banks. */
+        for (i = bank + 1; i < gcmCOUNTOF(Memory->sentinel); ++i)
+        {
+            if (Memory->sentinel[i].VidMem.nextFree == gcvNULL)
+            {
+                /* Abort when we reach unused banks. */
+                break;
+            }
 
-	if (node == gcvNULL)
-	{
-		/* Walk all upper banks. */
-		for (i = bank + 1; i < gcmCOUNTOF(Memory->sentinel); ++i)
-		{
-			if (Memory->sentinel[i].VidMem.nextFree == gcvNULL)
-			{
-				/* Abort when we reach unused banks. */
-				break;
-			}
-
-			/* Find a free node inside the current bank. */
-			node = _FindNode(Memory, i, Bytes, &alignment);
-			if (node != gcvNULL)
-			{
-				break;
-			}
-		}
-	}
+            /* Find a free node inside the current bank. */
+            node = _FindNode(Memory, i, Bytes, &alignment);
+            if (node != gcvNULL)
+            {
+                break;
+            }
+        }
+    }
 
-	if (node == gcvNULL)
-	{
-		/* Out of memory. */
-		gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
-	}
+    if (node == gcvNULL)
+    {
+		gcmkLOG_WARNING_ARGS("Can't find a free node");
+        /* Out of memory. */
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
 
-	/* Do we have an alignment? */
-	if (alignment > 0)
-	{
-		/* Split the node so it is aligned. */
-		if (_Split(Memory->os, node, alignment))
-		{
-			/* Successful split, move to aligned node. */
-			node = node->VidMem.next;
-
-			/* Remove alignment. */
-			alignment = 0;
-		}
-	}
+    /* Do we have an alignment? */
+    if (alignment > 0)
+    {
+        /* Split the node so it is aligned. */
+        if (_Split(Memory->os, node, alignment))
+        {
+            /* Successful split, move to aligned node. */
+            node = node->VidMem.next;
+
+            /* Remove alignment. */
+            alignment = 0;
+        }
+    }
 
-	/* Do we have enough memory after the allocation to split it? */
-	if (node->VidMem.bytes - Bytes > Memory->threshold)
-	{
-		/* Adjust the node size. */
-		_Split(Memory->os, node, Bytes);
-	}
+    /* Do we have enough memory after the allocation to split it? */
+    if (node->VidMem.bytes - Bytes > Memory->threshold)
+    {
+        /* Adjust the node size. */
+        _Split(Memory->os, node, Bytes);
+    }
 
-	/* Remove the node from the free list. */
-	node->VidMem.prevFree->VidMem.nextFree = node->VidMem.nextFree;
-	node->VidMem.nextFree->VidMem.prevFree = node->VidMem.prevFree;
-	node->VidMem.nextFree                  =
-	node->VidMem.prevFree                  = gcvNULL;
+    /* Remove the node from the free list. */
+    node->VidMem.prevFree->VidMem.nextFree = node->VidMem.nextFree;
+    node->VidMem.nextFree->VidMem.prevFree = node->VidMem.prevFree;
+    node->VidMem.nextFree                  =
+    node->VidMem.prevFree                  = gcvNULL;
 
-	/* Fill in the information. */
-	node->VidMem.alignment = alignment;
-	node->VidMem.memory    = Memory;
+    /* Fill in the information. */
+    node->VidMem.alignment = alignment;
+    node->VidMem.memory    = Memory;
 #ifdef __QNXNTO__
-	node->VidMem.logical   = gcvNULL;
-	node->VidMem.handle    = Handle;
+    node->VidMem.logical   = gcvNULL;
+    node->VidMem.handle    = Handle;
 #endif
 
-	/* Adjust the number of free bytes. */
-	Memory->freeBytes -= node->VidMem.bytes;
+    /* Adjust the number of free bytes. */
+    Memory->freeBytes -= node->VidMem.bytes;
 
-	/* Release the mutex. */
-	gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
 
-	/* Return the pointer to the node. */
-	*Node = node;
+    /* Return the pointer to the node. */
+    *Node = node;
 
-	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-				   "Allocated %u bytes @ 0x%x [0x%08X]",
-				   node->VidMem.bytes, node, node->VidMem.offset);
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                   "Allocated %u bytes @ 0x%x [0x%08X]",
+                   node->VidMem.bytes, node, node->VidMem.offset);
 
-	/* Success. */
-	gcmkFOOTER_ARG("*Node=0x%x", *Node);
-	return gcvSTATUS_OK;
+	/* Update video memory usage. */
+	gckOS_UpdateVidMemUsage(Memory->os, gcvTRUE, node->VidMem.bytes);
+	
+    /* Success. */
+    gcmkFOOTER_ARG("*Node=0x%x", *Node);
+    return gcvSTATUS_OK;
 
 OnError:
-	if (acquired)
-	{
-   	 /* Release the mutex. */
-    	gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
+    if (acquired)
+    {
+     /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
     }
 
     /* Return the status. */
@@ -968,87 +975,78 @@ OnError:
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Free
+**  gckVIDMEM_Free
 **
-**	Free an allocated video memory node.
+**  Free an allocated video memory node.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to a gcuVIDMEM_NODE object.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to a gcuVIDMEM_NODE object.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 */
 gceSTATUS
 gckVIDMEM_Free(
-	IN gcuVIDMEM_NODE_PTR Node
-	)
+    IN gcuVIDMEM_NODE_PTR Node
+    )
 {
-	gckVIDMEM memory = gcvNULL;
-	gcuVIDMEM_NODE_PTR node;
-	gceSTATUS status;
-	gctBOOL acquired = gcvFALSE;
-
-	gcmkHEADER_ARG("Node=0x%x", Node);
-
-	/* Verify the arguments. */
-	if ((Node == gcvNULL)
-	||  (Node->VidMem.memory == gcvNULL)
-	)
-	{
-		/* Invalid object. */
-		gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
-	}
-
-	/**************************** Video Memory ********************************/
-
-	if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-	{
-		if (Node->VidMem.locked > 0)
-		{
-			gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_VIDMEM,
-						   "Node 0x%x is locked (%d)",
-						   Node, Node->VidMem.locked);
-
-			/* Node is locked. */
-			gcmkONERROR(gcvSTATUS_MEMORY_LOCKED);
-		}
-
-		/* Extract pointer to gckVIDMEM object owning the node. */
-		memory = Node->VidMem.memory;
-
-		/* Acquire the mutex. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(memory->os, memory->mutex, gcvINFINITE));
+    gckVIDMEM memory = gcvNULL;
+    gcuVIDMEM_NODE_PTR node;
+    gceSTATUS status;
+    gctBOOL acquired = gcvFALSE;
+	gctSIZE_T bytes = 0; 
+    gcmkHEADER_ARG("Node=0x%x", Node);
+
+    /* Verify the arguments. */
+    if ((Node == gcvNULL)
+    ||  (Node->VidMem.memory == gcvNULL)
+    )
+    {
+        /* Invalid object. */
+        gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
+    }
 
-		acquired = gcvTRUE;
+    /**************************** Video Memory ********************************/
 
+    if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    {
+        if (Node->VidMem.locked > 0)
+        {
+            gcmkLOG_ERROR_ARGS("Node 0x%x is locked", Node);
+            gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_VIDMEM,
+                           "Node 0x%x is locked (%d)",
+                           Node, Node->VidMem.locked);
+
+            /* Node is locked. */
+            gcmkONERROR(gcvSTATUS_MEMORY_LOCKED);
+        }
+
+        /* Extract pointer to gckVIDMEM object owning the node. */
+        memory = Node->VidMem.memory;
+
+        /* Acquire the mutex. */
+        gcmkONERROR(
+            gckOS_AcquireMutex(memory->os, memory->mutex, gcvINFINITE));
+
+        acquired = gcvTRUE;
+		bytes = Node->VidMem.bytes;
 #ifdef __QNXNTO__
-		/* Reset handle to 0. */
+        /* Reset handle to 0. */
         Node->VidMem.logical = gcvNULL;
-		Node->VidMem.handle = 0;
+        Node->VidMem.handle = 0;
 
         /* Don't try to a re-free an already freed node. */
-		if ((Node->VidMem.nextFree == gcvNULL)
-		&&  (Node->VidMem.prevFree == gcvNULL)
-		)
+        if ((Node->VidMem.nextFree == gcvNULL)
+        &&  (Node->VidMem.prevFree == gcvNULL)
+        )
 #endif
-		{
+        {
             /* Update the number of free bytes. */
             memory->freeBytes += Node->VidMem.bytes;
 
-#ifdef MRVL_DEBUG_VMEM
-/*	total_used_vmem -= Node->VidMem.bytes;
-
-	printk("total used vmem : %ld\n",total_used_vmem);*/
-	
-	total_free_vmem += Node->VidMem.bytes;
-
-	printk("total free vmem : %ld\n",total_free_vmem);
-#endif
-
             /* Find the next free node. */
             for (node = Node->VidMem.next;
                  node->VidMem.nextFree == gcvNULL;
@@ -1082,37 +1080,39 @@ gckVIDMEM_Free(
                 gcmkASSERT(node->VidMem.nextFree != node);
                 gcmkASSERT(node->VidMem.prevFree != node);
             }
-		}
-
-		/* Release the mutex. */
-		gcmkVERIFY_OK(gckOS_ReleaseMutex(memory->os, memory->mutex));
-
-		/* Success. */
-		gcmkFOOTER_NO();
-		return gcvSTATUS_OK;
-	}
+        }
+		/* Update video memory usage. */
+		gckOS_UpdateVidMemUsage(memory->os, gcvFALSE, bytes);
+		
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(memory->os, memory->mutex));
+
+        /* Success. */
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
 
-	/*************************** Virtual Memory *******************************/
+    /*************************** Virtual Memory *******************************/
 
-	/* Verify the gckKERNEL object pointer. */
-	gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
+    /* Verify the gckKERNEL object pointer. */
+    gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
 
 #ifdef __QNXNTO__
-	if (!Node->Virtual.unlockPending && (Node->Virtual.locked > 0))
+    if (!Node->Virtual.unlockPending && (Node->Virtual.locked > 0))
 #else
-	if (!Node->Virtual.pending && (Node->Virtual.locked > 0))
+    if (!Node->Virtual.pending && (Node->Virtual.locked > 0))
 #endif
-	{
-		gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_VIDMEM,
-					   "gckVIDMEM_Free: Virtual node 0x%x is locked (%d)",
-					   Node, Node->Virtual.locked);
+    {
+        gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_VIDMEM,
+                       "gckVIDMEM_Free: Virtual node 0x%x is locked (%d)",
+                       Node, Node->Virtual.locked);
 
-		/* Node is locked. */
-		gcmkONERROR(gcvSTATUS_MEMORY_LOCKED);
-	}
+        /* Node is locked. */
+        gcmkONERROR(gcvSTATUS_MEMORY_LOCKED);
+    }
 
 #ifdef __QNXNTO__
-	if (!Node->Virtual.freePending) { if (Node->Virtual.unlockPending)
+    if (!Node->Virtual.freePending) { if (Node->Virtual.unlockPending)
 #else
     if (Node->Virtual.pending)
 #endif
@@ -1126,92 +1126,93 @@ gckVIDMEM_Free(
 
         /* Schedule the video memory to be freed again. */
         gcmkONERROR(gckEVENT_FreeVideoMemory(Node->Virtual.kernel->event,
-											 Node,
-											 gcvKERNEL_PIXEL));
+                                             Node,
+                                             gcvKERNEL_PIXEL));
 
 #ifdef __QNXNTO__
-		Node->Virtual.freePending = gcvTRUE; }
+        Node->Virtual.freePending = gcvTRUE; }
 #endif
-	}
+    }
 
     else
     {
-		/* Free the virtual memory. */
-		gcmkVERIFY_OK(gckOS_FreePagedMemory(Node->Virtual.kernel->os,
-										    Node->Virtual.physical,
-										    Node->Virtual.bytes));
+        /* Free the virtual memory. */
+        gcmkVERIFY_OK(gckOS_FreePagedMemory(Node->Virtual.kernel->os,
+                                            Node->Virtual.physical,
+                                            Node->Virtual.bytes));
 
         /* Destroy the gcuVIDMEM_NODE union. */
         gcmkVERIFY_OK(gckVIDMEM_DestroyVirtual(Node));
     }
 
-	/* Success. */
-	gcmkFOOTER_NO();
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 
 OnError:
-	if (acquired)
-	{
-		/* Release the mutex. */
-		gcmkVERIFY_OK(gckOS_ReleaseMutex(memory->os, memory->mutex));
-	}
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
+    if (acquired)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(memory->os, memory->mutex));
+    }
 
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 
 #ifdef __QNXNTO__
 /*******************************************************************************
 **
-**	gcoVIDMEM_FreeHandleMemory
+**  gcoVIDMEM_FreeHandleMemory
 **
-**	Free all allocated video memory nodes for a handle.
+**  Free all allocated video memory nodes for a handle.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gcoVIDMEM Memory
-**			Pointer to an gcoVIDMEM object..
+**      gcoVIDMEM Memory
+**          Pointer to an gcoVIDMEM object..
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 */
 gceSTATUS
 gckVIDMEM_FreeHandleMemory(
-	IN gckVIDMEM Memory,
-	IN gctHANDLE Handle
-	)
+    IN gckVIDMEM Memory,
+    IN gctHANDLE Handle
+    )
 {
     gceSTATUS status;
     gctBOOL mutex = gcvFALSE;
-	gcuVIDMEM_NODE_PTR node;
-	gctINT i;
-	gctUINT32 nodeCount = 0, byteCount = 0;
-	gctBOOL again;
+    gcuVIDMEM_NODE_PTR node;
+    gctINT i;
+    gctUINT32 nodeCount = 0, byteCount = 0;
+    gctBOOL again;
 
-	gcmkHEADER_ARG("Memory=0x%x Handle=0x%x", Memory, Handle);
+    gcmkHEADER_ARG("Memory=0x%x Handle=0x%x", Memory, Handle);
 
-	gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
+    gcmkVERIFY_OBJECT(Memory, gcvOBJ_VIDMEM);
 
-	gcmkONERROR(gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
-	mutex = gcvTRUE;
+    gcmkONERROR(gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
+    mutex = gcvTRUE;
 
-	/* Walk all sentinels. */
-	for (i = 0; i < gcmCOUNTOF(Memory->sentinel); ++i)
-	{
-		/* Bail out of the heap if it is not used. */
-		if (Memory->sentinel[i].VidMem.next == gcvNULL)
-		{
-			break;
-		}
+    /* Walk all sentinels. */
+    for (i = 0; i < gcmCOUNTOF(Memory->sentinel); ++i)
+    {
+        /* Bail out of the heap if it is not used. */
+        if (Memory->sentinel[i].VidMem.next == gcvNULL)
+        {
+            break;
+        }
 
-		do
-		{
-		    again = gcvFALSE;
+        do
+        {
+            again = gcvFALSE;
 
-		    /* Walk all the nodes until we reach the sentinel. */
+            /* Walk all the nodes until we reach the sentinel. */
             for (node = Memory->sentinel[i].VidMem.next;
                  node->VidMem.bytes != 0;
                  node = node->VidMem.next)
@@ -1239,13 +1240,13 @@ gckVIDMEM_FreeHandleMemory(
                     break;
                 }
             }
-		}
-		while (again);
-	}
+        }
+        while (again);
+    }
 
-	gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
-	gcmkFOOTER();
-	return gcvSTATUS_OK;
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Memory->os, Memory->mutex));
+    gcmkFOOTER();
+    return gcvSTATUS_OK;
 
 OnError:
     if (mutex)
@@ -1260,392 +1261,393 @@ OnError:
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Lock
+**  gckVIDMEM_Lock
 **
-**	Lock a video memory node and return it's hardware specific address.
+**  Lock a video memory node and return it's hardware specific address.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to a gcuVIDMEM_NODE union.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to a gcuVIDMEM_NODE union.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gctUINT32 * Address
-**			Pointer to a variable that will hold the hardware specific address.
+**      gctUINT32 * Address
+**          Pointer to a variable that will hold the hardware specific address.
 */
 gceSTATUS
 gckVIDMEM_Lock(
-	IN gcuVIDMEM_NODE_PTR Node,
-	OUT gctUINT32 * Address
-	)
+    IN gcuVIDMEM_NODE_PTR Node,
+    OUT gctUINT32 * Address
+    )
 {
-	gceSTATUS status;
-	gctBOOL acquired = gcvFALSE;
-	gctBOOL locked = gcvFALSE;
-	gckOS os = gcvNULL;
+    gceSTATUS status;
+    gctBOOL acquired = gcvFALSE;
+    gctBOOL locked = gcvFALSE;
+    gckOS os = gcvNULL;
 
-	gcmkHEADER_ARG("Node=0x%x", Node);
+    gcmkHEADER_ARG("Node=0x%x", Node);
 
-	/* Verify the arguments. */
-	gcmkVERIFY_ARGUMENT(Address != gcvNULL);
+    /* Verify the arguments. */
+    gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
-	if ((Node == gcvNULL)
-	||  (Node->VidMem.memory == gcvNULL)
-	)
-	{
-		/* Invalid object. */
-		gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
-	}
+    if ((Node == gcvNULL)
+    ||  (Node->VidMem.memory == gcvNULL)
+    )
+    {
+        /* Invalid object. */
+        gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
+    }
 
-	/**************************** Video Memory ********************************/
+    /**************************** Video Memory ********************************/
 
-	if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-	{
-		/* Increment the lock count. */
-		Node->VidMem.locked ++;
-
-		/* Return the address of the node. */
-		*Address = Node->VidMem.memory->baseAddress
-				 + Node->VidMem.offset
-				 + Node->VidMem.alignment;
-
-		gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-					  "Locked node 0x%x (%d) @ 0x%08X",
-					  Node,
-					  Node->VidMem.locked,
-					  *Address);
-	}
+    if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    {
+        /* Increment the lock count. */
+        Node->VidMem.locked ++;
 
-	/*************************** Virtual Memory *******************************/
+        /* Return the address of the node. */
+        *Address = Node->VidMem.memory->baseAddress
+                 + Node->VidMem.offset
+                 + Node->VidMem.alignment;
 
-	else
-	{
-		/* Verify the gckKERNEL object pointer. */
-		gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                      "Locked node 0x%x (%d) @ 0x%08X",
+                      Node,
+                      Node->VidMem.locked,
+                      *Address);
+    }
+
+    /*************************** Virtual Memory *******************************/
+
+    else
+    {
+        /* Verify the gckKERNEL object pointer. */
+        gcmkVERIFY_OBJECT(Node->Virtual.kernel, gcvOBJ_KERNEL);
 
-		/* Extract the gckOS object pointer. */
-		os = Node->Virtual.kernel->os;
-		gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+        /* Extract the gckOS object pointer. */
+        os = Node->Virtual.kernel->os;
+        gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
 
-		/* Grab the mutex. */
-		gcmkONERROR(gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
-		acquired = gcvTRUE;
+        /* Grab the mutex. */
+        gcmkONERROR(gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
+        acquired = gcvTRUE;
 
-		/* Increment the lock count. */
-		if (Node->Virtual.locked ++ == 0)
-		{
-			/* Is this node pending for a final unlock? */
+        /* Increment the lock count. */
+        if (Node->Virtual.locked ++ == 0)
+        {
+            /* Is this node pending for a final unlock? */
 #ifdef __QNXNTO__
-			if (!Node->Virtual.contiguous && Node->Virtual.unlockPending)
+            if (!Node->Virtual.contiguous && Node->Virtual.unlockPending)
 #else
-			if (!Node->Virtual.contiguous && Node->Virtual.pending)
+            if (!Node->Virtual.contiguous && Node->Virtual.pending)
 #endif
-			{
-				/* Make sure we have a page table. */
-				gcmkASSERT(Node->Virtual.pageTable != gcvNULL);
+            {
+                /* Make sure we have a page table. */
+                gcmkASSERT(Node->Virtual.pageTable != gcvNULL);
 
-				/* Remove pending unlock. */
+                /* Remove pending unlock. */
 #ifdef __QNXNTO__
                 Node->Virtual.unlockPending = gcvFALSE;
 #else
                 Node->Virtual.pending = gcvFALSE;
 #endif
-			}
+            }
 
-			/* First lock - create a page table. */
-			gcmkASSERT(Node->Virtual.pageTable == gcvNULL);
+            /* First lock - create a page table. */
+            gcmkASSERT(Node->Virtual.pageTable == gcvNULL);
 
-			/* Make sure we mark our node as not flushed. */
+            /* Make sure we mark our node as not flushed. */
 #ifdef __QNXNTO__
-			Node->Virtual.unlockPending = gcvFALSE;
+            Node->Virtual.unlockPending = gcvFALSE;
 #else
-			Node->Virtual.pending = gcvFALSE;
+            Node->Virtual.pending = gcvFALSE;
 #endif
 
-			/* Lock the allocated pages. */
+            /* Lock the allocated pages. */
 #ifdef __QNXNTO__
-			gcmkONERROR(
-				gckOS_LockPages(os,
-								Node->Virtual.physical,
-								Node->Virtual.bytes,
-								Node->Virtual.userPID,
-								&Node->Virtual.logical,
-								&Node->Virtual.pageCount));
+            gcmkONERROR(
+                gckOS_LockPages(os,
+                                Node->Virtual.physical,
+                                Node->Virtual.bytes,
+                                Node->Virtual.userPID,
+                                &Node->Virtual.logical,
+                                &Node->Virtual.pageCount));
 #else
-			gcmkONERROR(
-				gckOS_LockPages(os,
-								Node->Virtual.physical,
-								Node->Virtual.bytes,
-								&Node->Virtual.logical,
-								&Node->Virtual.pageCount));
+            gcmkONERROR(
+                gckOS_LockPages(os,
+                                Node->Virtual.physical,
+                                Node->Virtual.bytes,
+                                &Node->Virtual.logical,
+                                &Node->Virtual.pageCount));
 #endif
 
-			locked = gcvTRUE;
-
-			if (Node->Virtual.contiguous)
-			{
-				/* Get physical address directly */
-				gcmkONERROR(gckOS_GetPhysicalAddress(os,
-									Node->Virtual.logical,
-									&Node->Virtual.address));
-			}
-			else
-			{
-				/* Allocate pages inside the MMU. */
-				gcmkONERROR(
-					gckMMU_AllocatePages(Node->Virtual.kernel->mmu,
-										 Node->Virtual.pageCount,
-										 &Node->Virtual.pageTable,
-										 &Node->Virtual.address));
-
-				/* Map the pages. */
+            locked = gcvTRUE;
+
+            if (Node->Virtual.contiguous)
+            {
+                /* Get physical address directly */
+                gcmkONERROR(gckOS_GetPhysicalAddress(os,
+                                    Node->Virtual.logical,
+                                    &Node->Virtual.address));
+            }
+            else
+            {
+                /* Allocate pages inside the MMU. */
+                gcmkONERROR(
+                    gckMMU_AllocatePages(Node->Virtual.kernel->mmu,
+                                         Node->Virtual.pageCount,
+                                         &Node->Virtual.pageTable,
+                                         &Node->Virtual.address));
+
+                /* Map the pages. */
 #ifdef __QNXNTO__
-				gcmkONERROR(
-					gckOS_MapPages(os,
-								   Node->Virtual.physical,
-								   Node->Virtual.logical,
-								   Node->Virtual.pageCount,
-								   Node->Virtual.pageTable));
+                gcmkONERROR(
+                    gckOS_MapPages(os,
+                                   Node->Virtual.physical,
+                                   Node->Virtual.logical,
+                                   Node->Virtual.pageCount,
+                                   Node->Virtual.pageTable));
 #else
-				gcmkONERROR(
-					gckOS_MapPages(os,
-								   Node->Virtual.physical,
-								   Node->Virtual.pageCount,
-								   Node->Virtual.pageTable));
+                gcmkONERROR(
+                    gckOS_MapPages(os,
+                                   Node->Virtual.physical,
+                                   Node->Virtual.pageCount,
+                                   Node->Virtual.pageTable));
 #endif
 
-				gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-							   "Mapped virtual node 0x%x to 0x%08X",
-							   Node,
-							   Node->Virtual.address);
-			}
-		}
+                gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                               "Mapped virtual node 0x%x to 0x%08X",
+                               Node,
+                               Node->Virtual.address);
+            }
+        }
 
-		/* Return hardware address. */
-		*Address = Node->Virtual.address;
+        /* Return hardware address. */
+        *Address = Node->Virtual.address;
 
-		/* Release the mutex. */
-		gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-	}
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+    }
 
-	/* Success. */
-	gcmkFOOTER_ARG("*Address=%08x", *Address);
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_ARG("*Address=%08x", *Address);
+    return gcvSTATUS_OK;
 
 OnError:
-	if (locked)
-	{
-		if (Node->Virtual.pageTable != gcvNULL)
-		{
-			/* Free the pages from the MMU. */
-			gcmkVERIFY_OK(
-				gckMMU_FreePages(Node->Virtual.kernel->mmu,
-								 Node->Virtual.pageTable,
-								 Node->Virtual.pageCount));
-
-			Node->Virtual.pageTable = gcvNULL;
-		}
-
-		/* Unlock the pages. */
+    gcmkLOG_ERROR_ARGS("status=%d, locked=%d, acquired=%d", status, locked, acquired);
+    if (locked)
+    {
+        if (Node->Virtual.pageTable != gcvNULL)
+        {
+            /* Free the pages from the MMU. */
+            gcmkVERIFY_OK(
+                gckMMU_FreePages(Node->Virtual.kernel->mmu,
+                                 Node->Virtual.pageTable,
+                                 Node->Virtual.pageCount));
+
+            Node->Virtual.pageTable = gcvNULL;
+        }
+
+        /* Unlock the pages. */
 #ifdef __QNXNTO__
-		gcmkVERIFY_OK(
+		gcmkERR_RETURN(
 			gckOS_UnlockPages(os,
 							  Node->Virtual.physical,
 							  Node->Virtual.userPID,
 							  Node->Virtual.bytes,
 							  Node->Virtual.logical));
+
 #else
-        gcmkVERIFY_OK(
-			gckOS_UnlockPages(os,
-							  Node->Virtual.physical,
-							  Node->Virtual.bytes,
-							  Node->Virtual.logical));
+        gcmkERR_RETURN(
+            gckOS_UnlockPages(os,
+                              Node->Virtual.physical,
+                              Node->Virtual.bytes,
+                              Node->Virtual.logical));
 #endif
-	}
+    }
 
-	if (acquired)
-	{
-		/* Release the mutex. */
-		gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-	}
+    if (acquired)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+    }
 
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
 **
-**	gckVIDMEM_Unlock
+**  gckVIDMEM_Unlock
 **
-**	Unlock a video memory node.
+**  Unlock a video memory node.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gcuVIDMEM_NODE_PTR Node
-**			Pointer to a locked gcuVIDMEM_NODE union.
+**      gcuVIDMEM_NODE_PTR Node
+**          Pointer to a locked gcuVIDMEM_NODE union.
 **
-**		gceSURF_TYPE Type
-**			Type of surface to unlock.
+**      gceSURF_TYPE Type
+**          Type of surface to unlock.
 **
-**		gctSIZE_T * CommandSize
-**			Pointer to a variable specifying the number of bytes in the command
-**			buffer specified by 'Commands'.  If gcvNULL, there is no command
-**			buffer and the video memory shoud be unlocked synchronously.
+**      gctSIZE_T * CommandSize
+**          Pointer to a variable specifying the number of bytes in the command
+**          buffer specified by 'Commands'.  If gcvNULL, there is no command
+**          buffer and the video memory shoud be unlocked synchronously.
 **
-**		gctBOOL * Asynchroneous
-**			Pointer to a variable specifying whether the surface should be
-**			unlocked asynchroneously or not.
+**      gctBOOL * Asynchroneous
+**          Pointer to a variable specifying whether the surface should be
+**          unlocked asynchroneously or not.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gctBOOL * Asynchroneous
-**			Pointer to a variable receiving the number of bytes used in the
-**			command buffer specified by 'Commands'.  If gcvNULL, there is no
-**			command buffer.
+**      gctBOOL * Asynchroneous
+**          Pointer to a variable receiving the number of bytes used in the
+**          command buffer specified by 'Commands'.  If gcvNULL, there is no
+**          command buffer.
 */
 gceSTATUS
 gckVIDMEM_Unlock(
-	IN gcuVIDMEM_NODE_PTR Node,
-	IN gceSURF_TYPE Type,
-	IN OUT gctBOOL * Asynchroneous
-	)
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gceSURF_TYPE Type,
+    IN OUT gctBOOL * Asynchroneous
+    )
 {
-	gceSTATUS status;
-	gckKERNEL kernel;
-	gckHARDWARE hardware;
-	gctPOINTER buffer;
-	gctSIZE_T requested, bufferSize;
-	gckCOMMAND command = gcvNULL;
-	gceKERNEL_FLUSH flush;
-	gckOS os = gcvNULL;
-	gctBOOL acquired = gcvFALSE;
-	gctBOOL needRelease = gcvFALSE;
-	gctBOOL pendingUnlock = gcvFALSE;
-
-	gcmkHEADER_ARG("Node=0x%x Type=%d *Asynchroneous=%d",
-				   Node, Type, gcmOPT_VALUE(Asynchroneous));
-
-	/* Verify the arguments. */
-	if ((Node == gcvNULL)
-	||  (Node->VidMem.memory == gcvNULL)
-	)
-	{
-		/* Invalid object. */
-		gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
-	}
+    gceSTATUS status;
+    gckKERNEL kernel;
+    gckHARDWARE hardware;
+    gctPOINTER buffer;
+    gctSIZE_T requested, bufferSize;
+    gckCOMMAND command = gcvNULL;
+    gceKERNEL_FLUSH flush;
+    gckOS os = gcvNULL;
+    gctBOOL acquired = gcvFALSE;
+    gctBOOL needRelease = gcvFALSE;
+    gctBOOL pendingUnlock = gcvFALSE;
+
+    gcmkHEADER_ARG("Node=0x%x Type=%d *Asynchroneous=%d",
+                   Node, Type, gcmOPT_VALUE(Asynchroneous));
+
+    /* Verify the arguments. */
+    if ((Node == gcvNULL)
+    ||  (Node->VidMem.memory == gcvNULL)
+    )
+    {
+        /* Invalid object. */
+        gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
+    }
 
-	/**************************** Video Memory ********************************/
+    /**************************** Video Memory ********************************/
 
-	if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-	{
-		if (Node->VidMem.locked <= 0)
-		{
-			/* The surface was not locked. */
-			gcmkONERROR(gcvSTATUS_MEMORY_UNLOCKED);
-		}
-
-		/* Decrement the lock count. */
-		Node->VidMem.locked --;
-
-		if (Asynchroneous != gcvNULL)
-		{
-			/* No need for any events. */
-			*Asynchroneous = gcvFALSE;
-		}
-	}
+    if (Node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+    {
+        if (Node->VidMem.locked <= 0)
+        {
+            /* The surface was not locked. */
+            gcmkONERROR(gcvSTATUS_MEMORY_UNLOCKED);
+        }
+
+        /* Decrement the lock count. */
+        Node->VidMem.locked --;
+
+        if (Asynchroneous != gcvNULL)
+        {
+            /* No need for any events. */
+            *Asynchroneous = gcvFALSE;
+        }
+    }
 
-	/*************************** Virtual Memory *******************************/
+    /*************************** Virtual Memory *******************************/
 
-	else
-	{
-		/* Verify the gckKERNEL object pointer. */
-		kernel = Node->Virtual.kernel;
-		gcmkVERIFY_OBJECT(kernel, gcvOBJ_KERNEL);
-
-		/* Verify the gckHARDWARE object pointer. */
-		hardware = Node->Virtual.kernel->hardware;
-		gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
-
-		/* Verify the gckCOMMAND object pointer. */
-		command = Node->Virtual.kernel->command;
-		gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
-
-		if (Asynchroneous == gcvNULL)
-		{
-			gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-						   "gckVIDMEM_Unlock: Unlocking virtual node 0x%x (%d)",
-						   Node,
-						   Node->Virtual.locked);
-
-			/* Get the gckOS object pointer. */
-			os = kernel->os;
-			gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
-
-			/* Grab the mutex. */
-			gcmkONERROR(
-				gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
-
-			/* If we need to unlock a node from virtual memory we have to be
-			** very carefull.  If the node is still inside the caches we
-			** might get a bus error later if the cache line needs to be
-			** replaced.  So - we have to flush the caches before we do
-			** anything.  We also need to stall to make sure the flush has
-			** happened.  However - when we get to this point we are inside
-			** the interrupt handler and we cannot just gckCOMMAND_Wait
-			** because it will wait forever.  So - what we do here is we
-			** verify the type of the surface, flush the appropriate cache,
-			** mark the node as flushed, and issue another unlock to unmap
-			** the MMU. */
-			if (!Node->Virtual.contiguous
-			&&  (Node->Virtual.locked == 1)
+    else
+    {
+        /* Verify the gckKERNEL object pointer. */
+        kernel = Node->Virtual.kernel;
+        gcmkVERIFY_OBJECT(kernel, gcvOBJ_KERNEL);
+
+        /* Verify the gckHARDWARE object pointer. */
+        hardware = Node->Virtual.kernel->hardware;
+        gcmkVERIFY_OBJECT(hardware, gcvOBJ_HARDWARE);
+
+        /* Verify the gckCOMMAND object pointer. */
+        command = Node->Virtual.kernel->command;
+        gcmkVERIFY_OBJECT(command, gcvOBJ_COMMAND);
+
+        if (Asynchroneous == gcvNULL)
+        {
+            gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                           "gckVIDMEM_Unlock: Unlocking virtual node 0x%x (%d)",
+                           Node,
+                           Node->Virtual.locked);
+
+            /* Get the gckOS object pointer. */
+            os = kernel->os;
+            gcmkVERIFY_OBJECT(os, gcvOBJ_OS);
+
+            /* Grab the mutex. */
+            gcmkONERROR(
+                gckOS_AcquireMutex(os, Node->Virtual.mutex, gcvINFINITE));
+
+            /* If we need to unlock a node from virtual memory we have to be
+            ** very carefull.  If the node is still inside the caches we
+            ** might get a bus error later if the cache line needs to be
+            ** replaced.  So - we have to flush the caches before we do
+            ** anything.  We also need to stall to make sure the flush has
+            ** happened.  However - when we get to this point we are inside
+            ** the interrupt handler and we cannot just gckCOMMAND_Wait
+            ** because it will wait forever.  So - what we do here is we
+            ** verify the type of the surface, flush the appropriate cache,
+            ** mark the node as flushed, and issue another unlock to unmap
+            ** the MMU. */
+            if (!Node->Virtual.contiguous
+            &&  (Node->Virtual.locked == 1)
 #ifdef __QNXTO__
-			&&  !Node->Virtual.unlockPending
+            &&  !Node->Virtual.unlockPending
 #else
-			&&  !Node->Virtual.pending
+            &&  !Node->Virtual.pending
 #endif
-			)
-			{
-				if (Type == gcvSURF_BITMAP)
-				{
-					/* Flush 2D cache. */
-					flush = gcvFLUSH_2D;
-				}
-				else if (Type == gcvSURF_RENDER_TARGET)
-				{
-					/* Flush color cache. */
-					flush = gcvFLUSH_COLOR;
-				}
-				else if (Type == gcvSURF_DEPTH)
-				{
-					/* Flush depth cache. */
-					flush = gcvFLUSH_DEPTH;
-				}
-				else
-				{
-					/* No flush required. */
-					flush = (gceKERNEL_FLUSH) 0;
-				}
-
-				gcmkONERROR(
-					gckHARDWARE_Flush(hardware, flush, gcvNULL, &requested));
-
-				if (requested != 0)
-				{
+            )
+            {
+                if (Type == gcvSURF_BITMAP)
+                {
+                    /* Flush 2D cache. */
+                    flush = gcvFLUSH_2D;
+                }
+                else if (Type == gcvSURF_RENDER_TARGET)
+                {
+                    /* Flush color cache. */
+                    flush = gcvFLUSH_COLOR;
+                }
+                else if (Type == gcvSURF_DEPTH)
+                {
+                    /* Flush depth cache. */
+                    flush = gcvFLUSH_DEPTH;
+                }
+                else
+                {
+                    /* No flush required. */
+                    flush = (gceKERNEL_FLUSH) 0;
+                }
+
+                gcmkONERROR(
+                    gckHARDWARE_Flush(hardware, flush, gcvNULL, &requested));
+
+                if (requested != 0)
+                {
                     gcmkONERROR(
                         gckCOMMAND_Reserve(command,
                                            requested,
-										   gcvFALSE,
                                            &buffer,
                                            &bufferSize));
 
                     needRelease = gcvTRUE;
 
                     gcmkONERROR(gckHARDWARE_Flush(hardware,
-												  flush,
-												  buffer,
-												  &bufferSize));
+                                                  flush,
+                                                  buffer,
+                                                  &bufferSize));
 
                     gcmkONERROR(
                         gckEVENT_Unlock(Node->Virtual.kernel->event,
@@ -1662,119 +1664,120 @@ gckVIDMEM_Unlock(
 
                     needRelease = gcvFALSE;
 
-                    gcmkONERROR(gckCOMMAND_Execute(command, requested, gcvFALSE));
+                    gcmkONERROR(gckCOMMAND_Execute(command, requested));
 
-					pendingUnlock = gcvTRUE;
-				}
-			}
+                    pendingUnlock = gcvTRUE;
+                }
+            }
 
-			if (!pendingUnlock)
-			{
-				/* Decrement lock count. */
-				-- Node->Virtual.locked;
+            if (!pendingUnlock)
+            {
+                /* Decrement lock count. */
+                -- Node->Virtual.locked;
 
-				/* See if we can unlock the resources. */
-				if (Node->Virtual.locked == 0)
-				{
-					/* Unlock the pages. */
+                /* See if we can unlock the resources. */
+                if (Node->Virtual.locked == 0)
+                {
+                    /* Unlock the pages. */
 #ifdef __QNXNTO__
-					gcmkONERROR(
-						gckOS_UnlockPages(os,
-										  Node->Virtual.physical,
-										  Node->Virtual.userPID,
-										  Node->Virtual.bytes,
-										  Node->Virtual.logical));
+                    gcmkONERROR(
+                        gckOS_UnlockPages(os,
+                                          Node->Virtual.physical,
+                                          Node->Virtual.userPID,
+                                          Node->Virtual.bytes,
+                                          Node->Virtual.logical));
 #else
-					gcmkONERROR(
-						gckOS_UnlockPages(os,
-										  Node->Virtual.physical,
-										  Node->Virtual.bytes,
-										  Node->Virtual.logical));
+                    gcmkONERROR(
+                        gckOS_UnlockPages(os,
+                                          Node->Virtual.physical,
+                                          Node->Virtual.bytes,
+                                          Node->Virtual.logical));
 #endif
 
-					/* Free the page table. */
-					if (Node->Virtual.pageTable != gcvNULL)
-					{
-						gcmkONERROR(
-							gckMMU_FreePages(Node->Virtual.kernel->mmu,
-											 Node->Virtual.pageTable,
-											 Node->Virtual.pageCount));
+                    /* Free the page table. */
+                    if (Node->Virtual.pageTable != gcvNULL)
+                    {
+                        gcmkONERROR(
+                            gckMMU_FreePages(Node->Virtual.kernel->mmu,
+                                             Node->Virtual.pageTable,
+                                             Node->Virtual.pageCount));
 
-						/* Mark page table as freed. */
-						Node->Virtual.pageTable = gcvNULL;
-					}
+                        /* Mark page table as freed. */
+                        Node->Virtual.pageTable = gcvNULL;
+                    }
 
-					/* Mark node as unlocked. */
+                    /* Mark node as unlocked. */
 #ifdef __QNXTO
-					Node->Virtual.unlockPending = gcvFALSE;
+                    Node->Virtual.unlockPending = gcvFALSE;
 #else
-					Node->Virtual.pending = gcvFALSE;
+                    Node->Virtual.pending = gcvFALSE;
 #endif
-				}
-
-				gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-							   "Unmapped virtual node 0x%x from 0x%08X",
-						   	   Node, Node->Virtual.address);
-			}
-
-			/* Release the mutex. */
-			gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-		}
-
-		else
-		{
-			gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
-						   "Scheduled unlock for virtual node 0x%x",
-						   Node);
-
-			/* Schedule the surface to be unlocked. */
-			*Asynchroneous = gcvTRUE;
-		}
-	}
+                }
+
+                gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                               "Unmapped virtual node 0x%x from 0x%08X",
+                               Node, Node->Virtual.address);
+            }
+
+            /* Release the mutex. */
+            gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+        }
 
-	/* Success. */
-	gcmkFOOTER_ARG("*Asynchroneous=%d", gcmOPT_VALUE(Asynchroneous));
-	return gcvSTATUS_OK;
+        else
+        {
+            gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_VIDMEM,
+                           "Scheduled unlock for virtual node 0x%x",
+                           Node);
+
+            /* Schedule the surface to be unlocked. */
+            *Asynchroneous = gcvTRUE;
+        }
+    }
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Asynchroneous=%d", gcmOPT_VALUE(Asynchroneous));
+    return gcvSTATUS_OK;
 
 OnError:
-	if (needRelease)
-	{
-		gcmkVERIFY_OK(gckCOMMAND_Release(command));
-	}
+    gcmkLOG_ERROR_ARGS("status=%d, needRelease=%d, acquired=%d", status, needRelease, acquired);
+    if (needRelease)
+    {
+        gcmkVERIFY_OK(gckCOMMAND_Release(command));
+    }
 
-	if (acquired)
-	{
-		/* Release the mutex. */
-		gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
-	}
+    if (acquired)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(os, Node->Virtual.mutex));
+    }
 
-	/* Return the status. */
-	gcmkFOOTER();
-	return status;
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 #ifdef __QNXNTO__
 /* Set the allocating process' PID for this node. */
 gceSTATUS
 gckVIDMEM_SetPID(
-	IN gcuVIDMEM_NODE_PTR Node,
-	IN gctUINT32 Pid
-	)
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT32 Pid
+    )
 {
-	if (Node != gcvNULL)
-	{
-		if (Node->VidMem.memory->object.type != gcvOBJ_VIDMEM)
-		{
-			Node->Virtual.userPID = Pid;
-		}
+    if (Node != gcvNULL)
+    {
+        if (Node->VidMem.memory->object.type != gcvOBJ_VIDMEM)
+        {
+            Node->Virtual.userPID = Pid;
+        }
 
-	}
-	else
-	{
-		return gcvSTATUS_INVALID_OBJECT;
-	}
+    }
+    else
+    {
+        return gcvSTATUS_INVALID_OBJECT;
+    }
 
-	return gcvSTATUS_OK;
+    return gcvSTATUS_OK;
 }
 #endif
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/makefile.linux b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/makefile.linux
index f0cfb54..6d344b2 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/makefile.linux
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/kernel/makefile.linux
@@ -1,21 +1,21 @@
 ##############################################################################
-#
+#  
 #    Copyright (C) 2005 - 2010 by Vivante Corp.
-#
+#  
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
 #    the Free Software Foundation; either version 2 of the license, or
 #    (at your option) any later version.
-#
+#  
 #    This program is distributed in the hope that it will be useful,
 #    but WITHOUT ANY WARRANTY; without even the implied warranty of
 #    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-#    GNU General Public Lisence for more details.
-#
+#    GNU General Public License for more details.
+#  
 #    You should have received a copy of the GNU General Public License
 #    along with this program; if not write to the Free Software
 #    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-#
+#  
 ##############################################################################
 
 
@@ -44,7 +44,9 @@ INCLUDE += -I$(AQROOT)/hal/inc
 INCLUDE += -I$(AQROOT)/hal/user
 INCLUDE += -I$(AQARCH)/hal/kernel
 
-CFLAGS += $(INCLUDE) -Werror -ansi
+#CFLAGS += $(INCLUDE) -Werror -ansi
+# cy modify for build using GCC4.6.6 compiler
+CFLAGS += $(INCLUDE) -ansi
 
 ################################################################################
 # Describe object files.
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/makefile.linux b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/makefile.linux
index cbdc434..f957d92 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/makefile.linux
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/makefile.linux
@@ -1,16 +1,16 @@
 ##############################################################################
-#
+#  
 #    Copyright (c) 2005 - 2010 by Vivante Corp.  All rights reserved.
-#
+#  
 #    The material in this file is confidential and contains trade secrets
 #    of Vivante Corporation. This is proprietary information owned by
-#    Vivante Corporation. No part of this work may be disclosed,
-#    reproduced, copied, transmitted, or used in any way for any purpose,
+#    Vivante Corporation. No part of this work may be disclosed, 
+#    reproduced, copied, transmitted, or used in any way for any purpose, 
 #    without the express written permission of Vivante Corporation.
-#
+#  
 ##############################################################################
-#
-#
+#  
+#  
 ##############################################################################
 
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_debug.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_debug.c
index 8e776ce..80225f6 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_debug.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_debug.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -94,9 +94,9 @@ _Print(
 
     if (strcmp(Message, "$$FLUSH$$") == 0)
     {
-	spin_lock(&_lock);
-	{
-		OutputDebugString(gcvNULL);
+    	spin_lock(&_lock);
+    	{
+        	OutputDebugString(gcvNULL);
         }
         spin_unlock(&_lock);
         return;
@@ -126,9 +126,9 @@ _Print(
     }
 
     /* Output to debugger. */
-	spin_lock(&_lock);
-	{
-	OutputDebugString(buffer);
+   	spin_lock(&_lock);
+   	{
+    	OutputDebugString(buffer);
     }
     spin_unlock(&_lock);
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.c
index 18becc8..d4240d7 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -26,7 +26,7 @@
 #include <linux/seq_file.h>
 #include <linux/mm.h>
 #include <linux/mman.h>
-
+#include <linux/slab.h>
 #define _GC_OBJ_ZONE	gcvZONE_DEVICE
 
 #ifdef FLAREON
@@ -48,10 +48,10 @@ gckGALDEVICE_AllocateMemory(
 {
 	gceSTATUS status;
 
-	gcmkVERIFY_ARGUMENT(Device != NULL);
-	gcmkVERIFY_ARGUMENT(Logical != NULL);
-	gcmkVERIFY_ARGUMENT(Physical != NULL);
-	gcmkVERIFY_ARGUMENT(PhysAddr != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+	gcmkVERIFY_ARGUMENT(PhysAddr != gcvNULL);
 
 	status = gckOS_AllocateContiguous(Device->os,
 					  gcvFALSE,
@@ -61,6 +61,7 @@ gckGALDEVICE_AllocateMemory(
 
 	if (gcmIS_ERROR(status))
 	{
+        gcmkLOG_ERROR_ARGS("status=%d, allocate memory error", status);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
     				   "gckGALDEVICE_AllocateMemory: error status->0x%x",
     				   status);
@@ -85,7 +86,7 @@ gckGALDEVICE_FreeMemory(
 	IN gctPOINTER Logical,
 	IN gctPHYS_ADDR Physical)
 {
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
     return gckOS_FreeContiguous(Device->os,
 					Physical,
@@ -130,16 +131,18 @@ int threadRoutine(void *ctxt)
 
 		if (device->killThread == gcvTRUE)
 		{
+			/* The daemon exits. */
+			while (!kthread_should_stop())
+			{
+				gckOS_Delay(device->os, 1);
+			}
+
 			return 0;
 		}
-
-        /* Wait for the interrupt. */
-		if (kthread_should_stop())
+		else
 		{
-			return 0;
+			gckKERNEL_Notify(device->kernel, gcvNOTIFY_INTERRUPT, gcvFALSE);
 		}
-
-		gckKERNEL_Notify(device->kernel, gcvNOTIFY_INTERRUPT, gcvFALSE);
     }
     }
 
@@ -151,22 +154,33 @@ int threadRoutine(void *ctxt)
 
 int timer_thread(void *ctxt)
 {
+	gceSTATUS status;
     gckGALDEVICE device = (gckGALDEVICE) ctxt;
-    int idle;
+    gctUINT32 idle;
 
 	while (1)
 	{
 		if(down_interruptible(&device->timersema) == 0)
-		{
-            gckHARDWARE_GetIdle(device->kernel->hardware,
+		{	
+			gcmkONERROR(gckOS_AcquireRecMutex(device->os,
+							   device->kernel->hardware->recMutexPower,
+							   gcvINFINITE));
+            
+            gcmkONERROR(gckHARDWARE_GetIdle(device->kernel->hardware,
         									gcvFALSE,
-        									&idle);
+        									&idle));
 
-            printk("idle = %x\n", idle);
+            gcmkPRINT("idle = %x\n", idle);
+            gcmkONERROR(gckOS_ReleaseRecMutex(device->os,
+				   device->kernel->hardware->recMutexPower));
         }
     }
 
-    return 0;    
+    return 0;
+    
+OnError:
+    gcmkPRINT("ERROR: %s has error \n",__func__);
+    return status;
 }
 
 void timer_fn(unsigned long arg)
@@ -180,6 +194,262 @@ void timer_fn(unsigned long arg)
 }
 #endif
 
+#if MRVL_PROFILE_THREAD
+int profile_thread(void *ctxt)
+{
+	gceSTATUS status;
+    gckGALDEVICE device = (gckGALDEVICE) ctxt;
+    gctUINT32 delayTime = 300; /* should be the max time of once draw */
+    
+	while (1)
+	{
+        delayTime = device->profileStep; 
+
+	    if((device->os != gcvNULL)
+         && (device->kernel != gcvNULL)
+         && (device->kernel->command != gcvNULL)
+         && (device->kernel->atomClients > 0))
+	    {
+            gckCOMMAND command = device->kernel->command;
+            
+            /* hold profile thread if GC is off */	
+			gcmkONERROR(gckOS_AcquireSemaphore(device->os, command->powerSemaphore));
+            gcmkVERIFY_OK(gckOS_ReleaseSemaphore(device->os, command->powerSemaphore));
+
+            
+            /* Grab the mutex. */
+		    gcmkONERROR(gckOS_AcquireRecMutex(device->os, device->kernel->hardware->recMutexPower, gcvINFINITE));
+
+            /* 
+                FIXME:
+                current idle event has bug, which may not set GC to be idle 
+                after early suspend. NotifyIdle here can temporarily solve this issue.
+            */
+            if(device->clkEnabled && (device->currentPMode != gcvPM_NORMAL))
+            {
+                gctBOOL isIdle;
+                gcmkONERROR(gckHARDWARE_QueryIdle(device->kernel->hardware, &isIdle));
+
+                if(isIdle)
+                {
+                    if(device->kernel->command->idle == gcvFALSE)
+                    {
+        				device->kernel->command->idle = gcvTRUE;
+        				gcmkONERROR(gckOS_NotifyIdle(device->os, gcvTRUE));
+                    }
+                }
+            }
+            
+            /* Release the mutex. */
+    		gcmkVERIFY_OK(gckOS_ReleaseRecMutex(device->os, device->kernel->hardware->recMutexPower));
+            
+            /* power off GC when idle */
+    	    if(device->powerOffWhenIdle)
+            {
+                gckOS_PowerOffWhenIdle(device->os, gcvTRUE);
+            }
+
+            /* */
+            gcmkONERROR(gckOS_Delay(device->os, delayTime));
+	    }
+        else
+        {
+            gcmkONERROR(gckOS_Delay(device->os, 10000));
+            /* schedule_timeout_interruptible(500); */
+        }
+    }
+
+    return 0;
+    
+OnError:
+    gcmkPRINT("ERROR: %s has error \n",__func__);
+    return status;
+}
+#endif
+
+#if MRVL_GUARD_THREAD
+
+#if MRVL_PRINT_CMD_BUFFER
+extern void _PrintCmdBuffer(
+	gckCOMMAND Command,
+	gctUINT Address
+	);
+#endif
+
+int guard_thread(void *ctxt)
+{
+	gceSTATUS status;
+    gckGALDEVICE device = (gckGALDEVICE) ctxt;
+    gctUINT32 captureAddr = GC_INVALID_PHYS_ADDR;
+    gctUINT32 currentAddr = GC_INVALID_PHYS_ADDR;
+    gctUINT32 delayTime = 300; /* should be the max time of once draw */
+    gctINT32 atomRefMark, ref;
+    gctBOOL isIdle;
+
+    while (1)
+	{
+        delayTime = device->profileStep; 
+
+	    if((device->os != gcvNULL)
+         && (device->kernel != gcvNULL)
+         && (device->kernel->command != gcvNULL)
+         && (device->kernel->atomClients > 0))
+	    {
+	        gckCOMMAND command = device->kernel->command;
+            gctBOOL needSilentReset = gcvFALSE;
+            static gctUINT count = 0;
+            gctUINT32 lastWaitLink = GC_INVALID_PHYS_ADDR;
+            
+            /* hold guard thread if GC is off */	
+			gcmkONERROR(gckOS_AcquireSemaphore(device->os, command->powerSemaphore));
+            gcmkVERIFY_OK(gckOS_ReleaseSemaphore(device->os, command->powerSemaphore));
+
+            
+            /* Grab the mutex. */
+		    gcmkONERROR(gckOS_AcquireRecMutex(device->os, device->kernel->hardware->recMutexPower, gcvINFINITE));
+
+            if(device->clkEnabled)
+            {
+                lastWaitLink = device->kernel->hardware->lastWaitLink;
+
+                /* Read the current FE address. */
+                gcmkONERROR(gckOS_ReadRegister(device->os,
+                                           0x00664,
+                                           &currentAddr));
+
+                /* Test if address is outside the last WAIT/LINK sequence. */
+                if( (currentAddr == captureAddr)
+                    && ((currentAddr < lastWaitLink) || (currentAddr >= lastWaitLink + 16)))
+                {
+                    count++;
+
+                    if(device->powerDebug)
+                    {
+                        gcmkPRINT("GPU stop at 0x%x for %d ms, lastWaitLink = 0x%08x\n",currentAddr,delayTime*count, lastWaitLink);
+                    }
+
+                    if (count == 1)
+                    {
+                        /* Acquire current event count at first time */
+                        gckOS_AtomGet(device->os, device->kernel->event->atomEventRef, &atomRefMark);
+                    }
+                    else
+                    {
+                        /* Acquire event count again at second or third time */
+                        gckOS_AtomGet(device->os, device->kernel->event->atomEventRef, &ref);
+
+                        /* Event counts changed, that means some event successfully returned between
+                          these two checking points which further indicates that GC hardware is still
+                          working, so we clear "count" here and the capture address remains unchanged.*/
+                        if (atomRefMark != ref)
+                        {
+                            count = 0;
+                        }
+                    }
+                }
+                else
+                {
+                    captureAddr = currentAddr;
+                    count = 0;
+                }
+
+                if(count >= 3)
+                {
+                    if(device->powerDebug)
+                    {
+                        gcmkPRINT("GPU may hang, [captureAddr,currentAddr,lastWaitLink] = [0x%x,0x%x,0x%x]\n",
+                            captureAddr,currentAddr,device->kernel->hardware->lastWaitLink);
+                    }
+
+                    needSilentReset = gcvTRUE;
+                    count = 0;
+                }       
+
+                /* GPU stop at the same address */
+                if(needSilentReset)
+                {
+#if MRVL_PRINT_CMD_BUFFER
+                    if(device->kernel->command->dumpCmdBuf)
+                    {
+            			gctUINT i;
+                        gctUINT32 idle;
+            			gctUINT32 intAck;
+            			gctUINT32 prevAddr = 0;
+            			gctUINT32 currAddr;
+            			gctBOOL changeDetected;
+
+            			changeDetected = gcvFALSE;
+
+                        /* IDLE */
+        			    gcmkONERROR(gckOS_ReadRegister(device->os, 0x0004, &idle));
+                        
+        				/* INT ACK */
+        				gcmkONERROR(gckOS_ReadRegister(device->os, 0x0010, &intAck));
+
+        				/* DMA POS */
+        				for (i = 0; i < 300; i += 1)
+        				{
+        					gcmkONERROR(gckOS_ReadRegister(device->os, 0x0664, &currAddr));
+
+        					if ((i > 0) && (prevAddr != currAddr))
+        					{
+        						changeDetected = gcvTRUE;
+        					}
+
+        					prevAddr = currAddr;
+        				}
+
+        				gcmkPRINT("\n%s(%d):\n"
+                					"  idle = 0x%08X\n"
+                					"  int  = 0x%08X\n"
+                					"  dma  = 0x%08X (change=%d)\n",
+                					__FUNCTION__, __LINE__,
+                					idle,
+                					intAck,
+                					currAddr,
+                					changeDetected
+                					);
+                        
+        				_PrintCmdBuffer(device->kernel->command, currAddr);
+
+                    }
+#endif
+
+                    gcmkONERROR(gckHARDWARE_QueryIdle(device->kernel->hardware, &isIdle));
+                    /* gcmkPRINT("[galcore], timeout, isIdle=%d\n",isIdle); */
+
+                    if(isIdle == gcvFALSE)
+                    {
+                        /* silent reset */
+                        if(device->silentReset)
+                        {
+                            gcmkONERROR(gckOS_Reset(device->os));
+                        }
+                    }
+                }
+            }
+            
+            /* Release the mutex. */
+    		gcmkVERIFY_OK(gckOS_ReleaseRecMutex(device->os, device->kernel->hardware->recMutexPower));
+            
+            /* */
+            gcmkONERROR(gckOS_Delay(device->os, delayTime));
+	    }
+        else
+        {
+            gcmkONERROR(gckOS_Delay(device->os, 10000));
+            /* schedule_timeout_interruptible(500); */
+        }
+    }
+
+    return 0;
+    
+OnError:
+    gcmkPRINT("ERROR: %s has error \n",__func__);
+    return status;
+}
+#endif
+
 /*******************************************************************************
 **
 **	gckGALDEVICE_Setup_ISR
@@ -209,7 +479,7 @@ gckGALDEVICE_Setup_ISR(
 {
 	gctINT ret;
 
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
 	if (Device->irqLine == 0)
 	{
@@ -280,7 +550,7 @@ gckGALDEVICE_Release_ISR(
 	IN gckGALDEVICE Device
 	)
 {
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
 	/* release the irq */
 	if (Device->isrInitialized)
@@ -290,6 +560,7 @@ gckGALDEVICE_Release_ISR(
 #else
 		free_irq(Device->irqLine, Device);
 #endif
+        Device->isrInitialized = gcvFALSE;
 	}
 
 	return gcvSTATUS_OK;
@@ -322,7 +593,7 @@ gckGALDEVICE_Start_Thread(
 	IN gckGALDEVICE Device
 	)
 {
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
 	/* start the kernel thread */
     Device->threadCtxt = kthread_run(threadRoutine,
@@ -363,7 +634,7 @@ gckGALDEVICE_Stop_Thread(
 	gckGALDEVICE Device
 	)
 {
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
 	/* stop the thread */
 	if (Device->threadInitialized)
@@ -372,6 +643,8 @@ gckGALDEVICE_Stop_Thread(
 		up(&Device->sema);
 
 		kthread_stop(Device->threadCtxt);
+
+        Device->threadInitialized = gcvFALSE;
 	}
 
 	return gcvSTATUS_OK;
@@ -416,9 +689,22 @@ gckGALDEVICE_Start(
     */
 #if 0
 	/* Switch to SUSPEND power state. */
+    /* To simplify power state logic, temporarily use gcvPOWER_OFF instead*/
 	gcmkVERIFY_OK(
 		gckHARDWARE_SetPowerManagementState(Device->kernel->hardware,
-											gcvPOWER_SUSPEND));
+                                            gcvPOWER_SUSPEND_ATPOWERON));
+#endif
+
+#if MRVL_PROFILE_THREAD
+    Device->profilethread= kthread_run(profile_thread,
+				Device,
+				"galcore profile thread");
+#endif
+
+#if MRVL_GUARD_THREAD
+    Device->guardthread= kthread_run(guard_thread,
+				Device,
+				"galcore guard thread");
 #endif
 
 #if MRVL_TIMER
@@ -464,7 +750,7 @@ gckGALDEVICE_Stop(
     gckGALDEVICE Device
     )
 {
-    gcmkVERIFY_ARGUMENT(Device != NULL);
+    gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
     /*
        There is not need to change power state here
@@ -484,6 +770,14 @@ gckGALDEVICE_Stop(
     {
     	gckGALDEVICE_Stop_Thread(Device);
     }
+    
+#if MRVL_PROFILE_THREAD
+    kthread_stop(Device->profilethread);
+#endif
+
+#if MRVL_GUARD_THREAD
+    kthread_stop(Device->guardthread);
+#endif
 
 #if MRVL_TIMER
     del_timer(&Device->timer);
@@ -532,12 +826,13 @@ gckGALDEVICE_Construct(
 
     gcmkTRACE(gcvLEVEL_VERBOSE, "[galcore] Enter gckGALDEVICE_Construct\n");
 
-    printk("\n[galcore] registerBase =0x%08x, registerMemSize = 0x%08x, contiguousBase= 0x%08x, contiguousSize = 0x%08x\n", 
+    gcmkPRINT("\n[galcore] registerBase =0x%08x, registerMemSize = 0x%08x, contiguousBase= 0x%08x, contiguousSize = 0x%08x\n", 
               (gctUINT32)RegisterMemBase, (gctUINT32)RegisterMemSize, (gctUINT32)ContiguousBase, (gctUINT32)ContiguousSize);
     /* Allocate device structure. */
     device = kmalloc(sizeof(struct _gckGALDEVICE), GFP_KERNEL);
     if (!device)
     {
+        gcmkLOG_ERROR_ARGS("Can't allocate memory for device.");
     	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
     	    	      "[galcore] gckGALDEVICE_Construct: Can't allocate memory.\n");
 
@@ -545,6 +840,8 @@ gckGALDEVICE_Construct(
     }
     memset(device, 0, sizeof(struct _gckGALDEVICE));
 
+    device->clkEnabled = gcvTRUE;
+
     physical = RegisterMemBase;
 
     /* Set up register memory region */
@@ -555,12 +852,14 @@ gckGALDEVICE_Construct(
         device->registerBase = (gctPOINTER) ioremap_nocache(RegisterMemBase,
 	    	    	    	    	    	    	    RegisterMemSize);
         if (!device->registerBase)
-	{
+	    {
     	    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
 	    	    	  "[galcore] gckGALDEVICE_Construct: Unable to map location->0x%lX for size->%ld\n",
 			  RegisterMemBase,
 			  RegisterMemSize);
-
+            /* free device to avoid memory leakage*/
+            kfree(device);
+            device = gcvNULL;
     	    return gcvSTATUS_OUT_OF_RESOURCES;
         }
 
@@ -574,19 +873,21 @@ gckGALDEVICE_Construct(
 					(gctUINT32)device->registerBase);
     }
 
-	/* construct the gckOS object */
 	device->baseAddress = BaseAddress;
-    gcmkVERIFY_OK(gckOS_Construct(device, &device->os));
+    
+ 	/* construct the gckOS object */ 
+    gcmkONERROR(gckOS_Construct(device, &device->os));
 
     /* construct the gckKERNEL object. */
-    gcmkVERIFY_OK(gckKERNEL_Construct(device->os, device, &device->kernel));
+    gcmkONERROR(gckKERNEL_Construct(device->os, device, &device->kernel));
 
-    gcmkVERIFY_OK(gckHARDWARE_SetFastClear(device->kernel->hardware,
+    /* set fast clear. */
+    gcmkONERROR(gckHARDWARE_SetFastClear(device->kernel->hardware,
     					  				  FastClear,
 										  Compression));
 
     /* query the ceiling of the system memory */
-    gcmkVERIFY_OK(gckHARDWARE_QuerySystemMemory(device->kernel->hardware,
+    gcmkONERROR(gckHARDWARE_QuerySystemMemory(device->kernel->hardware,
 					&device->systemMemorySize,
                     &device->systemMemoryBaseAddress));
 
@@ -598,11 +899,12 @@ gckGALDEVICE_Construct(
 
 #if COMMAND_PROCESSOR_VERSION == 1
     /* start the command queue */
-    gcmkVERIFY_OK(gckCOMMAND_Start(device->kernel->command));
+    gcmkONERROR(gckCOMMAND_Start(device->kernel->command));
 #endif
 
     /* initialize the thread daemon */
 	sema_init(&device->sema, 0);
+
 	device->threadInitialized = gcvFALSE;
 	device->killThread = gcvFALSE;
 
@@ -613,17 +915,35 @@ gckGALDEVICE_Construct(
 
 	device->signal = Signal;
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    /* create mutex for GALDevice */
-    device->mutexGCDevice = gcvNULL;
-    gcmkVERIFY_OK(
-        gckOS_CreateMutex(device->os, &device->mutexGCDevice));
-#endif
+    device->printPID = gcvFALSE;
+    device->silentReset = gcvTRUE;
+    device->powerOffWhenIdle = gcvTRUE;
+    device->profileStep = 300; /* profiling every 300 ms */
+    device->profileTimeSlice = 300; /* take recent 300 ms as profiling foundation */
+    /* for a 30 fps application, recent 33 ms idle means the app may be paused */
+    device->profileTailTimeSlice = 33; 
+    device->powerDebug = gcvFALSE;
+    device->idleThreshold = 80; /* try to power off GC when idle time > 80% */
+    device->needPowerOff = gcvFALSE;
+    
+#if SEPARATE_CLOCK_AND_POWER && KEEP_POWER_ON
+    device->clkOffOnly = gcvTRUE;
+#else
+    device->clkOffOnly = gcvFALSE;
 #endif
 
+    device->currentPMode = gcvPM_NORMAL;
+
+    device->enableLowPowerMode = gcvFALSE;
+    device->enableDVFM = gcvTRUE;
+
+    memset(device->profNode, 0, NUM_PROFILE_NODES*sizeof(struct _gckProfNode));
+    device->lastNodeIndex = 0;
+
+    device->memRandomFailRate   = 0;
+
 	/* query the amount of video memory */
-    gcmkVERIFY_OK(gckHARDWARE_QueryMemory(device->kernel->hardware,
+    gcmkONERROR(gckHARDWARE_QueryMemory(device->kernel->hardware,
                     &device->internalSize,
                     &internalBaseAddress,
                     &internalAlignment,
@@ -655,7 +975,7 @@ gckGALDEVICE_Construct(
             device->internalLogical   = (gctPOINTER)ioremap_nocache(
 					physical, device->internalSize);
 
-            gcmkASSERT(device->internalLogical != NULL);
+            gcmkASSERT(device->internalLogical != gcvNULL);
 
 			physical += device->internalSize;
         }
@@ -683,7 +1003,7 @@ gckGALDEVICE_Construct(
             device->externalLogical = (gctPOINTER)ioremap_nocache(
 					physical, device->externalSize);
 
-			gcmkASSERT(device->externalLogical != NULL);
+			gcmkASSERT(device->externalLogical != gcvNULL);
 
 			physical += device->externalSize;
         }
@@ -746,13 +1066,13 @@ gckGALDEVICE_Construct(
 					break;
 				}
 
-				gcmkVERIFY_OK(gckGALDEVICE_FreeMemory(
+				gcmkONERROR(gckGALDEVICE_FreeMemory(
 					device,
 					device->contiguousBase,
 					device->contiguousPhysical
 					));
 
-				device->contiguousBase = NULL;
+				device->contiguousBase = gcvNULL;
 			}
 
 			if (device->contiguousSize <= (4 << 20))
@@ -795,7 +1115,7 @@ gckGALDEVICE_Construct(
 			device->contiguousPhysical = (gctPHYS_ADDR) ContiguousBase;
 			device->contiguousSize     = ContiguousSize;
 //			device->contiguousBase     = (gctPOINTER) ioremap_nocache(ContiguousBase, ContiguousSize);
-			device->contiguousBase = (gctPOINTER)ContiguousBase;
+			device->contiguousBase     = (gctPOINTER)ContiguousBase;
 			device->contiguousMapped   = gcvTRUE;
 
 			if (device->contiguousBase == gcvNULL)
@@ -812,7 +1132,7 @@ gckGALDEVICE_Construct(
 
     *Device = device;
 
-    printk("\n[galcore] real contiguouSize = 0x%08x \n",  (gctUINT32)(device->contiguousSize));
+    gcmkPRINT("\n[galcore] real contiguouSize = 0x%08x \n",  (gctUINT32)(device->contiguousSize));
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
     	    	  "[galcore] gckGALDEVICE_Construct: Initialized device->0x%p contiguous->%lu @ 0x%p (0x%08X)\n",
 		  device,
@@ -820,7 +1140,18 @@ gckGALDEVICE_Construct(
 		  device->contiguousBase,
 		  device->contiguousPhysical);
 
+	/* Init GC memory profile. */
+	device->reservedMem = ContiguousSize;
+	device->vidMemUsage = 0;
+	device->contiguousMemUsage = 0;
+	device->virtualMemUsage = 0;
+
     return gcvSTATUS_OK;
+    
+OnError:
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
 }
 
 /*******************************************************************************
@@ -845,18 +1176,20 @@ gceSTATUS
 gckGALDEVICE_Destroy(
 	gckGALDEVICE Device)
 {
-	gcmkVERIFY_ARGUMENT(Device != NULL);
+	gcmkVERIFY_ARGUMENT(Device != gcvNULL);
 
     gcmkTRACE(gcvLEVEL_VERBOSE, "[ENTER] gckGALDEVICE_Destroy\n");
 
     /* Destroy the gckKERNEL object. */
     gcmkVERIFY_OK(gckKERNEL_Destroy(Device->kernel));
+    Device->kernel = gcvNULL;
 
     if (Device->internalVidMem != gcvNULL)
     {
         /* destroy the internal heap */
         gcmkVERIFY_OK(gckVIDMEM_Destroy(Device->internalVidMem));
 
+        Device->internalVidMem = gcvNULL;
 		/* unmap the internal memory */
 		iounmap(Device->internalLogical);
     }
@@ -866,6 +1199,7 @@ gckGALDEVICE_Destroy(
         /* destroy the internal heap */
         gcmkVERIFY_OK(gckVIDMEM_Destroy(Device->externalVidMem));
 
+        Device->externalVidMem = gcvNULL;
         /* unmap the external memory */
 		iounmap(Device->externalLogical);
     }
@@ -874,26 +1208,27 @@ gckGALDEVICE_Destroy(
     {
         /* Destroy the contiguous heap */
         gcmkVERIFY_OK(gckVIDMEM_Destroy(Device->contiguousVidMem));
+        Device->contiguousVidMem = gcvNULL;
 
-	if (Device->contiguousMapped)
-	{
-    	    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
-	        	  "[galcore] gckGALDEVICE_Destroy: "
-			  "Unmapping contiguous memory->0x%08lX\n",
-			  Device->contiguousBase);
-
-	    iounmap(Device->contiguousBase);
-	}
-	else
-	{
-    	    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
-	        	  "[galcore] gckGALDEVICE_Destroy: "
-			  "Freeing contiguous memory->0x%08lX\n",
-			  Device->contiguousBase);
+    	if (Device->contiguousMapped)
+    	{
+        	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
+    	    	  "[galcore] gckGALDEVICE_Destroy: "
+    		  "Unmapping contiguous memory->0x%08lX\n",
+    		  Device->contiguousBase);
 
-    	    gcmkVERIFY_OK(gckGALDEVICE_FreeMemory(Device,
-						 Device->contiguousBase,
-						 Device->contiguousPhysical));
+    	    iounmap(Device->contiguousBase);
+    	}
+    	else
+    	{
+        	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
+    	    	  "[galcore] gckGALDEVICE_Destroy: "
+    		  "Freeing contiguous memory->0x%08lX\n",
+    		  Device->contiguousBase);
+
+        	gcmkVERIFY_OK(gckGALDEVICE_FreeMemory(Device,
+    					 Device->contiguousBase,
+    					 Device->contiguousPhysical));
     	}
     }
 
@@ -902,16 +1237,12 @@ gckGALDEVICE_Destroy(
         iounmap(Device->registerBase);
     }
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    gcmkVERIFY_OK(gckOS_DeleteMutex(Device->os, Device->mutexGCDevice));
-#endif
-#endif
-
     /* Destroy the gckOS object. */
     gcmkVERIFY_OK(gckOS_Destroy(Device->os));
+    Device->os = gcvNULL;
 
     kfree(Device);
+    Device = gcvNULL;
 
     gcmkTRACE(gcvLEVEL_VERBOSE, "[galcore] Leave gckGALDEVICE_Destroy\n");
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.h
index 4222b2e..b2d89a7 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_device.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -35,19 +35,15 @@
 /******************************************************************************\
 ******************************* gckGALDEVICE Structure *******************************
 \******************************************************************************/
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
 typedef enum _gcePOWRE_MODE
 {
     gcvPM_NORMAL,
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
     gcvPM_EARLY_SUSPEND,
-    gcvPM_LATE_RESUME,
+#endif
     gcvPM_SUSPEND,
-    gcvPM_RESUME
 }
 gcePOWER_MODE;
-#endif
-#endif
 
 typedef struct _gckProfNode
 {
@@ -96,47 +92,67 @@ typedef struct _gckGALDEVICE
 
 	/* Signal management. */
 	gctINT				signal;
-#if defined CONFIG_PXA_DVFM || defined CONFIG_CPU_MMP2
+    
+#if MRVL_CONFIG_ENABLE_DVFM
     /* dvfm device index */
     gctINT              dvfm_dev_index;
+#endif
 
-    /* dvfm notifier */
-    struct notifier_block *dvfm_notifier;
-
-    /* GC register state can't be retained
-       after existing form D2 on PV2 board.
-       So we must reset GC on this case.
-    */
-    gctBOOL             needResetAfterD2;
-    gctBOOL             needD2DebugInfo;
-    gctBOOL             enableMdelay;
-    gctBOOL             enableD0CS;
-    gctBOOL             enableD1;
-    gctBOOL             enableD2;
-    gctBOOL             enableCG;
-
-#elif defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
+    /* current power mode */
     gcePOWER_MODE       currentPMode;
-    gctPOINTER          mutexGCDevice;
-#endif
 
-#endif
     /* do silent reset */
-    gctBOOL             reset;
+    gctBOOL             silentReset;
+    gctBOOL             powerDebug;
+    
+    /* power off GC when idle */
+    gctBOOL             powerOffWhenIdle;
+    gctUINT32           profileStep;
+    gctUINT32           profileTimeSlice;
+    gctUINT32           profileTailTimeSlice;
+    gctUINT32           idleThreshold;
+    gctBOOL             needPowerOff;
+    gctBOOL             clkOffOnly;
+
+    /* print pid of the process that is using GC */
     gctBOOL             printPID;
+
+    /* enable/disable DVFM LPM by default */
     gctBOOL             enableDVFM;
     gctBOOL             enableLowPowerMode;
 
+    /* mark GC power and clk status */
+    gctBOOL             clkEnabled;
+
     /* profiling data */
     struct _gckProfNode profNode[100];
     gctUINT32           lastNodeIndex;
 
 #if MRVL_TIMER
+    /* the timer thread */
     struct timer_list   timer;
     struct semaphore	timersema;
     struct task_struct	*timerthread;
 #endif
+
+#if MRVL_PROFILE_THREAD
+    /* the profile thread */
+    struct task_struct	*profilethread;
+#endif
+
+#if MRVL_GUARD_THREAD
+    /* the guard thread */
+    struct task_struct	*guardthread;
+#endif
+
+	/* GC memory profile */
+	gctSIZE_T			reservedMem;
+	gctINT32			vidMemUsage;
+	gctINT32			contiguousMemUsage;
+	gctINT32			virtualMemUsage;
+
+    /* simulate memory allocation random fail */
+    gctINT32            memRandomFailRate;
 }
 * gckGALDEVICE;
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_driver.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_driver.c
index bc00ff9..3792833 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_driver.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -19,65 +19,65 @@
 *****************************************************************************/
 
 
+#include <linux/device.h>
+#include "gc_hal_kernel_linux.h"
+#include "gc_hal_driver.h"
+#include "gc_hal_user_context.h"
+
 #ifdef ENABLE_GPU_CLOCK_BY_DRIVER
 #undef ENABLE_GPU_CLOCK_BY_DRIVER
 #endif
 
-#if defined(CONFIG_DOVE_GPU)
+#if (defined CONFIG_DOVE_GPU)
 #define ENABLE_GPU_CLOCK_BY_DRIVER	0
 #else
 #define ENABLE_GPU_CLOCK_BY_DRIVER	1
 #endif
 
 /* You can comment below line to use legacy driver model */
-#define USE_PLATFORM_DRIVER 1
-#include <linux/device.h>
-
-#include "gc_hal_kernel_linux.h"
-#include "gc_hal_driver.h"
-#include "gc_hal_user_context.h"
+#define USE_PLATFORM_DRIVER         1
 
 #if USE_PLATFORM_DRIVER
 #include <linux/platform_device.h>
 #endif
 
+#if MRVL_PLATFORM_MMP2
+#include <mach/cputype.h>
+#endif
+
+#if MRVL_CONFIG_ENABLE_DVFM
+#include <mach/dvfm.h>
+#endif
+
 MODULE_DESCRIPTION("Vivante Graphics Driver");
 MODULE_LICENSE("GPL");
 
 struct class *gpuClass;
 
-#if defined CONFIG_CPU_PXA910
-    #if POWER_OFF_GC_WHEN_IDLE
-        gckGALDEVICE galDevice;
-    #else
-        static gckGALDEVICE galDevice;
-    #endif
-#else
-    static gckGALDEVICE galDevice;
-#endif
+static gckGALDEVICE galDevice;
 
 static int major = 199;
 module_param(major, int, 0644);
 
 #ifdef CONFIG_MACH_CUBOX
-int irqLine = 42;
-long registerMemBase = 0xf1840000;
-ulong contiguousBase = 0x8000000;
+    int irqLine = 42;
+    long registerMemBase = 0xf1840000;
+    ulong contiguousBase = 0x8000000;
 #else
-int irqLine = 8;
-long registerMemBase = 0xc0400000;
-ulong contiguousBase = 0;
+    int irqLine = 8;
+    long registerMemBase = 0xc0400000;
+    ulong contiguousBase = 0;
 #endif
-module_param(irqLine, int, 0644);
 
+module_param(irqLine, int, 0644);
 module_param(registerMemBase, long, 0644);
 
 ulong registerMemSize = 256 << 10;
 module_param(registerMemSize, ulong, 0644);
 
+
 long contiguousSize = 32 << 20;
 module_param(contiguousSize, long, 0644);
-
 module_param(contiguousBase, ulong, 0644);
 
 long bankSize = 32 << 20;
@@ -100,207 +100,71 @@ module_param(showArgs, int, 0644);
 
 ulong gpu_frequency = 312;
 module_param(gpu_frequency, ulong, 0644);
-#ifdef CONFIG_PXA_DVFM
-#include <mach/dvfm.h>
-#include <mach/pxa3xx_dvfm.h>
-#include <linux/delay.h>
-
-static int galcore_dvfm_notifier(struct notifier_block *nb,
-				unsigned long val, void *data);
-
-static struct notifier_block galcore_notifier_block = {
-	.notifier_call = galcore_dvfm_notifier,
-};
-#endif
 
+/******************************************************************************\
+* Create a data entry system using proc for GC
+\******************************************************************************/
 #define MRVL_CONFIG_PROC
+
 #ifdef MRVL_CONFIG_PROC
 #include <linux/proc_fs.h>
-#define GC_PROC_FILE    "driver/gc"
-static struct proc_dir_entry * gc_proc_file;
-
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-#define MUTEX_CONTEXT 0
-#define MUTEX_QUEUE 0
-
-gceSTATUS _power_off_gc(gckGALDEVICE device, gctBOOL early_suspend)
-{
-    /* turn off gc */
-    if (device->kernel->hardware->chipPowerState != gcvPOWER_OFF)
-    {
-        gceSTATUS status;
-        gckCOMMAND command;
-
-        command = device->kernel->command;
-        printk("[%s]\t@%d\tC:0x%p\tQ:0x%p\n", __func__, __LINE__, command->mutexContext, command->mutexQueue);
-
-        // stall
-        {
-            /* Acquire the context switching mutex so nothing else can be committed. */
-#if MUTEX_CONTEXT
-            gcmkONERROR(
-                gckOS_AcquireMutex(device->kernel->hardware->os,
-                                   command->mutexContext,
-                                   gcvINFINITE));
-#endif
-            if (gcvTRUE == early_suspend)
-            {
-                gcmkONERROR(
-                    gckCOMMAND_Stall(command));
-            }
-        }
-
-        // stop
-        {
-
-            /* Stop the command parser. */
-            gcmkONERROR(
-                    gckCOMMAND_Stop(command));
-
-#if MUTEX_QUEUE
-            /* Grab the command queue mutex so nothing can get access to the command queue. */
-            gcmkONERROR(
-                    gckOS_AcquireMutex(device->kernel->hardware->os,
-                                       command->mutexQueue,
-                                       gcvINFINITE));
-#endif
-        }
-
-        // disable irq and clock
-        {
-            gckOS_SuspendInterrupt(device->os);
-            gckOS_ClockOff();
-        }
-
-        galDevice->kernel->hardware->chipPowerState = gcvPOWER_OFF;
 
-    }
-
-    return gcvSTATUS_OK;
-
-OnError:
-    printk("ERROR: %s has error \n",__func__);
-    return gcvSTATUS_OK;
-}
-
-
-gceSTATUS _power_on_gc(gckGALDEVICE device)
-{
-    /* turn on gc */
-    if(device->kernel->hardware->chipPowerState != gcvPOWER_ON)
-    {
-        gceSTATUS status;
-
-        // enable clock and irq
-        {
-            gckOS_ClockOn(0);
-            gckOS_ResumeInterrupt(device->os);
-        }
-        // INITIALIZE
-        {
-            /* Initialize hardware. */
-            gcmkONERROR(
-                gckHARDWARE_InitializeHardware(device->kernel->hardware));
-
-            gcmkONERROR(
-                gckHARDWARE_SetFastClear(device->kernel->hardware,
-                                         device->kernel->hardware->allowFastClear,
-                                         device->kernel->hardware->allowCompression));
-
-            /* Force the command queue to reload the next context. */
-            device->kernel->command->currentContext = 0;
-        }
-
-        /* Sleep for 1ms, to make sure everything is powered on. */
-//        mdelay(1);//gcmVERIFY_OK(gcoOS_Delay(galDevice->os, 1));
-
-        // start
-        {
-#if MUTEX_QUEUE
-            /* Release the command mutex queue. */
-            gcmkONERROR(
-                gckOS_ReleaseMutex(device->kernel->hardware->os,
-                                   device->kernel->command->mutexQueue));
-#endif
-            /* Start the command processor. */
-            gcmkONERROR(
-                gckCOMMAND_Start(device->kernel->command));
-        }
-
-        // release_context
-        {
-#if MUTEX_CONTEXT
-            /* Release the context switching mutex. */
-            gcmkVERIFY_OK(
-                gckOS_ReleaseMutex(device->kernel->hardware->os,
-                                   device->kernel->command->mutexContext));
-#endif
-        }
-
-        printk("[%s]\t@%d\tC:0x%p\tQ:0x%p\n", __func__, __LINE__, device->kernel->command->mutexContext, device->kernel->command->mutexQueue);
-        device->kernel->hardware->chipPowerState = gcvPOWER_ON;
-        //galDevice->kernel->notifyIdle = gcvTRUE;
-    }
-
-    return gcvSTATUS_TRUE;
-OnError:
-    printk("ERROR: %s has error \n",__func__);
-
-    return gcvSTATUS_FALSE;
-}
-
-static gceSTATUS _wake_up_gc(gckGALDEVICE device)
-{
-    static gctINT count = 0;
-//    if(gcvPM_EARLY_SUSPEND == device->currentPMode)
-    {
-        ++count;
-        if (device->printPID)
-            printk(">>>[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
-
-        _power_on_gc(device);
-
-        if (device->printPID)
-            printk("<<<[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
-    }
+#define GC_PROC_FILE    "driver/gc"
+#define _GC_OBJ_ZONE	gcvZONE_DRIVER
 
-    return gcvSTATUS_TRUE;
-}
-#endif
-#endif
+static struct proc_dir_entry * gc_proc_file;
 
 /* cat /proc/driver/gc will print gc related msg */
 static ssize_t gc_proc_read(struct file *file,
     char __user *buffer, size_t count, loff_t *offset)
 {
+    gceSTATUS status;
 	ssize_t len = 0;
 	char buf[1000];
     gctUINT32 idle;
+    gctBOOL   isIdle;
     gctUINT32 clockControl;
 
-    gcmkVERIFY_OK(gckHARDWARE_GetIdle(galDevice->kernel->hardware, gcvFALSE, &idle));
-	len += sprintf(buf+len, "idle register: 0x%02x\n", idle);
+    len += sprintf(buf+len, "%s(%s)\n", _VENDOR_STRING_, _GC_VERSION_STRING_);
+#ifdef _DEBUG
+    len += sprintf(buf+len, "DEBUG VERSION\n");
+#else
+    len += sprintf(buf+len, "RELEASE VERSION\n");
+#endif
+
+    gcmkONERROR(gckHARDWARE_GetIdle(galDevice->kernel->hardware, gcvFALSE, &idle));
+    gcmkONERROR(gckHARDWARE_QueryIdle(galDevice->kernel->hardware, &isIdle));
+    len += sprintf(buf+len, "idle register: 0x%02x, hardware is %s\n", idle, (gcvTRUE == isIdle)?"idle":"busy");
 
-    gckOS_ReadRegister(galDevice->os, 0x00000, &clockControl);
+    gcmkONERROR(gckOS_ReadRegister(galDevice->os, 0x00000, &clockControl));
     len += sprintf(buf+len, "clockControl register: 0x%02x\n", clockControl);
 
-#ifdef CONFIG_PXA_DVFM
-	len += sprintf(buf+len, "mode:\tDOCS(%d)D1(%d)D2(%d)CG(%d)\n\tDebug(%d)Pid(%d)Reset(%d)\n",
-		           galDevice->enableD0CS,
-		           galDevice->enableD1,
-		           galDevice->enableD2,
-		           galDevice->enableCG,
-		           galDevice->needD2DebugInfo,
-		           galDevice->printPID,
-		           galDevice->needResetAfterD2);
-#endif
+	len += sprintf(buf+len, "print mode:\tPid(%d) Reset(%d) DumpCmdBuf(%d)\n",
+                    galDevice->printPID, galDevice->silentReset, galDevice->kernel->command->dumpCmdBuf);
+
+	len += sprintf(buf+len, "GC memory usage profile:\n");
+
+	len += sprintf(buf+len, "Total reserved video memory: %ld KB\n", galDevice->reservedMem/1024);
+
+	len += sprintf(buf+len, "Used video mem: %d KB\tcontiguous: %d KB\tvirtual: %d KB\n", galDevice->vidMemUsage/1024,
+							galDevice->contiguousMemUsage/1024, galDevice->virtualMemUsage/1024);
+
+	if (galDevice->kernel->mmu)
+		len += sprintf(buf+len, "MMU Entries usage(PageCount): Total(%d), Used(%d)\n", galDevice->kernel->mmu->pageTableEntries,galDevice->kernel->mmu->pageTableUsedEntries);
 
 	return simple_read_from_buffer(buffer, count, offset, buf, len);
 
+OnError:
     return 0;
 }
 
+#if MRVL_PRINT_CMD_BUFFER
+extern gceSTATUS
+_PrintAllCmdBuffer(
+	gckCOMMAND Command
+	);
+#endif
+
 /* echo xx > /proc/driver/gc set ... */
 static ssize_t gc_proc_write(struct file *file,
 		const char *buff, size_t len, loff_t *off)
@@ -313,138 +177,178 @@ static ssize_t gc_proc_write(struct file *file,
 	if(copy_from_user(messages, buff, len))
 		return -EFAULT;
 
-    printk("\n");
+    gcmkPRINT("\n");
     if(strncmp(messages, "printPID", 8) == 0)
     {
         galDevice->printPID = galDevice->printPID ? gcvFALSE : gcvTRUE;
-        printk("==>Change printPID to %s\n", galDevice->printPID ? "gcvTRUE" : "gcvFALSE");
+        gcmkPRINT("==>Change printPID to %s\n", galDevice->printPID ? "gcvTRUE" : "gcvFALSE");
+    }
+    else if(strncmp(messages, "powerDebug", 10) == 0)
+    {
+        galDevice->powerDebug= galDevice->powerDebug ? gcvFALSE : gcvTRUE;
     }
     else if(strncmp(messages, "profile", 7) == 0)
     {
-        gctUINT32 idleTime, timeSlice;
-        gctUINT32 start,end;
-        timeSlice = 10000;
-        start = gckOS_GetTicks();
-        gckOS_IdleProfile(galDevice->os, &timeSlice, &idleTime);
-        end = gckOS_GetTicks();
-
-        printk("idle:total [%d, %d]\n", idleTime, timeSlice);
-        printk("profile cost %d\n", end - start);
+        sscanf(messages+7,"%d %d %d %d",
+            &galDevice->profileStep,&galDevice->profileTimeSlice,&galDevice->profileTailTimeSlice,&galDevice->idleThreshold);
+        gcmkPRINT("==>Change profling [step timeSlice tailTimeSlice threshold] to be [%d %d %d %d]\n",
+            galDevice->profileStep,galDevice->profileTimeSlice,galDevice->profileTailTimeSlice,galDevice->idleThreshold);
     }
     else if(strncmp(messages, "hang", 4) == 0)
     {
 		galDevice->kernel->hardware->hang = galDevice->kernel->hardware->hang ? gcvFALSE : gcvTRUE;
     }
-    else if(strncmp(messages, "reset", 5) == 0)
+    else if(strncmp(messages, "reset2", 6) == 0)
     {
-        galDevice->reset = galDevice->reset ? gcvFALSE : gcvTRUE;
+        gckOS_Reset(galDevice->os);
     }
-#ifdef CONFIG_PXA_DVFM
-    else if(strncmp(messages, "d2debug", 7) == 0)
+    else if(strncmp(messages, "memFail", 7) == 0)
     {
-        galDevice->needD2DebugInfo = galDevice->needD2DebugInfo ? gcvFALSE : gcvTRUE;
+        gctUINT32 para = 0xFFFFFFFF;
+        sscanf(messages+7, "%d", &para);
+        galDevice->memRandomFailRate = para;
+        gcmkPRINT("==>Change memory random fail rate to %d%\n", galDevice->memRandomFailRate);
     }
-    else if(strncmp(messages, "D1", 2) == 0)
+    else if(strncmp(messages, "irq", 3) == 0)
     {
-        galDevice->enableD1 = galDevice->enableD1 ? gcvFALSE : gcvTRUE;
-        gckOS_SetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
+        gctUINT32 enable  = ~0U;
+
+        sscanf(messages+3, "%d", &enable);
+
+        switch (enable) {
+            case 0:
+                /* disable GC interrupt line */
+                gckOS_SuspendInterrupt(galDevice->os);
+                break;
+            case 1:
+                /* enable GC interrupt line */
+                gckOS_ResumeInterrupt(galDevice->os);
+                break;
+            default:
+                gcmkPRINT("[galcore] Usage: echo irq [0|1] > /proc/driver/gc");
+        }
     }
-    else if(strncmp(messages, "D2", 2) == 0)
+    else if(strncmp(messages, "log", 3) == 0)
     {
-        galDevice->enableD2 = galDevice->enableD2 ? gcvFALSE : gcvTRUE;
-        gckOS_SetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
+        gctUINT32 filter = _GFX_LOG_NONE_;
+        gctUINT32 level  = _GFX_LOG_NONE_;
+        /*
+        @Description
+            Only deal with the lowest two bits of input value
+            so level 5(0x101) is functional equivalent to level 1(0x001)
+        @level  Val  Hex    Description
+                0   0x00    print nothing
+                1   0x01    print error log only
+                2   0x10    print warning log only
+                3   0x11    print error and warning info
+        @Sample
+            echo log 0 > /proc/driver/gc    # Disable error log print
+            echo log 3 > /proc/driver/gc    # Enable error & warning log print
+        */
+        sscanf(messages+3, "%d", &level);
+
+        if ((level & _GFX_LOG_ERROR_) != _GFX_LOG_NONE_)
+            filter |= _GFX_LOG_ERROR_;
+        if ((level & _GFX_LOG_WARNING_) != _GFX_LOG_NONE_)
+            filter |= _GFX_LOG_WARNING_;
+        gckOS_SetLogFilter(filter);
+        gcmkPRINT("==>Change log level to %d", filter);
     }
-    else if(strncmp(messages, "D0", 2) == 0)
+    else if(strncmp(messages, "silentReset", 11) == 0)
     {
-        galDevice->enableD0CS= galDevice->enableD0CS ? gcvFALSE : gcvTRUE;
-        gckOS_SetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
+        gctUINT32 para = 0xFFFFFFFF;
+
+        sscanf(messages+11, "%d", &para);
+
+        switch(para)
+        {
+        case 0:
+            galDevice->silentReset = gcvFALSE;
+            gcmkPRINT("==>Change silentReset to %s\n", galDevice->silentReset ? "gcvTRUE" : "gcvFALSE");
+            break;
+        case 1:
+            galDevice->silentReset = gcvTRUE;
+            gcmkPRINT("==>Change silentReset to %s\n", galDevice->silentReset ? "gcvTRUE" : "gcvFALSE");
+            break;
+        default:
+            gcmkPRINT("usage:  \n \
+            to enable silent reset:     #echo silentReset 1 > /proc/driver/gc \n \
+            to disable silent reset:    #echo silentReset 0 > /proc/driver/gc \n");
+            break;
+        }
     }
-    else if(strncmp(messages, "CG", 2) == 0)
+    else if(strncmp(messages, "dumpCmdBuf", 10) == 0)
     {
-        galDevice->enableCG= galDevice->enableCG ? gcvFALSE : gcvTRUE;
-        gckOS_SetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
+        gctUINT32 para = 0xFFFFFFFF;
+
+        sscanf(messages+10, "%d", &para);
+
+        switch(para)
+        {
+        case 0:
+            galDevice->kernel->command->dumpCmdBuf = gcvFALSE;
+            gcmkPRINT("==>Change dumpCmdBuf to %s\n", galDevice->kernel->command->dumpCmdBuf ? "gcvTRUE" : "gcvFALSE");
+            break;
+        case 1:
+            galDevice->kernel->command->dumpCmdBuf = gcvTRUE;
+            gcmkPRINT("==>Change dumpCmdBuf to %s\n", galDevice->kernel->command->dumpCmdBuf ? "gcvTRUE" : "gcvFALSE");
+            break;
+        default:
+            gcmkPRINT("usage:  \n \
+            to enable dump cmd buffer   #echo dumpCmdBuf 1 > /proc/driver/gc \n \
+            to disable dump cmd buffer  #echo dumpCmdBuf 0 > /proc/driver/gc \n");
+            break;
+        }
     }
-    else if(strncmp(messages, "needreset", 9) == 0)
+#if MRVL_PRINT_CMD_BUFFER
+    else if(strncmp(messages, "dumpall", 7) == 0)
     {
-        galDevice->needResetAfterD2 = galDevice->needResetAfterD2 ? gcvFALSE : gcvTRUE;
+        _PrintAllCmdBuffer(galDevice->kernel->command);
     }
 #endif
+    else if(strncmp(messages, "clkoffonly", 10) == 0)
+    {
+        galDevice->clkOffOnly= galDevice->clkOffOnly? gcvFALSE : gcvTRUE;
+        gcmkPRINT("==>Change clkOffOnly to %s\n", galDevice->clkOffOnly ? "gcvTRUE" : "gcvFALSE");
+    }
+    else if(strncmp(messages, "offidle", 7) == 0)
+    {
+        galDevice->powerOffWhenIdle = galDevice->powerOffWhenIdle? gcvFALSE : gcvTRUE;
+        gcmkPRINT("==>Change powerOffWhenIdle to %s\n", galDevice->powerOffWhenIdle ? "gcvTRUE" : "gcvFALSE");
+    }
     else if(strncmp(messages, "su", 2) == 0)
     {
-        gceSTATUS status;
-
-        if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_OFF)
-        {
-            status = gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_OFF);
-            if (gcmIS_ERROR(status))
-            {
-                return -1;
-            }
-
-            gckOS_SuspendInterrupt(galDevice->os);
-            gckOS_ClockOff();
-        }
+        /* gckOS_PowerOff(galDevice->os); */
     }
     else if(strncmp(messages, "re", 2) == 0)
     {
-        gceSTATUS status;
-
-        if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_ON)
-        {
-            gckOS_ClockOn(0);
-            gckOS_ResumeInterrupt(galDevice->os);
-
-            status = gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_ON);
-		if (gcmIS_ERROR(status))
-		{
-			return -1;
-		}
-        }
+        /* gckOS_PowerOn(galDevice->os); */
     }
     else if(strncmp(messages, "stress", 6) == 0)
     {
         int i;
-         /* struct vmalloc_info vmi; */
+        static int count = 0;
 
-     /* {get_vmalloc_info(&vmi);printk("%s,%d,VmallocUsed: %8lu kB\n",__func__,__LINE__,vmi.used >> 10); } */
+        sscanf(messages+6,"%d", &count);
+        /* struct vmalloc_info vmi; */
+
+        /* {get_vmalloc_info(&vmi);gcmkPRINT("%s,%d,VmallocUsed: %8lu kB\n",__func__,__LINE__,vmi.used >> 10); } */
 
 #ifdef _DEBUG
-	gckOS_SetDebugLevel(gcvLEVEL_VERBOSE);
-	gckOS_SetDebugZone(1023);
+    	gckOS_SetDebugLevel(gcvLEVEL_VERBOSE);
+    	gckOS_SetDebugZone(1023);
 #endif
 
-        for(i=0;i<20000;i++)
+        for(i=0;i<count;i++)
         {
-            gceSTATUS status;
             static int count = 0;
 
-            printk("count:%d\n",count++);
-            printk("!!!\t");
-            if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_OFF)
-            {
-                status = gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_OFF);
-		if (gcmIS_ERROR(status))
-		{
-			return -1;
-		}
-
-                gckOS_SuspendInterrupt(galDevice->os);
-                gckOS_ClockOff();
-
-            }
-            printk("@@@\t");
-            if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_ON)
-            {
-                gckOS_ClockOn(0);
-                gckOS_ResumeInterrupt(galDevice->os);
-
-                status = gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_ON);
-		if (gcmIS_ERROR(status))
-		{
-			return -1;
-		}
-            }
-            printk("###\n");
+            gcmkPRINT("count:%d\n",count++);
+            gcmkPRINT("!!!\t");
+            /* gckOS_PowerOff(galDevice->os); */
+            gcmkPRINT("@@@\t");
+            /* gckOS_PowerOn(galDevice->os); */
+            gcmkPRINT("###\n");
         }
 
     }
@@ -452,86 +356,110 @@ static ssize_t gc_proc_write(struct file *file,
     {
 #ifdef _DEBUG
         static int count = 0;
+        gctINT debugLevel = gcvLEVEL_NONE;
+        gctINT debugZone = 0;
+
+        sscanf(messages+5,"%d %d", &debugLevel,&debugZone);
+
+
+        /*
+            #define gcvLEVEL_NONE           -1
+            #define gcvLEVEL_ERROR          0
+            #define gcvLEVEL_WARNING        1
+            #define gcvLEVEL_INFO           2
+            #define gcvLEVEL_VERBOSE        3
+        */
+
+        /*
+            #define gcvZONE_OS              (1 << 0)
+            #define gcvZONE_HARDWARE        (1 << 1)
+            #define gcvZONE_HEAP            (1 << 2)
+
+            #define gcvZONE_KERNEL          (1 << 3)
+            #define gcvZONE_VIDMEM          (1 << 4)
+            #define gcvZONE_COMMAND         (1 << 5)
+            #define gcvZONE_DRIVER          (1 << 6)
+            #define gcvZONE_CMODEL          (1 << 7)
+            #define gcvZONE_MMU             (1 << 8)
+            #define gcvZONE_EVENT           (1 << 9)
+            #define gcvZONE_DEVICE          (1 << 10)
+        */
 
-        if(count%2 == 0)
-        {
-		gckOS_SetDebugLevel(gcvLEVEL_VERBOSE);
-		gckOS_SetDebugZone(1023);
-        }
-        else
-        {
-            gckOS_SetDebugLevel(gcvLEVEL_NONE);
-		gckOS_SetDebugZone(0);
-        }
         count++;
+        gckOS_SetDebugLevel(debugLevel);
+        gckOS_SetDebugZone(debugZone);
+        gcmkPRINT("==>Change Debuglevel to %s, DebugZone to %d, Count:%d\n",
+            (debugLevel == gcvLEVEL_VERBOSE) ? "gcvLEVEL_VERBOSE" : "gcvLEVEL_NONE",
+            debugZone,
+            count);
 #endif
     }
     else if(strncmp(messages, "16", 2) == 0)
     {
-		printk("frequency change to 1/16\n");
+		gcmkPRINT("frequency change to 1/16\n");
         /* frequency change to 1/16 */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x210));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x010));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x010));
 
     }
     else if(strncmp(messages, "32", 2) == 0)
     {
-		printk("frequency change to 1/32\n");
+		gcmkPRINT("frequency change to 1/32\n");
         /* frequency change to 1/32*/
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x208));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x008));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x008));
 
     }
 	else if(strncmp(messages, "64", 2) == 0)
     {
-		printk("frequency change to 1/64\n");
+		gcmkPRINT("frequency change to 1/64\n");
         /* frequency change to 1/64 */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x204));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x004));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x004));
 
     }
     else if('1' == messages[0])
     {
-        printk("frequency change to full speed\n");
+        gcmkPRINT("frequency change to full speed\n");
         /* frequency change to full speed */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x300));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x100));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x100));
 
     }
     else if('2' == messages[0])
     {
-        printk("frequency change to 1/2\n");
+        gcmkPRINT("frequency change to 1/2\n");
         /* frequency change to 1/2 */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x280));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x080));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x080));
 
     }
     else if('4' == messages[0])
     {
-        printk("frequency change to 1/4\n");
+        gcmkPRINT("frequency change to 1/4\n");
         /* frequency change to 1/4 */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x240));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x040));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x040));
 
     }
     else if('8' == messages[0])
     {
-        printk("frequency change to 1/8\n");
+        gcmkPRINT("frequency change to 1/8\n");
         /* frequency change to 1/8 */
         gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x220));
         /* Loading the frequency scaler. */
-	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x020));
+    	gcmkVERIFY_OK(gckOS_WriteRegister(galDevice->os,0x00000,0x020));
 
     }
     else
     {
-        printk("unknown echo\n");
+        gcmkPRINT("unknown echo\n");
     }
 
     return len;
@@ -544,20 +472,23 @@ static struct file_operations gc_proc_ops = {
 
 static void create_gc_proc_file(void)
 {
-	gc_proc_file = create_proc_entry(GC_PROC_FILE, 0644, NULL);
+	gc_proc_file = create_proc_entry(GC_PROC_FILE, 0644, gcvNULL);
 	if (gc_proc_file) {
 		gc_proc_file->proc_fops = &gc_proc_ops;
 	} else
-		printk("[galcore] proc file create failed!\n");
+		gcmkPRINT("[galcore] proc file create failed!\n");
 }
 
 static void remove_gc_proc_file(void)
 {
-	remove_proc_entry(GC_PROC_FILE, NULL);
+	remove_proc_entry(GC_PROC_FILE, gcvNULL);
 }
 
 #endif
 
+/******************************************************************************\
+* Driver operations definition
+\******************************************************************************/
 static int drv_open(struct inode *inode, struct file *filp);
 static int drv_release(struct inode *inode, struct file *filp);
 static long drv_ioctl(struct file *filp,
@@ -577,13 +508,13 @@ int drv_open(struct inode *inode, struct file* filp)
     gcsHAL_PRIVATE_DATA_PTR	private;
 
     gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_DRIVER,
-		  "Entering drv_open\n");
+    	    	  "Entering drv_open\n");
 
     private = kmalloc(sizeof(gcsHAL_PRIVATE_DATA), GFP_KERNEL);
 
     if (private == gcvNULL)
     {
-	return -ENOTTY;
+    	return -ENOTTY;
     }
 
     private->device				= galDevice;
@@ -601,7 +532,7 @@ int drv_open(struct inode *inode, struct file* filp)
 
     if (!galDevice->contiguousMapped)
     {
-	gcmkVERIFY_OK(gckOS_MapMemory(galDevice->os,
+    	gcmkVERIFY_OK(gckOS_MapMemory(galDevice->os,
 									galDevice->contiguousPhysical,
 									galDevice->contiguousSize,
 									&private->contiguousLogical));
@@ -612,19 +543,13 @@ int drv_open(struct inode *inode, struct file* filp)
     return 0;
 }
 
-extern void
-OnProcessExit(
-	IN gckOS Os,
-	IN gckKERNEL Kernel
-	);
-
 int drv_release(struct inode* inode, struct file* filp)
 {
     gcsHAL_PRIVATE_DATA_PTR	private;
     gckGALDEVICE			device;
 
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
-		  "Entering drv_close\n");
+    	    	  "Entering drv_close\n");
 
     private = filp->private_data;
     gcmkASSERT(private != gcvNULL);
@@ -632,29 +557,37 @@ int drv_release(struct inode* inode, struct file* filp)
     device = private->device;
 
 #if gcdkUSE_MEMORY_RECORD
+    gcmkVERIFY_OK(gckCOMMAND_Stall(device->kernel->command));
+
 	FreeAllMemoryRecord(galDevice->os, &private->memoryRecordList);
 
-#ifdef ANDROID
-	gcmkVERIFY_OK(gckOS_Delay(galDevice->os, 1000));
-#else
-	gcmkVERIFY_OK(gckCOMMAND_Stall(device->kernel->command));
-#endif
+    gcmkVERIFY_OK(gckCOMMAND_Stall(device->kernel->command));
 #endif
 
-		if (private->contiguousLogical != gcvNULL)
-		{
-			gcmkVERIFY_OK(gckOS_UnmapMemory(galDevice->os,
-											galDevice->contiguousPhysical,
-											galDevice->contiguousSize,
-											private->contiguousLogical));
-		}
+	if (private->contiguousLogical != gcvNULL)
+	{
+		gcmkVERIFY_OK(gckOS_UnmapMemory(galDevice->os,
+										galDevice->contiguousPhysical,
+										galDevice->contiguousSize,
+										private->contiguousLogical));
+	}
+
+    /* Free some uncleared resource when unnormal exit */
+    gckOS_FreeProcessResource(galDevice->os, current->tgid);
+
+	/* Print GC memory usage after every process exits. */
+	gcmkPRINT("PID=%d , name=%s exits\n", current->tgid, current->comm);
+	gcmkPRINT("GC memory usage profile:\n");
+	gcmkPRINT("Total reserved video memory: %ld KB\n", galDevice->reservedMem/1024);
+	gcmkPRINT("Used video mem: %d KB\tcontiguous: %d KB\tvirtual: %d KB\n", galDevice->vidMemUsage/1024,
+							galDevice->contiguousMemUsage/1024, galDevice->virtualMemUsage/1024);
 
 	/* A process gets detached. */
 	gcmkVERIFY_OK(
 		gckKERNEL_AttachProcess(galDevice->kernel, gcvFALSE));
 
     kfree(private);
-    filp->private_data = NULL;
+    filp->private_data = gcvNULL;
 
     return 0;
 }
@@ -674,20 +607,21 @@ long drv_ioctl(struct file *filp,
 
     if (private == gcvNULL)
     {
-	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
-		      "[galcore] drv_ioctl: private_data is NULL\n");
+        gcmkLOG_WARNING_ARGS("private data is null");
+    	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+    	    	      "[galcore] drv_ioctl: private_data is gcvNULL\n");
 
-	return -ENOTTY;
+    	return -ENOTTY;
     }
 
     device = private->device;
 
     if (device == gcvNULL)
     {
-	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
-		      "[galcore] drv_ioctl: device is NULL\n");
+    	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+    	    	      "[galcore] drv_ioctl: device is gcvNULL\n");
 
-	return -ENOTTY;
+    	return -ENOTTY;
     }
 
     if (ioctlCode != IOCTL_GCHAL_INTERFACE
@@ -699,12 +633,12 @@ long drv_ioctl(struct file *filp,
 
     /* Get the drvArgs to begin with. */
     copyLen = copy_from_user(&drvArgs,
-			     (void *) arg,
+    	    	    	     (void *) arg,
 			     sizeof(DRIVER_ARGS));
 
     if (copyLen != 0)
     {
-	/* The input buffer is not big enough. So fail the I/O. */
+    	/* The input buffer is not big enough. So fail the I/O. */
         return -ENOTTY;
     }
 
@@ -713,12 +647,12 @@ long drv_ioctl(struct file *filp,
     ||  (drvArgs.OutputBufferSize != sizeof(gcsHAL_INTERFACE))
     )
     {
-        printk("\n [galcore] data structure size in kernel and user do not match !\n");
-	return -ENOTTY;
+        gcmkPRINT("\n [galcore] data structure size in kernel and user do not match !\n");
+    	return -ENOTTY;
     }
 
     copyLen = copy_from_user(&iface,
-			     drvArgs.InputBuffer,
+    	    	    	     drvArgs.InputBuffer,
 			     sizeof(gcsHAL_INTERFACE));
 
     if (copyLen != 0)
@@ -728,7 +662,7 @@ long drv_ioctl(struct file *filp,
     }
     if(galDevice->printPID)
     {
-        printk("--->pid=%d\tname=%s\tiface.command=%d.\n", current->pid, current->comm, iface.command);
+        gcmkPRINT("--->pid=%d\tname=%s\tiface.command=%d.\n", current->pid, current->comm, iface.command);
     }
 #if gcdkUSE_MEMORY_RECORD
 	if (iface.command == gcvHAL_EVENT_COMMIT)
@@ -759,7 +693,7 @@ long drv_ioctl(struct file *filp,
 				}
 				else
 				{
-					printk("*ERROR* Invalid video memory (0x%p) for free\n",
+					gcmkPRINT("*ERROR* Invalid video memory (0x%p) for free\n",
 						record->iface.u.FreeVideoMemory.node);
 				}
                 break;
@@ -781,47 +715,20 @@ long drv_ioctl(struct file *filp,
 	}
 #endif
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    gcmkVERIFY_OK(
-        gckOS_AcquireMutex(galDevice->os, galDevice->mutexGCDevice, gcvINFINITE));
-
-    if(galDevice->printPID) {
-        printk("|-|-|- Acquired gcdevice mutex...\t%s@%d\tCommand:%d\t0x%p\n",__FUNCTION__,__LINE__,iface.command,galDevice->mutexGCDevice);
-    }
-
-    if (/*galDevice->enableIdleOff &&*/ iface.command == gcvHAL_COMMIT && gcvPM_EARLY_SUSPEND == galDevice->currentPMode)
-    {
-        if (1) {
-            /* turn on gc when gc is power off and in early-suspend mode */
-            _wake_up_gc(galDevice);
-        }
-    }
-
-    gcmkVERIFY_OK(
-        gckOS_ReleaseMutex(galDevice->os, galDevice->mutexGCDevice));
-
-    if(galDevice->printPID) {
-        printk("|-|-|- Released gcdevice mutex...\t%s@%d\n",__FUNCTION__,__LINE__);
-    }
-
-#endif
-#endif
-
     status = gckKERNEL_Dispatch(device->kernel,
 		(ioctlCode == IOCTL_GCHAL_INTERFACE) , &iface);
 
     if (gcmIS_ERROR(status))
     {
-	gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DRIVER,
-		      "[galcore] gckKERNEL_Dispatch returned %d.\n",
+    	gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DRIVER,
+	    	      "[galcore] gckKERNEL_Dispatch returned %d.\n",
 		      status);
     }
 
     else if (gcmIS_ERROR(iface.status))
     {
-	gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DRIVER,
-		      "[galcore] IOCTL %d returned %d.\n",
+    	gcmkTRACE_ZONE(gcvLEVEL_WARNING, gcvZONE_DRIVER,
+	    	      "[galcore] IOCTL %d returned %d.\n",
 		      iface.command,
 		      iface.status);
     }
@@ -829,18 +736,18 @@ long drv_ioctl(struct file *filp,
     /* See if this was a LOCK_VIDEO_MEMORY command. */
     else if (iface.command == gcvHAL_LOCK_VIDEO_MEMORY)
     {
-	/* Special case for mapped memory. */
-	if (private->mappedMemory != gcvNULL
+    	/* Special case for mapped memory. */
+    	if (private->mappedMemory != gcvNULL
 			&& iface.u.LockVideoMemory.node->VidMem.memory->object.type
 				== gcvOBJ_VIDMEM)
 		{
-			/* Compute offset into mapped memory. */
-		gctUINT32 offset = (gctUINT8 *) iface.u.LockVideoMemory.memory
-				- (gctUINT8 *) device->contiguousBase;
+	   		/* Compute offset into mapped memory. */
+	    	gctUINT32 offset = (gctUINT8 *) iface.u.LockVideoMemory.memory
+	    	    	     	- (gctUINT8 *) device->contiguousBase;
 
-	    /* Compute offset into user-mapped region. */
-	    iface.u.LockVideoMemory.memory =
-		(gctUINT8 *)  private->mappedMemory + offset;
+    	    /* Compute offset into user-mapped region. */
+    	    iface.u.LockVideoMemory.memory =
+	    	(gctUINT8 *)  private->mappedMemory + offset;
 		}
     }
 #if gcdkUSE_MEMORY_RECORD
@@ -870,19 +777,19 @@ long drv_ioctl(struct file *filp,
 		}
 		else
 		{
-			printk("*ERROR* Invalid video memory for free\n");
+			gcmkPRINT("*ERROR* Invalid video memory for free\n");
 		}
 	}
 #endif
 
     /* Copy data back to the user. */
     copyLen = copy_to_user(drvArgs.OutputBuffer,
-			   &iface,
+    	    	    	   &iface,
 			   sizeof(gcsHAL_INTERFACE));
 
     if (copyLen != 0)
     {
-	/* The output buffer is not big enough. So fail the I/O. */
+    	/* The output buffer is not big enough. So fail the I/O. */
         return -ENOTTY;
     }
     return 0;
@@ -897,7 +804,7 @@ static int drv_mmap(struct file * filp, struct vm_area_struct * vma)
 
     if (private == gcvNULL)
     {
-	return -ENOTTY;
+    	return -ENOTTY;
     }
 
     device = private->device;
@@ -917,22 +824,25 @@ static int drv_mmap(struct file * filp, struct vm_area_struct * vma)
 
     if (device->contiguousMapped)
     {
-	ret = io_remap_pfn_range(vma,
-				 vma->vm_start,
-				 (gctUINT32) device->contiguousPhysical >> PAGE_SHIFT,
+    	ret = io_remap_pfn_range(vma,
+	    	    	    	 vma->vm_start,
+    	    	    	    	 (gctUINT32) device->contiguousPhysical >> PAGE_SHIFT,
 				 size,
 				 vma->vm_page_prot);
 
-	private->mappedMemory = (ret == 0) ? (gctPOINTER) vma->vm_start : gcvNULL;
+    	private->mappedMemory = (ret == 0) ? (gctPOINTER) vma->vm_start : gcvNULL;
 
-	return ret;
+    	return ret;
     }
     else
     {
-	return -ENOTTY;
+    	return -ENOTTY;
     }
 }
 
+/******************************************************************************\
+* Driver initialization - cleanup and power management functions
+\******************************************************************************/
 
 #if !USE_PLATFORM_DRIVER
 static int __init drv_init(void)
@@ -944,10 +854,11 @@ static int drv_init(void)
     gckGALDEVICE device;
 
     gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_DRIVER,
-		  "Entering drv_init\n");
+    	    	  "Entering drv_init\n");
+	printk("\n[galcore] GC Version: %s\n", _GC_VERSION_STRING_);
 
 #if ENABLE_GPU_CLOCK_BY_DRIVER && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
-    gckOS_ClockOn(gpu_frequency);
+    gckOS_ClockOn(gcvNULL, gcvTRUE, gcvTRUE, gpu_frequency);
 #endif
 
 	if (showArgs)
@@ -966,7 +877,7 @@ static int drv_init(void)
 
     /* Create the GAL device. */
     gcmkVERIFY_OK(gckGALDEVICE_Construct(irqLine,
-					registerMemBase,
+    	    	    	    	    	registerMemBase,
 					registerMemSize,
 					contiguousBase,
 					contiguousSize,
@@ -976,112 +887,78 @@ static int drv_init(void)
 					baseAddress,
 					signal,
 					&device));
-    printk("\n[galcore] chipModel=0x%x,chipRevision=0x%x,chipFeatures=0x%x,chipMinorFeatures=0x%x\n",
+    gcmkPRINT("\n[galcore] chipModel=0x%x,chipRevision=0x%x,chipFeatures=0x%x,chipMinorFeatures=0x%x\n",
         device->kernel->hardware->chipModel, device->kernel->hardware->chipRevision,
         device->kernel->hardware->chipFeatures, device->kernel->hardware->chipMinorFeatures0);
 
-#ifdef CONFIG_PXA_DVFM
+#if MRVL_CONFIG_ENABLE_DVFM
     /* register galcore as a dvfm device*/
     if(dvfm_register("Galcore", &device->dvfm_dev_index))
     {
-        printk("\n[galcore] fail to do dvfm_register\n");
-    }
-
-    if(dvfm_register_notifier(&galcore_notifier_block,
-				DVFM_FREQUENCY_NOTIFIER))
-    {
-        printk("\n[galcore] fail to do dvfm_register_notifier\n");
+        gcmkPRINT("\n[galcore] fail to do dvfm_register\n");
     }
-
-    device->dvfm_notifier = &galcore_notifier_block;
-
-    device->needResetAfterD2 = gcvTRUE;
-    device->needD2DebugInfo = gcvFALSE;
-    device->enableMdelay = gcvFALSE;
-
-    device->enableD0CS = gcvTRUE;
-    device->enableD1 = gcvTRUE;
-    device->enableD2 = gcvTRUE;
-    device->enableCG = gcvTRUE;
-
-    gckOS_SetConstraint(device->os, gcvTRUE, gcvTRUE);
 #endif
-
-    device->printPID = gcvFALSE;
-    device->reset = gcvTRUE;
-
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    device->currentPMode = gcvPM_NORMAL;
-#endif
-#endif
-
-    device->enableLowPowerMode = gcvFALSE;
-    device->enableDVFM = gcvTRUE;
-
-    memset(device->profNode, 0, 100*sizeof(struct _gckProfNode));
-    device->lastNodeIndex = 0;
+	gckOS_SetConstraint(device->os, gcvTRUE, gcvTRUE);
 
     /* Start the GAL device. */
     if (gcmIS_ERROR(gckGALDEVICE_Start(device)))
     {
-	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
-		      "[galcore] Can't start the gal device.\n");
+    	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+    	    	      "[galcore] Can't start the gal device.\n");
 
-	/* Roll back. */
-	gckGALDEVICE_Stop(device);
-	gckGALDEVICE_Destroy(device);
+    	/* Roll back. */
+    	gckGALDEVICE_Stop(device);
+    	gckGALDEVICE_Destroy(device);
 
-	return -1;
+    	return -1;
     }
 
     /* Register the character device. */
     ret = register_chrdev(major, DRV_NAME, &driver_fops);
     if (ret < 0)
     {
-	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
-		      "[galcore] Could not allocate major number for mmap.\n");
+    	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+    	    	      "[galcore] Could not allocate major number for mmap.\n");
 
-	/* Roll back. */
-	gckGALDEVICE_Stop(device);
-	gckGALDEVICE_Destroy(device);
+    	/* Roll back. */
+    	gckGALDEVICE_Stop(device);
+    	gckGALDEVICE_Destroy(device);
 
-	return -1;
+    	return -1;
     }
     else
     {
-	if (major == 0)
-	{
-	    major = ret;
-	}
+    	if (major == 0)
+    	{
+    	    major = ret;
+    	}
     }
 
     galDevice = device;
 
 	gpuClass = class_create(THIS_MODULE, "v_graphics_class");
 	if (IS_ERR(gpuClass)) {
-	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+    	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
 					  "Failed to create the class.\n");
 		return -1;
 	}
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
-	device_create(gpuClass, NULL, MKDEV(major, 0), NULL, "galcore");
+	device_create(gpuClass, gcvNULL, MKDEV(major, 0), gcvNULL, "galcore");
 #else
-	device_create(gpuClass, NULL, MKDEV(major, 0), "galcore");
+	device_create(gpuClass, gcvNULL, MKDEV(major, 0), "galcore");
 #endif
 
     gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_DRIVER,
-		  "[galcore] irqLine->%ld, contiguousSize->%lu, memBase->0x%lX\n",
+    	    	  "[galcore] irqLine->%ld, contiguousSize->%lu, memBase->0x%lX\n",
 		  irqLine,
 		  contiguousSize,
 		  registerMemBase);
 
     gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_DRIVER,
-		  "[galcore] driver registered successfully.\n");
+    	    	  "[galcore] driver registered successfully.\n");
 
-    /* device should be idle because it is just initialized */
-    gckOS_NotifyIdle(device->os, gcvTRUE);
+    BSP_IDLE_PROFILE_INIT;
     return 0;
 }
 
@@ -1092,7 +969,7 @@ static void drv_exit(void)
 #endif
 {
     gcmkTRACE_ZONE(gcvLEVEL_VERBOSE, gcvZONE_DRIVER,
-		  "[galcore] Entering drv_exit\n");
+    	    	  "[galcore] Entering drv_exit\n");
 
 	device_destroy(gpuClass, MKDEV(major, 0));
 	class_destroy(gpuClass);
@@ -1100,220 +977,99 @@ static void drv_exit(void)
     unregister_chrdev(major, DRV_NAME);
 
     gckGALDEVICE_Stop(galDevice);
-#ifdef CONFIG_PXA_DVFM
-    gckOS_UnSetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
 
-    if(dvfm_unregister_notifier(&galcore_notifier_block,
-				DVFM_FREQUENCY_NOTIFIER))
-    {
-        printk("\n[galcore] fail to do dvfm_unregister_notifier\n");
-    }
+    gckOS_UnSetConstraint(galDevice->os, gcvTRUE, gcvTRUE);
 
+#if MRVL_CONFIG_ENABLE_DVFM
     if(dvfm_unregister("Galcore", &galDevice->dvfm_dev_index))
     {
-        printk("\n[galcore] fail to do dvfm_unregister\n");
+        gcmkPRINT("\n[galcore] fail to do dvfm_unregister\n");
     }
 #endif
+
     gckGALDEVICE_Destroy(galDevice);
 
 #if ENABLE_GPU_CLOCK_BY_DRIVER && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
-    gckOS_ClockOff();
+    gckOS_ClockOff(gcvNULL, gcvTRUE, gcvTRUE);
 #endif
 }
 
 #if !USE_PLATFORM_DRIVER
 module_init(drv_init);
 module_exit(drv_exit);
-#else
+#else /* USE_PLATFORM_DRIVER -- start */
 
 #define DEVICE_NAME "galcore"
 
-static int _gpu_off(gckGALDEVICE device)
-{
-	gceSTATUS status;
-
-    printk(">>>>>>[%s]@%d\n",__func__, __LINE__);
-
-#ifdef CONFIG_PXA_DVFM
-    device->needResetAfterD2 = gcvFALSE;
-#endif
-    if(device->kernel->hardware->chipPowerState != gcvPOWER_OFF)
-    {
-        status = gckHARDWARE_SetPowerManagementState(device->kernel->hardware, gcvPOWER_OFF);
-	if (gcmIS_ERROR(status))
-	{
-		return -1;
-	}
-
-        gckOS_SuspendInterrupt(device->os);
-        gckOS_ClockOff();
-    }
-
-    gckOS_UnSetConstraint(device->os, gcvTRUE, gcvTRUE);
-    printk("<<<<<<[%s]@%d\n",__func__, __LINE__);
-	return 0;
-}
-
-static int _gpu_on(gckGALDEVICE device)
-{
-	gceSTATUS status;
-
-    printk(">>>>>>[%s]@%d\n",__func__, __LINE__);
-
-    gckOS_SetConstraint(device->os, gcvTRUE, gcvTRUE);
-
-    if(device->kernel->hardware->chipPowerState != gcvPOWER_ON)
-    {
-        gckOS_ClockOn(0);
-        gckOS_ResumeInterrupt(device->os);
-
-        status = gckHARDWARE_SetPowerManagementState(device->kernel->hardware, gcvPOWER_ON);
-	if (gcmIS_ERROR(status))
-	{
-		return -1;
-	}
-    }
-
-#ifdef CONFIG_PXA_DVFM
-    device->needResetAfterD2 = gcvTRUE;
-#endif
-
-    printk("<<<<<<[%s]@%d\n",__func__, __LINE__);
-	return 0;
-}
-
-#ifdef ANDROID
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
 static void gpu_early_suspend(struct early_suspend *h)
 {
-#if defined CONFIG_CPU_PXA910
-    gceSTATUS   status;
-#endif
-//    printk(">>>>>>>[%s]@%d\n",__func__,__LINE__);
-#if defined CONFIG_PXA_DVFM || defined CONFIG_CPU_MMP2
+    gcmkPRINT("\n");
+    gcmkPRINT("[galcore]: %s, %d\n",__func__, __LINE__);
+
     if(galDevice->printPID)
     {
     }
     else
     {
-        _gpu_off(galDevice);
+#if MRVL_PLATFORM_MMP2
+        if (!cpu_is_mmp2_z0() && !cpu_is_mmp2_z1())
+#endif
+            gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_OFF);
+        BSP_IDLE_PROFILE_CALC_IDLE_TIME;
     }
-#elif defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    {
-        static gctINT count = 0;
-        ++count;
-        printk(">>>[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
 
-        /* Acquire the mutex. */
-        gcmkONERROR(
-            gckOS_AcquireMutex(galDevice->os, galDevice->mutexGCDevice, gcvINFINITE));
+    galDevice->currentPMode = gcvPM_EARLY_SUSPEND;
 
-        if (galDevice->printPID) {
-            printk("|-|-|- Acquired gcdevice mutex...\t%s@%d\n",__func__,__LINE__);
-        }
-
-        _power_off_gc(galDevice, gcvTRUE);
-        galDevice->currentPMode = gcvPM_EARLY_SUSPEND;
-
-        /* Release the mutex. */
-        gcmkVERIFY_OK(
-            gckOS_ReleaseMutex(galDevice->os, galDevice->mutexGCDevice));
-
-        if (galDevice->printPID) {
-            printk("|-|-|- Released gcdevice mutex...\t%s@%d\n",__func__,__LINE__);
-        }
-
-        printk("<<<[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
+    gcmkPRINT("[galcore]: %s, %d\n\n",__func__, __LINE__);
+    gcmkPRINT("\n");
 
-        // useless
-        if(0) _gpu_off(galDevice);
-    }
-#endif
-#endif
-//    printk("<<<<<<<[%s]@%d\n",__func__,__LINE__);
     return;
-
-#if defined CONFIG_CPU_PXA910
-OnError:
-    /* Return the status. */
-    printk("---->ERROR:%s @ %d\n", __func__, __LINE__);
-#endif
 }
+
 static void gpu_late_resume(struct early_suspend *h)
 {
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    gceSTATUS   status;
-    static gctINT count = 0;
-#endif
-#endif
-//    printk(">>>>>>>[%s]@%d\n",__func__,__LINE__);
+    gcmkPRINT("\n");
+    gcmkPRINT("[galcore]: %s, %d\n",__func__, __LINE__);
+
+    galDevice->currentPMode = gcvPM_NORMAL;
 
-#if defined CONFIG_PXA_DVFM || defined CONFIG_CPU_MMP2
     if(galDevice->printPID)
     {
     }
     else
     {
-	    _gpu_on(galDevice);
-    }
-
-#elif defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    ++count;
-    printk("#@@##@@##@@@#\n");
-    printk(">>>[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
-
-    gcmkONERROR(
-        gckOS_AcquireMutex(galDevice->os, galDevice->mutexGCDevice, gcvINFINITE));
-
-    if(galDevice->printPID) {
-        printk("|-|-|- Acquired gcdevice mutex...\t%s@%d\t0x%p\n",__func__,__LINE__,galDevice->mutexGCDevice);
-    }
-
-    galDevice->currentPMode = gcvPM_LATE_RESUME;
-    _power_on_gc(galDevice);
-    galDevice->currentPMode = gcvPM_NORMAL;
-    gcmkVERIFY_OK(
-        gckOS_ReleaseMutex(galDevice->os, galDevice->mutexGCDevice));
-
-    if(galDevice->printPID) {
-        printk("|-|-|- Released gcdevice mutex...\t%s@%d\n",__func__,__LINE__);
+        /* NO need to add the time during early-suspend to idle-time */
+        BSP_IDLE_PROFILE_INIT;
     }
-    printk("<<<[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
-
-    if (0) _gpu_on(galDevice);
-#endif
 
-#endif
+    gcmkPRINT("[galcore]: %s, %d\n\n",__func__, __LINE__);
+    gcmkPRINT("\n");
 
     return;
-#if defined CONFIG_CPU_PXA910
-OnError:
-    /* Return the status. */
-    printk("---->ERROR:%s @ %d\n", __func__, __LINE__);
-#endif
 }
+
 static struct early_suspend gpu_early_suspend_desc = {
     .level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 200,  /*  make sure GC early_suspend after surfaceflinger stop drawing */
 	.suspend = gpu_early_suspend,
 	.resume = gpu_late_resume,
 };
-#endif
+#endif /* MRVL_CONFIG_ENABLE_EARLYSUSPEND -- end */
+
 static int __devinit gpu_probe(struct platform_device *pdev)
 {
 	int ret = -ENODEV;
 	struct resource *res;
 	res = platform_get_resource_byname(pdev, IORESOURCE_IRQ,"gpu_irq");
 	if (!res) {
-		printk(KERN_ERR "%s: No irq line supplied.\n",__FUNCTION__);
+		gcmkPRINT(KERN_ERR "%s: No irq line supplied.\n",__FUNCTION__);
 		goto gpu_probe_fail;
 	}
 	irqLine = res->start;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,"gpu_base");
 	if (!res) {
-		printk(KERN_ERR "%s: No register base supplied.\n",__FUNCTION__);
+		gcmkPRINT(KERN_ERR "%s: No register base supplied.\n",__FUNCTION__);
 		goto gpu_probe_fail;
 	}
 	registerMemBase = res->start;
@@ -1321,7 +1077,7 @@ static int __devinit gpu_probe(struct platform_device *pdev)
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,"gpu_mem");
 	if (!res) {
-		printk(KERN_ERR "%s: No memory base supplied.\n",__FUNCTION__);
+		gcmkPRINT(KERN_ERR "%s: No memory base supplied.\n",__FUNCTION__);
 		goto gpu_probe_fail;
 	}
 	contiguousBase  = res->start;
@@ -1334,14 +1090,14 @@ static int __devinit gpu_probe(struct platform_device *pdev)
     create_gc_proc_file();
 #endif
 
-#ifdef ANDROID
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
     register_early_suspend(&gpu_early_suspend_desc);
 #endif
 		return ret;
 	}
 
 gpu_probe_fail:
-	printk(KERN_INFO "Failed to register gpu driver.\n");
+	gcmkPRINT(KERN_INFO "Failed to register gpu driver.\n");
 	return ret;
 }
 
@@ -1353,7 +1109,7 @@ static int __devinit gpu_remove(struct platform_device *pdev)
     remove_gc_proc_file();
 #endif
 
-#ifdef ANDROID
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
     unregister_early_suspend(&gpu_early_suspend_desc);
 #endif
 	return 0;
@@ -1361,25 +1117,47 @@ static int __devinit gpu_remove(struct platform_device *pdev)
 
 static int __devinit gpu_suspend(struct platform_device *dev, pm_message_t state)
 {
+    gceSTATUS status;
+    gctUINT32 countRetry = 0;
 
-    printk("[galcore]: %s, %d\n",__func__, __LINE__);
+    gcmkPRINT("\n");
+    gcmkPRINT("[galcore]: %s, %d\n",__func__, __LINE__);
 
-#if (defined CONFIG_PXA_DVFM) || (defined CONFIG_CPU_PXA910)
-    return 0;
-#endif
+    while((status = gckHARDWARE_SetPowerManagementState(galDevice->kernel->hardware, gcvPOWER_OFF)) != gcvSTATUS_OK)
+    {
+        countRetry++;
+        if(countRetry > 3)
+        {
+            countRetry = 0;
+            gcmkPRINT("%s, GC is not correctly powered off, abort..\n",__func__);
+            break;
+        }
+    }
+
+    galDevice->currentPMode = gcvPM_SUSPEND;
+
+    gcmkPRINT("[galcore]: %s, %d\n",__func__, __LINE__);
+    gcmkPRINT("\n");
 
-    return _gpu_off(galDevice);
+    return 0;
 }
 
 static int __devinit gpu_resume(struct platform_device *dev)
 {
-    printk("[galcore]: %s, %d\n",__func__, __LINE__);
+    gcmkPRINT("\n");
+    gcmkPRINT("[galcore]: %s, %d",__func__, __LINE__);
 
-#if (defined CONFIG_PXA_DVFM) || (defined CONFIG_CPU_PXA910)
-	return 0;
+
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
+    galDevice->currentPMode = gcvPM_EARLY_SUSPEND;
+#else
+    galDevice->currentPMode = gcvPM_NORMAL;
 #endif
 
-    return _gpu_on(galDevice);
+    gcmkPRINT("[galcore]: %s, %d\n",__func__, __LINE__);
+    gcmkPRINT("\n");
+
+    return 0;
 }
 
 static struct platform_driver gpu_driver = {
@@ -1430,7 +1208,7 @@ static int __init gpu_init(void)
 	gpu_device = platform_device_alloc(DEVICE_NAME, -1);
 	if (!gpu_device)
 	{
-		printk(KERN_ERR "galcore: platform_device_alloc failed.\n");
+		gcmkPRINT(KERN_ERR "galcore: platform_device_alloc failed.\n");
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -1439,7 +1217,7 @@ static int __init gpu_init(void)
 	ret = platform_device_add_resources(gpu_device, gpu_resources, 3);
 	if (ret)
 	{
-		printk(KERN_ERR "galcore: platform_device_add_resources failed.\n");
+		gcmkPRINT(KERN_ERR "galcore: platform_device_add_resources failed.\n");
 		goto put_dev;
 	}
 
@@ -1447,7 +1225,7 @@ static int __init gpu_init(void)
 	ret = platform_device_add(gpu_device);
 	if (ret)
 	{
-		printk(KERN_ERR "galcore: platform_device_add failed.\n");
+		gcmkPRINT(KERN_ERR "galcore: platform_device_add failed.\n");
 		goto del_dev;
 	}
 #endif
@@ -1481,279 +1259,4 @@ static void __exit gpu_exit(void)
 module_init(gpu_init);
 module_exit(gpu_exit);
 
-#endif
-
-#ifdef CONFIG_PXA_DVFM
-#define TRACE   if(galDevice->needD2DebugInfo) \
-                { \
-                    printk("%s,%d\n",__func__,__LINE__); \
-                }
-
-static void gc_off(void)
-{
-    if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_OFF)
-    {
-        gceSTATUS  status;
-	gckCOMMAND command;
-	 /* gctPOINTER buffer; */
-	 /* gctSIZE_T  bytes, requested; */
-
-        command = galDevice->kernel->command;
-         /* galDevice->kernel->notifyIdle = gcvFALSE; */
-
-         /*  stall */
-	{
-            /* Acquire the context switching mutex so nothing else can be
-		** committed. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(galDevice->kernel->hardware->os,
-							   command->mutexContext,
-							   gcvINFINITE));
-
-             /* mdelay(20); */
-	}
-	 /*  stop */
-	{
-
-		/* Stop the command parser. */
-		gcmkONERROR(
-			gckCOMMAND_Stop(command));
-
-		/* Grab the command queue mutex so nothing can get access to the
-		** command queue. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(galDevice->kernel->hardware->os,
-							   command->mutexQueue,
-							   gcvINFINITE));
-	}
-
-        {
-            gckOS_SuspendInterrupt(galDevice->os);
-            gckOS_ClockOff();
-        }
-
-        galDevice->kernel->hardware->chipPowerState = gcvPOWER_OFF;
-
-    }
-    return;
-
-OnError:
-	printk("ERROR: %s has error \n",__func__);
-}
-
-static void gc_on(void)
-{
-    gctUINT32 idle = 0;
-
-    if(galDevice->kernel->hardware->chipPowerState != gcvPOWER_ON)
-    {
-        gceSTATUS  status;
-
-        gckOS_ClockOn(0);
-        gckOS_ResumeInterrupt(galDevice->os);
-
-         /*  INITIALIZE */
-	{
-		/* Initialize hardware. */
-		gcmkONERROR(
-			gckHARDWARE_InitializeHardware(galDevice->kernel->hardware));
-
-		gcmkONERROR(
-			gckHARDWARE_SetFastClear(galDevice->kernel->hardware,
-									 galDevice->kernel->hardware->allowFastClear,
-									 galDevice->kernel->hardware->allowCompression));
-
-		/* Force the command queue to reload the next context. */
-		galDevice->kernel->command->currentContext = 0;
-	}
-
-	/* Sleep for 1ms, to make sure everything is powered on. */
-	mdelay(1); /* gcmkVERIFY_OK(gcoOS_Delay(galDevice->os, 1)); */
-
-	 /*  start */
-	{
-            /* Release the command mutex queue. */
-		gcmkONERROR(
-			gckOS_ReleaseMutex(galDevice->kernel->hardware->os,
-							   galDevice->kernel->command->mutexQueue));
-		/* Start the command processor. */
-		gcmkONERROR(
-			gckCOMMAND_Start(galDevice->kernel->command));
-	}
-	 /*  RELEASE_CONTEXT */
-	{
-		/* Release the context switching mutex. */
-		gcmkVERIFY_OK(
-			gckOS_ReleaseMutex(galDevice->kernel->hardware->os,
-							   galDevice->kernel->command->mutexContext));
-	}
-
-        galDevice->kernel->hardware->chipPowerState = gcvPOWER_ON;
-         /* galDevice->kernel->notifyIdle = gcvTRUE; */
-
-        /* Read idle register. */
-        gcmkVERIFY_OK(gckHARDWARE_GetIdle(galDevice->kernel->hardware, gcvFALSE, &idle));
-
-#if MRVL_LOW_POWER_MODE_DEBUG
-        {
-            int strlen = 0;
-            strlen = sprintf(galDevice->kernel->kernelMSG + galDevice->kernel->msgLen,
-					"after reset, idle register:0x%08X\n",idle);
-            galDevice->kernel->msgLen += strlen;
-        }
-#endif
-        if(galDevice->needD2DebugInfo)
-            printk("after reset, idle register:0x%08X\n",idle);
-    }
-    else
-    {
-#if MRVL_LOW_POWER_MODE_DEBUG
-        {
-            int strlen = 0;
-            strlen = sprintf(galDevice->kernel->kernelMSG + galDevice->kernel->msgLen,
-					"no reset, idle register:0x%08X\n",idle);
-            galDevice->kernel->msgLen += strlen;
-        }
-#endif
-        if(galDevice->needD2DebugInfo)
-            printk("no reset, idle register:0x%08X\n",idle);
-    }
-    return;
-
-OnError:
-	printk("ERROR: %s has error \n",__func__);
-}
-
-static int galcore_dvfm_notifier(struct notifier_block *nb,
-				unsigned long val, void *data)
-{
-    struct dvfm_freqs *freqs = (struct dvfm_freqs *)data;
-	struct op_info *new = NULL;
-    struct op_info *old = NULL;
-	struct dvfm_md_opt *md_old;
-    struct dvfm_md_opt *md_new;
-    int newMode, oldMode;
-
-    static int count = 0;
-    static int countD0CS = 0;
-
-	if (freqs)
-	{
-		new = &freqs->new_info;
-        old = &freqs->old_info;
-	}
-	else
-		return 0;
-
-	md_old = (struct dvfm_md_opt *)old->op;
-    md_new = (struct dvfm_md_opt *)new->op;
-    oldMode = md_old->power_mode;
-    newMode = md_new->power_mode;
-
-    if(galDevice->needResetAfterD2)
-    {
-        /*
-        Any run mode -> D0CS
-        Pre:    Turn off GC clock
-        Post:   Do nothing
-
-        D0CS -> any run mode
-        Pre:    Do nothing
-        Post:   Turn on GC clock and restore state
-
-        D0CS mode -> D1/D2/CG
-        Pre:    Do nothing
-        Post:   Do nothing
-
-        Any run mode (except D0CS) -> D1/D2/CG
-        Pre:    Turn off GC clock
-        Post:   Turn on GC clock and restore state
-        */
-
-        if((oldMode == POWER_MODE_D0) && (newMode == POWER_MODE_D0CS))
-        { /*  Any run mode -> D0CS */
-            if(val == DVFM_FREQ_PRECHANGE)
-            {
-                gc_off();
-            }
-            else if(val == DVFM_FREQ_POSTCHANGE)
-            {
-            }
-        }
-        else if((oldMode == POWER_MODE_D0CS) && (newMode == POWER_MODE_D0))
-        { /*  D0CS -> any run mode */
-            if(val == DVFM_FREQ_PRECHANGE)
-            {
-            }
-            else if(val == DVFM_FREQ_POSTCHANGE)
-            {
-                gc_on();
-                countD0CS++;
-            }
-        }
-        else if((oldMode == POWER_MODE_D0CS)
-            && ((newMode == POWER_MODE_D1)
-                || (newMode == POWER_MODE_D2)
-                || (newMode == POWER_MODE_CG)))
-        { /*  D0CS mode -> D1/D2/CG */
-            if(val == DVFM_FREQ_PRECHANGE)
-            {
-            }
-            else if(val == DVFM_FREQ_POSTCHANGE)
-            {
-            }
-        }
-        else if((oldMode == POWER_MODE_D0)
-            && ((newMode == POWER_MODE_D1)
-                || (newMode == POWER_MODE_D2)
-                || (newMode == POWER_MODE_CG)))
-        { /*  Any run mode (except D0CS) -> D1/D2/CG */
-            if(val == DVFM_FREQ_PRECHANGE)
-            {
-                galDevice->enableMdelay = gcvTRUE;
-                gc_off();
-            }
-            else if(val == DVFM_FREQ_POSTCHANGE)
-            {
-                gc_on();
-                count++;
-                galDevice->enableMdelay = gcvFALSE;
-            }
-        }
-
-        if((oldMode != newMode)&&(val == DVFM_FREQ_POSTCHANGE))
-        {
-#if MRVL_LOW_POWER_MODE_DEBUG
-            {
-                int strlen = 0;
-                strlen = sprintf(galDevice->kernel->kernelMSG + galDevice->kernel->msgLen,
-						"count:%d,countD0CS:%d,power mode %d->%d\n",count,countD0CS,oldMode,newMode);
-                galDevice->kernel->msgLen += strlen;
-            }
-#endif
-            if(galDevice->needD2DebugInfo)
-                printk("[%s@%d]count:%d,countD0CS:%d,power mode %d->%d\n",__func__,__LINE__,count,countD0CS,oldMode,newMode);
-        }
-
-    }
-    else
-    {
-        if((oldMode != newMode)&&(val == DVFM_FREQ_POSTCHANGE))
-        {
-#if 0 /* AXI bus may be off at this point. Remove gckHARDWARE_GetIdle in case of this case */
-            gctUINT32 idle;
-
-            /* Read idle register. */
-		gcmkVERIFY_OK(gckHARDWARE_GetIdle(galDevice->kernel->hardware, gcvFALSE, &idle));
-
-            if(galDevice->needD2DebugInfo)
-                printk("[%s@%d]count:%d,countD0CS:%d,power mode %d->%d\n",__func__, __LINE__,count,countD0CS,oldMode,newMode);
-#endif
-        }
-    }
-	return 0;
-
-}
-
-#endif
-
+#endif /* USE_PLATFORM_DRIVER -- end */
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.c
index a2d732a..41a300c 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -58,7 +58,7 @@ gckKERNEL_QueryVideoMemory(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
-	gcmkVERIFY_ARGUMENT(Interface != NULL);
+	gcmkVERIFY_ARGUMENT(Interface != gcvNULL);
 
 	/* Extract the pointer to the gckGALDEVICE class. */
 	device = (gckGALDEVICE) Kernel->context;
@@ -114,7 +114,7 @@ gckKERNEL_GetVideoMemoryPool(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
-	gcmkVERIFY_ARGUMENT(VideoMemory != NULL);
+	gcmkVERIFY_ARGUMENT(VideoMemory != gcvNULL);
 
     /* Extract the pointer to the gckGALDEVICE class. */
     device = (gckGALDEVICE) Kernel->context;
@@ -139,7 +139,7 @@ gckKERNEL_GetVideoMemoryPool(
 
 	default:
 		/* Unknown pool. */
-		videoMemory = NULL;
+		videoMemory = gcvNULL;
 	}
 
 	/* Return pointer to the gckVIDMEM object. */
@@ -147,7 +147,7 @@ gckKERNEL_GetVideoMemoryPool(
 
 	/* Return status. */
 	gcmkFOOTER_ARG("*VideoMemory=0x%p", *VideoMemory);
-	return (videoMemory == NULL) ? gcvSTATUS_OUT_OF_MEMORY : gcvSTATUS_OK;
+	return (videoMemory == gcvNULL) ? gcvSTATUS_OUT_OF_MEMORY : gcvSTATUS_OK;
 }
 
 /*******************************************************************************
@@ -260,31 +260,31 @@ gckKERNEL_MapVideoMemory(
     gctPOINTER logical;
 
     gcmkHEADER_ARG("Kernel=0x%p InUserSpace=%d Address=%08x",
-			   Kernel, InUserSpace, Address);
+    			   Kernel, InUserSpace, Address);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Kernel, gcvOBJ_KERNEL);
-    gcmkVERIFY_ARGUMENT(Logical != NULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
     /* Extract the pointer to the gckGALDEVICE class. */
     device = (gckGALDEVICE) Kernel->context;
 
     /* Split the memory address into a pool type and offset. */
     gcmkONERROR(
-	gckHARDWARE_SplitMemory(Kernel->hardware, Address, &pool, &offset));
+    	gckHARDWARE_SplitMemory(Kernel->hardware, Address, &pool, &offset));
 
     /* Dispatch on pool. */
     switch (pool)
     {
     case gcvPOOL_LOCAL_INTERNAL:
-	/* Internal memory. */
-	logical = device->internalLogical;
-	break;
+    	/* Internal memory. */
+    	logical = device->internalLogical;
+    	break;
 
     case gcvPOOL_LOCAL_EXTERNAL:
-	/* External memory. */
-	logical = device->externalLogical;
-	break;
+    	/* External memory. */
+    	logical = device->externalLogical;
+    	break;
 
     case gcvPOOL_SYSTEM:
 		/* System memory. */
@@ -298,11 +298,18 @@ gckKERNEL_MapVideoMemory(
 
 			mdlMap = FindMdlMap(mdl, current->tgid);
 			gcmkASSERT(mdlMap);
-
-			logical = (gctPOINTER) mdlMap->vmaAddr;
+            if (mdlMap)
+            {
+			    logical = (gctPOINTER) mdlMap->vmaAddr;
+            }
+            else
+            {
+                /* FindMdlMap Fail, Invalid mdlMap. */
+    	        gcmkONERROR(gcvSTATUS_NOT_FOUND);
+            }
 		}
 
-		gcmkVERIFY_OK(
+		gcmkONERROR(
 			gckHARDWARE_SplitMemory(Kernel->hardware,
 									device->contiguousVidMem->baseAddress,
 									&pool,
@@ -312,8 +319,8 @@ gckKERNEL_MapVideoMemory(
 		break;
 
     default:
-	/* Invalid memory pool. */
-	gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    	/* Invalid memory pool. */
+    	gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
     /* Build logical address of specified address. */
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.h
index 15246ce..d4c80ca 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_linux.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -40,9 +40,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/kthread.h>
 
-#ifdef ANDROID
-#include <linux/earlysuspend.h>
-#endif
 #ifdef MODVERSIONS
 #  include <linux/modversions.h>
 #endif
@@ -53,6 +50,11 @@
 
 #define NTSTRSAFE_NO_CCH_FUNCTIONS
 #include "gc_hal.h"
+
+#if MRVL_CONFIG_ENABLE_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
 #include "gc_hal_driver.h"
 #include "gc_hal_kernel.h"
 #include "gc_hal_kernel_device.h"
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c
index 9718a19..f7be762 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -23,6 +23,7 @@
 
 #include "gc_hal_kernel_linux.h"
 
+#include <linux/random.h>
 #include <linux/pagemap.h>
 #include <linux/seq_file.h>
 #include <linux/mm.h>
@@ -30,24 +31,28 @@
 #include <linux/sched.h>
 #include <asm/atomic.h>
 #include <stdarg.h>
+
 #ifdef NO_DMA_COHERENT
 #include <linux/dma-mapping.h>
 #endif /* NO_DMA_COHERENT */
-
-#if defined CONFIG_PXA_DVFM || defined CONFIG_CPU_MMP2
+#include <linux/slab.h>
+#include <linux/delay.h>
+#if MRVL_CONFIG_ENABLE_DVFM
 #include <mach/dvfm.h>
 #include <mach/hardware.h>
-#include <linux/delay.h>
-#ifdef CONFIG_PXA_DVFM
+/* MG1 dot32 kernel: gc_pwr function defined in pxa3xx_pm.h */
+#if MRVL_CONFIG_DVFM_MG1 && (defined CONFIG_PXA3xx_DVFM)
 #include <mach/pxa3xx_dvfm.h>
 #endif
 #endif
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-extern gckGALDEVICE galDevice;
-extern gceSTATUS _power_on_gc(gckGALDEVICE device);
-extern gceSTATUS _power_off_gc(gckGALDEVICE device, gctBOOL early_suspend);
+/* MG1/TD dot 35 kernel move gc_pwr define to mach/pxaXXX_pm.h */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+#if MRVL_PLATFORM_MG1
+#include <mach/pxa95x_pm.h>
+#endif
+#if MRVL_PLATFORM_TD
+#include <mach/pxa910_pm.h>
 #endif
 #endif
 
@@ -79,19 +84,18 @@ extern gceSTATUS _power_off_gc(gckGALDEVICE device, gctBOOL early_suspend);
     if (IS_ERR(clock)) \
     { \
         int retval = PTR_ERR(clock); \
-        printk("clk get error: %d\t@LINE:%d\n", retval, __LINE__); \
+        gcmkPRINT("clk get error: %d\t@LINE:%d\n", retval, __LINE__); \
         return retval; \
     }
 
-
 static void _Print(
-	char *Message,
+	const char *Message,
 	va_list Arguments
 	)
 {
 	char buffer[1000];
 	int n;
-
+	
 	/* Print message to buffer. */
 	n = vsnprintf(buffer, sizeof(buffer), Message, Arguments);
 	if ((n <= 0) || (buffer[n - 1] != '\n'))
@@ -100,7 +104,7 @@ static void _Print(
 		strncat(buffer, "\n", sizeof(buffer));
 	}
 
-	/* Output to debugger. */
+	/* Output to debugger. */	
 	printk(buffer);
 }
 
@@ -121,10 +125,14 @@ static void _Print(
 #if MRVL_ENABLE_API_LOG
 static gctUINT32 g_logFilter = _GFX_LOG_ALL_;
 #else
-static gctUINT32 g_logFilter = _GFX_LOG_ERROR_ | _GFX_LOG_WARNING_ | _GFX_LOG_NOTIFY_;
+#   if MRVL_ENABLE_ERROR_LOG
+    static gctUINT32 g_logFilter = _GFX_LOG_ERROR_ | _GFX_LOG_WARNING_ | _GFX_LOG_NOTIFY_;
+#   else
+    static gctUINT32 g_logFilter = _GFX_LOG_NONE_;
+#   endif
 #endif
 
-void gckOS_Log(IN unsigned int filter, IN char* msg,
+void gckOS_Log(IN unsigned int filter, IN const char* msg,
 			...
 			)
 {
@@ -136,7 +144,7 @@ void gckOS_Log(IN unsigned int filter, IN char* msg,
 
 void gckOS_SetLogFilter(IN unsigned int filter)
 {
-    g_logFilter = filter;
+    g_logFilter = filter;    
 }
 
 /********************************** Structures **********************************
@@ -162,25 +170,31 @@ struct _gckOS
 
 	gctUINT32					baseAddress;
 
+    /* Kernel process ID. */
+    gctUINT32                   kernelProcessID;
+
 #if !USE_NEW_LINUX_SIGNAL
 	/* Signal management. */
 	struct _signal {
 		/* Unused signal ID number. */
-		gctINT unused;
+        gctINT                  unused;
 
-		/* The pointer to the table. */
-		gctPOINTER * table;
+        /* The pointer to the table. */
+        gctPOINTER *            table;
 
-		/* Signal table length. */
-		gctINT tableLen;
+        /* Signal table length. */
+        gctINT                  tableLen;
 
-		/* The current unused signal ID. */
-		gctINT currentID;
+        /* The current unused signal ID. */
+        gctINT                  currentID;
 
-		/* Lock. */
-		gctPOINTER lock;
+        /* Lock. */
+        gctPOINTER              lock;
 	} signal;
 #endif
+
+    /* idle profiling mutex. */
+    gctPOINTER                  mutexIdleProfile;
 };
 
 #if !USE_NEW_LINUX_SIGNAL
@@ -195,6 +209,9 @@ typedef struct _gcsSIGNAL
 	/* The reference counter. */
 	atomic_t ref;
 
+	/* The signal type */
+	gceSIGNAL_TYPE signalType;
+
 	/* The owner of the signal. */
 	gctHANDLE process;
 }
@@ -220,12 +237,29 @@ _CreateMdl(
 	PLINUX_MDL	mdl;
 
     mdl = (PLINUX_MDL)kmalloc(sizeof(struct _LINUX_MDL), GFP_ATOMIC);
-	if (mdl == gcvNULL) return gcvNULL;
+    if (mdl == gcvNULL)
+    {
+        gcmkLOG_WARNING_ARGS("out of memory to create Mdl");
+        return gcvNULL;
+    }
+
+	mdl->pid	    = PID;
+	mdl->maps	    = gcvNULL;
+	mdl->prev	    = gcvNULL;
+	mdl->next	    = gcvNULL;
+
+	mdl->addr       = gcvNULL;
+
+#ifdef NO_DMA_COHERENT
+#if !ALLOC_HIGHMEM
+	mdl->kaddr      = gcvNULL;
+#endif
+#endif
 
-	mdl->pid	= PID;
-	mdl->maps	= gcvNULL;
-	mdl->prev	= gcvNULL;
-	mdl->next	= gcvNULL;
+	mdl->numPages   = 0;
+	mdl->pagedMem   = 0;
+	mdl->contiguous = gcvTRUE;
+	mdl->dmaHandle  = GC_INVALID_PHYS_ADDR;
 
 	return mdl;
 }
@@ -241,7 +275,7 @@ _DestroyMdl(
 	IN PLINUX_MDL Mdl
 	)
 {
-	PLINUX_MDL_MAP mdlMap;
+    PLINUX_MDL_MAP mdlMap, next;
 
 	/* Verify the arguments. */
 	gcmkVERIFY_ARGUMENT(Mdl != gcvNULL);
@@ -250,12 +284,15 @@ _DestroyMdl(
 
 	while (mdlMap != gcvNULL)
 	{
+        next = mdlMap->next;
+
 		gcmkVERIFY_OK(_DestroyMdlMap(Mdl, mdlMap));
 
-		mdlMap = Mdl->maps;
+        mdlMap = next;
 	}
 
 	kfree(Mdl);
+    Mdl = gcvNULL;
 
 	return gcvSTATUS_OK;
 }
@@ -269,7 +306,11 @@ _CreateMdlMap(
 	PLINUX_MDL_MAP	mdlMap;
 
     mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_ATOMIC);
-	if (mdlMap == gcvNULL) return gcvNULL;
+    if (mdlMap == gcvNULL)
+    {
+        gcmkLOG_WARNING_ARGS("out of memory to create MdlMap");
+        return gcvNULL;
+    }
 
 	mdlMap->pid		= PID;
 	mdlMap->vmaAddr	= gcvNULL;
@@ -408,7 +449,7 @@ PrintInfoOnExit(
 			nextMdl = gcvNULL;
 		}
 
-		printk("Unfreed mdl: %p, pid: %d -> pagedMem: %s, addr: %p, dmaHandle: 0x%x, pages: %d",
+		gcmkPRINT("Unfreed mdl: %p, pid: %d -> pagedMem: %s, addr: %p, dmaHandle: 0x%x, pages: %d",
 			mdl,
 			mdl->pid,
 			mdl->pagedMem? "true" : "false",
@@ -420,7 +461,7 @@ PrintInfoOnExit(
 
 		while (mdlMap != gcvNULL)
 		{
-			printk("\tmap: %p, pid: %d -> vmaAddr: %p, vma: %p",
+			gcmkPRINT("\tmap: %p, pid: %d -> vmaAddr: %p, vma: %p",
 					mdlMap,
 					mdlMap->pid,
 					mdlMap->vmaAddr,
@@ -464,7 +505,8 @@ OnProcessExit(
 **		gckOS * Os
 **			Pointer to a variable that will hold the pointer to the gckOS object.
 */
-gceSTATUS gckOS_Construct(
+gceSTATUS
+gckOS_Construct(
 	IN gctPOINTER Context,
 	OUT gckOS * Os
 	)
@@ -485,7 +527,7 @@ gceSTATUS gckOS_Construct(
 	}
 
 	/* Zero the memory. */
-	memset(os, 0, gcmSIZEOF(struct _gckOS));
+    gckOS_ZeroMemory(os, gcmSIZEOF(struct _gckOS));
 
 	/* Initialize the gckOS object. */
 	os->object.type = gcvOBJ_OS;
@@ -497,15 +539,12 @@ gceSTATUS gckOS_Construct(
 	os->heap = gcvNULL;
 
 	/* Initialize the memory lock. */
-	gcmkONERROR(
-		gckOS_CreateMutex(os, &os->memoryLock));
+    gcmkONERROR(gckOS_CreateMutex(os, &os->memoryLock));
 
-	gcmkONERROR(
-		gckOS_CreateMutex(os, &os->memoryMapLock));
+    gcmkONERROR(gckOS_CreateMutex(os, &os->memoryMapLock));
 
 	/* Create the gckHEAP object. */
-    gcmkONERROR(
-		gckHEAP_Construct(os, gcdHEAP_SIZE, &os->heap));
+    gcmkONERROR(gckHEAP_Construct(os, gcdHEAP_SIZE, &os->heap));
 
 	os->mdlHead = os->mdlTail = gcvNULL;
 
@@ -516,6 +555,9 @@ gceSTATUS gckOS_Construct(
 				  "Physical base address set to 0x%08X.",
 				  os->baseAddress);
 
+    /* Get the kernel process ID. */
+    gcmkONERROR(gckOS_GetProcessID(&os->kernelProcessID));
+
 #if !USE_NEW_LINUX_SIGNAL
 	/*
 	 * Initialize the signal manager.
@@ -538,9 +580,8 @@ gceSTATUS gckOS_Construct(
 		goto OnError;
 	}
 
-	memset(os->signal.table,
-		   0,
-		   gcmSIZEOF(gctPOINTER) * USER_SIGNAL_TABLE_LEN_INIT);
+    gckOS_ZeroMemory(os->signal.table,
+                     gcmSIZEOF(gctPOINTER) * USER_SIGNAL_TABLE_LEN_INIT);
 
 	/* Set the signal table length. */
 	os->signal.tableLen = USER_SIGNAL_TABLE_LEN_INIT;
@@ -552,6 +593,9 @@ gceSTATUS gckOS_Construct(
 	os->signal.currentID = 0;
 #endif
 
+	gcmkONERROR(
+		gckOS_CreateMutex(os, &os->mutexIdleProfile));
+
 	/* Return pointer to the gckOS object. */
 	*Os = os;
 
@@ -559,17 +603,26 @@ gceSTATUS gckOS_Construct(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
+    if (os->mutexIdleProfile != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(os, os->mutexIdleProfile));
+	}
+   
 #if !USE_NEW_LINUX_SIGNAL
 	/* Roll back any allocation. */
 	if (os->signal.table != gcvNULL)
 	{
 		kfree(os->signal.table);
+        os->signal.table = gcvNULL;
 	}
 
 	if (os->signal.lock != gcvNULL)
 	{
 		gcmkVERIFY_OK(
 			gckOS_DeleteMutex(os, os->signal.lock));
+        os->signal.lock = gcvNULL;
 	}
 #endif
 
@@ -577,22 +630,27 @@ OnError:
 	{
 		gcmkVERIFY_OK(
 			gckHEAP_Destroy(os->heap));
+        os->heap = gcvNULL;
 	}
 
 	if (os->memoryMapLock != gcvNULL)
 	{
 		gcmkVERIFY_OK(
 			gckOS_DeleteMutex(os, os->memoryMapLock));
+        os->memoryMapLock = gcvNULL;
 	}
 
 	if (os->memoryLock != gcvNULL)
 	{
 		gcmkVERIFY_OK(
 			gckOS_DeleteMutex(os, os->memoryLock));
+        os->memoryLock = gcvNULL;
 	}
 
 	kfree(os);
 
+    os = gcvNULL;
+
 	/* Return the error. */
 	return status;
 }
@@ -617,29 +675,50 @@ gckOS_Destroy(
 	IN gckOS Os
 	)
 {
-	gckHEAP heap;
-
+	gckHEAP     heap    = gcvNULL;
+    gctINT      i       = 0;
+    gctPOINTER *table   = Os->signal.table;   
+    
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
+    if (Os->mutexIdleProfile != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(Os, Os->mutexIdleProfile));
+        Os->mutexIdleProfile = gcvNULL;
+	}  
+    
 #if !USE_NEW_LINUX_SIGNAL
-	/*
-	 * Destroy the signal manager.
-	 */
-
 	/* Destroy the mutex. */
-	gcmkVERIFY_OK(
-		gckOS_DeleteMutex(Os, Os->signal.lock));
-
+    if(Os->signal.lock != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->signal.lock));
+        Os->signal.lock = gcvNULL;
+    }
+    
+    /* Free remain signal left in table */
+    for (i = 0; i < Os->signal.tableLen; i++)
+    {
+        if(table[i] != gcvNULL)
+        {
+            kfree(table[i]);
+            table[i] = gcvNULL;
+        }
+    }
+    
 	/* Free the signal table. */
 	kfree(Os->signal.table);
+    Os->signal.table    = gcvNULL;
+    Os->signal.tableLen = 0;
 #endif
 
-	if (Os->heap != NULL)
+	if (Os->heap != gcvNULL)
 	{
 		/* Mark gckHEAP as gone. */
 		heap     = Os->heap;
-		Os->heap = NULL;
+		Os->heap = gcvNULL;
 
 		/* Destroy the gckHEAP object. */
 		gcmkVERIFY_OK(
@@ -647,12 +726,20 @@ gckOS_Destroy(
 	}
 
 	/* Destroy the memory lock. */
-	gcmkVERIFY_OK(
-		gckOS_DeleteMutex(Os, Os->memoryMapLock));
-
-	gcmkVERIFY_OK(
-		gckOS_DeleteMutex(Os, Os->memoryLock));
+    if(Os->memoryMapLock != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->memoryMapLock));
+        Os->memoryMapLock = gcvNULL;
+    }
 
+    if(Os->memoryLock != gcvNULL)
+    {	
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->memoryLock));
+        Os->memoryLock = gcvNULL;
+    }
+    
 	gcmkPRINT("$$FLUSH$$");
 
 	/* Mark the gckOS object as unknown. */
@@ -660,11 +747,40 @@ gckOS_Destroy(
 
 	/* Free the gckOS object. */
 	kfree(Os);
+    Os = gcvNULL;
 
 	/* Success. */
 	return gcvSTATUS_OK;
 }
 
+/* the first numbers must success, because we need make sure surfaceFlinger start*/
+#define MUST_SUCCESS_THREASHOLD   30     
+
+static unsigned int cntMalloc = 0;
+static unsigned int failMalloc = 0;
+
+gctBOOL gckOS_ForceMemAllocFail(gckOS Os)
+{
+    unsigned int value = 0;
+
+    if(Os->device->memRandomFailRate == 0)
+        return gcvFALSE;
+    
+	get_random_bytes(&value, sizeof(unsigned int));
+
+    cntMalloc ++;
+    
+    if((value & 32767) < (gctUINT32)(Os->device->memRandomFailRate*327) && cntMalloc > MUST_SUCCESS_THREASHOLD)
+    {
+        failMalloc++;
+        gcmkPRINT("@@@@@@@@@@@@@@ total mem Malloc count: %d, fail Malloc count %d", cntMalloc, failMalloc);
+        return gcvTRUE;
+    }
+    else
+    {   
+        return gcvFALSE;
+    }
+}
 /*******************************************************************************
 **
 **	gckOS_Allocate
@@ -698,17 +814,17 @@ gckOS_Allocate(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Memory != NULL);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
 
     /* Do we have a heap? */
-    if (Os->heap != NULL)
+    if (Os->heap != gcvNULL)
     {
         /* Allocate from the heap. */
         gcmkONERROR(gckHEAP_Allocate(Os->heap, Bytes, Memory));
     }
     else
     {
-	gcmkONERROR(gckOS_AllocateMemory(Os, Bytes, Memory));
+    	gcmkONERROR(gckOS_AllocateMemory(Os, Bytes, Memory));
     }
 
     /* Success. */
@@ -716,6 +832,7 @@ gckOS_Allocate(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -749,12 +866,12 @@ gckOS_Free(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Memory != NULL);
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
 
 	 /* gcmkHEADER_ARG("Os=0x%x Memory=0x%x", Os, memory); */
 
 	/* Do we have a heap? */
-	if (Os->heap != NULL)
+	if (Os->heap != gcvNULL)
 	{
 		/* Free from the heap. */
 		gcmkONERROR(gckHEAP_Free(Os->heap, Memory));
@@ -769,6 +886,7 @@ gckOS_Free(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -804,11 +922,11 @@ gckOS_AllocateMemory(
 
     /* Verify the arguments. */
     gcmkVERIFY_ARGUMENT(Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Memory != NULL);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
 
     memory = (gctPOINTER) kmalloc(Bytes, GFP_ATOMIC);
 
-    if (memory == NULL)
+    if (memory == gcvNULL)
     {
         /* Out of memory. */
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
@@ -822,8 +940,11 @@ gckOS_AllocateMemory(
     return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_STATUS();
 	/* Return the status. */
 	gcmkFOOTER();
+
+    *Memory = gcvNULL;
 	return status;
 }
 
@@ -851,10 +972,11 @@ gckOS_FreeMemory(
 	gcmkHEADER_ARG("Memory=0x%p", Memory);
 
 	/* Verify the arguments. */
-	gcmkVERIFY_ARGUMENT(Memory != NULL);
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
 
 	/* Free the memory from the OS pool. */
 	kfree(Memory);
+    Memory = gcvNULL;
 
 	/* Success. */
 	gcmkFOOTER_NO();
@@ -884,7 +1006,8 @@ gckOS_FreeMemory(
 **			Pointer to a variable that will hold the logical address of the
 **			mapped memory.
 */
-gceSTATUS gckOS_MapMemory(
+gceSTATUS
+gckOS_MapMemory(
 	IN gckOS Os,
 	IN gctPHYS_ADDR Physical,
 	IN gctSIZE_T Bytes,
@@ -898,9 +1021,15 @@ gceSTATUS gckOS_MapMemory(
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
     gcmkVERIFY_ARGUMENT(Physical != 0);
     gcmkVERIFY_ARGUMENT(Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Logical != NULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
-	MEMORY_LOCK(Os);
+    if(((unsigned int)mdl->addr) & (ALLOC_ALIGN_BYTES -1 ))
+    {
+        gcmkPRINT("gckOS_MapMemory: physical address is %x, cannot satisfy alignment request! \n", (unsigned int)Physical);
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    MEMORY_LOCK(Os);
 
 	mdlMap = FindMdlMap(mdl, current->tgid);
 
@@ -918,17 +1047,20 @@ gceSTATUS gckOS_MapMemory(
 
 	if (mdlMap->vmaAddr == gcvNULL)
 	{
+	    unsigned long ret = 0;
 		down_write(&current->mm->mmap_sem);
 
-		mdlMap->vmaAddr = (char *)do_mmap_pgoff(NULL,
+		ret = do_mmap_pgoff(gcvNULL,
 					0L,
 					mdl->numPages * PAGE_SIZE,
 					PROT_READ | PROT_WRITE,
 					MAP_SHARED,
 					0);
-
-		if (mdlMap->vmaAddr == gcvNULL)
+        
+		if (IS_ERR_VALUE(ret))
 		{
+            gcmkLOG_WARNING_ARGS("do_mmap_pgoff failure!");
+
 			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 				gcvZONE_OS,
 				"gckOS_MapMemory: do_mmap error");
@@ -947,11 +1079,16 @@ gceSTATUS gckOS_MapMemory(
 
 			return gcvSTATUS_OUT_OF_MEMORY;
 		}
+        else
+        {
+            mdlMap->vmaAddr = (char *)ret;
+        }
 
 		mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
 		if (!mdlMap->vma)
 		{
+            gcmkLOG_WARNING_ARGS("can't find vma: 0x%08x", (unsigned long)mdlMap->vmaAddr);
 			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 					gcvZONE_OS,
 					"gckOS_MapMemory: find_vma error.");
@@ -966,12 +1103,13 @@ gceSTATUS gckOS_MapMemory(
 		}
 
 #ifndef NO_DMA_COHERENT
-		if (dma_mmap_coherent(NULL,
+		if (dma_mmap_coherent(gcvNULL,
 					mdlMap->vma,
 					mdl->addr,
 					mdl->dmaHandle,
 					mdl->numPages * PAGE_SIZE) < 0)
 		{
+            gcmkLOG_WARNING_ARGS("dma_mmap_coherent failure");
 			up_write(&current->mm->mmap_sem);
 
 			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
@@ -992,10 +1130,11 @@ gceSTATUS gckOS_MapMemory(
 		if (remap_pfn_range(mdlMap->vma,
 							mdlMap->vma->vm_start,
 							mdl->dmaHandle >> PAGE_SHIFT,
-			        mdl->numPages*PAGE_SIZE,
-			    mdlMap->vma->vm_page_prot) < 0)
+                	        mdl->numPages*PAGE_SIZE,
+                    	    mdlMap->vma->vm_page_prot) < 0)
 		{
-	    up_write(&current->mm->mmap_sem);
+            gcmkLOG_WARNING_ARGS("remap_pfn_range failure");
+    	    up_write(&current->mm->mmap_sem);
 
 			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 					gcvZONE_OS,
@@ -1017,8 +1156,8 @@ gceSTATUS gckOS_MapMemory(
     *Logical = mdlMap->vmaAddr;
 
 	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_OS,
-			"gckOS_MapMemory: User Mapped address for 0x%x is 0x%x pid->%d",
-			(gctUINT32)mdl->addr,
+    			"gckOS_MapMemory: User Mapped address for 0x%x is 0x%x pid->%d",
+           		(gctUINT32)mdl->addr,
 				(gctUINT32)*Logical,
 				mdlMap->pid);
 
@@ -1049,7 +1188,8 @@ gceSTATUS gckOS_MapMemory(
 **
 **		Nothing.
 */
-gceSTATUS gckOS_UnmapMemory(
+gceSTATUS
+gckOS_UnmapMemory(
 	IN gckOS Os,
 	IN gctPHYS_ADDR Physical,
 	IN gctSIZE_T Bytes,
@@ -1064,7 +1204,7 @@ gceSTATUS gckOS_UnmapMemory(
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 	gcmkVERIFY_ARGUMENT(Physical != 0);
 	gcmkVERIFY_ARGUMENT(Bytes > 0);
-	gcmkVERIFY_ARGUMENT(Logical != NULL);
+	gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
@@ -1101,14 +1241,23 @@ gceSTATUS gckOS_UnmapMemory(
         if (task != gcvNULL && task->mm != gcvNULL)
 		{
 			down_write(&task->mm->mmap_sem);
-			do_munmap(task->mm, (unsigned long)Logical, mdl->numPages*PAGE_SIZE);
-			up_write(&task->mm->mmap_sem);
+			if(do_munmap(task->mm, 
+                         (unsigned long)Logical, 
+                         mdl->numPages*PAGE_SIZE) < 0)
+            {
+                gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    				gcvZONE_OS,
+            		"Can't unmap the address %x",
+    				(unsigned long)Logical);
+            }			
+
+            up_write(&task->mm->mmap_sem);
         }
         else
 		{
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 						gcvZONE_OS,
-				"Can't find the task with pid->%d. No unmapping",
+            			"Can't find the task with pid->%d. No unmapping",
 						mdlMap->pid);
         }
 
@@ -1151,7 +1300,8 @@ gceSTATUS gckOS_UnmapMemory(
 **			Pointer to a variable that will hold the logical address of the
 **			allocation.
 */
-gceSTATUS gckOS_AllocateNonPagedMemory(
+gceSTATUS
+gckOS_AllocateNonPagedMemory(
 	IN gckOS Os,
 	IN gctBOOL InUserSpace,
 	IN OUT gctSIZE_T * Bytes,
@@ -1161,25 +1311,29 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
 {
     gctSIZE_T		bytes;
     gctINT			numPages;
-    PLINUX_MDL		mdl;
-	PLINUX_MDL_MAP	mdlMap = 0;
-	gctSTRING		addr;
+    gctBOOL         reservepage = gcvFALSE;
+    PLINUX_MDL		mdl     = gcvNULL;
+	PLINUX_MDL_MAP	mdlMap  = gcvNULL;
+	gctSTRING		addr    = gcvNULL;
+    gceSTATUS       status  = gcvSTATUS_OK;
 
 #ifdef NO_DMA_COHERENT
-	struct page *	page;
-    long			size, order;
-	gctPOINTER		vaddr;
+	struct page *	page    = gcvNULL;
+    long			size    = PAGE_SIZE, order;
+	gctPOINTER		vaddr   = gcvNULL;
 #endif
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT((Bytes != NULL) && (*Bytes > 0));
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
-    gcmkVERIFY_ARGUMENT(Logical != NULL);
+    gcmkVERIFY_ARGUMENT((Bytes != gcvNULL) && (*Bytes > 0));
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
 				"in gckOS_AllocateNonPagedMemory");
+    if(gckOS_ForceMemAllocFail(Os))
+        return gcvSTATUS_OUT_OF_MEMORY;
 
     /* Align number of bytes to page size. */
     bytes = gcmALIGN(*Bytes, PAGE_SIZE);
@@ -1187,64 +1341,91 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
     /* Get total number of pages.. */
     numPages = GetPageCount(bytes, 0);
 
+	MEMORY_LOCK(Os);
+
     /* Allocate mdl+vector structure */
     mdl = _CreateMdl(current->tgid);
 
 	if (mdl == gcvNULL)
 	{
-		return gcvSTATUS_OUT_OF_MEMORY;
+	    gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
 	}
 
 	mdl->pagedMem = 0;
     mdl->numPages = numPages;
 
-	MEMORY_LOCK(Os);
-
 #ifndef NO_DMA_COHERENT
-    addr = dma_alloc_coherent(NULL,
+    addr = dma_alloc_coherent(gcvNULL,
 				mdl->numPages * PAGE_SIZE,
 				&mdl->dmaHandle,
 				GFP_ATOMIC);
 #else
 	size	= mdl->numPages * PAGE_SIZE;
 	order	= get_order(size);
-	page	= alloc_pages(GFP_KERNEL | GFP_DMA, order);
+
+#if ALLOC_HIGHMEM
+	page	= alloc_pages(GFP_KERNEL | __GFP_HIGHMEM, order);
+#else
+    page    = alloc_pages(GFP_KERNEL | GFP_DMA, order);
+#endif
 
 	if (page == gcvNULL)
 	{
-		MEMORY_UNLOCK(Os);
+        gcmkLOG_WARNING_ARGS("Out of memory to alloc pages!");
 
-		return gcvSTATUS_OUT_OF_MEMORY;
+		gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
 	}
+
 	vaddr			= (gctPOINTER)page_address(page);
+    
+#if ALLOC_HIGHMEM
+    addr			= ioremap_nocache(page_to_pfn(page) << PAGE_SHIFT, size);
+	mdl->dmaHandle	= page_to_pfn(page) << PAGE_SHIFT;
+#else
 	addr			= ioremap_nocache(virt_to_phys(vaddr), size);
 	mdl->dmaHandle	= virt_to_phys(vaddr);
-	mdl->kaddr		= vaddr;
+
+    mdl->kaddr      = vaddr;
+#endif
+
 #if ENABLE_ARM_L2_CACHE
-//	dma_cache_maint(vaddr, size, DMA_FROM_DEVICE);
+    if (vaddr)
+    {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+		dma_sync_single_for_cpu(gcvNULL, virt_to_phys(vaddr), size, DMA_FROM_DEVICE);
+#else
+		dma_cache_maint(vaddr, size, DMA_FROM_DEVICE);
+#endif
+    }
 #endif
 
+    if(size > 0)
+    {
+        reservepage = gcvTRUE;
+    }
+
 	while (size > 0)
 	{
+#if ALLOC_HIGHMEM
+		SetPageReserved(page);
+		page ++;
+#else
 		SetPageReserved(virt_to_page(vaddr));
-
 		vaddr	+= PAGE_SIZE;
+#endif
 		size	-= PAGE_SIZE;
 	}
 #endif
 
     if (addr == gcvNULL)
 	{
+        gcmkLOG_WARNING_ARGS("ioremap_nocache failure of allocating memory -> 0x%08x", (gctUINT32)bytes);
 		gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
-			"galcore: Can't allocate memorry for size->0x%x",
+       			"galcore: Can't allocate memorry for size->0x%x",
 				(gctUINT32)bytes);
 
-        gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-		MEMORY_UNLOCK(Os);
-
-        return gcvSTATUS_OUT_OF_MEMORY;
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
 	if ((Os->baseAddress & 0x80000000) != (mdl->dmaHandle & 0x80000000))
@@ -1267,15 +1448,12 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
 
     if (InUserSpace)
     {
+        unsigned long ret = 0;
 		mdlMap = _CreateMdlMap(mdl, current->tgid);
 
 		if (mdlMap == gcvNULL)
 		{
-			gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-			MEMORY_UNLOCK(Os);
-
-			return gcvSTATUS_OUT_OF_MEMORY;
+			gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
 		}
 
         /* Only after mmap this will be valid. */
@@ -1283,66 +1461,58 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
         /* We need to map this to user space. */
         down_write(&current->mm->mmap_sem);
 
-        mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
+        ret = do_mmap_pgoff(gcvNULL,
 				0L,
 				mdl->numPages * PAGE_SIZE,
 				PROT_READ | PROT_WRITE,
 				MAP_SHARED,
 				0);
 
-        if (mdlMap->vmaAddr == gcvNULL)
+        if (IS_ERR_VALUE(ret))
         {
+            gcmkLOG_WARNING_ARGS("do_mmap_pgoff failure!");
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
 				"galcore: do_mmap error");
 
 			up_write(&current->mm->mmap_sem);
 
-			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
-			gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-			MEMORY_UNLOCK(Os);
-
-			return gcvSTATUS_OUT_OF_MEMORY;
+			gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+        else
+        {
+            mdlMap->vmaAddr = (gctSTRING)ret;
         }
 
         mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
 		if (mdlMap->vma == gcvNULL)
 		{
+            gcmkLOG_WARNING_ARGS("can't find vma: 0x%08x", (unsigned long)mdlMap->vmaAddr);
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
 				"find_vma error");
 
 			up_write(&current->mm->mmap_sem);
 
-			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
-			gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-			MEMORY_UNLOCK(Os);
-
-			return gcvSTATUS_OUT_OF_RESOURCES;
+			gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
 		}
 
 #ifndef NO_DMA_COHERENT
-        if (dma_mmap_coherent(NULL,
+        if (dma_mmap_coherent(gcvNULL,
 				mdlMap->vma,
 				mdl->addr,
 				mdl->dmaHandle,
 				mdl->numPages * PAGE_SIZE) < 0)
 		{
+            gcmkLOG_WARNING_ARGS("dma_mmap_coherent failure");
 			up_write(&current->mm->mmap_sem);
 
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
 				"dma_mmap_coherent error");
 
-			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
-			gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-			MEMORY_UNLOCK(Os);
-
-			return gcvSTATUS_OUT_OF_RESOURCES;
+			gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
 		}
 #else
 		mdlMap->vma->vm_page_prot = pgprot_noncached(mdlMap->vma->vm_page_prot);
@@ -1355,18 +1525,14 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
 							mdl->numPages * PAGE_SIZE,
 							mdlMap->vma->vm_page_prot))
 		{
+            gcmkLOG_WARNING_ARGS("remap_pfn_range failure");
 			up_write(&current->mm->mmap_sem);
 
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 					gcvZONE_OS,
 					"remap_pfn_range error");
 
-			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
-			gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-			MEMORY_UNLOCK(Os);
-
-			return gcvSTATUS_OUT_OF_RESOURCES;
+			gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
 		}
 #endif /* NO_DMA_COHERENT */
 
@@ -1398,13 +1564,22 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
         Os->mdlTail = mdl;
     }
 
+	/* Update contiguous or virtual memory usage. */
+	if (mdl)
+	{
+		if (mdl->contiguous)
+			Os->device->contiguousMemUsage += bytes;
+		else
+			Os->device->virtualMemUsage += bytes;
+	}
+
 	MEMORY_UNLOCK(Os);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
-			"gckOS_AllocateNonPagedMemory: "
+    			"gckOS_AllocateNonPagedMemory: "
 				"Bytes->0x%x, Mdl->%p, Logical->0x%x dmaHandle->0x%x",
-			(gctUINT32)bytes,
+           		(gctUINT32)bytes,
 				mdl,
 				(gctUINT32)mdl->addr,
 				mdl->dmaHandle);
@@ -1415,11 +1590,103 @@ gceSTATUS gckOS_AllocateNonPagedMemory(
 				gcvZONE_OS,
 				"vmaAddr->0x%x pid->%d",
 				(gctUINT32)mdlMap->vmaAddr,
-				mdlMap->pid);
+ 				mdlMap->pid);
 	}
 
-    /* Success. */
     return gcvSTATUS_OK;
+    
+OnError:
+    gcmkLOG_ERROR_STATUS();
+
+    if(mdl)
+    {
+#ifndef NO_DMA_COHERENT
+        dma_free_coherent(gcvNULL,
+            mdl->numPages * PAGE_SIZE,
+            mdl->addr,
+            mdl->dmaHandle);
+#else
+
+        /* Clear the page reserve flag */
+        if(reservepage)
+        {
+            size = mdl->numPages * PAGE_SIZE;
+            while (size > 0)
+        	{
+#if ALLOC_HIGHMEM
+            	ClearPageReserved(page);
+        		page ++;
+#else
+        		ClearPageReserved(virt_to_page(vaddr));
+        		vaddr	+= PAGE_SIZE;
+#endif
+        		size	-= PAGE_SIZE;
+        	}
+        }
+
+        /*  free pages allocated */
+#if ALLOC_HIGHMEM
+        if(mdl->dmaHandle)
+        {
+            page = pfn_to_page(mdl->dmaHandle >> PAGE_SHIFT);
+
+            __free_pages(page, get_order(mdl->numPages * PAGE_SIZE));
+
+            mdl->dmaHandle = gcvNULL;
+        }
+#else
+        if(mdl->kaddr)
+        {
+            free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
+
+            mdl->kaddr = gcvNULL;
+        }
+#endif
+
+        /* unmap the kernal space */
+        if(mdl->addr)
+        {
+            iounmap(mdl->addr);
+            mdl->addr = gcvNULL;
+        }
+
+        /* unmap from user space */
+        if(InUserSpace && mdlMap && mdlMap->vmaAddr)
+        {
+            if (do_munmap(current->mm,
+    					 (unsigned long)mdlMap->vmaAddr,
+    					  mdl->numPages * PAGE_SIZE) < 0)
+    		{
+    			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    						gcvZONE_OS,
+            				"gckOS_FreeNonPagedMemory: "
+    						"Unmap Failed ->Mdl->0x%x Logical->0x%x vmaAddr->0x%x",
+                    		(gctUINT32)mdl,
+    						(gctUINT32)mdl->addr,
+    						(gctUINT32)mdlMap->vmaAddr);
+    		}
+
+            mdlMap->vmaAddr = gcvNULL;
+        }
+#endif
+    }
+    /* Destroy the mdlMap if necessary*/
+    if(mdlMap)
+    {
+        gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+        mdlMap = gcvNULL;
+    }
+
+    /* Destroy the mdl if necessary*/
+    if(mdl)
+    {
+        gcmkVERIFY_OK(_DestroyMdl(mdl));
+        mdl = gcvNULL;
+    }
+
+    MEMORY_UNLOCK(Os);
+
+	return status;
 }
 
 /*******************************************************************************
@@ -1459,14 +1726,18 @@ gceSTATUS gckOS_FreeNonPagedMemory(
 
 #ifdef NO_DMA_COHERENT
 	unsigned				size;
+#if ALLOC_HIGHMEM
+    struct page *page;
+#else
 	gctPOINTER				vaddr;
+#endif
 #endif /* NO_DMA_COHERENT */
-
+ 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 	gcmkVERIFY_ARGUMENT(Bytes > 0);
 	gcmkVERIFY_ARGUMENT(Physical != 0);
-	gcmkVERIFY_ARGUMENT(Logical != NULL);
+	gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
@@ -1476,96 +1747,138 @@ gceSTATUS gckOS_FreeNonPagedMemory(
     mdl = (PLINUX_MDL) Physical;
 
 	MEMORY_LOCK(Os);
-
+    
+	if (mdl)
+	{
 #ifndef NO_DMA_COHERENT
-    dma_free_coherent(gcvNULL,
-					mdl->numPages * PAGE_SIZE,
-					mdl->addr,
-					mdl->dmaHandle);
+        dma_free_coherent(gcvNULL,
+    					mdl->numPages * PAGE_SIZE,
+    					mdl->addr,
+    					mdl->dmaHandle);
 #else
-	size	= mdl->numPages * PAGE_SIZE;
-	vaddr	= mdl->kaddr;
-
-	while (size > 0)
-	{
-		ClearPageReserved(virt_to_page(vaddr));
-
-		vaddr	+= PAGE_SIZE;
-		size	-= PAGE_SIZE;
-	}
-
-	free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
-
-	iounmap(mdl->addr);
-#endif /* NO_DMA_COHERENT */
-
-	mdlMap = mdl->maps;
-
-	while (mdlMap != gcvNULL)
-	{
-		if (mdlMap->vmaAddr != gcvNULL)
-		{
-			/* Get the current pointer for the task with stored pid. */
-			task = FIND_TASK_BY_PID(mdlMap->pid);
+    	size	= mdl->numPages * PAGE_SIZE;
 
-			if (task != gcvNULL && task->mm != gcvNULL)
-			{
-				down_write(&task->mm->mmap_sem);
+#if ALLOC_HIGHMEM
+        page    = pfn_to_page(mdl->dmaHandle >> PAGE_SHIFT);
+#else 
+        vaddr   = mdl->kaddr;
 
-				if (do_munmap(task->mm,
-							(unsigned long)mdlMap->vmaAddr,
-							mdl->numPages * PAGE_SIZE) < 0)
-				{
-					gcmkTRACE_ZONE(gcvLEVEL_INFO,
-								gcvZONE_OS,
-						"gckOS_FreeNonPagedMemory: "
-								"Unmap Failed ->Mdl->0x%x Logical->0x%x vmaAddr->0x%x",
-					(gctUINT32)mdl,
-								(gctUINT32)mdl->addr,
-								(gctUINT32)mdlMap->vmaAddr);
-				}
+#endif
 
-				up_write(&task->mm->mmap_sem);
-			}
 
-			mdlMap->vmaAddr = gcvNULL;
-		}
+    	while (size > 0)
+    	{
+#if ALLOC_HIGHMEM
+        	ClearPageReserved(page);
+    		page ++;
+#else
+    		ClearPageReserved(virt_to_page(vaddr));
+    		vaddr	+= PAGE_SIZE;
+#endif
+    		size	-= PAGE_SIZE;
+    	}
 
-		mdlMap = mdlMap->next;
-	}
+#if ALLOC_HIGHMEM
+        if(mdl->dmaHandle)
+        {
+            page = pfn_to_page(mdl->dmaHandle >> PAGE_SHIFT);
+            __free_pages(page, get_order(mdl->numPages * PAGE_SIZE));
+            mdl->dmaHandle = gcvNULL;
+        }
+#else
+        if(mdl->kaddr)
+        {
+            free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
+            mdl->kaddr = gcvNULL;
+        }
+#endif
 
-    /* Remove the node from global list.. */
-    if (mdl == Os->mdlHead)
-    {
-        if ((Os->mdlHead = mdl->next) == gcvNULL)
+        if(mdl->addr)
         {
-            Os->mdlTail = gcvNULL;
+    	    iounmap(mdl->addr);
+            mdl->addr = gcvNULL;
         }
-    }
-    else
-    {
-        mdl->prev->next = mdl->next;
-        if (mdl == Os->mdlTail)
+        
+#endif /* NO_DMA_COHERENT */
+
+    	mdlMap = mdl->maps;
+
+    	while (mdlMap != gcvNULL)
+    	{
+    		if (mdlMap->vmaAddr != gcvNULL)
+    		{
+    			/* Get the current pointer for the task with stored pid. */
+    			task = FIND_TASK_BY_PID(mdlMap->pid);
+
+    			if (task != gcvNULL && task->mm != gcvNULL)
+    			{
+    				down_write(&task->mm->mmap_sem);
+
+    				if (do_munmap(task->mm,
+    							(unsigned long)mdlMap->vmaAddr,
+    							mdl->numPages * PAGE_SIZE) < 0)
+    				{
+    					gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    								gcvZONE_OS,
+                    				"gckOS_FreeNonPagedMemory: "
+    								"Unmap Failed ->Mdl->0x%x Logical->0x%x vmaAddr->0x%x",
+                            		(gctUINT32)mdl,
+    								(gctUINT32)mdl->addr,
+    								(gctUINT32)mdlMap->vmaAddr);
+    				}
+
+    				up_write(&task->mm->mmap_sem);
+    			}
+
+    			mdlMap->vmaAddr = gcvNULL;
+    		}
+
+    		mdlMap = mdlMap->next;
+    	}
+
+        /* Remove the node from global list.. */
+        if (mdl == Os->mdlHead)
         {
-            Os->mdlTail = mdl->prev;
+            if ((Os->mdlHead = mdl->next) == gcvNULL)
+            {
+                Os->mdlTail = gcvNULL;
+            }
         }
         else
         {
-            mdl->next->prev = mdl->prev;
+            mdl->prev->next = mdl->next;
+            if (mdl == Os->mdlTail)
+            {
+                Os->mdlTail = mdl->prev;
+            }
+            else
+            {
+                mdl->next->prev = mdl->prev;
+            }
         }
-    }
+	}
+
+	/* Update contiguous or virtual memory usage. */
+	if (mdl)
+	{
+		if (mdl->contiguous)
+			Os->device->contiguousMemUsage -= (mdl->numPages * PAGE_SIZE);
+		else
+			Os->device->virtualMemUsage -= (mdl->numPages * PAGE_SIZE);
+	}
 
 	MEMORY_UNLOCK(Os);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
-			"gckOS_FreeNonPagedMemory: "
+    			"gckOS_FreeNonPagedMemory: "
 				"Mdl->0x%x Logical->0x%x",
-			(gctUINT32)mdl,
+          		(gctUINT32)mdl,
 				(gctUINT32)mdl->addr);
 
 	gcmkVERIFY_OK(_DestroyMdl(mdl));
 
+    mdl = gcvNULL;
     /* Success. */
     return gcvSTATUS_OK;
 }
@@ -1597,10 +1910,66 @@ gceSTATUS gckOS_ReadRegister(
 {
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Data != NULL);
+    gcmkVERIFY_ARGUMENT(Data != gcvNULL);
 
-    *Data = readl((gctUINT8 *)Os->device->registerBase + Address);
+    if(Os->device->kernel
+        && Os->device->kernel->hardware)
+    {
+        gcmkVERIFY_OK(gckOS_AcquireRecMutex(Os, Os->device->kernel->hardware->recMutexPower, gcvINFINITE));
+
+        if(Os->device->clkEnabled)
+        {
+            *Data = readl((gctUINT8 *)Os->device->registerBase + Address);
+        }
+        else
+        {
+            *Data = 0x0;
+            gcmkPRINT("(pid=%d,name=%s)GC is clk off, dont read register(0x%08x)\n", 
+                current->pid, current->comm, Address);
+        }
+
+    	gcmkVERIFY_OK(gckOS_ReleaseRecMutex(Os, Os->device->kernel->hardware->recMutexPower));
+    }
+    else
+    {
+        *Data = readl((gctUINT8 *)Os->device->registerBase + Address);
+    }
+    
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_DirectReadRegister
+**
+**	Read data from a register directly without mutex protection
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Address
+**			Address of register.
+**
+**	OUTPUT:
+**
+**		gctUINT32 * Data
+**			Pointer to a variable that receives the data read from the register.
+*/
+gceSTATUS gckOS_DirectReadRegister(
+	IN gckOS Os,
+	IN gctUINT32 Address,
+	OUT gctUINT32 * Data
+	)
+{
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Data != gcvNULL);
 
+    *Data = readl((gctUINT8 *)Os->device->registerBase + Address);
+    
     /* Success. */
     return gcvSTATUS_OK;
 }
@@ -1632,8 +2001,28 @@ gceSTATUS gckOS_WriteRegister(
 	IN gctUINT32 Data
 	)
 {
-    writel(Data, (gctUINT8 *)Os->device->registerBase + Address);
+    if(Os->device->kernel
+        && Os->device->kernel->hardware)
+    {
+        gcmkVERIFY_OK(gckOS_AcquireRecMutex(Os, Os->device->kernel->hardware->recMutexPower, gcvINFINITE));
 
+        if(Os->device->clkEnabled)
+        {
+            writel(Data, (gctUINT8 *)Os->device->registerBase + Address);
+        }
+        else
+        {
+            gcmkPRINT("(pid=%d,name=%s)GC is clk off, dont write register(0x%08x)\n", 
+                current->pid, current->comm, Address);
+        }
+
+    	gcmkVERIFY_OK(gckOS_ReleaseRecMutex(Os, Os->device->kernel->hardware->recMutexPower));
+    }
+    else
+    {
+        writel(Data, (gctUINT8 *)Os->device->registerBase + Address);
+    }
+    
     /* Success. */
     return gcvSTATUS_OK;
 }
@@ -1661,7 +2050,7 @@ gceSTATUS gckOS_GetPageSize(
 {
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(PageSize != NULL);
+	gcmkVERIFY_ARGUMENT(PageSize != gcvNULL);
 
 	/* Return the page size. */
 	*PageSize = (gctSIZE_T) PAGE_SIZE;
@@ -1753,7 +2142,7 @@ gceSTATUS gckOS_GetPhysicalAddress(
 			&& (gctUINT32)Logical >= (gctUINT32)mdl->addr
 			&& (gctUINT32)Logical < ((gctUINT32)mdl->addr + mdl->numPages*PAGE_SIZE))
         {
-            if (mdl->dmaHandle)
+            if (mdl->dmaHandle != GC_INVALID_PHYS_ADDR)
             {
                 /* The memory was from coherent area. */
                 *Address = (gctUINT32)mdl->dmaHandle
@@ -1774,7 +2163,7 @@ gceSTATUS gckOS_GetPhysicalAddress(
             }
             else
             {
-                *Address = (gctUINT32)virt_to_phys(mdl->addr)
+                *Address = (gctUINT32)virt_to_phys(mdl->kaddr)
 							+ ((gctUINT32)Logical - (gctUINT32)mdl->addr);
             }
             break;
@@ -1788,7 +2177,7 @@ gceSTATUS gckOS_GetPhysicalAddress(
 			&& Logical >= mdlMap->vmaAddr
 			&& Logical < (mdlMap->vmaAddr + mdl->numPages * PAGE_SIZE))
         {
-            if (mdl->dmaHandle)
+            if (mdl->dmaHandle != GC_INVALID_PHYS_ADDR)
             {
                 /* The memory was from coherent area. */
                 *Address = (gctUINT32)mdl->dmaHandle
@@ -1811,7 +2200,7 @@ gceSTATUS gckOS_GetPhysicalAddress(
             else
             {
                 /* Return the kernel virtual pointer based on this. */
-                *Address = (gctUINT32)virt_to_phys(mdl->addr)
+                *Address = (gctUINT32)virt_to_phys(mdl->kaddr)
 							+ (gctUINT32)(Logical - mdlMap->vmaAddr);
             }
             break;
@@ -1861,7 +2250,7 @@ gceSTATUS gckOS_GetPhysicalAddress(
 gceSTATUS gckOS_MapPhysical(
 	IN gckOS Os,
 	IN gctUINT32 Physical,
-	IN gctUINT32 OriginalLogical,
+	IN gctUINT32 OriginalLogical,	
 	IN gctSIZE_T Bytes,
 	OUT gctPOINTER * Logical
 	)
@@ -1885,7 +2274,7 @@ gceSTATUS gckOS_MapPhysical(
 
     while (mdl != gcvNULL)
     {
-        if (mdl->dmaHandle != 0)
+        if (mdl->dmaHandle != GC_INVALID_PHYS_ADDR)
         {
             if ((physical >= mdl->dmaHandle)
 			&&  (physical < mdl->dmaHandle + mdl->numPages * PAGE_SIZE)
@@ -1905,10 +2294,10 @@ gceSTATUS gckOS_MapPhysical(
         request_mem_region(physical, Bytes, "MapRegion");
         logical = (gctPOINTER) ioremap_nocache(physical, Bytes);
 
-	    if (logical == NULL)
+	    if (logical == gcvNULL)
 	    {
 			gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
-				  "gckOS_MapMemory: Failed to ioremap");
+            			  "gckOS_MapMemory: Failed to ioremap");
 
 			MEMORY_UNLOCK(Os);
 
@@ -1923,7 +2312,7 @@ gceSTATUS gckOS_MapPhysical(
 	MEMORY_UNLOCK(Os);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
-			  "gckOS_MapPhysical: "
+    			  "gckOS_MapPhysical: "
 				  "Physical->0x%X Bytes->0x%X Logical->0x%X MappingFound->%d",
 				  (gctUINT32) Physical,
 				  (gctUINT32) Bytes,
@@ -1965,7 +2354,7 @@ gceSTATUS gckOS_UnmapPhysical(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Logical != NULL);
+	gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 	gcmkVERIFY_ARGUMENT(Bytes > 0);
 
 	MEMORY_LOCK(Os);
@@ -1996,9 +2385,9 @@ gceSTATUS gckOS_UnmapPhysical(
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 					gcvZONE_OS,
-				"gckOS_UnmapPhysical: "
+    				"gckOS_UnmapPhysical: "
 					"Logical->0x%x Bytes->0x%x MappingFound(?)->%d",
-				(gctUINT32)Logical,
+           			(gctUINT32)Logical,
 					(gctUINT32)Bytes,
 					mdl ? 1 : 0);
 
@@ -2029,7 +2418,7 @@ gceSTATUS gckOS_CreateMutex(
 {
 	/* Validate the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
 	/* Allocate a FAST_MUTEX structure. */
 	*Mutex = (gctPOINTER)kmalloc(sizeof(struct semaphore), GFP_KERNEL);
@@ -2072,11 +2461,12 @@ gceSTATUS gckOS_DeleteMutex(
 {
 	/* Validate the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
 	/* Delete the fast mutex. */
 	kfree(Mutex);
 
+    Mutex = gcvNULL;
 	return gcvSTATUS_OK;
 }
 
@@ -2112,7 +2502,7 @@ gckOS_AcquireMutex(
 {
 	/* Validate the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
 	if (Timeout == gcvINFINITE)
 	{
@@ -2122,7 +2512,7 @@ gckOS_AcquireMutex(
 		return gcvSTATUS_OK;
 	}
 
-	while (Timeout-- > 0)
+    while (gcvTRUE)
 	{
 		/* Try to acquire the fast mutex. */
 		if (!down_trylock((struct semaphore *) Mutex))
@@ -2131,6 +2521,8 @@ gckOS_AcquireMutex(
 			return gcvSTATUS_OK;
 		}
 
+		if (Timeout-- == 0) break;
+
 		/* Wait for 1 millisecond. */
 		gcmkVERIFY_OK(gckOS_Delay(Os, 1));
 	}
@@ -2164,7 +2556,7 @@ gceSTATUS gckOS_ReleaseMutex(
 {
 	/* Validate the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
 	/* Release the fast mutex. */
 	up((struct semaphore *) Mutex);
@@ -2175,479 +2567,988 @@ gceSTATUS gckOS_ReleaseMutex(
 
 /*******************************************************************************
 **
-**	gckOS_AtomicExchange
+**	gckOS_UpdateVidMemUsage
 **
-**	Atomically exchange a pair of 32-bit values.
+**	Update video memory usage.
 **
 **	INPUT:
 **
 **		gckOS Os
 **			Pointer to an gckOS object.
 **
-**      IN OUT gctINT32_PTR Target
-**          Pointer to the 32-bit value to exchange.
-**
-**		IN gctINT32 NewValue
-**			Specifies a new value for the 32-bit value pointed to by Target.
+**      IN gctBOOL IsAllocated
+**          Specifies whether this call is following allocate or free memory.
 **
-**      OUT gctINT32_PTR OldValue
-**          The old value of the 32-bit value pointed to by Target.
+**		IN gctSIZE_T Bytes
+**			Specifies the bytes to allocate or free.
 **
 **	OUTPUT:
 **
 **		Nothing.
 */
 gceSTATUS
-gckOS_AtomicExchange(
+gckOS_UpdateVidMemUsage(
 	IN gckOS Os,
-    IN OUT gctUINT32_PTR Target,
-	IN gctUINT32 NewValue,
-    OUT gctUINT32_PTR OldValue
+    IN gctBOOL IsAllocated,
+	IN gctSIZE_T Bytes
 	)
 {
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-	/* Exchange the pair of 32-bit values. */
-	*OldValue = (gctUINT32) atomic_xchg((atomic_t *) Target, (int) NewValue);
+	/* Update memory usage. */
+	if (IsAllocated)
+		Os->device->vidMemUsage += Bytes;
+	else
+		Os->device->vidMemUsage -= Bytes;
 
 	/* Success. */
 	return gcvSTATUS_OK;
 }
 
-
 /*******************************************************************************
 **
-**	gckOS_AtomicExchangePtr
-**
-**	Atomically exchange a pair of pointers.
-**
-**	INPUT:
-**
-**		gckOS Os
-**			Pointer to an gckOS object.
+**  gckOS_AtomConstruct
 **
-**      IN OUT gctPOINTER * Target
-**          Pointer to the 32-bit value to exchange.
+**  Create an atom.
 **
-**		IN gctPOINTER NewValue
-**			Specifies a new value for the pointer pointed to by Target.
+**  INPUT:
 **
-**      OUT gctPOINTER * OldValue
-**          The old value of the pointer pointed to by Target.
+**      gckOS Os
+**          Pointer to a gckOS object.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      gctPOINTER * Atom
+**          Pointer to a variable receiving the constructed atom.
 */
 gceSTATUS
-gckOS_AtomicExchangePtr(
-	IN gckOS Os,
-    IN OUT gctPOINTER * Target,
-	IN gctPOINTER NewValue,
-    OUT gctPOINTER * OldValue
-	)
+gckOS_AtomConstruct(
+    IN gckOS Os,
+    OUT gctPOINTER * Atom
+    )
 {
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gceSTATUS status;
 
-	/* Exchange the pair of pointers. */
-	*OldValue = (gctPOINTER) atomic_xchg((atomic_t *) Target, (int) NewValue);
+    gcmkHEADER_ARG("Os=0x%x", Os);
 
-	/* Success. */
-	return gcvSTATUS_OK;
-}
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
+
+    /* Allocate the atom. */
+    gcmkONERROR(gckOS_Allocate(Os, gcmSIZEOF(atomic_t), Atom));
+
+    /* Initialize the atom. */
+    atomic_set((atomic_t *) *Atom, 0);
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Atom=0x%x", *Atom);
+    return gcvSTATUS_OK;
 
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
 
 /*******************************************************************************
 **
-**	gckOS_Delay
+**  gckOS_AtomDestroy
 **
-**	Delay execution of the current thread for a number of milliseconds.
+**  Destroy an atom.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to a gckOS object.
 **
-**		gctUINT32 Delay
-**			Delay to sleep, specified in milliseconds.
+**      gctPOINTER Atom
+**          Pointer to the atom to destroy.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      Nothing.
 */
-gceSTATUS gckOS_Delay(
-	IN gckOS Os,
-	IN gctUINT32 Delay
-	)
+gceSTATUS
+gckOS_AtomDestroy(
+    IN gckOS Os,
+    OUT gctPOINTER Atom
+    )
 {
-#ifdef CONFIG_PXA_DVFM
-    if(Os->device->enableMdelay)
-    {
-        mdelay(1);
-    }
-    else
-#endif
-    {
-	struct timeval now;
-	unsigned long ticks;
+    gceSTATUS status;
 
-	if (Delay == 0)
-	{
-		/* Smallest delay possible. */
-		ticks = 1;
-	}
-	else
-	{
-		/* Convert milliseconds into seconds and microseconds. */
-		now.tv_sec  = Delay / 1000;
-		now.tv_usec = (Delay % 1000) * 1000;
+    gcmkHEADER_ARG("Os=0x%x Atom=0x%0x", Os, Atom);
 
-		/* Convert Delay to jiffies. */
-		ticks = timeval_to_jiffies(&now);
-	}
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
 
-	/* Schedule timeout. */
-	schedule_timeout_interruptible(ticks);
-    }
+    /* Free the atom. */
+    gcmkONERROR(gckOS_Free(Os, Atom));
 
-	/* Success. */
-	return gcvSTATUS_OK;
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
 /*******************************************************************************
 **
-**	gckOS_MemoryBarrier
+**  gckOS_AtomGet
 **
-**	Make sure the CPU has executed everything up to this point and the data got
-**	written to the specified pointer.
+**  Get the 32-bit value protected by an atom.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to a gckOS object.
 **
-**		gctPOINTER Address
-**			Address of memory that needs to be barriered.
+**      gctPOINTER Atom
+**          Pointer to the atom.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		Nothing.
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the value of the atom.
 */
-gceSTATUS gckOS_MemoryBarrier(
-	IN gckOS Os,
-	IN gctPOINTER Address
-	)
+gceSTATUS
+gckOS_AtomGet(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    )
 {
-	/* Verify thearguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkHEADER_ARG("Os=0x%x Atom=0x%0x", Os, Atom);
 
-	mb();
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
 
-	/* Success. */
-	return gcvSTATUS_OK;
+    /* Return the current value of atom. */
+    *Value = atomic_read((atomic_t *) Atom);
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Value=%d", *Value);
+    return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
 **
-**	gckOS_AllocatePagedMemory
+**  gckOS_AtomIncrement
 **
-**	Allocate memory from the paged pool.
+**  Atomically increment the 32-bit integer value inside an atom.
 **
-**	INPUT:
+**  INPUT:
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**      gckOS Os
+**          Pointer to a gckOS object.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes to allocate.
+**      gctPOINTER Atom
+**          Pointer to the atom.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gctPHYS_ADDR * Physical
-**			Pointer to a variable that receives the physical address of the
-**			memory allocation.
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
 */
 gceSTATUS
-gckOS_AllocatePagedMemory(
-	IN gckOS Os,
-	IN gctSIZE_T Bytes,
-	OUT gctPHYS_ADDR * Physical
-	)
+gckOS_AtomIncrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    )
 {
-	return gckOS_AllocatePagedMemoryEx(Os, gcvFALSE, Bytes, Physical);
+    gcmkHEADER_ARG("Os=0x%x Atom=0x%0x", Os, Atom);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
+
+    /* Increment the atom. */
+    *Value = atomic_inc_return((atomic_t *) Atom) - 1;
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Value=%d", *Value);
+    return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
 **
-**	gckOS_AllocatePagedMemoryEx
-**
-**	Allocate memory from the paged pool.
+**  gckOS_AtomDecrement
 **
-**	INPUT:
+**  Atomically decrement the 32-bit integer value inside an atom.
 **
-**		gckOS Os
-**			Pointer to an gckOS object.
+**  INPUT:
 **
-**		gctBOOL Contiguous
-**			Need contiguous memory or not.
+**      gckOS Os
+**          Pointer to a gckOS object.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes to allocate.
+**      gctPOINTER Atom
+**          Pointer to the atom.
 **
-**	OUTPUT:
+**  OUTPUT:
 **
-**		gctPHYS_ADDR * Physical
-**			Pointer to a variable that receives	the	physical address of the
-**			memory allocation.
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
 */
-gceSTATUS gckOS_AllocatePagedMemoryEx(
-	IN gckOS Os,
-	IN gctBOOL Contiguous,
-	IN gctSIZE_T Bytes,
-	OUT gctPHYS_ADDR * Physical
-	)
+gceSTATUS
+gckOS_AtomDecrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    )
 {
-    gctINT		numPages;
-    gctINT		i;
-    PLINUX_MDL  mdl;
-    gctSTRING	addr;
-    gctSIZE_T   bytes;
+    gcmkHEADER_ARG("Os=0x%x Atom=0x%0x", Os, Atom);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Bytes > 0);
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
-
-	gcmkTRACE_ZONE(gcvLEVEL_INFO,
-				gcvZONE_OS,
-				"in gckOS_AllocatePagedMemoryEx");
+    gcmkVERIFY_ARGUMENT(Atom != gcvNULL);
 
-    bytes = gcmALIGN(Bytes, PAGE_SIZE);
+    /* Decrement the atom. */
+    *Value = atomic_dec_return((atomic_t *) Atom) + 1;
 
-    numPages = GetPageCount(bytes, 0);
-
-	MEMORY_LOCK(Os);
+    /* Success. */
+    gcmkFOOTER_ARG("*Value=%d", *Value);
+    return gcvSTATUS_OK;
+}
 
-	/* Bugbug: for some specific linux systems, vmalloc can't work correctly. Disable the non-contiguous support by default */
-	Contiguous = gcvTRUE;
+/*******************************************************************************
+**
+**	gckOS_CreateRecMutex
+**
+**	Create a new recursive mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**	OUTPUT:
+**
+**		gckRecursiveMutex * Mutex
+**			Pointer to a variable that will hold a pointer to the mutex.
+*/
+gceSTATUS
+gckOS_CreateRecMutex(
+	IN gckOS Os,
+	OUT gckRecursiveMutex *Mutex
+	)
+{
+	gceSTATUS status = gcvSTATUS_OK;
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-	if (Contiguous)
+	/* Allocate a _gckRecursiveMutex structure. */
+	*Mutex = kmalloc(sizeof(struct _gckRecursiveMutex), GFP_KERNEL);
+	if (*Mutex)
 	{
-		addr = (char *)__get_free_pages(GFP_ATOMIC | GFP_DMA, GetOrder(numPages));
+		(*Mutex)->accMutex = (*Mutex)->undMutex = gcvNULL;
+		gcmkONERROR(gckOS_CreateMutex(Os, &(*Mutex)->accMutex));
+		gcmkONERROR(gckOS_CreateMutex(Os, &(*Mutex)->undMutex));
+		(*Mutex)->nReference = 0;
+		(*Mutex)->pThread = -1;
 	}
 	else
+		status = gcvSTATUS_OUT_OF_MEMORY;
+	
+	/* Return status. */
+	return status;
+	
+OnError:
+	if (*Mutex)
 	{
-	    addr = vmalloc(bytes);
+		/* Free the underlying mutex. */	
+		if ((*Mutex)->accMutex)
+			gckOS_DeleteMutex(Os, (*Mutex)->accMutex);
+		if ((*Mutex)->undMutex)
+			gckOS_DeleteMutex(Os, (*Mutex)->undMutex);
+		/* free _gckRecursiveMutex structure. */
+		kfree(*Mutex);
+		*Mutex = gcvNULL;
 	}
+	return status;
+}
 
-    if (!addr)
-    {
-		gcmkTRACE_ZONE(gcvLEVEL_INFO,
-				gcvZONE_OS,
-			"gckOS_AllocatePagedMemoryEx: "
-				"Can't allocate memorry for size->0x%x",
-				(gctUINT32)bytes);
-
-		MEMORY_UNLOCK(Os);
-
-        return gcvSTATUS_OUT_OF_MEMORY;
-    }
+/*******************************************************************************
+**
+**	gckOS_DeleteRecMutex
+**
+**	Delete a recursive mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gckRecursiveMutex Mutex
+**			Pointer to the mute to be deleted.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_DeleteRecMutex(
+	IN gckOS Os,
+	IN gckRecursiveMutex Mutex
+	)
+{
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
+
+	/* Delete the underlying mutex. */	
+	if (Mutex->accMutex)
+		gckOS_DeleteMutex(Os, Mutex->accMutex);
+	if (Mutex->undMutex)
+		gckOS_DeleteMutex(Os, Mutex->undMutex);
+	/* Delete _gckRecursiveMutex structure. */
+	kfree(Mutex);
+    Mutex = gcvNULL;
+	return gcvSTATUS_OK;
+}
 
-    mdl = _CreateMdl(current->tgid);
+/*******************************************************************************
+**
+**	gckOS_AcquireRecMutex
+**
+**	Acquire a recursive mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gckRecursiveMutex Mutex
+**			Pointer to the mutex to be acquired.
+**
+**		gctUINT32 Timeout
+**			Timeout value specified in milliseconds.
+**			Specify the value of gcvINFINITE to keep the thread suspended
+**			until the mutex has been acquired.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_AcquireRecMutex(
+	IN gckOS Os,
+	IN gckRecursiveMutex Mutex,
+	IN gctUINT32 Timeout
+	)
+{
+	gceSTATUS status = gcvSTATUS_TIMEOUT;
+	gctUINT32 tid;
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-	if (mdl == gcvNULL)
+	gckOS_AcquireMutex(Os, Mutex->accMutex, gcvINFINITE);
+	/* Get current thread ID. */
+	gckOS_GetThreadID(&tid);
+	/* Locked by itself. */
+	if (Mutex->pThread == tid)
 	{
-		MEMORY_UNLOCK(Os);
-
-		return gcvSTATUS_OUT_OF_MEMORY;
+		Mutex->nReference++;
+		gckOS_ReleaseMutex(Os, Mutex->accMutex);
+		status = gcvSTATUS_OK;
 	}
-
-	mdl->dmaHandle	= 0;
-    mdl->addr		= addr;
-    mdl->numPages	= numPages;
-    mdl->pagedMem	= 1;
-	mdl->contiguous = Contiguous;
-
-	for (i = 0; i < mdl->numPages; i++)
-    {
-		if (mdl->contiguous)
-		{
-			SetPageReserved(virt_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE)));
-		}
-		else
+	else
+	{
+		gckOS_ReleaseMutex(Os, Mutex->accMutex);
+		/* Try lock. */
+		status = gckOS_AcquireMutex(Os, Mutex->undMutex, Timeout);
+		/* First time get the lock . */
+		if (status == gcvSTATUS_OK)
 		{
-			SetPageReserved(vmalloc_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE)));
+			gckOS_AcquireMutex(Os, Mutex->accMutex, gcvINFINITE);
+			Mutex->pThread = tid;
+			Mutex->nReference = 1;
+			gckOS_ReleaseMutex(Os, Mutex->accMutex);
 		}
-    }
-
-    /* Return physical address. */
-    *Physical = (gctPHYS_ADDR) mdl;
-
-    /*
-	 * Add this to a global list.
-	 * Will be used by get physical address
-	 * and mapuser pointer functions.
-	 */
-    if (!Os->mdlHead)
-    {
-        /* Initialize the queue. */
-        Os->mdlHead = Os->mdlTail = mdl;
-    }
-    else
-    {
-        /* Add to tail. */
-        mdl->prev			= Os->mdlTail;
-        Os->mdlTail->next	= mdl;
-        Os->mdlTail			= mdl;
-    }
-
-	MEMORY_UNLOCK(Os);
-
-	gcmkTRACE_ZONE(gcvLEVEL_INFO,
-				gcvZONE_OS,
-			"gckOS_AllocatePagedMemoryEx: "
-				"Bytes->0x%x, Mdl->%p, Logical->%p",
-			(gctUINT32)bytes,
-				mdl,
-				mdl->addr);
+		
+	}
 
-    /* Success. */
-    return gcvSTATUS_OK;
+	/* Timeout. */
+	return status;
 }
 
 /*******************************************************************************
 **
-**	gckOS_FreePagedMemory
+**	gckOS_ReleaseRecMutex
 **
-**	Free memory allocated from the paged pool.
+**	Release an acquired mutex.
 **
 **	INPUT:
 **
 **		gckOS Os
 **			Pointer to an gckOS object.
 **
-**		gctPHYS_ADDR Physical
-**			Physical address of the allocation.
-**
-**		gctSIZE_T Bytes
-**			Number of bytes of the allocation.
+**		gckRecursiveMutex Mutex
+**			Pointer to the mutex to be released.
 **
 **	OUTPUT:
 **
 **		Nothing.
 */
-gceSTATUS gckOS_FreePagedMemory(
+gceSTATUS gckOS_ReleaseRecMutex(
 	IN gckOS Os,
-	IN gctPHYS_ADDR Physical,
-	IN gctSIZE_T Bytes
+	IN gckRecursiveMutex Mutex
 	)
 {
-    PLINUX_MDL  mdl = (PLINUX_MDL)Physical;
-    gctSTRING	addr;
-    gctINT		i;
-
-    /* Verify the arguments. */
-    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
-
-	gcmkTRACE_ZONE(gcvLEVEL_INFO,
-				gcvZONE_OS,
-				"in gckOS_FreePagedMemory");
-
-    addr = mdl->addr;
+	gctUINT32 tid;
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != gcvNULL);
 
-	MEMORY_LOCK(Os);
+	gckOS_AcquireMutex(Os, Mutex->accMutex, gcvINFINITE);
 
-    for (i = 0; i < mdl->numPages; i++)
+	/* Get current thread ID. */
+	gckOS_GetThreadID(&tid);
+	/* Locked by itself. */
+	if (Mutex->pThread == tid)
 	{
-		if (mdl->contiguous)
-		{
-	        ClearPageReserved(virt_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
-		}
-		else
+		Mutex->nReference--;
+		if(Mutex->nReference == 0)
 		{
-			ClearPageReserved(vmalloc_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
+			Mutex->pThread = -1;
+			/* Unlock. */
+			gckOS_ReleaseMutex(Os, Mutex->undMutex);
 		}
-    }
-
-	if (mdl->contiguous)
-	{
-		free_pages((unsigned long)mdl->addr, GetOrder(mdl->numPages));
-	}
-	else
-	{
-		vfree(mdl->addr);
 	}
 
-    /* Remove the node from global list. */
-    if (mdl == Os->mdlHead)
-    {
-        if ((Os->mdlHead = mdl->next) == gcvNULL)
-        {
-            Os->mdlTail = gcvNULL;
-        }
-    }
-    else
-    {
-        mdl->prev->next = mdl->next;
-
-        if (mdl == Os->mdlTail)
-        {
-            Os->mdlTail = mdl->prev;
-        }
-        else
-        {
-            mdl->next->prev = mdl->prev;
-        }
-    }
-
-	MEMORY_UNLOCK(Os);
-
-    /* Free the structure... */
-    gcmkVERIFY_OK(_DestroyMdl(mdl));
-
-	gcmkTRACE_ZONE(gcvLEVEL_INFO,
-				gcvZONE_OS,
-			"gckOS_FreePagedMemory: Bytes->0x%x, Mdl->0x%x",
-				(gctUINT32)Bytes,
-				(gctUINT32)mdl);
-
-    /* Success. */
-    return gcvSTATUS_OK;
+	gckOS_ReleaseMutex(Os, Mutex->accMutex);
+	/* Success. */
+	return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
 **
-**	gckOS_LockPages
+**	gckOS_AtomicExchange
 **
-**	Lock memory allocated from the paged pool.
+**	Atomically exchange a pair of 32-bit values.
 **
 **	INPUT:
 **
 **		gckOS Os
 **			Pointer to an gckOS object.
 **
-**		gctPHYS_ADDR Physical
-**			Physical address of the allocation.
+**      IN OUT gctINT32_PTR Target
+**          Pointer to the 32-bit value to exchange.
 **
-**		gctSIZE_T Bytes
-**			Number of bytes of the allocation.
+**		IN gctINT32 NewValue
+**			Specifies a new value for the 32-bit value pointed to by Target.
 **
-**	OUTPUT:
+**      OUT gctINT32_PTR OldValue
+**          The old value of the 32-bit value pointed to by Target.
 **
-**		gctPOINTER * Logical
-**			Pointer to a variable that receives the	address of the mapped
-**			memory.
+**	OUTPUT:
 **
-**		gctSIZE_T * PageCount
-**			Pointer to a variable that receives the	number of pages required for
-**			the page table according to the GPU page size.
+**		Nothing.
 */
-gceSTATUS gckOS_LockPages(
+gceSTATUS
+gckOS_AtomicExchange(
+	IN gckOS Os,
+    IN OUT gctUINT32_PTR Target,
+	IN gctUINT32 NewValue,
+    OUT gctUINT32_PTR OldValue
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	/* Exchange the pair of 32-bit values. */
+	*OldValue = (gctUINT32) atomic_xchg((atomic_t *) Target, (int) NewValue);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AtomicExchangePtr
+**
+**	Atomically exchange a pair of pointers.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**      IN OUT gctPOINTER * Target
+**          Pointer to the 32-bit value to exchange.
+**
+**		IN gctPOINTER NewValue
+**			Specifies a new value for the pointer pointed to by Target.
+**
+**      OUT gctPOINTER * OldValue
+**          The old value of the pointer pointed to by Target.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_AtomicExchangePtr(
+	IN gckOS Os,
+    IN OUT gctPOINTER * Target,
+	IN gctPOINTER NewValue,
+    OUT gctPOINTER * OldValue
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	/* Exchange the pair of pointers. */
+	*OldValue = (gctPOINTER) atomic_xchg((atomic_t *) Target, (int) NewValue);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+
+/*******************************************************************************
+**
+**	gckOS_Delay
+**
+**	Delay execution of the current thread for a number of milliseconds.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Delay
+**			Delay to sleep, specified in milliseconds.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_Delay(
+	IN gckOS Os,
+	IN gctUINT32 Delay
+	)
+{
+	struct timeval now;
+	unsigned long ticks;
+
+	if (Delay == 0)
+	{
+		/* Smallest delay possible. */
+		ticks = 1;
+	}
+	else
+	{
+		/* Convert milliseconds into seconds and microseconds. */
+		now.tv_sec  = Delay / 1000;
+		now.tv_usec = (Delay % 1000) * 1000;
+
+		/* Convert Delay to jiffies. */
+		ticks = timeval_to_jiffies(&now);
+	}
+
+	/* Schedule timeout. */
+	schedule_timeout_interruptible(ticks);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS gckOS_Udelay(
+	IN gckOS Os,
+	IN gctUINT32 Delay
+	)
+{
+    udelay(Delay);
+
+    /* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MemoryBarrier
+**
+**	Make sure the CPU has executed everything up to this point and the data got
+**	written to the specified pointer.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Address
+**			Address of memory that needs to be barriered.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_MemoryBarrier(
+	IN gckOS Os,
+	IN gctPOINTER Address
+	)
+{
+	/* Verify thearguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	mb();
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocatePagedMemory
+**
+**	Allocate memory from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that receives the physical address of the
+**			memory allocation.
+*/
+gceSTATUS
+gckOS_AllocatePagedMemory(
 	IN gckOS Os,
-	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes,
+	OUT gctPHYS_ADDR * Physical
+	)
+{
+	return gckOS_AllocatePagedMemoryEx(Os, gcvFALSE, Bytes, Physical);
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocatePagedMemoryEx
+**
+**	Allocate memory from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctBOOL Contiguous
+**			Need contiguous memory or not.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that receives	the	physical address of the
+**			memory allocation.
+*/
+gceSTATUS gckOS_AllocatePagedMemoryEx(
+	IN gckOS Os,
+	IN gctBOOL Contiguous,
+	IN gctSIZE_T Bytes,
+	OUT gctPHYS_ADDR * Physical
+	)
+{
+    gctINT numPages;
+    gctINT i;
+    PLINUX_MDL mdl;
+    gctSTRING addr;
+    gctSIZE_T   bytes;
+
+    gcmkHEADER_ARG("Os=0x%0x Contiguous=%d Bytes=%lu", Os, Contiguous, Bytes);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+
+    if(gckOS_ForceMemAllocFail(Os))
+        return gcvSTATUS_OUT_OF_MEMORY;
+    
+	MEMORY_LOCK(Os);
+
+	if (Contiguous)
+	{
+	    bytes = gcmALIGN(Bytes, PAGE_SIZE);
+        numPages = GetPageCount(bytes, 0);
+        
+		addr = (char *)__get_free_pages(GFP_ATOMIC | GFP_DMA, GetOrder(numPages));
+	}
+	else
+	{
+	    Bytes = gcmALIGN(Bytes, ALLOC_ALIGN_BYTES);
+	    bytes = gcmALIGN(Bytes, PAGE_SIZE);
+        numPages = GetPageCount(bytes, 0);
+	    addr = vmalloc(bytes);
+	}
+
+    if (!addr)
+    {
+        gcmkLOG_WARNING_ARGS("Cant's allocate memory for size 0x%08x", (gctUINT32)bytes);
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+       			"gckOS_AllocatePagedMemoryEx: "
+				"Can't allocate memorry for size->0x%x",
+				(gctUINT32)bytes);
+
+		MEMORY_UNLOCK(Os);
+
+        gcmkHEADER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    mdl = _CreateMdl(current->tgid);
+
+	if (mdl == gcvNULL)
+	{
+        if (Contiguous)
+        {
+            free_pages((unsigned int) addr, GetOrder(numPages));
+        }
+        else
+        {
+            vfree(addr);
+        }
+
+		MEMORY_UNLOCK(Os);
+
+        gcmkHEADER_ARG("status=%d", gcvSTATUS_OUT_OF_MEMORY);
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	mdl->dmaHandle	= GC_INVALID_PHYS_ADDR;
+    mdl->numPages	= numPages;
+    mdl->pagedMem	= 1;
+	mdl->contiguous = Contiguous;
+
+    if(Contiguous)
+    {
+        mdl->addr		= addr;
+    }
+    else
+    {
+        /* consider 64 byte align, adjust the head address pointer */
+        unsigned int alignByte = ((unsigned int) addr + ALLOC_ALIGN_BYTES - 1) % ALLOC_ALIGN_BYTES;
+        mdl->addr_free  = addr;
+        mdl->addr       = addr + ALLOC_ALIGN_BYTES - 1 - alignByte;
+    }
+
+	for (i = 0; i < mdl->numPages; i++)
+    {
+        struct page *page;
+
+		if (mdl->contiguous)
+		{
+            page = virt_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE));
+		}
+		else
+		{
+            page = vmalloc_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE));
+		}
+
+        SetPageReserved(page);
+        flush_dcache_page(page);
+    }
+
+    /* Return physical address. */
+    *Physical = (gctPHYS_ADDR) mdl;
+
+    /*
+	 * Add this to a global list.
+	 * Will be used by get physical address
+	 * and mapuser pointer functions.
+	 */
+    if (!Os->mdlHead)
+    {
+        /* Initialize the queue. */
+        Os->mdlHead = Os->mdlTail = mdl;
+    }
+    else
+    {
+        /* Add to tail. */
+        mdl->prev			= Os->mdlTail;
+        Os->mdlTail->next	= mdl;
+        Os->mdlTail			= mdl;
+    }
+
+	MEMORY_UNLOCK(Os);
+
+    gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
+                   "%s: Bytes=%lu Mdl=0x%08x Logical=0x%08x",
+                   __FUNCTION__, bytes, mdl, mdl->addr);
+
+	/* Update contiguous or virtual memory usage. */
+	if (Contiguous)
+		Os->device->contiguousMemUsage += bytes;
+	else
+		Os->device->virtualMemUsage += bytes;
+    /* Success. */
+    gcmkHEADER_ARG("*Physical=0x%08x", *Physical);
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_FreePagedMemory
+**
+**	Free memory allocated from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_FreePagedMemory(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes
+	)
+{
+    PLINUX_MDL  mdl = (PLINUX_MDL)Physical;
+    gctSTRING	addr;
+    gctINT		i;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_FreePagedMemory");
+
+    addr = mdl->addr;
+
+	MEMORY_LOCK(Os);
+
+    for (i = 0; i < mdl->numPages; i++)
+	{
+		if (mdl->contiguous)
+		{
+	        ClearPageReserved(virt_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+		else
+		{
+			ClearPageReserved(vmalloc_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+    }
+
+	if (mdl->contiguous)
+	{
+		free_pages((unsigned long)mdl->addr, GetOrder(mdl->numPages));
+
+        mdl->addr = gcvNULL;
+	}
+	else
+	{
+	    /* vfree need free the real head pointer */
+		vfree(mdl->addr_free);
+
+        mdl->addr_free = gcvNULL;
+	}
+
+    /* Remove the node from global list. */
+    if (mdl == Os->mdlHead)
+    {
+        if ((Os->mdlHead = mdl->next) == gcvNULL)
+        {
+            Os->mdlTail = gcvNULL;
+        }
+    }
+    else
+    {
+        mdl->prev->next = mdl->next;
+
+        if (mdl == Os->mdlTail)
+        {
+            Os->mdlTail = mdl->prev;
+        }
+        else
+        {
+            mdl->next->prev = mdl->prev;
+        }
+    }
+
+	/* Update contiguous or virtual memory usage. */
+	if (mdl)
+	{
+		if (mdl->contiguous)
+			Os->device->contiguousMemUsage -= (mdl->numPages * PAGE_SIZE);
+		else
+			Os->device->virtualMemUsage -= (mdl->numPages * PAGE_SIZE);
+	}
+	MEMORY_UNLOCK(Os);
+
+    /* Free the structure... */
+    gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+    mdl = gcvNULL;
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+    			"gckOS_FreePagedMemory: Bytes->0x%x, Mdl->0x%x",
+				(gctUINT32)Bytes,
+				(gctUINT32)mdl);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_LockPages
+**
+**	Lock memory allocated from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Logical
+**			Pointer to a variable that receives the	address of the mapped
+**			memory.
+**
+**		gctSIZE_T * PageCount
+**			Pointer to a variable that receives the	number of pages required for
+**			the page table according to the GPU page size.
+*/
+gceSTATUS gckOS_LockPages(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
 	IN gctSIZE_T Bytes,
 	OUT gctPOINTER * Logical,
 	OUT gctSIZE_T * PageCount
@@ -2662,9 +3563,9 @@ gceSTATUS gckOS_LockPages(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
-    gcmkVERIFY_ARGUMENT(Logical != NULL);
-    gcmkVERIFY_ARGUMENT(PageCount != NULL);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(PageCount != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
@@ -2690,9 +3591,10 @@ gceSTATUS gckOS_LockPages(
 
 	if (mdlMap->vmaAddr == gcvNULL)
 	{
+	    unsigned long ret = 0;
 		down_write(&current->mm->mmap_sem);
 
-		mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(NULL,
+		ret = do_mmap_pgoff(gcvNULL,
 						0L,
 						mdl->numPages * PAGE_SIZE,
 						PROT_READ | PROT_WRITE,
@@ -2708,7 +3610,7 @@ gceSTATUS gckOS_LockPages(
 						(gctUINT32)mdlMap->vmaAddr,
 						(gctUINT32)mdl);
 
-		if (mdlMap->vmaAddr == gcvNULL)
+		if (IS_ERR_VALUE(ret))
 		{
 			gcmkTRACE_ZONE(gcvLEVEL_INFO,
 						gcvZONE_OS,
@@ -2718,6 +3620,10 @@ gceSTATUS gckOS_LockPages(
 
 			return gcvSTATUS_OUT_OF_MEMORY;
 		}
+        else
+        {
+            mdlMap->vmaAddr = (gctSTRING)ret;
+        }
 
 		mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
 
@@ -2756,7 +3662,7 @@ gceSTATUS gckOS_LockPages(
 
 				gcmkTRACE_ZONE(gcvLEVEL_INFO,
 							gcvZONE_OS,
-						"gckOS_LockPages: unable to mmap ret");
+        					"gckOS_LockPages: unable to mmap ret");
 
 				mdlMap->vmaAddr = gcvNULL;
 
@@ -2783,9 +3689,9 @@ gceSTATUS gckOS_LockPages(
 
 					gcmkTRACE_ZONE(gcvLEVEL_INFO,
 								gcvZONE_OS,
-						"gckOS_LockPages: "
+            					"gckOS_LockPages: "
 								"gctPHYS_ADDR->0x%x Logical->0x%x Unable to map addr->0x%x to start->0x%x",
-						(gctUINT32)Physical,
+                   				(gctUINT32)Physical,
 								(gctUINT32)*Logical,
 								(gctUINT32)addr,
 								(gctUINT32)start);
@@ -2818,9 +3724,9 @@ gceSTATUS gckOS_LockPages(
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
-			"gckOS_LockPages: "
+    			"gckOS_LockPages: "
 				"gctPHYS_ADDR->0x%x Bytes->0x%x Logical->0x%x pid->%d",
-			(gctUINT32)Physical,
+           		(gctUINT32)Physical,
 				(gctUINT32)Bytes,
 				(gctUINT32)*Logical,
 				mdlMap->pid);
@@ -2868,9 +3774,9 @@ gckOS_MapPages(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
     gcmkVERIFY_ARGUMENT(PageCount > 0);
-    gcmkVERIFY_ARGUMENT(PageTable != NULL);
+    gcmkVERIFY_ARGUMENT(PageTable != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
@@ -2881,9 +3787,9 @@ gckOS_MapPages(
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
-			"gckOS_MapPages: "
+    			"gckOS_MapPages: "
 				"Physical->0x%x PageCount->0x%x PagedMemory->?%d",
-			(gctUINT32)Physical,
+           		(gctUINT32)Physical,
 				(gctUINT32)PageCount,
 				mdl->pagedMem);
 
@@ -2917,7 +3823,7 @@ gckOS_MapPages(
     {
 		gcmkTRACE_ZONE(gcvLEVEL_INFO,
 					gcvZONE_OS,
-				"We should not get this call for Non Paged Memory!");
+        			"We should not get this call for Non Paged Memory!");
 
 		while (PageCount-- > 0)
         {
@@ -2969,11 +3875,11 @@ gceSTATUS gckOS_UnlockPages(
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-    gcmkVERIFY_ARGUMENT(Physical != NULL);
-    gcmkVERIFY_ARGUMENT(Logical != NULL);
+    gcmkVERIFY_ARGUMENT(Physical != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
 
 	/* Make sure there is already a mapping...*/
-    gcmkVERIFY_ARGUMENT(mdl->addr != NULL);
+    gcmkVERIFY_ARGUMENT(mdl->addr != gcvNULL);
 
 	gcmkTRACE_ZONE(gcvLEVEL_INFO,
 				gcvZONE_OS,
@@ -2993,7 +3899,15 @@ gceSTATUS gckOS_UnlockPages(
 			if (task != gcvNULL && task->mm != gcvNULL)
 			{
 				down_write(&task->mm->mmap_sem);
-				do_munmap(task->mm, (unsigned long)Logical, mdl->numPages * PAGE_SIZE);
+				if( do_munmap(task->mm, 
+                             (unsigned long)Logical, 
+                             mdl->numPages*PAGE_SIZE) < 0)
+                {
+                    gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    						gcvZONE_OS,
+                			"Can't unmap the address %x",
+    						(unsigned long)Logical);
+                }
 				up_write(&task->mm->mmap_sem);
 			}
 
@@ -3247,7 +4161,7 @@ gckOS_MapUserPointer(
 
 	*KernelPointer = buf;
 #else
-	*KernelPointer = Pointer;
+ 	*KernelPointer = Pointer;
 #endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
 
 	return gcvSTATUS_OK;
@@ -3341,7 +4255,7 @@ gckOS_WriteMemory(
 	)
 {
 	/* Verify the arguments. */
-	gcmkVERIFY_ARGUMENT(Address != NULL);
+	gcmkVERIFY_ARGUMENT(Address != gcvNULL);
 
 	/* Write memory. */
     writel(Data, (gctUINT8 *)Address);
@@ -3386,18 +4300,21 @@ gckOS_CreateSignal(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Signal != NULL);
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
 	/* Create an event structure. */
 	signal = (gcsSIGNAL_PTR)kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL);
 
 	if (signal == gcvNULL)
 	{
+        gcmkLOG_WARNING_ARGS("Out of memory to create signal.");
 		return gcvSTATUS_OUT_OF_MEMORY;
 	}
 
 	signal->manualReset = ManualReset;
 
+    signal->signalType  = gcvSIGNAL_NOPE;
+
 	init_completion(&signal->event);
 
 	atomic_set(&signal->ref, 1);
@@ -3439,15 +4356,25 @@ gckOS_DestroySignal(
 
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Signal != NULL);
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
 
 	signal = (gcsSIGNAL_PTR) Signal;
 
 	if (atomic_dec_and_test(&signal->ref))
 	{
-		 /* Free the sgianl. */
-		kfree(Signal);
+        /* Free the sgianl. */
+        kfree(Signal);
+        Signal = gcvNULL;
+        
 	}
+    else
+    {
+        gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+    		gcvZONE_OS,
+    		"Failed to destroy signal, it was not unmampped \n"
+		    );
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
 
 	/* Success. */
 	return gcvSTATUS_OK;
@@ -3663,6 +4590,15 @@ gckOS_MapSignal(
 	return gcvSTATUS_NOT_SUPPORTED;
 }
 
+gceSTATUS
+gckOS_UnMapSignal(
+	IN gckOS Os,
+	IN gctSIGNAL MappedSignal
+	)
+{
+	return gcvSTATUS_NOT_SUPPORTED;
+}
+
 #else
 
 /*******************************************************************************
@@ -3693,21 +4629,32 @@ gckOS_UserSignal(
 	IN gctHANDLE Process
 	)
 {
-	gceSTATUS status;
-	gctSIGNAL signal;
+	gceSTATUS status = gcvSTATUS_OK;
+	gctSIGNAL signal = gcvNULL;
+	gctBOOL sigMapped = gcvFALSE;
 
 	gcmkHEADER_ARG("Os=0x%x Signal=%d Process=0x%x",
 				   Os, (gctINT) Signal, Process);
 
 	/* Map the signal into kernel space. */
 	gcmkONERROR(gckOS_MapSignal(Os, Signal, Process, &signal));
+	sigMapped = gcvTRUE;
 
 	/* Signal. */
-	status = gckOS_Signal(Os, signal, gcvTRUE);
+    gcmkONERROR(gckOS_Signal(Os, signal, gcvTRUE));
+
+    /* UnMap the signal */
+    gcmkONERROR(gckOS_UnMapSignal(Os, signal));
+    
 	gcmkFOOTER();
-	return status;
+	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, sigMapped=%d", status, sigMapped);
+    if (sigMapped == gcvTRUE)
+    {
+        gcmkVERIFY_OK(gckOS_UnMapSignal(Os, signal));
+    }
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
@@ -3746,9 +4693,6 @@ gckOS_WaitSignal(
 	gcsSIGNAL_PTR signal;
 	gctUINT timeout;
 	gctUINT rc;
-#if MRVL_SILENT_RESET
-	gctUINT wait;
-#endif
 
 	gcmkHEADER_ARG("Os=0x%x Signal=0x%x Wait=%u", Os, Signal, Wait);
 
@@ -3758,15 +4702,8 @@ gckOS_WaitSignal(
 
 	signal = (gcsSIGNAL_PTR) Signal;
 
-#if MRVL_SILENT_RESET
-	wait = (Wait==gcvINFINITE)?1000:Wait;
-
-	/* Convert wait to milliseconds. */
-	timeout = wait*HZ/1000;
-#else
 	/* Convert wait to milliseconds. */
 	timeout = (Wait == gcvINFINITE) ? MAX_SCHEDULE_TIMEOUT : Wait*HZ/1000;
-#endif
 
 	/* Linux bug ? */
 	if (!signal->manualReset && timeout == 0) timeout = 1;
@@ -3774,22 +4711,64 @@ gckOS_WaitSignal(
 	rc = wait_for_completion_interruptible_timeout(&signal->event, timeout);
 	status = ((rc == 0) && !signal->event.done) ? gcvSTATUS_TIMEOUT
 												: gcvSTATUS_OK;
+    
+	/* Return status. */
+	gcmkFOOTER();
+	return status;
+}
 
-#if MRVL_SILENT_RESET
-    if (status==gcvSTATUS_TIMEOUT && Wait==gcvINFINITE)
-    {
-        gctBOOL isIdle;
-        gckHARDWARE_QueryIdle(Os->device->kernel->hardware, &isIdle);
-        /* printk("[galcore], timeout, isIdle=%d\n",isIdle); */
+/*******************************************************************************
+**
+**	gckOS_WaitSignalNoInterruptible
+**
+**	Wait for a signal to become signaled.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctUINT32 Wait
+**			Number of milliseconds to wait.
+**			Pass the value of gcvINFINITE for an infinite wait.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_WaitSignalNoInterruptible(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctUINT32 Wait
+	)
+{
+	gceSTATUS status;
+	gcsSIGNAL_PTR signal;
+	gctUINT timeout;
+	gctUINT rc;
 
-        if(isIdle == gcvFALSE)
-        {
-            printk("[galcore] %s : %d timeout, need to reset\n", __func__, __LINE__);
-            status = gckOS_Reset(Os);
-        }
-    }
-#endif
+	gcmkHEADER_ARG("Os=0x%x Signal=0x%x Wait=%u", Os, Signal, Wait);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+
+	signal = (gcsSIGNAL_PTR) Signal;
+
+	/* Convert wait to milliseconds. */
+	timeout = (Wait == gcvINFINITE) ? MAX_SCHEDULE_TIMEOUT : Wait*HZ/1000;
+
+	/* Linux bug ? */
+	if (!signal->manualReset && timeout == 0) timeout = 1;
 
+	rc = wait_for_completion_timeout(&signal->event, timeout);
+	status = ((rc == 0) && !signal->event.done) ? gcvSTATUS_TIMEOUT
+												: gcvSTATUS_OK;
+    
 	/* Return status. */
 	gcmkFOOTER();
 	return status;
@@ -3858,6 +4837,7 @@ gckOS_MapSignal(
 
 	if (atomic_inc_return(&signal->ref) <= 1)
 	{
+        gcmkLOG_WARNING_ARGS("Signal has been deleted before.");
 		/* The previous value is 0, it has been deleted. */
 		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
 	}
@@ -3872,6 +4852,64 @@ gckOS_MapSignal(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the staus. */
+	gcmkFOOTER();
+	return status;
+}
+
+
+
+/*******************************************************************************
+**
+**	gckOS_UnMapSignal
+**
+**	UnMap a signal .
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to that gctSIGNAL mapped.
+*/
+gceSTATUS
+gckOS_UnMapSignal(
+	IN gckOS Os,
+	IN gctSIGNAL MappedSignal
+	)
+{
+	gceSTATUS       status      = gcvSTATUS_OK;
+	gctBOOL         acquired    = gcvFALSE;
+    gcsSIGNAL_PTR   signal      = (gcsSIGNAL_PTR)MappedSignal;
+
+    gcmkVERIFY_ARGUMENT(MappedSignal != gcvNULL);
+
+    gcmkONERROR(gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+	acquired = gcvTRUE;
+
+	if (atomic_dec_return(&signal->ref) < 1)
+	{
+		/* The previous value is less than 1, it hasn't been mapped. */
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	/* Release the mutex. */
+	gcmkONERROR(gckOS_ReleaseMutex(Os, Os->signal.lock));
+
+	/* Success. */
+    gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -3909,6 +4947,7 @@ gceSTATUS
 gckOS_CreateUserSignal(
 	IN gckOS Os,
 	IN gctBOOL ManualReset,
+	IN gceSIGNAL_TYPE SignalType,
 	OUT gctINT * SignalID
 	)
 {
@@ -3940,6 +4979,7 @@ gckOS_CreateUserSignal(
 
 		if (table == gcvNULL)
 		{
+            gcmkLOG_WARNING_ARGS("Oops, out of memory to create signal table!");
 			/* Out of memory. */
 			gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
 		}
@@ -3969,9 +5009,12 @@ gckOS_CreateUserSignal(
 	/* Save the process ID. */
 	signal->process = (gctHANDLE) current->tgid;
 
+	/* Save the signal type. */
+	signal->signalType = SignalType;
+    
 	table[currentID] = signal;
 
-	/* Plus 1 to avoid NULL claims. */
+	/* Plus 1 to avoid gcvNULL claims. */
 	*SignalID = currentID + 1;
 
 	/* Update the currentID. */
@@ -4004,6 +5047,7 @@ gckOS_CreateUserSignal(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -4056,6 +5100,7 @@ gckOS_DestroyUserSignal(
 
 	if (SignalID < 1 || SignalID > Os->signal.tableLen)
 	{
+        gcmkLOG_WARNING_ARGS("invalid signalID {%d} to destroy", (gctINT) SignalID);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"gckOS_DestroyUserSignal: invalid signal->%d.",
@@ -4071,9 +5116,10 @@ gckOS_DestroyUserSignal(
 
 	if (signal == gcvNULL)
 	{
+        gcmkLOG_WARNING_ARGS("Error -> signal is gcvNULL");
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
-			"gckOS_DestroyUserSignal: signal is NULL."
+			"gckOS_DestroyUserSignal: signal is gcvNULL."
 			);
 
 		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
@@ -4082,6 +5128,8 @@ gckOS_DestroyUserSignal(
 	/* Check to see if the process is the owner of the signal. */
 	if (signal->process != (gctHANDLE) current->tgid)
 	{
+        gcmkLOG_WARNING_ARGS("signal->process: %d NOT equal to current->tgid: %d",
+                            signal->process, current->tgid);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"gckOS_DestroyUserSignal: process id doesn't match. ",
@@ -4110,6 +5158,7 @@ gckOS_DestroyUserSignal(
 	return gcvSTATUS_OK;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -4154,6 +5203,8 @@ gckOS_WaitUserSignal(
 	gceSTATUS status;
 	gcsSIGNAL_PTR signal;
 	gctBOOL acquired = gcvFALSE;
+    gctUINT thread;
+    gctUINT count = 1;
 
 	gcmkHEADER_ARG("Os=0x%x SignalID=%d Wait=%u", Os, SignalID, Wait);
 
@@ -4165,6 +5216,7 @@ gckOS_WaitUserSignal(
 
 	if (SignalID < 1 || SignalID > Os->signal.tableLen)
 	{
+        gcmkLOG_WARNING_ARGS("invalid signalID {%d} to destroy", (gctINT) SignalID);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"gckOS_WaitSignal: invalid signal.",
@@ -4183,16 +5235,21 @@ gckOS_WaitUserSignal(
 
 	if (signal == gcvNULL)
 	{
+        gcmkLOG_WARNING_ARGS("Signal is gcvNULL");
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
-			"gckOS_WaitSignal: signal is NULL."
+			"gckOS_WaitSignal: signal is gcvNULL."
 			);
 
 		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
 	}
 
+    gckOS_GetThreadID(&thread);
+
 	if (signal->process != (gctHANDLE) current->tgid)
 	{
+        gcmkLOG_WARNING_ARGS("signal->process: %d NOT equal to current->tgid: %d",
+                            signal->process, current->tgid);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"gckOS_WaitUserSignal: process id doesn't match. "
@@ -4203,13 +5260,44 @@ gckOS_WaitUserSignal(
 		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
 	}
 
-    status = gckOS_WaitSignal(Os, signal, Wait);
+    do {
+        #define MAX_WAIT_PERIOD_MSEC    10000
+        #define MAX_FORCE_RETURN_NPER   5
+
+        /* Split gcvINFINITE into slices, each slice is MAX_WAIT_PERIOD_MSEC millisecondes */
+        status = gckOS_WaitSignal(Os, signal, Wait == gcvINFINITE? MAX_WAIT_PERIOD_MSEC: Wait);
+
+        if (status == gcvSTATUS_TIMEOUT && Wait == gcvINFINITE)
+        {
+            gcmkPRINT("%s : %d\t<pid=%4d> [t=%d] SignalID: %4d, ProcessID: %4d, Type: %2x, index: %2d",
+                __FUNCTION__,
+                __LINE__,
+                thread,
+                count,
+                SignalID + 1,
+                signal->process,
+                signal->signalType & 0x0000FFFF,
+                (signal->signalType & 0xFFFF0000) >> gcmSIGNAL_OFFSET
+                );
+        }
+
+        /* Force waitUserSignal to return after MAX_FORCE_RETURN_NPER times trying. */
+        if (count++ >= MAX_FORCE_RETURN_NPER)
+        {
+            gcmkPRINT("%s : %d\t<pid=%d> Warning: force waitUserSignal to return.",
+                __FUNCTION__, __LINE__, thread);
+
+            status = gcvSTATUS_OK;
+            break;
+        }
+    }while(status == gcvSTATUS_TIMEOUT && Wait == gcvINFINITE);
 
 	/* Return the status. */
 	gcmkFOOTER();
 	return status;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -4267,6 +5355,7 @@ gckOS_SignalUserSignal(
 	||  (SignalID > Os->signal.tableLen)
 	)
 	{
+        gcmkLOG_WARNING_ARGS("invalid signalID {%d} to destroy", (gctINT) SignalID);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,  gcvZONE_OS,
 					   "gckOS_WaitSignal: invalid signal->%d.", SignalID);
 
@@ -4282,9 +5371,10 @@ gckOS_SignalUserSignal(
 
 	if (signal == gcvNULL)
 	{
+        gcmkLOG_WARNING_ARGS("Error -> signal is gcvNULL");
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
-			"gckOS_WaitSignal: signal is NULL."
+			"gckOS_WaitSignal: signal is gcvNULL."
 			);
 
 		gcmkONERROR(gcvSTATUS_INVALID_REQUEST);
@@ -4292,6 +5382,8 @@ gckOS_SignalUserSignal(
 
 	if (signal->process != (gctHANDLE) current->tgid)
 	{
+        gcmkLOG_WARNING_ARGS("signal->process: %d NOT equal to current->tgid: %d",
+                            signal->process, current->tgid);
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"gckOS_DestroyUserSignal: process id doesn't match. ",
@@ -4309,6 +5401,7 @@ gckOS_SignalUserSignal(
 	return status;
 
 OnError:
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
 	if (acquired)
 	{
 		/* Release the mutex. */
@@ -4426,12 +5519,19 @@ gckOS_MapUserMemory(
 		"[gckOS_MapUserMemory] enter."
 		);
 
+    /* If logic address cannot satisfy alignment, physical also cannot align */
+    if((unsigned int)Memory & (ALLOC_ALIGN_BYTES - 1))
+    {
+        gcmkPRINT("gckOS_MapUserMemory: address is %x, cannot satisfy alignment request! \n", (unsigned int)Memory);
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
 	do
 	{
 		memory = (gctUINT32) Memory;
 
 		/* Get the number of required pages. */
-		end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	 	end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		start = memory >> PAGE_SHIFT;
 		pageCount = end - start;
 
@@ -4469,6 +5569,7 @@ gckOS_MapUserMemory(
 
 		if (pages == gcvNULL)
 		{
+            gcmkLOG_WARNING_ARGS("out of memory to allocate page");
 			status = gcvSTATUS_OUT_OF_MEMORY;
 			break;
 		}
@@ -4482,11 +5583,11 @@ gckOS_MapUserMemory(
 					1,
 					0,
 					pages,
-					NULL
+					gcvNULL
 					);
 		up_read(&current->mm->mmap_sem);
 
-		if (result <=0 || result < pageCount)
+        if (result <=0 || result < pageCount)
 		{
 			struct vm_area_struct *vma;
 
@@ -4500,8 +5601,8 @@ gckOS_MapUserMemory(
 					spinlock_t 	* ptl;
 					unsigned long pfn;
 
-				pgd_t * pgd = pgd_offset(current->mm, memory);
-					pud_t * pud = pud_alloc(current->mm, pgd, memory);
+		    		pgd_t * pgd = pgd_offset(current->mm, memory);
+	   				pud_t * pud = pud_alloc(current->mm, pgd, memory);
 					if (pud)
 					{
 						pmd_t * pmd = pmd_alloc(current->mm, pud, memory);
@@ -4566,11 +5667,7 @@ gckOS_MapUserMemory(
 		{
 			/* Flush the data cache. */
 #ifdef ANDROID
-			dma_sync_single_for_device(
-						gcvNULL,
-						page_to_phys(pages[i]),
-						PAGE_SIZE,
-						DMA_TO_DEVICE);
+		    dma_map_page(gcvNULL, pages[i], 0, PAGE_SIZE, DMA_TO_DEVICE); 
 #else
 			flush_dcache_page(pages[i]);
 #endif
@@ -4617,25 +5714,29 @@ gckOS_MapUserMemory(
 		/* Return address. */
 		*Address = address + (memory & ~PAGE_MASK);
 
-		gcmkTRACE_ZONE(gcvLEVEL_INFO,
-			gcvZONE_OS,
-			"[gckOS_MapUserMemory] Address: 0x%x.",
-			*Address
-			);
+  		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    		gcvZONE_OS,
+    		"[gckOS_MapUserMemory] Address: 0x%x.",
+    		*Address
+    	    );
 
-		/* Success. */
-		status = gcvSTATUS_OK;
+    	/* Success. */
+    	status = gcvSTATUS_OK;
 	}
 	while (gcvFALSE);
 
 	if (gcmIS_ERROR(status))
 	{
+        gcmkLOG_ERROR_STATUS();
 		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
 			gcvZONE_OS,
 			"[gckOS_MapUserMemory] error occured: %d.",
 			status
 			);
 
+        *Address    = 0;
+		*Info       = gcvNULL;
+
 		/* Release page array. */
 		if (result > 0 && pages != gcvNULL)
 		{
@@ -4651,11 +5752,7 @@ gckOS_MapUserMemory(
 					break;
 				}
 #ifdef ANDROID
-				dma_sync_single_for_device(
-							gcvNULL,
-							page_to_phys(pages[i]),
-							PAGE_SIZE,
-							DMA_FROM_DEVICE);
+			    dma_map_page(gcvNULL, pages[i], 0, PAGE_SIZE, DMA_TO_DEVICE); 
 #endif
 				page_cache_release(pages[i]);
 			}
@@ -4683,7 +5780,6 @@ gckOS_MapUserMemory(
 
 			/* Free the page info struct. */
 			kfree(info);
-			*Info = gcvNULL;
 		}
 	}
 
@@ -4822,11 +5918,7 @@ gckOS_UnmapUserMemory(
 			}
 
 #ifdef ANDROID
-			dma_sync_single_for_device(
-						gcvNULL,
-						page_to_phys(pages[i]),
-						PAGE_SIZE,
-						DMA_FROM_DEVICE);
+			dma_map_page(gcvNULL, pages[i], 0, PAGE_SIZE, DMA_TO_DEVICE); 
 #endif
 			page_cache_release(pages[i]);
 		}
@@ -4842,9 +5934,12 @@ gckOS_UnmapUserMemory(
 		if (info->pages != gcvNULL)
 		{
 			kfree(info->pages);
+            info->pages = gcvNULL;
 		}
 
 		kfree(info);
+
+        info = gcvNULL;
 	}
 
 	MEMORY_MAP_UNLOCK(Os);
@@ -4879,846 +5974,1410 @@ gckOS_GetBaseAddress(
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 	gcmkVERIFY_ARGUMENT(BaseAddress != gcvNULL);
 
-	/* Return base address. */
-	*BaseAddress = Os->baseAddress;
+	/* Return base address. */
+	*BaseAddress = Os->baseAddress;
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_SuspendInterrupt(
+	IN gckOS Os
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	disable_irq(Os->device->irqLine);
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ResumeInterrupt(
+	IN gckOS Os
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	enable_irq(Os->device->irqLine);
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ClockOff(
+    IN gckOS Os,
+    IN gctBOOL disableClk,
+    IN gctBOOL disablePwr
+	)
+{
+
+#if SEPARATE_CLOCK_AND_POWER
+    if(disablePwr)
+    {
+        gc_pwr(0);
+        /* gcmkPRINT("[galcore]: pwr disable\n"); */
+    }
+#endif
+
+    if(disableClk)
+    {
+        static gctUINT count = 0;
+#if MRVL_CONFIG_AXICLK_CONTROL
+        static struct clk * clkAXI = gcvNULL;
+#endif
+        static struct clk * clkGC = gcvNULL;
+
+        if(count == 0)
+        {
+            clkGC = clk_get(gcvNULL, "GCCLK");
+            CLOCK_VERIFY(clkGC);
+        }
+        clk_disable(clkGC);
+        
+        if(Os && Os->device)
+        {
+            Os->device->clkEnabled = gcvFALSE;
+        }
+ 
+#if MRVL_CONFIG_AXICLK_CONTROL
+        if(count == 0)
+        {
+            clkAXI = clk_get(gcvNULL, "AXICLK");
+            CLOCK_VERIFY(clkAXI);
+        }
+    	/* decrease AXICLK count in kernel */
+        clk_disable(clkAXI);
+#endif
+        count++;
+    }
+    
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ClockOn(
+    IN gckOS Os,
+    IN gctBOOL enableClk,
+    IN gctBOOL enablePwr,
+	IN gctUINT64 Frequency
+	)
+{
+    if(enableClk)
+    {
+        static gctUINT count = 0;
+#if MRVL_CONFIG_AXICLK_CONTROL
+        static struct clk * clkAXI = gcvNULL;
+#endif
+        static struct clk * clkGC = gcvNULL;
+        
+#if MRVL_CONFIG_AXICLK_CONTROL
+        if(count == 0)
+        {
+            clkAXI = clk_get(gcvNULL, "AXICLK");
+            CLOCK_VERIFY(clkAXI);
+        }
+    	/* increase AXICLK count in kernel */
+    	clk_enable(clkAXI);
+#endif
+        if(count == 0)
+        {
+            clkGC = clk_get(gcvNULL, "GCCLK");
+            CLOCK_VERIFY(clkGC);
+        }
+        if(Frequency != 0)
+        {
+            /* APMU_GC_156M, APMU_GC_624M, APMU_GC_PLL2, APMU_GC_PLL2_DIV2 currently */
+            gcmkPRINT("\n[galcore] clk input = %dM Hz; running on %dM Hz\n",(int)Frequency, (int)Frequency/2);
+            if (clk_set_rate(clkGC, Frequency*1000*1000))
+            {
+                gcmkLOG_ERROR_ARGS("Set gpu core clock rate error.");
+               	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+            	    	      "[galcore] Can't set core clock.");
+                return -EAGAIN;
+            }
+        }
+
+        clk_enable(clkGC);
+
+        if(Os && Os->device)
+        {
+            Os->device->clkEnabled = gcvTRUE;
+        }
+        /* gcmkPRINT("[galcore]: clk enable\n"); */
+        count++;
+    }
+
+#if SEPARATE_CLOCK_AND_POWER
+    if(enablePwr)
+    {
+        gc_pwr(1);
+        /* gcmkPRINT("[galcore]: pwr enable\n"); */
+    }
+#endif
+ 
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_PowerOff(
+	IN gckOS Os
+	)
+{
+    return gcvSTATUS_OK;
+}
+gceSTATUS
+gckOS_PowerOffWhenIdle(
+	IN gckOS Os,
+	IN gctBOOL needProfile
+	)
+{
+	gceSTATUS status;
+    static gctUINT32 countDelay = 0;
+    gckHARDWARE hardware = Os->device->kernel->hardware;
+    gctUINT32 idleTime, timeSlice, tailTimeSlice, tailIdleTime;
+
+    gcmkHEADER_ARG("Os=0x%x", Os);
+    
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    timeSlice = Os->device->profileTimeSlice; 
+    tailTimeSlice = Os->device->profileTailTimeSlice;
+    
+    /* before the first time profiling, delay to make sure the profiling data is valid */
+    if(countDelay++ == 0)
+        gckOS_Delay(Os, timeSlice);
+    
+    if(needProfile)
+    {
+        gcmkONERROR(gckOS_IdleProfile(Os, &timeSlice, 
+                            &idleTime, gcvNULL));
+
+        if(Os->device->powerDebug)
+        {
+            gcmkPRINT("idle:total [%d, %d]\n",idleTime, timeSlice); 
+        }
+        
+        gcmkONERROR(gckOS_IdleProfile(Os, &tailTimeSlice, 
+                            &tailIdleTime, gcvNULL));
+        
+        if(Os->device->powerDebug)
+        {
+            gcmkPRINT("idle:total [%d, %d]\n", tailIdleTime, tailTimeSlice); 
+        }
+        if( (idleTime * 100 > timeSlice * Os->device->idleThreshold)
+            && (tailIdleTime == tailTimeSlice) )
+        {
+            Os->device->needPowerOff = gcvTRUE;
+        }
+        else
+        {
+            Os->device->needPowerOff = gcvFALSE; 
+        }
+    }
+    
+    if(Os->device->needPowerOff 
+        && (Os->device->currentPMode != gcvPM_NORMAL))
+    {
+        gcmkONERROR(gckHARDWARE_SetPowerManagementState(hardware, gcvPOWER_OFF));
+
+        BSP_IDLE_PROFILE_CALC_IDLE_TIME;
+    }
 
-	/* Success. */
-	return gcvSTATUS_OK;
+	gcmkFOOTER_NO();
+    
+    return gcvSTATUS_OK;
+
+OnError:
+
+    /* Return status. */
+    gcmkFOOTER();
+    return status;
 }
 
 gceSTATUS
-gckOS_SuspendInterrupt(
+gckOS_Reset(
 	IN gckOS Os
 	)
 {
+    gceSTATUS status = gcvSTATUS_OK;
+    gckHARDWARE hardware = Os->device->kernel->hardware;
+    gckEVENT event = Os->device->kernel->event;
+    gckCOMMAND command = Os->device->kernel->command;
+    static gctUINT resetCount;
+
+    gcmkHEADER_ARG("Os=0x%x", Os);
+    
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-	disable_irq(Os->device->irqLine);
+    if(Os->device->powerDebug)
+    {
+        gcmkPRINT("[galcore] %s, need to reset, chipPowerState=%d\n", __func__, hardware->chipPowerState);
+    }
+    
+	/* Stop the command parser. */
+    /* gckCOMMAND_Stop may delay on "wait for idle" 
+       use gckHARDWARE_End to stop GC directly
+    */
+	if (command->running)
+	{
+        /* Replace last WAIT with END. */
+        gcmkONERROR(
+    		gckHARDWARE_End(hardware,
+    						command->wait,
+    						&command->waitSize));
+
+    	/* Command queue is no longer running. */
+    	command->running = gcvFALSE;
+	}
+
+    gcmkONERROR(gckOS_SuspendInterrupt(Os));
+    gcmkONERROR(gckOS_ClockOff(Os, gcvTRUE, gcvTRUE));
+
+    gcmkONERROR(gckOS_ClockOn(Os, gcvTRUE, gcvTRUE, 0));
+    gcmkONERROR(gckOS_ResumeInterrupt(Os));
+
+	/* Initialize hardware. */
+	gcmkONERROR(
+		gckHARDWARE_InitializeHardware(hardware));
+ 
+	gcmkONERROR(
+		gckHARDWARE_SetFastClear(hardware,
+								 hardware->allowFastClear,
+								 hardware->allowCompression));
+
+	/* Force the command queue to reload the next context. */
+	command->currentContext = 0;
+
+	/* Sleep for 1000us, to make sure everything is powered on. */
+	gckOS_Udelay(Os, 1000);
+	
+	/* Start the command processor. */
+	gcmkONERROR(gckCOMMAND_Start(command));
+
+    /* trigger any commited event */
+	gcmkONERROR(gckEVENT_Interrupt(event, 0x7FFFFFFF));
+    gcmkONERROR(gckEVENT_Notify(event, 1));
+   
+    if(Os->device->powerDebug)
+    {
+        gcmkPRINT("[galcore] %s : resetCount=%d \n", __func__, resetCount++);
+    }
+
+    gcmkFOOTER();
+    return status;
+    
+
+OnError:
+    gcmkPRINT("ERROR: %s has error \n",__func__);
+    return status;
 
-	return gcvSTATUS_OK;
 }
 
 gceSTATUS
-gckOS_ResumeInterrupt(
-	IN gckOS Os
-	)
+gckOS_SetConstraint(
+	IN gckOS Os,
+	IN gctBOOL enableDVFM,
+	IN gctBOOL enableLPM
+        )
 {
-	/* Verify the arguments. */
+    gcmkHEADER_ARG("Os=0x%x", Os);
+        
+    /* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-	enable_irq(Os->device->irqLine);
+#if 0 /*MRVL_CONFIG_DVFM_MMP2*/
+    if(enableDVFM)
+    {
+        /* disable OP0(100M), OP4(1001M) on mmp2 */
+        dvfm_disable_op_name("Ultra Low MIPS", Os->device->dvfm_dev_index);
+		dvfm_disable_op_name("Super H MIPS", Os->device->dvfm_dev_index);
+    }
+#endif
+    
+#if MRVL_CONFIG_DVFM_MG1
 
-	return gcvSTATUS_OK;
-}
+#if 0
+    if(enableDVFM)
+    {
+        /* disable LPM and OP1 - OP5 on PV2 evb */
+        dvfm_disable(Os->device->dvfm_dev_index);
+    }
+#else
+    if(enableLPM)
+    {
+         /* gcmkPRINT("\n Idle = false, disable low power mode\n"); */
+        /* Disable D0CS */
+        dvfm_disable_op_name("D0CS", Os->device->dvfm_dev_index);
+        /* Disable Low power mode */
+        dvfm_disable_op_name("D1", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("D2", Os->device->dvfm_dev_index);
+        /* Disable CG */
+        if(cpu_is_pxa95x())
+        {
+            dvfm_disable_op_name("CG", Os->device->dvfm_dev_index);
+        }
+    }
 
-gceSTATUS
-gckOS_ClockOff(
-    void
-	)
-{
-    struct clk * clk = NULL;
+    if(enableDVFM)
+    {
 
-#ifdef CONFIG_PXA_DVFM
-    gc_pwr(0);
+        /* Disable OP1 - OP7  on PV2 evb */
+        dvfm_disable_op_name("156M", Os->device->dvfm_dev_index);
+        /* dvfm_disable_op_name("208M", Os->device->dvfm_dev_index); */
+        dvfm_disable_op_name("156M_HF", Os->device->dvfm_dev_index);
+        /* dvfm_disable_op_name("208M_HF", Os->device->dvfm_dev_index); */
+        /* dvfm_disable_op_name("416M", Os->device->dvfm_dev_index); */
+         /* dvfm_disable_op_name("624M", Os->device->dvfm_dev_index); */
+         /* dvfm_disable_op_name("832M", Os->device->dvfm_dev_index); */
+         /* dvfm_disable(Os->device->dvfm_dev_index); */
+    }
 #endif
 
-    clk = clk_get(NULL, "gpu_clk");
-    CLOCK_VERIFY(clk);
-    clk_disable(clk);
-    clk_unprepare(clk);
-
-#ifdef CONFIG_PXA_DVFM
-	/* decrease AXICLK count in kernel */
-    clk = NULL;
-    clk = clk_get(NULL, "axi_clk");
-    CLOCK_VERIFY(clk);
-    clk_disable(clk);
-    clk_unprepare(clk);
 #endif
 
-	return gcvSTATUS_OK;
+    gcmkFOOTER_NO();
+
+    return gcvSTATUS_OK;
 }
 
 gceSTATUS
-gckOS_ClockOn(
-	IN gctUINT64 Frequency
+gckOS_UnSetConstraint(
+	IN gckOS Os,
+	IN gctBOOL enableDVFM,
+	IN gctBOOL enableLPM
 	)
 {
-    struct clk * clk = NULL;
-
-#ifdef CONFIG_PXA_DVFM
-	/* increase AXICLK count in kernel */
-    clk = clk_get(NULL, "axi_clk");
-    CLOCK_VERIFY(clk);
-    clk_prepare(clk);
-    clk_enable(clk);
-    clk = NULL;
-#endif
+    gcmkHEADER_ARG("Os=0x%x", Os);
+        
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-    clk = clk_get(NULL, "gpu_clk");
-    CLOCK_VERIFY(clk);
+#if 0 /*MRVL_CONFIG_DVFM_MMP2*/
+    if(enableDVFM)
+    {
+        /* enable OP0(100M), OP4(1001M) on mmp2 */
+        dvfm_enable_op_name("Ultra Low MIPS", Os->device->dvfm_dev_index);
+		dvfm_enable_op_name("Super H MIPS", Os->device->dvfm_dev_index);
+    }
+#endif
+    
+#if MRVL_CONFIG_DVFM_MG1
 
-    if(Frequency != 0)
+#if 0
+    if(enableDVFM)
+    {
+        /* enable LPM and OP1 - OP5 on PV2 evb  */
+        dvfm_enable(Os->device->dvfm_dev_index);
+    }
+#else
+    if(enableLPM)
     {
-        /* APMU_GC_156M, APMU_GC_624M, APMU_GC_PLL2, APMU_GC_PLL2_DIV2 currently */
-        printk("\n[galcore] clk input = %dM Hz; running on %dM Hz\n",(int)Frequency, (int)Frequency/2);
-        if (clk_set_rate(clk, Frequency*1000*1000))
+         /* gcmkPRINT("\n Idle = true, enable low power mode\n"); */
+        /* Enable D0CS */
+        dvfm_enable_op_name("D0CS", Os->device->dvfm_dev_index);
+        /* Enable Low power mode */
+        dvfm_enable_op_name("D1", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("D2", Os->device->dvfm_dev_index);
+        /* Enable CG */
+        if(cpu_is_pxa95x())
         {
-		gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
-			      "[galcore] Can't set core clock.");
-            return -EAGAIN;
+            dvfm_enable_op_name("CG", Os->device->dvfm_dev_index);
         }
     }
-    clk_prepare(clk);
-    clk_enable(clk);
 
-#ifdef CONFIG_PXA_DVFM
-    gc_pwr(1);
+    if(enableDVFM)
+    {
+
+        /* Enable OP1 - OP7 on PV2 evb */
+        dvfm_enable_op_name("156M", Os->device->dvfm_dev_index);
+        /* dvfm_enable_op_name("208M", Os->device->dvfm_dev_index); */
+        dvfm_enable_op_name("156M_HF", Os->device->dvfm_dev_index);
+        /* dvfm_enable_op_name("208M_HF", Os->device->dvfm_dev_index); */
+        /* dvfm_enable_op_name("416M", Os->device->dvfm_dev_index); */
+         /* dvfm_enable_op_name("624M", Os->device->dvfm_dev_index); */
+         /* dvfm_enable_op_name("832M", Os->device->dvfm_dev_index); */
+         /* dvfm_enable(Os->device->dvfm_dev_index); */
+    }
+#endif
+
 #endif
 
-	return gcvSTATUS_OK;
+    gcmkFOOTER_NO();
+
+    return gcvSTATUS_OK;
 }
 
 gceSTATUS
-gckOS_Reset(
-	IN gckOS Os
+gckOS_AddProfNode(
+	IN gckOS Os,
+	IN gctBOOL Idle
 	)
 {
-    gceSTATUS status;
-    gckHARDWARE hardware = Os->device->kernel->hardware;
-    gckEVENT event = Os->device->kernel->event;
-    gckCOMMAND command = Os->device->kernel->command;
-    gctUINT32 data = 0;
-
+	gcmkHEADER_ARG("Os=0x%x", Os);
+        
 	/* Verify the arguments. */
 	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-    if(Os->device->reset)
-	{
-         /*  Stall */
-	{
-            /* Acquire the context switching mutex so nothing else can be
-		** committed. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Os,
-							   command->mutexContext,
-							   gcvINFINITE));
+    /* Grab the mutex. */
+   	gcmkVERIFY_OK(gckOS_AcquireMutex(Os, Os->mutexIdleProfile, gcvINFINITE));
 
-             /*  mdelay(); */
-	}
-	 /*  Stop */
-	{
-		/* Stop the command parser. */
-		gcmkONERROR(
-			gckCOMMAND_Stop(command));
+    
+	Os->device->lastNodeIndex = (Os->device->lastNodeIndex + 1) % NUM_PROFILE_NODES; 
+    Os->device->profNode[Os->device->lastNodeIndex].idle = Idle;
+    Os->device->profNode[Os->device->lastNodeIndex].tick = gckOS_GetTicks();
 
-		/* Grab the command queue mutex so nothing can get access to the
-		** command queue. */
-		gcmkONERROR(
-			gckOS_AcquireMutex(Os,
-							   command->mutexQueue,
-							   gcvINFINITE));
-	}
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->mutexIdleProfile));
 
-        gckOS_SuspendInterrupt(Os);
-        gckOS_ClockOff();
+	gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
 
-		/* Read AQIntrAcknowledge register. */
-		gcmkVERIFY_OK(gckOS_ReadRegister(Os,
-										0x00010,
-									    &data));
+gceSTATUS
+gckOS_NotifyIdle(
+	IN gckOS Os,
+	IN gctBOOL Idle
+	)
+{
+	gcmkHEADER_ARG("Os=0x%x Idle=%d", Os, Idle);
+        
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-        /* trigger any commited event */
-	gcmkVERIFY_OK(gckEVENT_Interrupt(event, data));
-        gcmkVERIFY_OK(gckEVENT_Notify(event, 1));
+    gckOS_AddProfNode(Os, Idle);
+    
+    /* gcmkPRINT("[galcore] %s:\n",Idle?"Idle,freq scale to 1/64":"Running"); */
+    if(Idle)
+    {
+        /* GC changes from run to idle, start profiling */
+        BSP_IDLE_PROFILE_CALC_BUSY_TIME;
 
-        gckOS_ClockOn(0);
-        gckOS_ResumeInterrupt(Os);
+#if MRVL_PLATFORM_MG1
+        gckHARDWARE_SetPowerManagementState(Os->device->kernel->hardware, gcvPOWER_SUSPEND);
+#else
+#if MRVL_ENABLE_FREQ_SCALING
+        /* frequence change to 1/64 */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x204));
+        /* Loading the frequency scaler. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x004));
 
-         /*  Initialize */
-	{
-		/* Initialize hardware. */
-		gcmkONERROR(
-			gckHARDWARE_InitializeHardware(hardware));
+        gckOS_UnSetConstraint(Os, 
+            Os->device->enableDVFM,
+            Os->device->enableLowPowerMode);
+#endif
+#endif
+    }
+    else
+    {
+#if MRVL_PLATFORM_MG1
+#else
+#if MRVL_ENABLE_FREQ_SCALING
+        /* Write the clock control register. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x300));
+        /* Done loading the frequency scaler. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x100));
 
-		gcmkONERROR(
-			gckHARDWARE_SetFastClear(hardware,
-									 hardware->allowFastClear,
-									 hardware->allowCompression));
+        gckOS_SetConstraint(Os, 
+            Os->device->enableDVFM,
+            Os->device->enableLowPowerMode);
+#endif
+#endif        
+        /* GC changes from idle to run, end profiling */
+        BSP_IDLE_PROFILE_CALC_IDLE_TIME;
+    }
+    
+	gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+}
 
-		/* Force the command queue to reload the next context. */
-		command->currentContext = 0;
-	}
+gctUINT32 
+gckOS_GetTicks(
+    void
+    )
+{
+    struct timeval tv;
+    unsigned int tickcount = 0;
+    do_gettimeofday(&tv);
+    tickcount = (tv.tv_sec*1000 + tv.tv_usec/1000);
+    return tickcount;
+}
 
-	/* Sleep for 1ms, to make sure everything is powered on. */
-	gcmkVERIFY_OK(gckOS_Delay(Os, 1));
+gceSTATUS
+gckOS_IdleProfile(
+    IN gckOS Os,
+    IN OUT gctUINT32* Timeslice,
+    OUT gctUINT32* IdleTime,
+    OUT gctUINT32* StateSwitchTimes
+    )
+{
+    gctUINT i;
+    gceSTATUS status;
+    gctBOOL acquired = gcvFALSE;
+    gctUINT currentTick;
+    gckProfNode firstNode;
+    gckProfNode lastNode;
+    gckProfNode iterNode; /* first node in the time slice */
+    gckProfNode nextNode; /* the next node of iterNode */
+    gctUINT firstIndex, lastIndex, iterIndex;
+    gctUINT idleTime = 0;
 
-	 /*  start */
-	{
-            /* Release the command mutex queue. */
-		gcmkONERROR(
-			gckOS_ReleaseMutex(Os,
-							   command->mutexQueue));
-		/* Start the command processor. */
-		gcmkONERROR(
-			gckCOMMAND_Start(command));
-	}
-	 /*  release context mutex */
-	{
-		/* Release the context switching mutex. */
-		gcmkONERROR(
-			gckOS_ReleaseMutex(Os,
-							   command->mutexContext));
-	}
+	gcmkHEADER_ARG("Os=0x%x Timeslice=0x%x IdleTime=0x%x", Os, Timeslice, IdleTime);
+    
+    /* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Timeslice != gcvNULL);
+    gcmkVERIFY_ARGUMENT(IdleTime != gcvNULL);
+
+    /* Grab the mutex. */
+	gcmkONERROR(gckOS_AcquireMutex(Os,
+									Os->mutexIdleProfile,
+									gcvINFINITE));
+    acquired = gcvTRUE;
+    			  
+    currentTick = gckOS_GetTicks();
+    lastIndex = Os->device->lastNodeIndex;
+    iterIndex = lastIndex;
+    firstIndex = (Os->device->lastNodeIndex + 1) % NUM_PROFILE_NODES;
+    firstNode = &Os->device->profNode[firstIndex];
+    lastNode = &Os->device->profNode[lastIndex];
+    
+    /* gcmkPRINT("@@@@@@[first last] [%d, %d]\n",firstIndex,lastIndex); */
+    
+    /* no node in the time slice */
+    if(currentTick - lastNode->tick >= *Timeslice)
+    {
+        if(lastNode->idle)
+        {
+            idleTime += *Timeslice;
+            /* gcmkPRINT("line %d, idletime : %d",__LINE__, idleTime); */
+        }
+    }
+    else
+    {
+        /* find first node in the time slice */
+        if(currentTick - firstNode->tick < *Timeslice)
+        {
+            /* */
+            *Timeslice = currentTick - firstNode->tick;
+            
+            iterIndex = firstIndex;
+            iterNode = &Os->device->profNode[iterIndex];
+        }
+        else
+        {
+            for(i = 0; i < NUM_PROFILE_NODES; i++)
+            {
+                iterIndex = (firstIndex + i) % NUM_PROFILE_NODES;
+                iterNode = &Os->device->profNode[iterIndex];
+                if(currentTick - iterNode->tick < *Timeslice)
+                {
+                    break;
+                }
+            }
+        }
+        /* gcmkPRINT("line %d, iterIndex : %d\n",__LINE__, iterIndex); */
+        
+        if(StateSwitchTimes != gcvNULL)
+        {
+            *StateSwitchTimes = (lastIndex - iterIndex + NUM_PROFILE_NODES) % NUM_PROFILE_NODES + 1;
+        }
+        
+        /* startTick to first node time */
+        if(!iterNode->idle)
+        {
+            idleTime += iterNode->tick - (currentTick - *Timeslice);
+            /* gcmkPRINT("line %d, idletime : %d\n",__LINE__, idleTime); */
+        }
 
-        hardware->chipPowerState = gcvPOWER_ON;
+        /* last node to currentTick time */
+        if(lastNode->idle)
+        {
+            idleTime += currentTick - lastNode->tick;
+            /* gcmkPRINT("line %d, idletime : %d\n",__LINE__, idleTime); */
+        }
 
-        printk("[galcore] %s : %d \n", __func__, __LINE__);
+        /* first node to last node time */
+        for(i = 0; i < NUM_PROFILE_NODES; i++ )
+        {
+            if(iterIndex == lastIndex)
+                break;
 
-        return status;
+            if(iterNode->idle)
+            {
+                nextNode = &Os->device->profNode[(iterIndex + 1) % NUM_PROFILE_NODES];
+                idleTime += nextNode->tick - iterNode->tick;
+                /* gcmkPRINT("line %d, idletime : %d\n",__LINE__, idleTime); */
+            }
+            iterIndex = (iterIndex + 1) % NUM_PROFILE_NODES;
+            iterNode = &Os->device->profNode[iterIndex];
+        }
+        
     }
-
-    return gcvSTATUS_SKIP;
+    
+    *IdleTime = idleTime;
+    
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->mutexIdleProfile));
+        
+	gcmkFOOTER_NO();
+    
+    return gcvSTATUS_OK;
 
 OnError:
-    printk("ERROR: %s has error \n",__func__);
-    return status;
+    gcmkLOG_ERROR_ARGS("status=%d, acquired=%d", status, acquired);
+    if (acquired)
+    {
+        /* Release command queue mutex on error. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->mutexIdleProfile));
+    }
+
+    /* Return status. */
+    gcmkFOOTER();
+    return status;          
 
 }
 
-gceSTATUS
-gckOS_SetConstraint(
-	IN gckOS Os,
-	IN gctBOOL enableDVFM,
-	IN gctBOOL enableLPM
-        )
+gceSTATUS gckOS_DumpToFile(
+    IN gckOS Os,
+    IN gctCONST_STRING filename,
+    IN gctPOINTER logical,
+    IN gctSIZE_T size
+    )
 {
-    /* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    struct file *file = gcvNULL;
+    mm_segment_t old_fs = get_fs();
+    set_fs(get_ds());
 
-#ifdef CONFIG_CPU_MMP2
-    if(enableDVFM)
+    file = filp_open(filename, O_WRONLY|O_CREAT, 0);
+    if ((file != gcvNULL ) && (file->f_op->read != gcvNULL))
     {
-        /* disable LPM and OP1 - OP5 on mmp2 */
-        dvfm_disable(Os->device->dvfm_dev_index);
+        if(logical != gcvNULL)
+        {
+            file->f_op->write(file, logical, size, &file->f_pos);
+            return gcvSTATUS_INVALID_ARGUMENT;
+        }
+        filp_close(file, gcvNULL);
+        
+        return gcvSTATUS_NOT_SUPPORTED;
     }
-#endif
 
-#ifdef CONFIG_PXA_DVFM
+    set_fs(old_fs);
 
-#if 0
-    if(enableDVFM)
-    {
-        /* disable LPM and OP1 - OP5 on PV2 evb */
-        dvfm_disable(Os->device->dvfm_dev_index);
-    }
-#else
-    if(enableLPM)
-    {
-         /* printk("\n Idle = false, disable low power mode\n"); */
-        /* Disable D0CS */
-        dvfm_disable_op_name("D0CS", Os->device->dvfm_dev_index);
-        /* Disable Low power mode */
-        dvfm_disable_op_name("D1", Os->device->dvfm_dev_index);
-        dvfm_disable_op_name("D2", Os->device->dvfm_dev_index);
-        /* Disable CG */
-        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
-            dvfm_disable_op_name("CG", Os->device->dvfm_dev_index);
-    }
+    /* Success. */
+	return gcvSTATUS_OK;
+}
 
-    if(Os->device->enableD1)
-    {
-        dvfm_disable_op_name("D1", Os->device->dvfm_dev_index);
-    }
+gceSTATUS
+gckOS_MemCopy(
+        IN gctPOINTER Destination,
+        IN gctCONST_POINTER Source,
+        IN gctSIZE_T Bytes
+        )
+{
+    gcmkVERIFY_ARGUMENT(Destination != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Source != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
 
-    if(Os->device->enableD2)
-    {
-        dvfm_disable_op_name("D2", Os->device->dvfm_dev_index);
-    }
+    memcpy(Destination, Source, Bytes);
 
-    if(Os->device->enableD0CS)
-    {
-        dvfm_disable_op_name("D0CS", Os->device->dvfm_dev_index);
-    }
+    return gcvSTATUS_OK;
+}
 
-    if(Os->device->enableCG)
-    {
-        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
-            dvfm_disable_op_name("CG", Os->device->dvfm_dev_index);
-    }
+gceSTATUS
+gckOS_ZeroMemory(
+	IN gctPOINTER Memory,
+	IN gctSIZE_T Bytes
+	)
+{
+	gcmkHEADER_ARG("Memory=0x%x Bytes=%lu", Memory, Bytes);
 
-    if(enableDVFM)
-    {
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
 
-        /* Disable OP1 - OP7  on PV2 evb */
-        dvfm_disable_op_name("156M", Os->device->dvfm_dev_index);
-        dvfm_disable_op_name("208M", Os->device->dvfm_dev_index);
-        dvfm_disable_op_name("156M_HF", Os->device->dvfm_dev_index);
-        dvfm_disable_op_name("208M_HF", Os->device->dvfm_dev_index);
-        dvfm_disable_op_name("416M", Os->device->dvfm_dev_index);
-         /* dvfm_disable_op_name("624M", Os->device->dvfm_dev_index); */
-         /* dvfm_disable_op_name("832M", Os->device->dvfm_dev_index); */
-         /* dvfm_disable(Os->device->dvfm_dev_index); */
-    }
-#endif
+	memset(Memory, 0, Bytes);
 
-#endif
-        return gcvSTATUS_OK;
+	gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
 }
 
-gceSTATUS
-gckOS_UnSetConstraint(
-	IN gckOS Os,
-	IN gctBOOL enableDVFM,
-	IN gctBOOL enableLPM
+#if gcdkUSE_MEMORY_RECORD
+MEMORY_RECORD_PTR
+CreateMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List,
+	gcuVIDMEM_NODE_PTR Node
 	)
 {
-    /* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	MEMORY_RECORD_PTR	mr;
 
-#ifdef CONFIG_CPU_MMP2
-    if(enableDVFM)
+	mr = (MEMORY_RECORD_PTR)kmalloc(sizeof(struct MEMORY_RECORD), GFP_ATOMIC);
+    if (mr == gcvNULL)
     {
-        /* enable LPM and OP1 - OP5 on mmp2 */
-        dvfm_enable(Os->device->dvfm_dev_index);
+        gcmkLOG_WARNING_ARGS("out of memory to create MemoryRecord");
+        return gcvNULL;
     }
-#endif
 
-#ifdef CONFIG_PXA_DVFM
+	MEMORY_LOCK(Os);
 
-#if 0
-    if(enableDVFM)
-    {
-        /* enable LPM and OP1 - OP5 on PV2 evb  */
-        dvfm_enable(Os->device->dvfm_dev_index);
-    }
-#else
-    if(enableLPM)
-    {
-         /* printk("\n Idle = true, enable low power mode\n"); */
-        /* Enable D0CS */
-        dvfm_enable_op_name("D0CS", Os->device->dvfm_dev_index);
-        /* Enable Low power mode */
-        dvfm_enable_op_name("D1", Os->device->dvfm_dev_index);
-        dvfm_enable_op_name("D2", Os->device->dvfm_dev_index);
-        /* Enable CG */
-        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
-            dvfm_enable_op_name("CG", Os->device->dvfm_dev_index);
-    }
+	mr->node			= Node;
 
-    if(Os->device->enableD1)
-    {
-        dvfm_enable_op_name("D1", Os->device->dvfm_dev_index);
-    }
+	mr->prev			= List->prev;
+	mr->next			= List;
+	List->prev->next	= mr;
+	List->prev			= mr;
 
-    if(Os->device->enableD2)
-    {
-        dvfm_enable_op_name("D2", Os->device->dvfm_dev_index);
-    }
+	MEMORY_UNLOCK(Os);
 
-    if(Os->device->enableD0CS)
-    {
-        dvfm_enable_op_name("D0CS", Os->device->dvfm_dev_index);
-    }
+	return mr;
+}
 
-    if(Os->device->enableCG)
-    {
-       if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
-           dvfm_enable_op_name("CG", Os->device->dvfm_dev_index);
-    }
+void
+DestoryMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR Mr
+	)
+{
+	MEMORY_LOCK(Os);
 
-    if(enableDVFM)
-    {
+	Mr->prev->next		= Mr->next;
+	Mr->next->prev		= Mr->prev;
 
-        /* Enable OP1 - OP7 on PV2 evb */
-        dvfm_enable_op_name("156M", Os->device->dvfm_dev_index);
-        dvfm_enable_op_name("208M", Os->device->dvfm_dev_index);
-        dvfm_enable_op_name("156M_HF", Os->device->dvfm_dev_index);
-        dvfm_enable_op_name("208M_HF", Os->device->dvfm_dev_index);
-        dvfm_enable_op_name("416M", Os->device->dvfm_dev_index);
-         /* dvfm_enable_op_name("624M", Os->device->dvfm_dev_index); */
-         /* dvfm_enable_op_name("832M", Os->device->dvfm_dev_index); */
-         /* dvfm_enable(Os->device->dvfm_dev_index); */
-    }
-#endif
+	MEMORY_UNLOCK(Os);
 
-#endif
-    return gcvSTATUS_OK;
+	kfree(Mr);
+
+    Mr = gcvNULL;
 }
 
-gceSTATUS
-gckOS_FrequencyScaling(
-	IN gckOS Os,
-	IN gctBOOL Idle
-    )
+MEMORY_RECORD_PTR
+FindMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List,
+	gcuVIDMEM_NODE_PTR Node
+	)
 {
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	MEMORY_RECORD_PTR mr;
 
-    /* printk("[galcore] %s:\n",Idle?"Idle,freq scale to 1/64":"Running"); */
-    if(Idle)
-    {
-        /* frequence change to 1/64 */
-        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x204));
-        /* Loading the frequency scaler. */
-        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x004));
+	MEMORY_LOCK(Os);
 
-        gckOS_UnSetConstraint(Os,
-            Os->device->enableDVFM,
-            Os->device->enableLowPowerMode);
-    }
-    else
-    {
-        /* Write the clock control register. */
-        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x300));
-        /* Done loading the frequency scaler. */
-        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x100));
+	mr = List->next;
 
-        gckOS_SetConstraint(Os,
-            Os->device->enableDVFM,
-            Os->device->enableLowPowerMode);
-    }
+	while (mr != List)
+	{
+		if (mr->node == Node)
+		{
+			MEMORY_UNLOCK(Os);
 
-    return gcvSTATUS_OK;
+			return mr;
+		}
+
+		mr = mr->next;
+	}
+
+	MEMORY_UNLOCK(Os);
+
+	return gcvNULL;
 }
 
-gceSTATUS
-gckOS_NotifyIdle(
-	IN gckOS Os,
-	IN gctBOOL Idle
+void
+FreeAllMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List
 	)
 {
+	MEMORY_RECORD_PTR mr;
+	gctUINT i = 0;
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    static int  count = 0;
-    gceSTATUS   status;
-#endif
-#endif
-
-	/* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	MEMORY_LOCK(Os);
 
-	Os->device->lastNodeIndex = (Os->device->lastNodeIndex + 1) %100;
-    Os->device->profNode[Os->device->lastNodeIndex].idle = Idle;
-    Os->device->profNode[Os->device->lastNodeIndex].tick = gckOS_GetTicks();
+	while (List->next != List)
+	{
+		mr = List->next;
 
-#if defined CONFIG_CPU_PXA910
-#if POWER_OFF_GC_WHEN_IDLE
-    switch (galDevice->currentPMode)
-    {
-    case gcvPM_NORMAL:
-        {
-            gckOS_FrequencyScaling(Os,Idle);
-        }
-        break;
+		mr->prev->next		= mr->next;
+		mr->next->prev		= mr->prev;
 
-    case gcvPM_EARLY_SUSPEND:
-        {
-            printk(">>>[%s]\t@%d\tN:0x%x\tIDLE:%d\n", __func__, __LINE__, count, Idle);
-            /* return if not idle */
-            if (gcvFALSE == Idle) {
-                printk("<<<<<busy, gcvPM_EARLY_SUSPEND return.\n");
-                break;
-            }
+		i++;
 
-            /* Acquire the mutex. */
-            if (galDevice->printPID) {
-                printk("|-|-|- Acquiring gcdevice mutex...\t%s@%d\n",__FUNCTION__,__LINE__);
-            }
+		MEMORY_UNLOCK(Os);
+
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"Unfreed %s memory: node: %p",
+				(mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)?
+					"video" : (mr->node->Virtual.contiguous)?
+						"contiguous" : "virtual",
+				mr->node);
 
-            gcmkONERROR(
-                gckOS_AcquireMutex(galDevice->os, galDevice->mutexGCDevice, gcvINFINITE));
+		while (gcvTRUE)
+		{
+			if (mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+			{
+				if (mr->node->VidMem.locked == 0) break;
+			}
+			else
+			{
+				if (mr->node->Virtual.locked == 0) break;
+			}
 
-            _power_off_gc(galDevice, gcvFALSE);
+			gckVIDMEM_Unlock(mr->node, gcvSURF_TYPE_UNKNOWN, gcvNULL);
+		}
 
-            /* Release the mutex. */
-            gcmkVERIFY_OK(
-                gckOS_ReleaseMutex(galDevice->os, galDevice->mutexGCDevice));
+		gckVIDMEM_Free(mr->node);
 
-            if (galDevice->printPID) {
-                printk("|-|-|- Released gcdevice mutex...\t%s@%d\n",__FUNCTION__,__LINE__);
-            }
+		kfree(mr);
 
+        mr = gcvNULL;
 
-            printk("<<<[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
-        }
-        break;
-    default:
-        break;
-    }
-    return gcvSTATUS_OK;
+		MEMORY_LOCK(Os);
+	}
 
-OnError:
-    /* Return the status. */
-    printk("---->ERROR:%s @ %d\n", __func__, __LINE__);
-    return status;
-#else
-    /* POWER_OFF_GC_WHEN_IDLE not true, just go to normal path*/
-    gckOS_FrequencyScaling(Os, Idle);
-#endif
+	MEMORY_UNLOCK(Os);
 
-#else
-    /* other platform */
-    gckOS_FrequencyScaling(Os, Idle);
+	if (i > 0)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"======== Total %d unfreed video/contiguous/virtual memory ========", i);
+	}
+}
 #endif
 
-	return gcvSTATUS_OK;
+/*******************************************************************************
+**  gckOS_CacheFlush
+**
+**  Flush the cache for the specified addresses.  The GPU is going to need the
+**  data.  If the system is allocating memory as non-cachable, this function can
+**  be ignored.
+**
+**  ARGUMENTS:
+**
+**      gckOS Os
+**          Pointer to gckOS object.
+**
+**      gctHANDLE Process
+**          Process handle Logical belongs to or gcvNULL if Logical belongs to
+**          the kernel.
+**
+**      gctPOINTER Logical
+**          Logical address to flush.
+**
+**      gctSIZE_T Bytes
+**          Size of the address range in bytes to flush.
+*/
+gceSTATUS
+gckOS_CacheFlush(
+    IN gckOS Os,
+    IN gctHANDLE Process,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    )
+{
+    return gcvSTATUS_OK;
 }
 
-gctUINT32
-gckOS_GetTicks(
-    void
+/*******************************************************************************
+**  gckOS_CacheInvalidate
+**
+**  Flush the cache for the specified addresses and invalidate the lines as
+**  well.  The GPU is going to need and modify the data.  If the system is
+**  allocating memory as non-cachable, this function can be ignored.
+**
+**  ARGUMENTS:
+**
+**      gckOS Os
+**          Pointer to gckOS object.
+**
+**      gctHANDLE Process
+**          Process handle Logical belongs to or gcvNULL if Logical belongs to
+**          the kernel.
+**
+**      gctPOINTER Logical
+**          Logical address to flush.
+**
+**      gctSIZE_T Bytes
+**          Size of the address range in bytes to flush.
+*/
+gceSTATUS
+gckOS_CacheInvalidate(
+    IN gckOS Os,
+    IN gctHANDLE Process,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
     )
 {
-    struct timeval tv;
-    unsigned int tickcount = 0;
-    do_gettimeofday(&tv);
-    tickcount = (tv.tv_sec*1000 + tv.tv_usec/1000);
-    return tickcount;
+    return gcvSTATUS_OK;
 }
 
+/*******************************************************************************
+********************************* Broadcasting *********************************
+*******************************************************************************/
+#if VIVANTE_POWER_MANAGE
+/*******************************************************************************
+**
+**  gckOS_Broadcast
+**
+**  System hook for broadcast events from the kernel driver.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gckHARDWARE Hardware
+**          Pointer to the gckHARDWARE object.
+**
+**      gceBROADCAST Reason
+**          Reason for the broadcast.  Can be one of the following values:
+**
+**              gcvBROADCAST_GPU_IDLE
+**                  Broadcasted when the kernel driver thinks the GPU might be
+**                  idle.  This can be used to handle power management.
+**
+**              gcvBROADCAST_GPU_COMMIT
+**                  Broadcasted when any client process commits a command
+**                  buffer.  This can be used to handle power management.
+**
+**              gcvBROADCAST_GPU_STUCK
+**                  Broadcasted when the kernel driver hits the timeout waiting
+**                  for the GPU.
+**
+**              gcvBROADCAST_FIRST_PROCESS
+**                  First process is trying to connect to the kernel.
+**
+**              gcvBROADCAST_LAST_PROCESS
+**                  Last process has detached from the kernel.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
 gceSTATUS
-gckOS_IdleProfile(
+gckOS_Broadcast(
     IN gckOS Os,
-    IN OUT gctUINT32* Timeslice,
-    OUT gctUINT32* IdleTime
+    IN gckHARDWARE Hardware,
+    IN gceBROADCAST Reason
     )
 {
-    int i;
-    gctUINT currentTick;
-    gckProfNode firstNode;
-    gckProfNode lastNode;
-    gckProfNode iterNode; /* first node in the time slice */
-    gckProfNode nextNode; /* the next node of iterNode */
-    gctUINT firstIndex, lastIndex, iterIndex;
-    gctUINT idleTime = 0;
+    gceSTATUS status;
+    gctUINT32 idle = 0, dma = 0, axi = 0, read0 = 0, read1 = 0, write = 0;
+
+    gcmkHEADER_ARG("Os=0x%x Hardware=0x%x Reason=%d", Os, Hardware, Reason);
 
     /* Verify the arguments. */
-	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
-	gcmkVERIFY_ARGUMENT(Timeslice != gcvNULL);
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-    /* Grab the conmmand queue mutex. */
-	gcmkVERIFY_OK(gckOS_AcquireMutex(Os,
-									Os->device->kernel->command->mutexQueue,
-									gcvINFINITE));
+    switch (Reason)
+    {
+    case gcvBROADCAST_FIRST_PROCESS:
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "First process has attached");
+        break;
 
+    case gcvBROADCAST_LAST_PROCESS:
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "Last process has detached");
 
-    currentTick = gckOS_GetTicks();
-    lastIndex = Os->device->lastNodeIndex;
-    iterIndex = lastIndex;
-    firstIndex = (Os->device->lastNodeIndex + 1) % 100;
-    firstNode = &Os->device->profNode[firstIndex];
-    lastNode = &Os->device->profNode[lastIndex];
+        break;
 
-    /* printk("@@@@@@[first last] [%d, %d]\n",firstIndex,lastIndex); */
+    case gcvBROADCAST_GPU_IDLE:
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "GPU idle.");
+        break;
 
-    /* no node in the time slice */
-    if(currentTick - lastNode->tick >= *Timeslice)
-    {
-        if(lastNode->idle)
-        {
-            idleTime += *Timeslice;
-            /* printk("line %d, idletime : %d",__LINE__, idleTime); */
-        }
-    }
-    else
-    {
-        /* find first node in the time slice */
-        if(currentTick - firstNode->tick < *Timeslice)
-        {
-            /* */
-            *Timeslice = currentTick - firstNode->tick;
+    case gcvBROADCAST_GPU_COMMIT:
+        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "COMMIT has arrived.");
+        break;
 
-            iterIndex = firstIndex;
-            iterNode = &Os->device->profNode[iterIndex];
-        }
-        else
-        {
-            for(i=0;i<100;i++)
-            {
-                iterIndex = (firstIndex + i)%100;
-                iterNode = &Os->device->profNode[iterIndex];
-                if(currentTick - iterNode->tick < *Timeslice)
-                {
-                    break;
-                }
-            }
-        }
-        /* printk("line %d, iterIndex : %d\n",__LINE__, iterIndex); */
+    case gcvBROADCAST_GPU_STUCK:
+		gcmkONERROR(gckHARDWARE_GetIdle(Hardware, gcvFALSE, &idle));
+        gcmkONERROR(gckOS_ReadRegister(Os, 0x00C, &axi));
+		gcmkONERROR(gckOS_ReadRegister(Os, 0x664, &dma));
+        gcmkPRINT("!!FATAL!! GPU Stuck");
+        gcmkPRINT("  idle=0x%08X axi=0x%08X cmd=0x%08X", idle, axi, dma);
 
-        /* startTick to first node time */
-        if(!iterNode->idle)
+        if (Hardware->chipFeatures & (1 << 4))
         {
-            idleTime += iterNode->tick - (currentTick - *Timeslice);
-            /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x43C, &read0));
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x440, &read1));
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x444, &write));
+            gcmkPRINT("  read0=0x%08X read1=0x%08X write=0x%08X",
+                      read0, read1, write);
         }
 
-        /* last node to currentTick time */
-        if(lastNode->idle)
-        {
-            idleTime += currentTick - lastNode->tick;
-            /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
-        }
+        gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
+        break;
 
-        /* first node to last node time */
-        for(i = 0; i < 100; i++ )
-        {
-            if(iterIndex == lastIndex)
-                break;
+    case gcvBROADCAST_AXI_BUS_ERROR:
+        gcmkONERROR(gckHARDWARE_GetIdle(Hardware, gcvFALSE, &idle));
+        gcmkONERROR(gckOS_ReadRegister(Os, 0x00C, &axi));
+        gcmkONERROR(gckOS_ReadRegister(Os, 0x664, &dma));
+        gcmkPRINT("!!FATAL!! AXI Bus Error");
+        gcmkPRINT("  idle=0x%08X axi=0x%08X cmd=0x%08X", idle, axi, dma);
 
-            if(iterNode->idle)
-            {
-                nextNode = &Os->device->profNode[(iterIndex + 1)%100];
-                idleTime += nextNode->tick - iterNode->tick;
-                /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
-            }
-            iterIndex = (iterIndex + 1)%100;
-            iterNode = &Os->device->profNode[iterIndex];
+        if (Hardware->chipFeatures & (1 << 4))
+        {
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x43C, &read0));
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x440, &read1));
+            gcmkONERROR(gckOS_ReadRegister(Os, 0x444, &write));
+            gcmkPRINT("  read0=0x%08X read1=0x%08X write=0x%08X",
+                      read0, read1, write);
         }
 
+        gcmkONERROR(gckKERNEL_Recovery(Hardware->kernel));
+        break;
     }
 
-    *IdleTime = idleTime;
-
-    /* Release the command queue mutex. */
-    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->device->kernel->command->mutexQueue));
-
+    /* Success. */
+    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
+#endif
 
+/*******************************************************************************
+********************************** Semaphores **********************************
+*******************************************************************************/
+
+/*******************************************************************************
+**
+**  gckOS_CreateSemaphore
+**
+**  Create a semaphore.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**  OUTPUT:
+**
+**      gctPOINTER * Semaphore
+**          Pointer to the variable that will receive the created semaphore.
+*/
 gceSTATUS
-gckOS_MemCopy(
-        IN gctPOINTER Destination,
-        IN gctCONST_POINTER Source,
-        IN gctSIZE_T Bytes
-        )
+gckOS_CreateSemaphore(
+    IN gckOS Os,
+    OUT gctPOINTER * Semaphore
+    )
 {
-        gcmkVERIFY_ARGUMENT(Destination != NULL);
-        gcmkVERIFY_ARGUMENT(Source != NULL);
-        gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gceSTATUS status;
+    struct semaphore *sem;
 
-        memcpy(Destination, Source, Bytes);
+    gcmkHEADER_ARG("Os=0x%x", Os);
 
-        return gcvSTATUS_OK;
-}
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
+
+    /* Allocate the semaphore structure. */
+    gcmkONERROR(
+        gckOS_Allocate(Os, gcmSIZEOF(struct semaphore), (gctPOINTER *) &sem));
 
-gceSTATUS
-gckOS_ZeroMemory(
-	IN gctPOINTER Memory,
-	IN gctSIZE_T Bytes
-	)
-{
-	gcmkHEADER_ARG("Memory=0x%x Bytes=%lu", Memory, Bytes);
+    /* Initialize the semaphore. */
+    sema_init(sem, 1);
 
-	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
-	gcmkVERIFY_ARGUMENT(Bytes > 0);
+    /* Return to caller. */
+    *Semaphore = (gctPOINTER) sem;
 
-	memset(Memory, 0, Bytes);
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 
-	gcmkFOOTER_NO();
-	return gcvSTATUS_OK;
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
-#if gcdkUSE_MEMORY_RECORD
-MEMORY_RECORD_PTR
-CreateMemoryRecord(
-	gckOS Os,
-	MEMORY_RECORD_PTR List,
-	gcuVIDMEM_NODE_PTR Node
-	)
+/*******************************************************************************
+**
+**  gckOS_AcquireSemaphore
+**
+**  Acquire a semaphore.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Semaphore
+**          Pointer to the semaphore thet needs to be acquired.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_AcquireSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    )
 {
-	MEMORY_RECORD_PTR	mr;
-
-	mr = (MEMORY_RECORD_PTR)kmalloc(sizeof(struct MEMORY_RECORD), GFP_ATOMIC);
-	if (mr == gcvNULL) return gcvNULL;
+    gceSTATUS status;
 
-	MEMORY_LOCK(Os);
+    gcmkHEADER_ARG("Os=0x%x", Os);
 
-	mr->node			= Node;
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
 
-	mr->prev			= List->prev;
-	mr->next			= List;
-	List->prev->next	= mr;
-	List->prev			= mr;
+    /* Acquire the semaphore. */
+    if (down_interruptible((struct semaphore *) Semaphore))
+    {
+        gcmkONERROR(gcvSTATUS_TIMEOUT);
+    }
 
-	MEMORY_UNLOCK(Os);
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 
-	return mr;
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
-void
-DestoryMemoryRecord(
-	gckOS Os,
-	MEMORY_RECORD_PTR Mr
-	)
+/*******************************************************************************
+**
+**  gckOS_ReleaseSemaphore
+**
+**  Release a previously acquired semaphore.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Semaphore
+**          Pointer to the semaphore thet needs to be released.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_ReleaseSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    )
 {
-	MEMORY_LOCK(Os);
+    gcmkHEADER_ARG("Os=0x%x Semaphore=0x%x", Os, Semaphore);
 
-	Mr->prev->next		= Mr->next;
-	Mr->next->prev		= Mr->prev;
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
 
-	MEMORY_UNLOCK(Os);
+    /* Release the semaphore. */
+    up((struct semaphore *) Semaphore);
 
-	kfree(Mr);
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 }
 
-MEMORY_RECORD_PTR
-FindMemoryRecord(
-	gckOS Os,
-	MEMORY_RECORD_PTR List,
-	gcuVIDMEM_NODE_PTR Node
-	)
+/*******************************************************************************
+**
+**  gckOS_DestroySemaphore
+**
+**  Destroy a semaphore.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to the gckOS object.
+**
+**      gctPOINTER Semaphore
+**          Pointer to the semaphore thet needs to be destroyed.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_DestroySemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    )
 {
-	MEMORY_RECORD_PTR mr;
-
-	MEMORY_LOCK(Os);
-
-	mr = List->next;
+    gceSTATUS status;
 
-	while (mr != List)
-	{
-		if (mr->node == Node)
-		{
-			MEMORY_UNLOCK(Os);
+    gcmkHEADER_ARG("Os=0x%x Semaphore=0x%x", Os, Semaphore);
 
-			return mr;
-		}
+     /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Semaphore != gcvNULL);
 
-		mr = mr->next;
-	}
+    /* Free the sempahore structure. */
+    gcmkONERROR(gckOS_Free(Os, Semaphore));
 
-	MEMORY_UNLOCK(Os);
+    /* Success. */
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
 
-	return gcvNULL;
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
 }
 
-void
-FreeAllMemoryRecord(
-	gckOS Os,
-	MEMORY_RECORD_PTR List
-	)
+/*******************************************************************************
+**
+**  gckOS_GetProcessID
+**
+**  Get current process ID.
+**
+**  INPUT:
+**
+**      Nothing.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR ProcessID
+**          Pointer to the variable that receives the process ID.
+*/
+gceSTATUS
+gckOS_GetProcessID(
+    OUT gctUINT32_PTR ProcessID
+    )
 {
-	MEMORY_RECORD_PTR mr;
-	gctUINT i = 0;
+    gcmkHEADER();
 
-	MEMORY_LOCK(Os);
-
-	while (List->next != List)
-	{
-		mr = List->next;
-
-		mr->prev->next		= mr->next;
-		mr->next->prev		= mr->prev;
-
-		i++;
-
-		MEMORY_UNLOCK(Os);
-
-		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
-				gcvZONE_OS,
-				"Unfreed %s memory: node: %p",
-				(mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)?
-					"video" : (mr->node->Virtual.contiguous)?
-						"contiguous" : "virtual",
-				mr->node);
+    /* Verify the arguments. */
+    gcmkVERIFY_ARGUMENT(ProcessID != gcvNULL);
 
-		while (gcvTRUE)
-		{
-			if (mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
-			{
-				if (mr->node->VidMem.locked == 0) break;
-			}
-			else
-			{
-				if (mr->node->Virtual.locked == 0) break;
-			}
+    /* Get process ID. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+    *ProcessID = task_tgid_vnr(current);
+#else
+    *ProcessID = current->tgid;
+#endif
 
-			gckVIDMEM_Unlock(mr->node, gcvSURF_TYPE_UNKNOWN, gcvNULL);
-		}
+    /* Success. */
+    gcmkFOOTER_ARG("*ProcessID=%u", *ProcessID);
+    return gcvSTATUS_OK;
+}
 
-		gckVIDMEM_Free(mr->node);
+/*******************************************************************************
+**
+**  gckOS_FreeProcessResource
+**
+**  Free process resource when application exit normall or unnormal
+**
+**  INPUT:
+**
+**      os,pid.
+**
+**  OUTPUT:
+**
+**      None
+*/
+gceSTATUS gckOS_FreeProcessResource(IN gckOS Os, gctUINT32 pid)
+{
+    PLINUX_MDL pNext, mdl = Os->mdlHead;
 
-		kfree(mr);
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
 
-		MEMORY_LOCK(Os);
-	}
+    while(mdl)
+    {
+        pNext = mdl->next;
+ 
+        if(mdl->pid == pid)
+        {
+            gcmkVERIFY_OK(gckOS_FreeNonPagedMemory(Os, 
+                PAGE_SIZE, (gctPHYS_ADDR) mdl, (gctPOINTER) mdl));
+        }
 
-	MEMORY_UNLOCK(Os);
+        mdl = pNext;
+    }        
 
-	if (i > 0)
-	{
-		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
-				gcvZONE_OS,
-				"======== Total %d unfreed video/contiguous/virtual memory ========", i);
-	}
+    return gcvSTATUS_OK;
 }
-#endif
 
 /*******************************************************************************
-**  gckOS_CacheFlush
 **
-**  Flush the cache for the specified addresses.  The GPU is going to need the
-**  data.  If the system is allocating memory as non-cachable, this function can
-**  be ignored.
+**  gckOS_GetThreadID
 **
-**  ARGUMENTS:
+**  Get current thread ID.
 **
-**      gckOS Os
-**          Pointer to gckOS object.
+**  INPUT:
 **
-**      gctHANDLE Process
-**          Process handle Logical belongs to or gcvNULL if Logical belongs to
-**          the kernel.
+**      Nothing.
 **
-**      gctPOINTER Logical
-**          Logical address to flush.
+**  OUTPUT:
 **
-**      gctSIZE_T Bytes
-**          Size of the address range in bytes to flush.
+**      gctUINT32_PTR ThreadID
+**          Pointer to the variable that receives the thread ID.
 */
 gceSTATUS
-gckOS_CacheFlush(
-    IN gckOS Os,
-    IN gctHANDLE Process,
-    IN gctPOINTER Logical,
-    IN gctSIZE_T Bytes
+gckOS_GetThreadID(
+    OUT gctUINT32_PTR ThreadID
     )
 {
+    gcmkHEADER();
+
+    /* Verify the arguments. */
+    gcmkVERIFY_ARGUMENT(ThreadID != gcvNULL);
+
+    /* Get thread ID. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+    *ThreadID = task_pid_vnr(current);
+#else
+    *ThreadID = current->pid;
+#endif
+
+    /* Success. */
+    gcmkFOOTER_ARG("*ThreadID=%u", *ThreadID);
     return gcvSTATUS_OK;
 }
 
 /*******************************************************************************
-**  gckOS_CacheInvalidate
 **
-**  Flush the cache for the specified addresses and invalidate the lines as
-**  well.  The GPU is going to need and modify the data.  If the system is
-**  allocating memory as non-cachable, this function can be ignored.
+**  gckOS_SetGPUPower
 **
-**  ARGUMENTS:
+**  Set the power of the GPU on or off.
+**
+**  INPUT:
 **
 **      gckOS Os
-**          Pointer to gckOS object.
+**          Pointer to a gckOS object.?
 **
-**      gctHANDLE Process
-**          Process handle Logical belongs to or gcvNULL if Logical belongs to
-**          the kernel.
+**      gctBOOL Clock
+**          gcvTRUE to turn on the clock, or gcvFALSE to turn off the clock.
 **
-**      gctPOINTER Logical
-**          Logical address to flush.
+**      gctBOOL Power
+**          gcvTRUE to turn on the power, or gcvFALSE to turn off the power.
 **
-**      gctSIZE_T Bytes
-**          Size of the address range in bytes to flush.
+**  OUTPUT:
+**
+**      Nothing.
 */
 gceSTATUS
-gckOS_CacheInvalidate(
+gckOS_SetGPUPower(
     IN gckOS Os,
-    IN gctHANDLE Process,
-    IN gctPOINTER Logical,
-    IN gctSIZE_T Bytes
+    IN gctBOOL Clock,
+    IN gctBOOL Power
     )
 {
+    gcmkHEADER_ARG("Os=0x%x Clock=%d Power=%d", Os, Clock, Power);
+
+    /* TODO: Put your code here. */
+
+    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 }
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c-temp b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c-temp
new file mode 100644
index 0000000..b914685
--- /dev/null
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.c-temp
@@ -0,0 +1,5873 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2010 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#include "gc_hal_kernel_linux.h"
+
+#include <linux/random.h>
+#include <linux/pagemap.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/sched.h>
+#include <asm/atomic.h>
+#include <stdarg.h>
+
+#ifdef NO_DMA_COHERENT
+#include <linux/dma-mapping.h>
+#endif /* NO_DMA_COHERENT */
+#include <linux/slab.h>
+#include <linux/delay.h>
+#if MRVL_CONFIG_ENABLE_DVFM
+#include <mach/dvfm.h>
+#include <mach/hardware.h>
+/* MG1 dot32 kernel: gc_pwr function defined in pxa3xx_pm.h */
+#if MRVL_CONFIG_DVFM_MG1 && (defined CONFIG_PXA3xx_DVFM)
+#include <mach/pxa3xx_dvfm.h>
+#endif
+#endif
+
+/* MG1/TD dot 35 kernel move gc_pwr define to mach/pxaXXX_pm.h */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
+#if MRVL_PLATFORM_MG1
+#include <mach/pxa95x_pm.h>
+#endif
+#if MRVL_PLATFORM_TD
+#include <mach/pxa910_pm.h>
+#endif
+#endif
+
+#if !USE_NEW_LINUX_SIGNAL
+#define USER_SIGNAL_TABLE_LEN_INIT 	64
+#endif
+
+#define _GC_OBJ_ZONE	gcvZONE_OS
+
+#define MEMORY_LOCK(os) \
+	gcmkVERIFY_OK(gckOS_AcquireMutex( \
+								(os), \
+								(os)->memoryLock, \
+								gcvINFINITE))
+
+#define MEMORY_UNLOCK(os) \
+	gcmkVERIFY_OK(gckOS_ReleaseMutex((os), (os)->memoryLock))
+
+#define MEMORY_MAP_LOCK(os) \
+	gcmkVERIFY_OK(gckOS_AcquireMutex( \
+								(os), \
+								(os)->memoryMapLock, \
+								gcvINFINITE))
+
+#define MEMORY_MAP_UNLOCK(os) \
+	gcmkVERIFY_OK(gckOS_ReleaseMutex((os), (os)->memoryMapLock))
+
+#define CLOCK_VERIFY(clock) \
+    if (IS_ERR(clock)) \
+    { \
+        int retval = PTR_ERR(clock); \
+        gcmkPRINT("clk get error: %d\t@LINE:%d\n", retval, __LINE__); \
+        return retval; \
+    }
+
+static void _Print(
+	const char *Message,
+	va_list Arguments
+	)
+{
+	char buffer[1000];
+	int n;
+	
+	/* Print message to buffer. */
+	n = vsnprintf(buffer, sizeof(buffer), Message, Arguments);
+	if ((n <= 0) || (buffer[n - 1] != '\n'))
+	{
+		/* Append new-line. */
+		strncat(buffer, "\n", sizeof(buffer));
+	}
+
+	/* Output to debugger. */	
+	printk(buffer);
+}
+
+/******************************************************************************\
+********************************* Debug Macros *********************************
+\******************************************************************************/
+
+#define _DEBUGPRINT(Message) \
+{ \
+	va_list arguments; \
+	\
+	va_start(arguments, Message); \
+	_Print(Message, arguments); \
+	va_end(arguments); \
+}
+
+
+#if MRVL_ENABLE_API_LOG
+static gctUINT32 g_logFilter = _GFX_LOG_ALL_;
+#else
+#   if MRVL_ENABLE_ERROR_LOG
+    static gctUINT32 g_logFilter = _GFX_LOG_ERROR_ | _GFX_LOG_WARNING_ | _GFX_LOG_NOTIFY_;
+#   else
+    static gctUINT32 g_logFilter = _GFX_LOG_NONE_;
+#   endif
+#endif
+
+void gckOS_Log(IN unsigned int filter, IN const char* msg,
+			...
+			)
+{
+    if(filter & g_logFilter)
+    {
+	    _DEBUGPRINT(msg);
+    }
+}
+
+void gckOS_SetLogFilter(IN unsigned int filter)
+{
+    g_logFilter = filter;    
+}
+
+/********************************** Structures **********************************
+\******************************************************************************/
+
+struct _gckOS
+{
+	/* Object. */
+	gcsOBJECT					object;
+
+	/* Heap. */
+	gckHEAP						heap;
+
+	/* Pointer to device */
+	gckGALDEVICE 				device;
+
+	/* Memory management */
+	gctPOINTER					memoryLock;
+	gctPOINTER					memoryMapLock;
+
+	struct _LINUX_MDL   		*mdlHead;
+	struct _LINUX_MDL   		*mdlTail;
+
+	gctUINT32					baseAddress;
+
+    /* Kernel process ID. */
+    gctUINT32                   kernelProcessID;
+
+#if !USE_NEW_LINUX_SIGNAL
+	/* Signal management. */
+	struct _signal {
+		/* Unused signal ID number. */
+        gctINT                  unused;
+
+        /* The pointer to the table. */
+        gctPOINTER *            table;
+
+        /* Signal table length. */
+        gctINT                  tableLen;
+
+        /* The current unused signal ID. */
+        gctINT                  currentID;
+
+        /* Lock. */
+        gctPOINTER              lock;
+	} signal;
+#endif
+
+    /* idle profiling mutex. */
+    gctPOINTER                  mutexIdleProfile;
+};
+
+#if !USE_NEW_LINUX_SIGNAL
+typedef struct _gcsSIGNAL
+{
+	/* Kernel sync primitive. */
+	struct completion event;
+
+	/* Manual reset flag. */
+	gctBOOL manualReset;
+
+	/* The reference counter. */
+	atomic_t ref;
+
+	/* The signal type */
+	gceSIGNAL_TYPE signalType;
+
+	/* The owner of the signal. */
+	gctHANDLE process;
+}
+gcsSIGNAL;
+
+typedef struct _gcsSIGNAL *	gcsSIGNAL_PTR;
+#endif
+
+typedef struct _gcsPageInfo * gcsPageInfo_PTR;
+
+typedef struct _gcsPageInfo
+{
+	struct page **pages;
+	gctUINT32_PTR pageTable;
+}
+gcsPageInfo;
+
+static PLINUX_MDL
+_CreateMdl(
+	IN gctINT PID
+	)
+{
+	PLINUX_MDL	mdl;
+
+    mdl = (PLINUX_MDL)kmalloc(sizeof(struct _LINUX_MDL), GFP_ATOMIC);
+    if (mdl == gcvNULL)
+    {
+        gcmkLOG_WARNING_ARGS("out of memory to create Mdl");
+        return gcvNULL;
+    }
+
+	mdl->pid	    = PID;
+	mdl->maps	    = gcvNULL;
+	mdl->prev	    = gcvNULL;
+	mdl->next	    = gcvNULL;
+
+	mdl->addr       = gcvNULL;
+
+#ifdef NO_DMA_COHERENT
+#if !ALLOC_HIGHMEM
+	mdl->kaddr      = gcvNULL;
+#endif
+#endif
+
+	mdl->numPages   = 0;
+	mdl->pagedMem   = 0;
+	mdl->contiguous = gcvTRUE;
+	mdl->dmaHandle  = GC_INVALID_PHYS_ADDR;
+
+	return mdl;
+}
+
+static gceSTATUS
+_DestroyMdlMap(
+	IN PLINUX_MDL Mdl,
+	IN PLINUX_MDL_MAP MdlMap
+	);
+
+static gceSTATUS
+_DestroyMdl(
+	IN PLINUX_MDL Mdl
+	)
+{
+    PLINUX_MDL_MAP mdlMap, next;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_ARGUMENT(Mdl != gcvNULL);
+
+	mdlMap = Mdl->maps;
+
+	while (mdlMap != gcvNULL)
+	{
+        next = mdlMap->next;
+
+		gcmkVERIFY_OK(_DestroyMdlMap(Mdl, mdlMap));
+
+        mdlMap = next;
+	}
+
+	kfree(Mdl);
+    Mdl = gcvNULL;
+
+	return gcvSTATUS_OK;
+}
+
+static PLINUX_MDL_MAP
+_CreateMdlMap(
+	IN PLINUX_MDL Mdl,
+	IN gctINT PID
+	)
+{
+	PLINUX_MDL_MAP	mdlMap;
+
+    mdlMap = (PLINUX_MDL_MAP)kmalloc(sizeof(struct _LINUX_MDL_MAP), GFP_ATOMIC);
+    if (mdlMap == gcvNULL)
+    {
+        gcmkLOG_WARNING_ARGS("out of memory to create MdlMap");
+        return gcvNULL;
+    }
+
+	mdlMap->pid		= PID;
+	mdlMap->vmaAddr	= gcvNULL;
+	mdlMap->vma		= gcvNULL;
+
+	mdlMap->next	= Mdl->maps;
+	Mdl->maps		= mdlMap;
+
+	return mdlMap;
+}
+
+static gceSTATUS
+_DestroyMdlMap(
+	IN PLINUX_MDL Mdl,
+	IN PLINUX_MDL_MAP MdlMap
+	)
+{
+	PLINUX_MDL_MAP	prevMdlMap;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_ARGUMENT(MdlMap != gcvNULL);
+	gcmkASSERT(Mdl->maps != gcvNULL);
+
+	if (Mdl->maps == MdlMap)
+	{
+		Mdl->maps = MdlMap->next;
+	}
+	else
+	{
+		prevMdlMap = Mdl->maps;
+
+		while (prevMdlMap->next != MdlMap)
+		{
+			prevMdlMap = prevMdlMap->next;
+
+			gcmkASSERT(prevMdlMap != gcvNULL);
+		}
+
+		prevMdlMap->next = MdlMap->next;
+	}
+
+	kfree(MdlMap);
+
+	return gcvSTATUS_OK;
+}
+
+extern PLINUX_MDL_MAP
+FindMdlMap(
+	IN PLINUX_MDL Mdl,
+	IN gctINT PID
+	)
+{
+	PLINUX_MDL_MAP	mdlMap;
+
+	mdlMap = Mdl->maps;
+
+	while (mdlMap != gcvNULL)
+	{
+		if (mdlMap->pid == PID) return mdlMap;
+
+		mdlMap = mdlMap->next;
+	}
+
+	return gcvNULL;
+}
+
+void
+FreeProcessMemoryOnExit(
+	IN gckOS Os,
+	IN gckKERNEL Kernel
+	)
+{
+	PLINUX_MDL      mdl, nextMdl;
+	PLINUX_MDL_MAP	mdlMap;
+
+	MEMORY_LOCK(Os);
+
+	mdl = Os->mdlHead;
+
+	while (mdl != gcvNULL)
+	{
+		if (mdl != Os->mdlTail)
+		{
+			nextMdl = mdl->next;
+		}
+		else
+		{
+			nextMdl = gcvNULL;
+		}
+
+		if (mdl->pagedMem)
+		{
+			mdlMap = mdl->maps;
+
+			if (mdlMap != gcvNULL
+				&& mdlMap->pid == current->tgid
+				&& mdlMap->next == gcvNULL)
+			{
+				MEMORY_UNLOCK(Os);
+
+				gcmkVERIFY_OK(gckOS_FreePagedMemory(Os, mdl, mdl->numPages * PAGE_SIZE));
+
+				MEMORY_LOCK(Os);
+
+				nextMdl = Os->mdlHead;
+			}
+		}
+
+		mdl = nextMdl;
+    }
+
+	MEMORY_UNLOCK(Os);
+}
+
+void
+PrintInfoOnExit(
+	IN gckOS Os,
+	IN gckKERNEL Kernel
+	)
+{
+	PLINUX_MDL      mdl, nextMdl;
+	PLINUX_MDL_MAP	mdlMap;
+
+	MEMORY_LOCK(Os);
+
+	mdl = Os->mdlHead;
+
+	while (mdl != gcvNULL)
+	{
+		if (mdl != Os->mdlTail)
+		{
+			nextMdl = mdl->next;
+		}
+		else
+		{
+			nextMdl = gcvNULL;
+		}
+
+		gcmkPRINT("Unfreed mdl: %p, pid: %d -> pagedMem: %s, addr: %p, dmaHandle: 0x%x, pages: %d",
+			mdl,
+			mdl->pid,
+			mdl->pagedMem? "true" : "false",
+			mdl->addr,
+			mdl->dmaHandle,
+			mdl->numPages);
+
+		mdlMap = mdl->maps;
+
+		while (mdlMap != gcvNULL)
+		{
+			gcmkPRINT("\tmap: %p, pid: %d -> vmaAddr: %p, vma: %p",
+					mdlMap,
+					mdlMap->pid,
+					mdlMap->vmaAddr,
+					mdlMap->vma);
+
+			mdlMap = mdlMap->next;
+		}
+
+		mdl = nextMdl;
+	}
+
+	MEMORY_UNLOCK(Os);
+}
+
+void
+OnProcessExit(
+	IN gckOS Os,
+	IN gckKERNEL Kernel
+	)
+{
+	/* PrintInfoOnExit(Os, Kernel); */
+
+#ifdef ANDROID
+	FreeProcessMemoryOnExit(Os, Kernel);
+#endif
+}
+
+/*******************************************************************************
+**
+**	gckOS_Construct
+**
+**	Construct a new gckOS object.
+**
+**	INPUT:
+**
+**		gctPOINTER Context
+**			Pointer to the gckGALDEVICE class.
+**
+**	OUTPUT:
+**
+**		gckOS * Os
+**			Pointer to a variable that will hold the pointer to the gckOS object.
+*/
+gceSTATUS
+gckOS_Construct(
+	IN gctPOINTER Context,
+	OUT gckOS * Os
+	)
+{
+    gckOS os;
+	gceSTATUS status;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_ARGUMENT(Os != gcvNULL);
+
+	/* Allocate the gckOS object. */
+    os = (gckOS) kmalloc(gcmSIZEOF(struct _gckOS), GFP_ATOMIC);
+
+	if (os == gcvNULL)
+	{
+		/* Out of memory. */
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	/* Zero the memory. */
+    gckOS_ZeroMemory(os, gcmSIZEOF(struct _gckOS));
+
+	/* Initialize the gckOS object. */
+	os->object.type = gcvOBJ_OS;
+
+	/* Set device device. */
+	os->device = Context;
+
+	/* IMPORTANT! No heap yet. */
+	os->heap = gcvNULL;
+
+	/* Initialize the memory lock. */
+    gcmkONERROR(gckOS_CreateMutex(os, &os->memoryLock));
+
+    gcmkONERROR(gckOS_CreateMutex(os, &os->memoryMapLock));
+
+	/* Create the gckHEAP object. */
+    gcmkONERROR(gckHEAP_Construct(os, gcdHEAP_SIZE, &os->heap));
+
+	os->mdlHead = os->mdlTail = gcvNULL;
+
+	/* Find the base address of the physical memory. */
+	os->baseAddress = os->device->baseAddress;
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
+				  "Physical base address set to 0x%08X.",
+				  os->baseAddress);
+
+    /* Get the kernel process ID. */
+    gcmkONERROR(gckOS_GetProcessID(&os->kernelProcessID));
+
+#if !USE_NEW_LINUX_SIGNAL
+	/*
+	 * Initialize the signal manager.
+	 * It creates the signals to be used in
+	 * the user space.
+	 */
+
+	/* Initialize mutex. */
+	gcmkONERROR(
+		gckOS_CreateMutex(os, &os->signal.lock));
+
+	/* Initialize the signal table. */
+	os->signal.table =
+		kmalloc(gcmSIZEOF(gctPOINTER) * USER_SIGNAL_TABLE_LEN_INIT, GFP_KERNEL);
+
+	if (os->signal.table == gcvNULL)
+	{
+		/* Out of memory. */
+		status = gcvSTATUS_OUT_OF_MEMORY;
+		goto OnError;
+	}
+
+    gckOS_ZeroMemory(os->signal.table,
+                     gcmSIZEOF(gctPOINTER) * USER_SIGNAL_TABLE_LEN_INIT);
+
+	/* Set the signal table length. */
+	os->signal.tableLen = USER_SIGNAL_TABLE_LEN_INIT;
+
+	/* The table is empty. */
+	os->signal.unused = os->signal.tableLen;
+
+	/* Initial signal ID. */
+	os->signal.currentID = 0;
+#endif
+
+	gcmkONERROR(
+		gckOS_CreateMutex(os, &os->mutexIdleProfile));
+
+	/* Return pointer to the gckOS object. */
+	*Os = os;
+
+	/* Success. */
+	return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+    if (os->mutexIdleProfile != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(os, os->mutexIdleProfile));
+	}
+   
+#if !USE_NEW_LINUX_SIGNAL
+	/* Roll back any allocation. */
+	if (os->signal.table != gcvNULL)
+	{
+		kfree(os->signal.table);
+        os->signal.table = gcvNULL;
+	}
+
+	if (os->signal.lock != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(os, os->signal.lock));
+        os->signal.lock = gcvNULL;
+	}
+#endif
+
+	if (os->heap != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckHEAP_Destroy(os->heap));
+        os->heap = gcvNULL;
+	}
+
+	if (os->memoryMapLock != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(os, os->memoryMapLock));
+        os->memoryMapLock = gcvNULL;
+	}
+
+	if (os->memoryLock != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(os, os->memoryLock));
+        os->memoryLock = gcvNULL;
+	}
+
+	kfree(os);
+
+    os = gcvNULL;
+
+	/* Return the error. */
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_Destroy
+**
+**	Destroy an gckOS object.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object that needs to be destroyed.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_Destroy(
+	IN gckOS Os
+	)
+{
+	gckHEAP     heap    = gcvNULL;
+    gctINT      i       = 0;
+    gctPOINTER *table   = Os->signal.table;   
+    
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    if (Os->mutexIdleProfile != gcvNULL)
+	{
+		gcmkVERIFY_OK(
+			gckOS_DeleteMutex(Os, Os->mutexIdleProfile));
+        Os->mutexIdleProfile = gcvNULL;
+	}  
+    
+#if !USE_NEW_LINUX_SIGNAL
+	/* Destroy the mutex. */
+    if(Os->signal.lock != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->signal.lock));
+        Os->signal.lock = gcvNULL;
+    }
+    
+    /* Free remain signal left in table */
+    for (i = 0; i < Os->signal.tableLen; i++)
+    {
+        if(table[i] != gcvNULL)
+        {
+            kfree(table[i]);
+            table[i] = gcvNULL;
+        }
+    }
+    
+	/* Free the signal table. */
+	kfree(Os->signal.table);
+    Os->signal.table    = gcvNULL;
+    Os->signal.tableLen = 0;
+#endif
+
+	if (Os->heap != gcvNULL)
+	{
+		/* Mark gckHEAP as gone. */
+		heap     = Os->heap;
+		Os->heap = gcvNULL;
+
+		/* Destroy the gckHEAP object. */
+		gcmkVERIFY_OK(
+			gckHEAP_Destroy(heap));
+	}
+
+	/* Destroy the memory lock. */
+    if(Os->memoryMapLock != gcvNULL)
+    {
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->memoryMapLock));
+        Os->memoryMapLock = gcvNULL;
+    }
+
+    if(Os->memoryLock != gcvNULL)
+    {	
+        gcmkVERIFY_OK(
+		    gckOS_DeleteMutex(Os, Os->memoryLock));
+        Os->memoryLock = gcvNULL;
+    }
+    
+	gcmkPRINT("$$FLUSH$$");
+
+	/* Mark the gckOS object as unknown. */
+	Os->object.type = gcvOBJ_UNKNOWN;
+
+	/* Free the gckOS object. */
+	kfree(Os);
+    Os = gcvNULL;
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/* the first numbers must success, because we need make sure surfaceFlinger start*/
+#define MUST_SUCCESS_THREASHOLD   30     
+
+static unsigned int cntMalloc = 0;
+static unsigned int failMalloc = 0;
+
+gctBOOL gckOS_ForceMemAllocFail(gckOS Os)
+{
+    unsigned int value = 0;
+
+    if(Os->device->memRandomFailRate == 0)
+        return gcvFALSE;
+    
+	get_random_bytes(&value, sizeof(unsigned int));
+
+    cntMalloc ++;
+    
+    if((value & 32767) < (gctUINT32)(Os->device->memRandomFailRate*327) && cntMalloc > MUST_SUCCESS_THREASHOLD)
+    {
+        failMalloc++;
+        gcmkPRINT("@@@@@@@@@@@@@@ total mem Malloc count: %d, fail Malloc count %d", cntMalloc, failMalloc);
+        return gcvTRUE;
+    }
+    else
+    {   
+        return gcvFALSE;
+    }
+}
+/*******************************************************************************
+**
+**	gckOS_Allocate
+**
+**	Allocate memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Memory
+**			Pointer to a variable that will hold the allocated memory location.
+*/
+gceSTATUS
+gckOS_Allocate(
+	IN gckOS Os,
+	IN gctSIZE_T Bytes,
+	OUT gctPOINTER * Memory
+	)
+{
+	gceSTATUS status;
+
+     /* gcmkHEADER_ARG("Os=0x%x Bytes=%lu", Os, Bytes); */
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+
+    /* Do we have a heap? */
+    if (Os->heap != gcvNULL)
+    {
+        /* Allocate from the heap. */
+        gcmkONERROR(gckHEAP_Allocate(Os->heap, Bytes, Memory));
+    }
+    else
+    {
+    	gcmkONERROR(gckOS_AllocateMemory(Os, Bytes, Memory));
+    }
+
+    /* Success. */
+     /* gcmkFOOTER_ARG("*memory=0x%x", *Memory); */
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_Free
+**
+**	Free allocated memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Memory
+**			Pointer to memory allocation to free.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_Free(
+	IN gckOS Os,
+	IN gctPOINTER Memory
+	)
+{
+	gceSTATUS status;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+
+	 /* gcmkHEADER_ARG("Os=0x%x Memory=0x%x", Os, memory); */
+
+	/* Do we have a heap? */
+	if (Os->heap != gcvNULL)
+	{
+		/* Free from the heap. */
+		gcmkONERROR(gckHEAP_Free(Os->heap, Memory));
+	}
+	else
+	{
+		gcmkONERROR(gckOS_FreeMemory(Os, Memory));
+	}
+
+	/* Success. */
+	 /* gcmkFOOTER_NO(); */
+	return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocateMemory
+**
+**	Allocate memory wrapper.
+**
+**	INPUT:
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Memory
+**			Pointer to a variable that will hold the allocated memory location.
+*/
+gceSTATUS
+gckOS_AllocateMemory(
+	IN gckOS Os,
+	IN gctSIZE_T Bytes,
+	OUT gctPOINTER * Memory
+	)
+{
+    gctPOINTER memory;
+    gceSTATUS status;
+
+    gcmkHEADER_ARG("Os=0x%x Bytes=%lu", Os, Bytes);
+
+    /* Verify the arguments. */
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+
+    memory = (gctPOINTER) kmalloc(Bytes, GFP_ATOMIC);
+
+    if (memory == gcvNULL)
+    {
+        /* Out of memory. */
+        gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+    }
+
+    /* Return pointer to the memory allocation. */
+    *Memory = memory;
+
+    /* Success. */
+    gcmkFOOTER_ARG("*Memory=0x%p", *Memory);
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkLOG_ERROR_STATUS();
+	/* Return the status. */
+	gcmkFOOTER();
+
+    *Memory = gcvNULL;
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_FreeMemory
+**
+**	Free allocated memory wrapper.
+**
+**	INPUT:
+**
+**		gctPOINTER Memory
+**			Pointer to memory allocation to free.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_FreeMemory(
+	IN gckOS Os,
+	IN gctPOINTER Memory
+	)
+{
+	gcmkHEADER_ARG("Memory=0x%p", Memory);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+
+	/* Free the memory from the OS pool. */
+	kfree(Memory);
+    Memory = gcvNULL;
+
+	/* Success. */
+	gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapMemory
+**
+**	Map physical memory into the current process.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Start of physical address memory.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to map.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Memory
+**			Pointer to a variable that will hold the logical address of the
+**			mapped memory.
+*/
+gceSTATUS
+gckOS_MapMemory(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes,
+	OUT gctPOINTER * Logical
+	)
+{
+	PLINUX_MDL_MAP	mdlMap;
+    PLINUX_MDL		mdl = (PLINUX_MDL)Physical;
+
+	/* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != 0);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+    if(((unsigned int)mdl->addr) & (ALLOC_ALIGN_BYTES -1 ))
+    {
+        gcmkPRINT("gckOS_MapMemory: physical address is %x, cannot satisfy alignment request! \n", (unsigned int)Physical);
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    MEMORY_LOCK(Os);
+
+	mdlMap = FindMdlMap(mdl, current->tgid);
+
+	if (mdlMap == gcvNULL)
+	{
+		mdlMap = _CreateMdlMap(mdl, current->tgid);
+
+		if (mdlMap == gcvNULL)
+		{
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+		}
+	}
+
+	if (mdlMap->vmaAddr == gcvNULL)
+	{
+	    unsigned long ret = 0;
+		down_write(&current->mm->mmap_sem);
+
+		ret = do_mmap_pgoff(gcvNULL,
+					0L,
+					mdl->numPages * PAGE_SIZE,
+					PROT_READ | PROT_WRITE,
+					MAP_SHARED,
+					0);
+
+		if (IS_ERR_VALUE(ret))
+		{
+            gcmkLOG_WARNING_ARGS("do_mmap_pgoff failure!");
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"gckOS_MapMemory: do_mmap error");
+
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"[gckOS_MapMemory] mdl->numPages: %d",
+				"[gckOS_MapMemory] mdl->vmaAddr: 0x%x",
+				mdl->numPages,
+				mdlMap->vmaAddr
+				);
+
+			up_write(&current->mm->mmap_sem);
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+		}
+        else
+        {
+            mdlMap->vmaAddr = (char *)ret;
+        }
+
+		mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
+
+		if (!mdlMap->vma)
+		{
+            gcmkLOG_WARNING_ARGS("can't find vma: 0x%08x", (unsigned long)mdlMap->vmaAddr);
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+					gcvZONE_OS,
+					"gckOS_MapMemory: find_vma error.");
+
+			mdlMap->vmaAddr = gcvNULL;
+
+			up_write(&current->mm->mmap_sem);
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+
+#ifndef NO_DMA_COHERENT
+		if (dma_mmap_coherent(gcvNULL,
+					mdlMap->vma,
+					mdl->addr,
+					mdl->dmaHandle,
+					mdl->numPages * PAGE_SIZE) < 0)
+		{
+            gcmkLOG_WARNING_ARGS("dma_mmap_coherent failure");
+			up_write(&current->mm->mmap_sem);
+
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+					gcvZONE_OS,
+					"gckOS_MapMemory: dma_mmap_coherent error.");
+
+			mdlMap->vmaAddr = gcvNULL;
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+#else
+		mdlMap->vma->vm_page_prot = pgprot_noncached(mdlMap->vma->vm_page_prot);
+		mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+		mdlMap->vma->vm_pgoff = 0;
+
+		if (remap_pfn_range(mdlMap->vma,
+							mdlMap->vma->vm_start,
+							mdl->dmaHandle >> PAGE_SHIFT,
+                	        mdl->numPages*PAGE_SIZE,
+                    	    mdlMap->vma->vm_page_prot) < 0)
+		{
+            gcmkLOG_WARNING_ARGS("remap_pfn_range failure");
+    	    up_write(&current->mm->mmap_sem);
+
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+					gcvZONE_OS,
+					"gckOS_MapMemory: remap_pfn_range error.");
+
+			mdlMap->vmaAddr = gcvNULL;
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+#endif
+
+		up_write(&current->mm->mmap_sem);
+	}
+
+	MEMORY_UNLOCK(Os);
+
+    *Logical = mdlMap->vmaAddr;
+
+	gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_OS,
+    			"gckOS_MapMemory: User Mapped address for 0x%x is 0x%x pid->%d",
+           		(gctUINT32)mdl->addr,
+				(gctUINT32)*Logical,
+				mdlMap->pid);
+
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_UnmapMemory
+**
+**	Unmap physical memory out of the current process.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Start of physical address memory.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to unmap.
+**
+**		gctPOINTER Memory
+**			Pointer to a previously mapped memory region.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_UnmapMemory(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes,
+	IN gctPOINTER Logical
+	)
+{
+	PLINUX_MDL_MAP			mdlMap;
+    PLINUX_MDL				mdl = (PLINUX_MDL)Physical;
+    struct task_struct *	task;
+
+    /* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Physical != 0);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
+	gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_UnmapMemory");
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"gckOS_UnmapMemory Will be unmapping 0x%x mdl->0x%x",
+				(gctUINT32)Logical,
+				(gctUINT32)mdl);
+
+	MEMORY_LOCK(Os);
+
+    if (Logical)
+    {
+		gcmkTRACE_ZONE(gcvLEVEL_VERBOSE,
+			gcvZONE_OS,
+			"[gckOS_UnmapMemory] Logical: 0x%x",
+			Logical
+			);
+
+		mdlMap = FindMdlMap(mdl, current->tgid);
+
+		if (mdlMap == gcvNULL || mdlMap->vmaAddr == gcvNULL)
+		{
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+        /* Get the current pointer for the task with stored pid. */
+        task = FIND_TASK_BY_PID(mdlMap->pid);
+
+        if (task != gcvNULL && task->mm != gcvNULL)
+		{
+			down_write(&task->mm->mmap_sem);
+			if(do_munmap(task->mm, 
+                         (unsigned long)Logical, 
+                         mdl->numPages*PAGE_SIZE) < 0)
+            {
+                gcmkTRACE_ZONE(gcvLEVEL_INFO,
+    				gcvZONE_OS,
+            		"Can't unmap the address %x",
+    				(unsigned long)Logical);
+            }			
+
+            up_write(&task->mm->mmap_sem);
+        }
+        else
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+						gcvZONE_OS,
+            			"Can't find the task with pid->%d. No unmapping",
+						mdlMap->pid);
+        }
+
+		gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	/* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocateNonPagedMemory
+**
+**	Allocate a number of pages from non-paged memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctBOOL InUserSpace
+**			gcvTRUE if the pages need to be mapped into user space.
+**
+**		gctSIZE_T * Bytes
+**			Pointer to a variable that holds the number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Bytes
+**			Pointer to a variable that hold the number of bytes allocated.
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that will hold the physical address of the
+**			allocation.
+**
+**		gctPOINTER * Logical
+**			Pointer to a variable that will hold the logical address of the
+**			allocation.
+*/
+gceSTATUS
+gckOS_AllocateNonPagedMemory(
+	IN gckOS Os,
+	IN gctBOOL InUserSpace,
+	IN OUT gctSIZE_T * Bytes,
+	OUT gctPHYS_ADDR * Physical,
+	OUT gctPOINTER * Logical
+	)
+{
+    gctSIZE_T		bytes;
+    gctINT			numPages;
+    PLINUX_MDL		mdl;
+	PLINUX_MDL_MAP	mdlMap = 0;
+	gctSTRING		addr;
+
+#ifdef NO_DMA_COHERENT
+	struct page *	page;
+    long			size, order;
+	gctPOINTER		vaddr;
+#endif
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT((Bytes != NULL) && (*Bytes > 0));
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+    gcmkVERIFY_ARGUMENT(Logical != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_AllocateNonPagedMemory");
+
+    /* Align number of bytes to page size. */
+    bytes = gcmALIGN(*Bytes, PAGE_SIZE);
+
+    /* Get total number of pages.. */
+    numPages = GetPageCount(bytes, 0);
+
+    /* Allocate mdl+vector structure */
+    mdl = _CreateMdl(current->tgid);
+
+	if (mdl == gcvNULL)
+	{
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	mdl->pagedMem = 0;
+    mdl->numPages = numPages;
+
+	MEMORY_LOCK(Os);
+
+#ifndef NO_DMA_COHERENT
+    addr = dma_alloc_coherent(NULL,
+				mdl->numPages * PAGE_SIZE,
+				&mdl->dmaHandle,
+				GFP_ATOMIC);
+#else
+	size	= mdl->numPages * PAGE_SIZE;
+	order	= get_order(size);
+	page	= alloc_pages(GFP_KERNEL | GFP_DMA, order);
+
+	if (page == gcvNULL)
+	{
+		MEMORY_UNLOCK(Os);
+
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+	vaddr			= (gctPOINTER)page_address(page);
+	addr			= ioremap_nocache(virt_to_phys(vaddr), size);
+	mdl->dmaHandle	= virt_to_phys(vaddr);
+	mdl->kaddr		= vaddr;
+#if ENABLE_ARM_L2_CACHE
+//	dma_cache_maint(vaddr, size, DMA_FROM_DEVICE);
+#endif
+
+	while (size > 0)
+	{
+		SetPageReserved(virt_to_page(vaddr));
+
+		vaddr	+= PAGE_SIZE;
+		size	-= PAGE_SIZE;
+	}
+#endif
+
+    if (addr == gcvNULL)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"galcore: Can't allocate memorry for size->0x%x",
+				(gctUINT32)bytes);
+
+        gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+		MEMORY_UNLOCK(Os);
+
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+	if ((Os->baseAddress & 0x80000000) != (mdl->dmaHandle & 0x80000000))
+	{
+		mdl->dmaHandle = (mdl->dmaHandle & ~0x80000000)
+					   | (Os->baseAddress & 0x80000000);
+	}
+
+    mdl->addr = addr;
+
+    /*
+	 * We will not do any mapping from here.
+	 * Mapping will happen from mmap method.
+	 * mdl structure will be used.
+	 */
+
+    /* Return allocated memory. */
+    *Bytes = bytes;
+    *Physical = (gctPHYS_ADDR) mdl;
+
+    if (InUserSpace)
+    {
+		mdlMap = _CreateMdlMap(mdl, current->tgid);
+
+		if (mdlMap == gcvNULL)
+		{
+			gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+		}
+
+        /* Only after mmap this will be valid. */
+
+        /* We need to map this to user space. */
+        down_write(&current->mm->mmap_sem);
+
+        mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(gcvNULL,
+				0L,
+				mdl->numPages * PAGE_SIZE,
+				PROT_READ | PROT_WRITE,
+				MAP_SHARED,
+				0);
+
+        if (mdlMap->vmaAddr == gcvNULL)
+        {
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"galcore: do_mmap error");
+
+			up_write(&current->mm->mmap_sem);
+
+			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+			gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+        }
+
+        mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
+
+		if (mdlMap->vma == gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"find_vma error");
+
+			up_write(&current->mm->mmap_sem);
+
+			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+			gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+
+#ifndef NO_DMA_COHERENT
+        if (dma_mmap_coherent(NULL,
+				mdlMap->vma,
+				mdl->addr,
+				mdl->dmaHandle,
+				mdl->numPages * PAGE_SIZE) < 0)
+		{
+			up_write(&current->mm->mmap_sem);
+
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"dma_mmap_coherent error");
+
+			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+			gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+#else
+		mdlMap->vma->vm_page_prot = pgprot_noncached(mdlMap->vma->vm_page_prot);
+		mdlMap->vma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_RESERVED;
+		mdlMap->vma->vm_pgoff = 0;
+
+		if (remap_pfn_range(mdlMap->vma,
+							mdlMap->vma->vm_start,
+							mdl->dmaHandle >> PAGE_SHIFT,
+							mdl->numPages * PAGE_SIZE,
+							mdlMap->vma->vm_page_prot))
+		{
+			up_write(&current->mm->mmap_sem);
+
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+					gcvZONE_OS,
+					"remap_pfn_range error");
+
+			gcmkVERIFY_OK(_DestroyMdlMap(mdl, mdlMap));
+			gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+#endif /* NO_DMA_COHERENT */
+
+        up_write(&current->mm->mmap_sem);
+
+        *Logical = mdlMap->vmaAddr;
+    }
+    else
+    {
+        *Logical = (gctPOINTER)mdl->addr;
+    }
+
+    /*
+	 * Add this to a global list.
+	 * Will be used by get physical address
+	 * and mapuser pointer functions.
+	 */
+
+    if (!Os->mdlHead)
+    {
+        /* Initialize the queue. */
+        Os->mdlHead = Os->mdlTail = mdl;
+    }
+    else
+    {
+        /* Add to the tail. */
+        mdl->prev = Os->mdlTail;
+        Os->mdlTail->next = mdl;
+        Os->mdlTail = mdl;
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_AllocateNonPagedMemory: "
+				"Bytes->0x%x, Mdl->%p, Logical->0x%x dmaHandle->0x%x",
+			(gctUINT32)bytes,
+				mdl,
+				(gctUINT32)mdl->addr,
+				mdl->dmaHandle);
+
+	if (InUserSpace)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"vmaAddr->0x%x pid->%d",
+				(gctUINT32)mdlMap->vmaAddr,
+				mdlMap->pid);
+	}
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_FreeNonPagedMemory
+**
+**	Free previously allocated and mapped pages from non-paged memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes allocated.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocated memory.
+**
+**		gctPOINTER Logical
+**			Logical address of the allocated memory.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_FreeNonPagedMemory(
+	IN gckOS Os,
+	IN gctSIZE_T Bytes,
+	IN gctPHYS_ADDR Physical,
+	IN gctPOINTER Logical
+	)
+{
+    PLINUX_MDL				mdl;
+	PLINUX_MDL_MAP			mdlMap;
+    struct task_struct *	task;
+
+#ifdef NO_DMA_COHERENT
+	unsigned				size;
+	gctPOINTER				vaddr;
+#endif /* NO_DMA_COHERENT */
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
+	gcmkVERIFY_ARGUMENT(Physical != 0);
+	gcmkVERIFY_ARGUMENT(Logical != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_FreeNonPagedMemory");
+
+	/* Convert physical address into a pointer to a MDL. */
+    mdl = (PLINUX_MDL) Physical;
+
+	MEMORY_LOCK(Os);
+
+#ifndef NO_DMA_COHERENT
+    dma_free_coherent(gcvNULL,
+					mdl->numPages * PAGE_SIZE,
+					mdl->addr,
+					mdl->dmaHandle);
+#else
+	size	= mdl->numPages * PAGE_SIZE;
+	vaddr	= mdl->kaddr;
+
+	while (size > 0)
+	{
+		ClearPageReserved(virt_to_page(vaddr));
+
+		vaddr	+= PAGE_SIZE;
+		size	-= PAGE_SIZE;
+	}
+
+	free_pages((unsigned long)mdl->kaddr, get_order(mdl->numPages * PAGE_SIZE));
+
+	iounmap(mdl->addr);
+#endif /* NO_DMA_COHERENT */
+
+	mdlMap = mdl->maps;
+
+	while (mdlMap != gcvNULL)
+	{
+		if (mdlMap->vmaAddr != gcvNULL)
+		{
+			/* Get the current pointer for the task with stored pid. */
+			task = FIND_TASK_BY_PID(mdlMap->pid);
+
+			if (task != gcvNULL && task->mm != gcvNULL)
+			{
+				down_write(&task->mm->mmap_sem);
+
+				if (do_munmap(task->mm,
+							(unsigned long)mdlMap->vmaAddr,
+							mdl->numPages * PAGE_SIZE) < 0)
+				{
+					gcmkTRACE_ZONE(gcvLEVEL_INFO,
+								gcvZONE_OS,
+						"gckOS_FreeNonPagedMemory: "
+								"Unmap Failed ->Mdl->0x%x Logical->0x%x vmaAddr->0x%x",
+					(gctUINT32)mdl,
+								(gctUINT32)mdl->addr,
+								(gctUINT32)mdlMap->vmaAddr);
+				}
+
+				up_write(&task->mm->mmap_sem);
+			}
+
+			mdlMap->vmaAddr = gcvNULL;
+		}
+
+		mdlMap = mdlMap->next;
+	}
+
+    /* Remove the node from global list.. */
+    if (mdl == Os->mdlHead)
+    {
+        if ((Os->mdlHead = mdl->next) == gcvNULL)
+        {
+            Os->mdlTail = gcvNULL;
+        }
+    }
+    else
+    {
+        mdl->prev->next = mdl->next;
+        if (mdl == Os->mdlTail)
+        {
+            Os->mdlTail = mdl->prev;
+        }
+        else
+        {
+            mdl->next->prev = mdl->prev;
+        }
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_FreeNonPagedMemory: "
+				"Mdl->0x%x Logical->0x%x",
+			(gctUINT32)mdl,
+				(gctUINT32)mdl->addr);
+
+	gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_ReadRegister
+**
+**	Read data from a register.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Address
+**			Address of register.
+**
+**	OUTPUT:
+**
+**		gctUINT32 * Data
+**			Pointer to a variable that receives the data read from the register.
+*/
+gceSTATUS gckOS_ReadRegister(
+	IN gckOS Os,
+	IN gctUINT32 Address,
+	OUT gctUINT32 * Data
+	)
+{
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Data != NULL);
+
+    *Data = readl((gctUINT8 *)Os->device->registerBase + Address);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_WriteRegister
+**
+**	Write data to a register.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Address
+**			Address of register.
+**
+**		gctUINT32 Data
+**			Data for register.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_WriteRegister(
+	IN gckOS Os,
+	IN gctUINT32 Address,
+	IN gctUINT32 Data
+	)
+{
+    writel(Data, (gctUINT8 *)Os->device->registerBase + Address);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_GetPageSize
+**
+**	Get the system's page size.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * PageSize
+**			Pointer to a variable that will receive the system's page size.
+*/
+gceSTATUS gckOS_GetPageSize(
+	IN gckOS Os,
+	OUT gctSIZE_T * PageSize
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(PageSize != NULL);
+
+	/* Return the page size. */
+	*PageSize = (gctSIZE_T) PAGE_SIZE;
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_GetPhysicalAddressProcess
+**
+**	Get the physical system address of a corresponding virtual address for a
+**  given process.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Logical
+**			Logical address.
+**
+**      gctUINT ProcessID
+**          Procedd ID.
+**
+**	OUTPUT:
+**
+**		gctUINT32 * Address
+**			Poinetr to a variable that receives the	32-bit physical adress.
+*/
+gceSTATUS
+gckOS_GetPhysicalAddressProcess(
+	IN gckOS Os,
+	IN gctPOINTER Logical,
+	IN gctUINT ProcessID,
+	OUT gctUINT32 * Address
+	)
+{
+    return gckOS_GetPhysicalAddress(Os, Logical, Address);
+}
+
+/*******************************************************************************
+**
+**	gckOS_GetPhysicalAddress
+**
+**	Get the physical system address of a corresponding virtual address.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Logical
+**			Logical address.
+**
+**	OUTPUT:
+**
+**		gctUINT32 * Address
+**			Poinetr to a variable that receives the	32-bit physical adress.
+*/
+gceSTATUS gckOS_GetPhysicalAddress(
+	IN gckOS Os,
+	IN gctPOINTER Logical,
+	OUT gctUINT32 * Address
+	)
+{
+    PLINUX_MDL		mdl;
+	PLINUX_MDL_MAP	mdlMap;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Address != gcvNULL);
+
+    /*
+	 * Try to search the address in our list.
+     * This could be an mmaped memory.
+	  * Search in our list.
+	  */
+
+	MEMORY_LOCK(Os);
+
+    mdl = Os->mdlHead;
+
+    while (mdl != gcvNULL)
+    {
+        /* Check for the logical address match. */
+        if (mdl->addr
+			&& (gctUINT32)Logical >= (gctUINT32)mdl->addr
+			&& (gctUINT32)Logical < ((gctUINT32)mdl->addr + mdl->numPages*PAGE_SIZE))
+        {
+            if (mdl->dmaHandle)
+            {
+                /* The memory was from coherent area. */
+                *Address = (gctUINT32)mdl->dmaHandle
+							+ (gctUINT32)((gctUINT32)Logical - (gctUINT32)mdl->addr);
+            }
+            else if (mdl->pagedMem)
+            {
+				if (mdl->contiguous)
+				{
+					*Address = (gctUINT32)virt_to_phys(mdl->addr)
+								+ ((gctUINT32)Logical - (gctUINT32)mdl->addr);
+				}
+				else
+				{
+					*Address = page_to_phys(vmalloc_to_page((gctSTRING)mdl->addr
+								+ ((gctUINT32)Logical - (gctUINT32)mdl->addr)));
+				}
+            }
+            else
+            {
+                *Address = (gctUINT32)virt_to_phys(mdl->addr)
+							+ ((gctUINT32)Logical - (gctUINT32)mdl->addr);
+            }
+            break;
+        }
+
+		mdlMap = FindMdlMap(mdl, current->tgid);
+
+        /* Is the given address within that range. */
+        if (mdlMap != gcvNULL
+			&& mdlMap->vmaAddr != gcvNULL
+			&& Logical >= mdlMap->vmaAddr
+			&& Logical < (mdlMap->vmaAddr + mdl->numPages * PAGE_SIZE))
+        {
+            if (mdl->dmaHandle)
+            {
+                /* The memory was from coherent area. */
+                *Address = (gctUINT32)mdl->dmaHandle
+							+ (gctUINT32)((gctUINT32)Logical
+							- (gctUINT32)mdlMap->vmaAddr);
+            }
+            else if (mdl->pagedMem)
+            {
+				if (mdl->contiguous)
+				{
+					*Address = (gctUINT32)virt_to_phys(mdl->addr)
+								+ (gctUINT32)(Logical - mdlMap->vmaAddr);
+				}
+				else
+				{
+					*Address = page_to_phys(vmalloc_to_page((gctSTRING)mdl->addr
+								+ ((gctUINT32)Logical - (gctUINT32)mdlMap->vmaAddr)));
+				}
+            }
+            else
+            {
+                /* Return the kernel virtual pointer based on this. */
+                *Address = (gctUINT32)virt_to_phys(mdl->addr)
+							+ (gctUINT32)(Logical - mdlMap->vmaAddr);
+            }
+            break;
+        }
+
+        mdl = mdl->next;
+    }
+
+	/* Subtract base address to get a GPU physical address. */
+	gcmkASSERT(*Address >= Os->baseAddress);
+	*Address -= Os->baseAddress;
+
+	MEMORY_UNLOCK(Os);
+
+    if (mdl == gcvNULL)
+    {
+        return gcvSTATUS_INVALID_ARGUMENT;
+    }
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapPhysical
+**
+**	Map a physical address into kernel space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Physical
+**			Physical address of the memory to map.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to map.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Logical
+**			Pointer to a variable that receives the	base address of the mapped
+**			memory.
+*/
+gceSTATUS gckOS_MapPhysical(
+	IN gckOS Os,
+	IN gctUINT32 Physical,
+	IN gctUINT32 OriginalLogical,
+	IN gctSIZE_T Bytes,
+	OUT gctPOINTER * Logical
+	)
+{
+	gctPOINTER logical;
+    PLINUX_MDL mdl;
+	gctUINT32 physical;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Logical != gcvNULL);
+
+	MEMORY_LOCK(Os);
+
+	/* Compute true physical address (before subtraction of the baseAddress). */
+	physical = Physical + Os->baseAddress;
+
+    /* Go through our mapping to see if we know this physical address already. */
+    mdl = Os->mdlHead;
+
+    while (mdl != gcvNULL)
+    {
+        if (mdl->dmaHandle != 0)
+        {
+            if ((physical >= mdl->dmaHandle)
+			&&  (physical < mdl->dmaHandle + mdl->numPages * PAGE_SIZE)
+			)
+            {
+                *Logical = mdl->addr + (physical - mdl->dmaHandle);
+                break;
+            }
+        }
+
+        mdl = mdl->next;
+    }
+
+    if (mdl == gcvNULL)
+    {
+        /* Map memory as cached memory. */
+        request_mem_region(physical, Bytes, "MapRegion");
+        logical = (gctPOINTER) ioremap_nocache(physical, Bytes);
+
+	    if (logical == NULL)
+	    {
+			gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
+				  "gckOS_MapMemory: Failed to ioremap");
+
+			MEMORY_UNLOCK(Os);
+
+			/* Out of resources. */
+		    return gcvSTATUS_OUT_OF_RESOURCES;
+	    }
+
+	    /* Return pointer to mapped memory. */
+	    *Logical = logical;
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS,
+			  "gckOS_MapPhysical: "
+				  "Physical->0x%X Bytes->0x%X Logical->0x%X MappingFound->%d",
+				  (gctUINT32) Physical,
+				  (gctUINT32) Bytes,
+				  (gctUINT32) *Logical,
+				   mdl ? 1 : 0);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_UnmapPhysical
+**
+**	Unmap a previously mapped memory region from kernel memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Logical
+**			Pointer to the base address of the memory to unmap.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to unmap.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_UnmapPhysical(
+	IN gckOS Os,
+	IN gctPOINTER Logical,
+	IN gctSIZE_T Bytes
+	)
+{
+    PLINUX_MDL  mdl;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Logical != NULL);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
+
+	MEMORY_LOCK(Os);
+
+    mdl = Os->mdlHead;
+
+    while (mdl != gcvNULL)
+    {
+        if (mdl->addr != gcvNULL)
+        {
+            if (Logical >= (gctPOINTER)mdl->addr
+					&& Logical < (gctPOINTER)((gctSTRING)mdl->addr + mdl->numPages * PAGE_SIZE))
+            {
+                break;
+            }
+        }
+
+        mdl = mdl->next;
+    }
+
+    if (mdl == gcvNULL)
+    {
+	    /* Unmap the memory. */
+	    iounmap(Logical);
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+					gcvZONE_OS,
+				"gckOS_UnmapPhysical: "
+					"Logical->0x%x Bytes->0x%x MappingFound(?)->%d",
+				(gctUINT32)Logical,
+					(gctUINT32)Bytes,
+					mdl ? 1 : 0);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_CreateMutex
+**
+**	Create a new mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Mutex
+**			Pointer to a variable that will hold a pointer to the mutex.
+*/
+gceSTATUS gckOS_CreateMutex(
+	IN gckOS Os,
+	OUT gctPOINTER * Mutex
+	)
+{
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+
+	/* Allocate a FAST_MUTEX structure. */
+	*Mutex = (gctPOINTER)kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+
+	if (*Mutex == gcvNULL)
+	{
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+    /* Initialize the semaphore.. Come up in unlocked state. */
+        sema_init(*Mutex,1);
+//    init_MUTEX(*Mutex);
+
+	/* Return status. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_DeleteMutex
+**
+**	Delete a mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Mutex
+**			Pointer to the mute to be deleted.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_DeleteMutex(
+	IN gckOS Os,
+	IN gctPOINTER Mutex
+	)
+{
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+
+	/* Delete the fast mutex. */
+	kfree(Mutex);
+
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AcquireMutex
+**
+**	Acquire a mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Mutex
+**			Pointer to the mutex to be acquired.
+**
+**		gctUINT32 Timeout
+**			Timeout value specified in milliseconds.
+**			Specify the value of gcvINFINITE to keep the thread suspended
+**			until the mutex has been acquired.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_AcquireMutex(
+	IN gckOS Os,
+	IN gctPOINTER Mutex,
+	IN gctUINT32 Timeout
+	)
+{
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+
+	if (Timeout == gcvINFINITE)
+	{
+		down((struct semaphore *) Mutex);
+
+		/* Success. */
+		return gcvSTATUS_OK;
+	}
+
+	while (Timeout-- > 0)
+	{
+		/* Try to acquire the fast mutex. */
+		if (!down_trylock((struct semaphore *) Mutex))
+		{
+			/* Success. */
+			return gcvSTATUS_OK;
+		}
+
+		/* Wait for 1 millisecond. */
+		gcmkVERIFY_OK(gckOS_Delay(Os, 1));
+	}
+
+	/* Timeout. */
+	return gcvSTATUS_TIMEOUT;
+}
+
+/*******************************************************************************
+**
+**	gckOS_ReleaseMutex
+**
+**	Release an acquired mutex.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Mutex
+**			Pointer to the mutex to be released.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_ReleaseMutex(
+	IN gckOS Os,
+	IN gctPOINTER Mutex
+	)
+{
+	/* Validate the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Mutex != NULL);
+
+	/* Release the fast mutex. */
+	up((struct semaphore *) Mutex);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AtomicExchange
+**
+**	Atomically exchange a pair of 32-bit values.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**      IN OUT gctINT32_PTR Target
+**          Pointer to the 32-bit value to exchange.
+**
+**		IN gctINT32 NewValue
+**			Specifies a new value for the 32-bit value pointed to by Target.
+**
+**      OUT gctINT32_PTR OldValue
+**          The old value of the 32-bit value pointed to by Target.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_AtomicExchange(
+	IN gckOS Os,
+    IN OUT gctUINT32_PTR Target,
+	IN gctUINT32 NewValue,
+    OUT gctUINT32_PTR OldValue
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	/* Exchange the pair of 32-bit values. */
+	*OldValue = (gctUINT32) atomic_xchg((atomic_t *) Target, (int) NewValue);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+
+/*******************************************************************************
+**
+**	gckOS_AtomicExchangePtr
+**
+**	Atomically exchange a pair of pointers.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**      IN OUT gctPOINTER * Target
+**          Pointer to the 32-bit value to exchange.
+**
+**		IN gctPOINTER NewValue
+**			Specifies a new value for the pointer pointed to by Target.
+**
+**      OUT gctPOINTER * OldValue
+**          The old value of the pointer pointed to by Target.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_AtomicExchangePtr(
+	IN gckOS Os,
+    IN OUT gctPOINTER * Target,
+	IN gctPOINTER NewValue,
+    OUT gctPOINTER * OldValue
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	/* Exchange the pair of pointers. */
+	*OldValue = (gctPOINTER) atomic_xchg((atomic_t *) Target, (int) NewValue);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+
+/*******************************************************************************
+**
+**	gckOS_Delay
+**
+**	Delay execution of the current thread for a number of milliseconds.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Delay
+**			Delay to sleep, specified in milliseconds.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_Delay(
+	IN gckOS Os,
+	IN gctUINT32 Delay
+	)
+{
+#ifdef CONFIG_PXA_DVFM
+    if(Os->device->enableMdelay)
+    {
+        mdelay(1);
+    }
+    else
+#endif
+    {
+	struct timeval now;
+	unsigned long ticks;
+
+	if (Delay == 0)
+	{
+		/* Smallest delay possible. */
+		ticks = 1;
+	}
+	else
+	{
+		/* Convert milliseconds into seconds and microseconds. */
+		now.tv_sec  = Delay / 1000;
+		now.tv_usec = (Delay % 1000) * 1000;
+
+		/* Convert Delay to jiffies. */
+		ticks = timeval_to_jiffies(&now);
+	}
+
+	/* Schedule timeout. */
+	schedule_timeout_interruptible(ticks);
+    }
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MemoryBarrier
+**
+**	Make sure the CPU has executed everything up to this point and the data got
+**	written to the specified pointer.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Address
+**			Address of memory that needs to be barriered.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_MemoryBarrier(
+	IN gckOS Os,
+	IN gctPOINTER Address
+	)
+{
+	/* Verify thearguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	mb();
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocatePagedMemory
+**
+**	Allocate memory from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that receives the physical address of the
+**			memory allocation.
+*/
+gceSTATUS
+gckOS_AllocatePagedMemory(
+	IN gckOS Os,
+	IN gctSIZE_T Bytes,
+	OUT gctPHYS_ADDR * Physical
+	)
+{
+	return gckOS_AllocatePagedMemoryEx(Os, gcvFALSE, Bytes, Physical);
+}
+
+/*******************************************************************************
+**
+**	gckOS_AllocatePagedMemoryEx
+**
+**	Allocate memory from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctBOOL Contiguous
+**			Need contiguous memory or not.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that receives	the	physical address of the
+**			memory allocation.
+*/
+gceSTATUS gckOS_AllocatePagedMemoryEx(
+	IN gckOS Os,
+	IN gctBOOL Contiguous,
+	IN gctSIZE_T Bytes,
+	OUT gctPHYS_ADDR * Physical
+	)
+{
+    gctINT		numPages;
+    gctINT		i;
+    PLINUX_MDL  mdl;
+    gctSTRING	addr;
+    gctSIZE_T   bytes;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Bytes > 0);
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_AllocatePagedMemoryEx");
+
+    bytes = gcmALIGN(Bytes, PAGE_SIZE);
+
+    numPages = GetPageCount(bytes, 0);
+
+	MEMORY_LOCK(Os);
+
+	/* Bugbug: for some specific linux systems, vmalloc can't work correctly. Disable the non-contiguous support by default */
+	Contiguous = gcvTRUE;
+
+	if (Contiguous)
+	{
+		addr = (char *)__get_free_pages(GFP_ATOMIC | GFP_DMA, GetOrder(numPages));
+	}
+	else
+	{
+	    addr = vmalloc(bytes);
+	}
+
+    if (!addr)
+    {
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_AllocatePagedMemoryEx: "
+				"Can't allocate memorry for size->0x%x",
+				(gctUINT32)bytes);
+
+		MEMORY_UNLOCK(Os);
+
+        return gcvSTATUS_OUT_OF_MEMORY;
+    }
+
+    mdl = _CreateMdl(current->tgid);
+
+	if (mdl == gcvNULL)
+	{
+		MEMORY_UNLOCK(Os);
+
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	mdl->dmaHandle	= 0;
+    mdl->addr		= addr;
+    mdl->numPages	= numPages;
+    mdl->pagedMem	= 1;
+	mdl->contiguous = Contiguous;
+
+	for (i = 0; i < mdl->numPages; i++)
+    {
+		if (mdl->contiguous)
+		{
+			SetPageReserved(virt_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+		else
+		{
+			SetPageReserved(vmalloc_to_page((void *)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+    }
+
+    /* Return physical address. */
+    *Physical = (gctPHYS_ADDR) mdl;
+
+    /*
+	 * Add this to a global list.
+	 * Will be used by get physical address
+	 * and mapuser pointer functions.
+	 */
+    if (!Os->mdlHead)
+    {
+        /* Initialize the queue. */
+        Os->mdlHead = Os->mdlTail = mdl;
+    }
+    else
+    {
+        /* Add to tail. */
+        mdl->prev			= Os->mdlTail;
+        Os->mdlTail->next	= mdl;
+        Os->mdlTail			= mdl;
+    }
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_AllocatePagedMemoryEx: "
+				"Bytes->0x%x, Mdl->%p, Logical->%p",
+			(gctUINT32)bytes,
+				mdl,
+				mdl->addr);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_FreePagedMemory
+**
+**	Free memory allocated from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_FreePagedMemory(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes
+	)
+{
+    PLINUX_MDL  mdl = (PLINUX_MDL)Physical;
+    gctSTRING	addr;
+    gctINT		i;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_FreePagedMemory");
+
+    addr = mdl->addr;
+
+	MEMORY_LOCK(Os);
+
+    for (i = 0; i < mdl->numPages; i++)
+	{
+		if (mdl->contiguous)
+		{
+	        ClearPageReserved(virt_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+		else
+		{
+			ClearPageReserved(vmalloc_to_page((gctPOINTER)(((unsigned long)addr) + i * PAGE_SIZE)));
+		}
+    }
+
+	if (mdl->contiguous)
+	{
+		free_pages((unsigned long)mdl->addr, GetOrder(mdl->numPages));
+	}
+	else
+	{
+		vfree(mdl->addr);
+	}
+
+    /* Remove the node from global list. */
+    if (mdl == Os->mdlHead)
+    {
+        if ((Os->mdlHead = mdl->next) == gcvNULL)
+        {
+            Os->mdlTail = gcvNULL;
+        }
+    }
+    else
+    {
+        mdl->prev->next = mdl->next;
+
+        if (mdl == Os->mdlTail)
+        {
+            Os->mdlTail = mdl->prev;
+        }
+        else
+        {
+            mdl->next->prev = mdl->prev;
+        }
+    }
+
+	MEMORY_UNLOCK(Os);
+
+    /* Free the structure... */
+    gcmkVERIFY_OK(_DestroyMdl(mdl));
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_FreePagedMemory: Bytes->0x%x, Mdl->0x%x",
+				(gctUINT32)Bytes,
+				(gctUINT32)mdl);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_LockPages
+**
+**	Lock memory allocated from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Logical
+**			Pointer to a variable that receives the	address of the mapped
+**			memory.
+**
+**		gctSIZE_T * PageCount
+**			Pointer to a variable that receives the	number of pages required for
+**			the page table according to the GPU page size.
+*/
+gceSTATUS gckOS_LockPages(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes,
+	OUT gctPOINTER * Logical,
+	OUT gctSIZE_T * PageCount
+	)
+{
+    PLINUX_MDL		mdl;
+	PLINUX_MDL_MAP	mdlMap;
+    gctSTRING		addr;
+    unsigned long	start;
+    unsigned long	pfn;
+    gctINT			i;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+    gcmkVERIFY_ARGUMENT(Logical != NULL);
+    gcmkVERIFY_ARGUMENT(PageCount != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_LockPages");
+
+    mdl = (PLINUX_MDL) Physical;
+
+	MEMORY_LOCK(Os);
+
+	mdlMap = FindMdlMap(mdl, current->tgid);
+
+	if (mdlMap == gcvNULL)
+	{
+		mdlMap = _CreateMdlMap(mdl, current->tgid);
+
+		if (mdlMap == gcvNULL)
+		{
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+		}
+	}
+
+	if (mdlMap->vmaAddr == gcvNULL)
+	{
+		down_write(&current->mm->mmap_sem);
+
+		mdlMap->vmaAddr = (gctSTRING)do_mmap_pgoff(NULL,
+						0L,
+						mdl->numPages * PAGE_SIZE,
+						PROT_READ | PROT_WRITE,
+						MAP_SHARED,
+						0);
+
+		up_write(&current->mm->mmap_sem);
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+						gcvZONE_OS,
+						"gckOS_LockPages: "
+						"vmaAddr->0x%x for phys_addr->0x%x",
+						(gctUINT32)mdlMap->vmaAddr,
+						(gctUINT32)mdl);
+
+		if (mdlMap->vmaAddr == gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+						gcvZONE_OS,
+						"gckOS_LockPages: do_mmap error");
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_MEMORY;
+		}
+
+		mdlMap->vma = find_vma(current->mm, (unsigned long)mdlMap->vmaAddr);
+
+		if (mdlMap->vma == gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+						gcvZONE_OS,
+						"find_vma error");
+
+			mdlMap->vmaAddr = gcvNULL;
+
+			MEMORY_UNLOCK(Os);
+
+			return gcvSTATUS_OUT_OF_RESOURCES;
+		}
+
+		mdlMap->vma->vm_flags |= VM_RESERVED;
+		/* Make this mapping non-cached. */
+		mdlMap->vma->vm_page_prot = pgprot_noncached(mdlMap->vma->vm_page_prot);
+
+		addr = mdl->addr;
+
+		/* Now map all the vmalloc pages to this user address. */
+		down_write(&current->mm->mmap_sem);
+
+		if (mdl->contiguous)
+		{
+			/* map kernel memory to user space.. */
+			if (remap_pfn_range(mdlMap->vma,
+								mdlMap->vma->vm_start,
+								virt_to_phys((gctPOINTER)mdl->addr) >> PAGE_SHIFT,
+								mdlMap->vma->vm_end - mdlMap->vma->vm_start,
+								mdlMap->vma->vm_page_prot) < 0)
+			{
+				up_write(&current->mm->mmap_sem);
+
+				gcmkTRACE_ZONE(gcvLEVEL_INFO,
+							gcvZONE_OS,
+						"gckOS_LockPages: unable to mmap ret");
+
+				mdlMap->vmaAddr = gcvNULL;
+
+				MEMORY_UNLOCK(Os);
+
+				return gcvSTATUS_OUT_OF_MEMORY;
+			}
+		}
+		else
+		{
+			start = mdlMap->vma->vm_start;
+
+			for (i = 0; i < mdl->numPages; i++)
+			{
+				pfn = vmalloc_to_pfn(addr);
+
+				if (remap_pfn_range(mdlMap->vma,
+									start,
+									pfn,
+									PAGE_SIZE,
+									mdlMap->vma->vm_page_prot) < 0)
+				{
+					up_write(&current->mm->mmap_sem);
+
+					gcmkTRACE_ZONE(gcvLEVEL_INFO,
+								gcvZONE_OS,
+						"gckOS_LockPages: "
+								"gctPHYS_ADDR->0x%x Logical->0x%x Unable to map addr->0x%x to start->0x%x",
+						(gctUINT32)Physical,
+								(gctUINT32)*Logical,
+								(gctUINT32)addr,
+								(gctUINT32)start);
+
+					mdlMap->vmaAddr = gcvNULL;
+
+					MEMORY_UNLOCK(Os);
+
+					return gcvSTATUS_OUT_OF_MEMORY;
+				}
+
+				start += PAGE_SIZE;
+				addr += PAGE_SIZE;
+			}
+		}
+
+		up_write(&current->mm->mmap_sem);
+	}
+
+    /* Convert pointer to MDL. */
+    *Logical = mdlMap->vmaAddr;
+
+	/* Return the page number according to the GPU page size. */
+	gcmkASSERT((PAGE_SIZE % 4096) == 0);
+	gcmkASSERT((PAGE_SIZE / 4096) >= 1);
+
+    *PageCount = mdl->numPages * (PAGE_SIZE / 4096);
+
+	MEMORY_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_LockPages: "
+				"gctPHYS_ADDR->0x%x Bytes->0x%x Logical->0x%x pid->%d",
+			(gctUINT32)Physical,
+				(gctUINT32)Bytes,
+				(gctUINT32)*Logical,
+				mdlMap->pid);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapPages
+**
+**	Map paged memory into a page table.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T PageCount
+**			Number of pages required for the physical address.
+**
+**		gctPOINTER PageTable
+**			Pointer to the page table to fill in.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_MapPages(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T PageCount,
+	IN gctPOINTER PageTable
+	)
+{
+    PLINUX_MDL  mdl;
+    gctUINT32*	table;
+    gctSTRING	addr;
+    gctINT		i = 0;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+    gcmkVERIFY_ARGUMENT(PageCount > 0);
+    gcmkVERIFY_ARGUMENT(PageTable != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_MapPages");
+
+    /* Convert pointer to MDL. */
+    mdl = (PLINUX_MDL)Physical;
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+			"gckOS_MapPages: "
+				"Physical->0x%x PageCount->0x%x PagedMemory->?%d",
+			(gctUINT32)Physical,
+				(gctUINT32)PageCount,
+				mdl->pagedMem);
+
+	MEMORY_LOCK(Os);
+
+    table = (gctUINT32 *)PageTable;
+
+	 /* Get all the physical addresses and store them in the page table. */
+
+	addr = mdl->addr;
+
+    if (mdl->pagedMem)
+    {
+        /* Try to get the user pages so DMA can happen. */
+        while (PageCount-- > 0)
+        {
+			if (mdl->contiguous)
+			{
+				*table++ = virt_to_phys(addr);
+			}
+			else
+			{
+				*table++ = page_to_phys(vmalloc_to_page(addr));
+			}
+
+            addr += 4096;
+            i++;
+        }
+    }
+    else
+    {
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+					gcvZONE_OS,
+				"We should not get this call for Non Paged Memory!");
+
+		while (PageCount-- > 0)
+        {
+            *table++ = (gctUINT32)virt_to_phys(addr);
+            addr += 4096;
+        }
+    }
+
+	MEMORY_UNLOCK(Os);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_UnlockPages
+**
+**	Unlock memory allocated from the paged pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**		gctPOINTER Logical
+**			Address of the mapped memory.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_UnlockPages(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctSIZE_T Bytes,
+	IN gctPOINTER Logical
+	)
+{
+	PLINUX_MDL_MAP			mdlMap;
+    PLINUX_MDL				mdl = (PLINUX_MDL)Physical;
+    struct task_struct *	task;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Physical != NULL);
+    gcmkVERIFY_ARGUMENT(Logical != NULL);
+
+	/* Make sure there is already a mapping...*/
+    gcmkVERIFY_ARGUMENT(mdl->addr != NULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"in gckOS_UnlockPages");
+
+	MEMORY_LOCK(Os);
+
+	mdlMap = mdl->maps;
+
+	while (mdlMap != gcvNULL)
+	{
+		if (mdlMap->vmaAddr != gcvNULL)
+		{
+			/* Get the current pointer for the task with stored pid. */
+			task = FIND_TASK_BY_PID(mdlMap->pid);
+
+			if (task != gcvNULL && task->mm != gcvNULL)
+			{
+				down_write(&task->mm->mmap_sem);
+				do_munmap(task->mm, (unsigned long)Logical, mdl->numPages * PAGE_SIZE);
+				up_write(&task->mm->mmap_sem);
+			}
+
+			mdlMap->vmaAddr = gcvNULL;
+		}
+
+		mdlMap = mdlMap->next;
+	}
+
+	MEMORY_UNLOCK(Os);
+
+    /* Success. */
+    return gcvSTATUS_OK;
+}
+
+
+/*******************************************************************************
+**
+**	gckOS_AllocateContiguous
+**
+**	Allocate memory from the contiguous pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+** 		gctBOOL InUserSpace
+**			gcvTRUE if the pages need to be mapped into user space.
+**
+**		gctSIZE_T * Bytes
+**			Pointer to the number of bytes to allocate.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Bytes
+**			Pointer to a variable that receives	the	number of bytes allocated.
+**
+**		gctPHYS_ADDR * Physical
+**			Pointer to a variable that receives	the	physical address of the
+**			memory allocation.
+**
+**		gctPOINTER * Logical
+**			Pointer to a variable that receives	the	logical address of the
+**			memory allocation.
+*/
+gceSTATUS gckOS_AllocateContiguous(
+	IN gckOS Os,
+	IN gctBOOL InUserSpace,
+	IN OUT gctSIZE_T * Bytes,
+	OUT gctPHYS_ADDR * Physical,
+	OUT gctPOINTER * Logical
+	)
+{
+    /* Same as non-paged memory for now. */
+    return gckOS_AllocateNonPagedMemory(Os,
+				InUserSpace,
+				Bytes,
+				Physical,
+				Logical
+				);
+}
+
+/*******************************************************************************
+**
+**	gckOS_FreeContiguous
+**
+**	Free memory allocated from the contiguous pool.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPHYS_ADDR Physical
+**			Physical address of the allocation.
+**
+**		gctPOINTER Logical
+**			Logicval address of the allocation.
+**
+**		gctSIZE_T Bytes
+**			Number of bytes of the allocation.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS gckOS_FreeContiguous(
+	IN gckOS Os,
+	IN gctPHYS_ADDR Physical,
+	IN gctPOINTER Logical,
+	IN gctSIZE_T Bytes
+	)
+{
+    /* Same of non-paged memory for now. */
+    return gckOS_FreeNonPagedMemory(Os, Bytes, Physical, Logical);
+}
+
+/******************************************************************************
+**
+**	gckOS_GetKernelLogical
+**
+**	Return the kernel logical pointer that corresponods to the specified
+**	hardware address.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctUINT32 Address
+**			Hardware physical address.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * KernelPointer
+**			Pointer to a variable receiving the pointer in kernel address space.
+*/
+gceSTATUS
+gckOS_GetKernelLogical(
+	IN gckOS Os,
+	IN gctUINT32 Address,
+	OUT gctPOINTER * KernelPointer
+	)
+{
+	gceSTATUS status;
+
+	do
+	{
+		gckGALDEVICE device;
+		gckKERNEL kernel;
+		gcePOOL pool;
+		gctUINT32 offset;
+		gctPOINTER logical;
+
+		/* Extract the pointer to the gckGALDEVICE class. */
+		device = (gckGALDEVICE) Os->device;
+
+		/* Kernel shortcut. */
+		kernel = device->kernel;
+
+		/* Split the memory address into a pool type and offset. */
+		gcmkERR_BREAK(gckHARDWARE_SplitMemory(
+			kernel->hardware, Address, &pool, &offset
+			));
+
+		/* Dispatch on pool. */
+		switch (pool)
+		{
+		case gcvPOOL_LOCAL_INTERNAL:
+			/* Internal memory. */
+			logical = device->internalLogical;
+			break;
+
+		case gcvPOOL_LOCAL_EXTERNAL:
+			/* External memory. */
+			logical = device->externalLogical;
+			break;
+
+		case gcvPOOL_SYSTEM:
+			/* System memory. */
+			logical = device->contiguousBase;
+			break;
+
+		default:
+			/* Invalid memory pool. */
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		/* Build logical address of specified address. */
+		* KernelPointer = ((gctUINT8_PTR) logical) + offset;
+
+		/* Success. */
+		return gcvSTATUS_OK;
+	}
+	while (gcvFALSE);
+
+	/* Return status. */
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapUserPointer
+**
+**	Map a pointer from the user process into the kernel address space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Pointer
+**			Pointer in user process space that needs to be mapped.
+**
+**		gctSIZE_T Size
+**			Number of bytes that need to be mapped.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * KernelPointer
+**			Pointer to a variable receiving the mapped pointer in kernel address
+**			space.
+*/
+gceSTATUS
+gckOS_MapUserPointer(
+	IN gckOS Os,
+	IN gctPOINTER Pointer,
+	IN gctSIZE_T Size,
+	OUT gctPOINTER * KernelPointer
+	)
+{
+#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
+	gctPOINTER buf = gcvNULL;
+	gctUINT32 len;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Size > 0);
+    gcmkVERIFY_ARGUMENT(KernelPointer != gcvNULL);
+
+	buf = kmalloc(Size, GFP_KERNEL);
+	if (buf == gcvNULL)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"Failed to allocate memory at line %d in %s.",
+			__LINE__, __FILE__
+			);
+
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	len = copy_from_user(buf, Pointer, Size);
+	if (len != 0)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"Failed to copy data from user at line %d in %s.",
+			__LINE__, __FILE__
+			);
+
+		if (buf != gcvNULL)
+		{
+			kfree(buf);
+		}
+
+		return gcvSTATUS_GENERIC_IO;
+	}
+
+	*KernelPointer = buf;
+#else
+	*KernelPointer = Pointer;
+#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
+
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_UnmapUserPointer
+**
+**	Unmap a user process pointer from the kernel address space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Pointer
+**			Pointer in user process space that needs to be unmapped.
+**
+**		gctSIZE_T Size
+**			Number of bytes that need to be unmapped.
+**
+**		gctPOINTER KernelPointer
+**			Pointer in kernel address space that needs to be unmapped.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_UnmapUserPointer(
+	IN gckOS Os,
+	IN gctPOINTER Pointer,
+	IN gctSIZE_T Size,
+	IN gctPOINTER KernelPointer
+	)
+{
+#if NO_USER_DIRECT_ACCESS_FROM_KERNEL
+	gctUINT32 len;
+
+    /* Verify the arguments. */
+    gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+    gcmkVERIFY_ARGUMENT(Pointer != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Size > 0);
+    gcmkVERIFY_ARGUMENT(KernelPointer != gcvNULL);
+
+	len = copy_to_user(Pointer, KernelPointer, Size);
+
+	kfree(KernelPointer);
+
+	if (len != 0)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"Failed to copy data to user at line %d in %s.",
+			__LINE__, __FILE__
+			);
+		return gcvSTATUS_GENERIC_IO;
+	}
+#endif /* NO_USER_DIRECT_ACCESS_FROM_KERNEL */
+
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_WriteMemory
+**
+**	Write data to a memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctPOINTER Address
+**			Address of the memory to write to.
+**
+**		gctUINT32 Data
+**			Data for register.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_WriteMemory(
+	IN gckOS Os,
+	IN gctPOINTER Address,
+	IN gctUINT32 Data
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_ARGUMENT(Address != NULL);
+
+	/* Write memory. */
+    writel(Data, (gctUINT8 *)Address);
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**
+**	gckOS_CreateSignal
+**
+**	Create a new signal.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctBOOL ManualReset
+**			If set to gcvTRUE, gckOS_Signal with gcvFALSE must be called in
+**			order to set the signal to nonsignaled state.
+**			If set to gcvFALSE, the signal will automatically be set to
+**			nonsignaled state by gckOS_WaitSignal function.
+**
+**	OUTPUT:
+**
+**		gctSIGNAL * Signal
+**			Pointer to a variable receiving the created gctSIGNAL.
+*/
+gceSTATUS
+gckOS_CreateSignal(
+	IN gckOS Os,
+	IN gctBOOL ManualReset,
+	OUT gctSIGNAL * Signal
+	)
+{
+#if USE_NEW_LINUX_SIGNAL
+	return gcvSTATUS_NOT_SUPPORTED;
+#else
+	gcsSIGNAL_PTR signal;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Signal != NULL);
+
+	/* Create an event structure. */
+	signal = (gcsSIGNAL_PTR)kmalloc(sizeof(gcsSIGNAL), GFP_KERNEL);
+
+	if (signal == gcvNULL)
+	{
+		return gcvSTATUS_OUT_OF_MEMORY;
+	}
+
+	signal->manualReset = ManualReset;
+
+	init_completion(&signal->event);
+
+	atomic_set(&signal->ref, 1);
+
+	*Signal = (gctSIGNAL) signal;
+
+	return gcvSTATUS_OK;
+#endif
+}
+
+/*******************************************************************************
+**
+**	gckOS_DestroySignal
+**
+**	Destroy a signal.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_DestroySignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal
+	)
+{
+#if USE_NEW_LINUX_SIGNAL
+	return gcvSTATUS_NOT_SUPPORTED;
+#else
+	gcsSIGNAL_PTR signal;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Signal != NULL);
+
+	signal = (gcsSIGNAL_PTR) Signal;
+
+	if (atomic_dec_and_test(&signal->ref))
+	{
+		 /* Free the sgianl. */
+		kfree(Signal);
+	}
+
+	/* Success. */
+	return gcvSTATUS_OK;
+#endif
+}
+
+/*******************************************************************************
+**
+**	gckOS_Signal
+**
+**	Set a state of the specified signal.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctBOOL State
+**			If gcvTRUE, the signal will be set to signaled state.
+**			If gcvFALSE, the signal will be set to nonsignaled state.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_Signal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctBOOL State
+	)
+{
+#if USE_NEW_LINUX_SIGNAL
+	return gcvSTATUS_NOT_SUPPORTED;
+#else
+	gcsSIGNAL_PTR signal;
+
+	gcmkHEADER_ARG("Os=0x%x Signal=0x%x State=%d", Os, Signal, State);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+
+	signal = (gcsSIGNAL_PTR) Signal;
+
+	/* Set the new state of the event. */
+	if (signal->manualReset)
+	{
+		if (State)
+		{
+			/* Set the event to a signaled state. */
+			complete_all(&signal->event);
+		}
+		else
+		{
+			/* Set the event to an unsignaled state. */
+			INIT_COMPLETION(signal->event);
+		}
+	}
+	else
+	{
+		if (State)
+		{
+			/* Set the event to a signaled state. */
+			complete(&signal->event);
+
+		}
+	}
+
+	/* Success. */
+	gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
+#endif
+}
+
+#if USE_NEW_LINUX_SIGNAL
+/*******************************************************************************
+**
+**	gckOS_UserSignal
+**
+**	Set the specified signal which is owned by a process to signaled state.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctHANDLE Process
+**			Handle of process owning the signal.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_UserSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctHANDLE Process
+	)
+{
+	gceSTATUS status;
+	gctINT result;
+	struct task_struct * task;
+	struct siginfo info;
+
+	task = FIND_TASK_BY_PID((pid_t) Process);
+
+	if (task != gcvNULL)
+	{
+		/* Fill in the siginfo structure. */
+		info.si_signo = Os->device->signal;
+		info.si_errno = 0;
+		info.si_code  = __SI_CODE(__SI_RT, SI_KERNEL);
+		info.si_ptr   = Signal;
+
+		/* Send the signal. */
+		if ((result = send_sig_info(Os->device->signal, &info, task)) < 0)
+		{
+			status = gcvSTATUS_GENERIC_IO;
+
+			gcmkTRACE(gcvLEVEL_ERROR,
+					 "%s(%d): send_sig_info failed.",
+					 __FUNCTION__, __LINE__);
+		}
+		else
+		{
+			/* Success. */
+			status = gcvSTATUS_OK;
+		}
+	}
+	else
+	{
+		status = gcvSTATUS_GENERIC_IO;
+
+		gcmkTRACE(gcvLEVEL_ERROR,
+				 "%s(%d): find_task_by_pid failed.",
+				 __FUNCTION__, __LINE__);
+	}
+
+	/* Return status. */
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_WaitSignal
+**
+**	Wait for a signal to become signaled.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctUINT32 Wait
+**			Number of milliseconds to wait.
+**			Pass the value of gcvINFINITE for an infinite wait.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_WaitSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctUINT32 Wait
+	)
+{
+	return gcvSTATUS_NOT_SUPPORTED;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapSignal
+**
+**	Map a signal in to the current process space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to tha gctSIGNAL to map.
+**
+**		gctHANDLE Process
+**			Handle of process owning the signal.
+**
+**	OUTPUT:
+**
+**		gctSIGNAL * MappedSignal
+**			Pointer to a variable receiving the mapped gctSIGNAL.
+*/
+gceSTATUS
+gckOS_MapSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctHANDLE Process,
+	OUT gctSIGNAL * MappedSignal
+	)
+{
+	return gcvSTATUS_NOT_SUPPORTED;
+}
+
+#else
+
+/*******************************************************************************
+**
+**	gckOS_UserSignal
+**
+**	Set the specified signal which is owned by a process to signaled state.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctHANDLE Process
+**			Handle of process owning the signal.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_UserSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctHANDLE Process
+	)
+{
+	gceSTATUS status;
+	gctSIGNAL signal;
+
+	gcmkHEADER_ARG("Os=0x%x Signal=%d Process=0x%x",
+				   Os, (gctINT) Signal, Process);
+
+	/* Map the signal into kernel space. */
+	gcmkONERROR(gckOS_MapSignal(Os, Signal, Process, &signal));
+
+	/* Signal. */
+	status = gckOS_Signal(Os, signal, gcvTRUE);
+	gcmkFOOTER();
+	return status;
+
+OnError:
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_WaitSignal
+**
+**	Wait for a signal to become signaled.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to the gctSIGNAL.
+**
+**		gctUINT32 Wait
+**			Number of milliseconds to wait.
+**			Pass the value of gcvINFINITE for an infinite wait.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_WaitSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctUINT32 Wait
+	)
+{
+	gceSTATUS status;
+	gcsSIGNAL_PTR signal;
+	gctUINT timeout;
+	gctUINT rc;
+#if MRVL_SILENT_RESET
+	gctUINT wait;
+#endif
+
+	gcmkHEADER_ARG("Os=0x%x Signal=0x%x Wait=%u", Os, Signal, Wait);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+
+	signal = (gcsSIGNAL_PTR) Signal;
+
+#if MRVL_SILENT_RESET
+	wait = (Wait==gcvINFINITE)?1000:Wait;
+
+	/* Convert wait to milliseconds. */
+	timeout = wait*HZ/1000;
+#else
+	/* Convert wait to milliseconds. */
+	timeout = (Wait == gcvINFINITE) ? MAX_SCHEDULE_TIMEOUT : Wait*HZ/1000;
+#endif
+
+	/* Linux bug ? */
+	if (!signal->manualReset && timeout == 0) timeout = 1;
+
+	rc = wait_for_completion_interruptible_timeout(&signal->event, timeout);
+	status = ((rc == 0) && !signal->event.done) ? gcvSTATUS_TIMEOUT
+												: gcvSTATUS_OK;
+
+#if MRVL_SILENT_RESET
+    if (status==gcvSTATUS_TIMEOUT && Wait==gcvINFINITE)
+    {
+        gctBOOL isIdle;
+        gckHARDWARE_QueryIdle(Os->device->kernel->hardware, &isIdle);
+        /* printk("[galcore], timeout, isIdle=%d\n",isIdle); */
+
+        if(isIdle == gcvFALSE)
+        {
+            printk("[galcore] %s : %d timeout, need to reset\n", __func__, __LINE__);
+            status = gckOS_Reset(Os);
+        }
+    }
+#endif
+
+	/* Return status. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_MapSignal
+**
+**	Map a signal in to the current process space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctSIGNAL Signal
+**			Pointer to tha gctSIGNAL to map.
+**
+**		gctHANDLE Process
+**			Handle of process owning the signal.
+**
+**	OUTPUT:
+**
+**		gctSIGNAL * MappedSignal
+**			Pointer to a variable receiving the mapped gctSIGNAL.
+*/
+gceSTATUS
+gckOS_MapSignal(
+	IN gckOS Os,
+	IN gctSIGNAL Signal,
+	IN gctHANDLE Process,
+	OUT gctSIGNAL * MappedSignal
+	)
+{
+	gctINT signalID;
+	gcsSIGNAL_PTR signal;
+	gceSTATUS status;
+	gctBOOL acquired = gcvFALSE;
+
+	gcmkHEADER_ARG("Os=0x%x Signal=0x%x Process=0x%x", Os, Signal, Process);
+
+	gcmkVERIFY_ARGUMENT(Signal != gcvNULL);
+	gcmkVERIFY_ARGUMENT(MappedSignal != gcvNULL);
+
+	signalID = (gctINT) Signal - 1;
+
+	gcmkONERROR(gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+	acquired = gcvTRUE;
+
+	if (signalID >= 0 && signalID < Os->signal.tableLen)
+	{
+		/* It is a user space signal. */
+		signal = Os->signal.table[signalID];
+
+		if (signal == gcvNULL)
+		{
+			gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+		}
+	}
+	else
+	{
+		/* It is a kernel space signal structure. */
+		signal = (gcsSIGNAL_PTR) Signal;
+	}
+
+	if (atomic_inc_return(&signal->ref) <= 1)
+	{
+		/* The previous value is 0, it has been deleted. */
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	/* Release the mutex. */
+	gcmkONERROR(gckOS_ReleaseMutex(Os, Os->signal.lock));
+
+	*MappedSignal = (gctSIGNAL) signal;
+
+	/* Success. */
+	gcmkFOOTER_ARG("*MappedSignal=0x%x", *MappedSignal);
+	return gcvSTATUS_OK;
+
+OnError:
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the staus. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_CreateUserSignal
+**
+**	Create a new signal to be used in the user space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctBOOL ManualReset
+**			If set to gcvTRUE, gckOS_Signal with gcvFALSE must be called in
+**			order to set the signal to nonsignaled state.
+**			If set to gcvFALSE, the signal will automatically be set to
+**			nonsignaled state by gckOS_WaitSignal function.
+**
+**	OUTPUT:
+**
+**		gctINT * SignalID
+**			Pointer to a variable receiving the created signal's ID.
+*/
+gceSTATUS
+gckOS_CreateUserSignal(
+	IN gckOS Os,
+	IN gctBOOL ManualReset,
+	OUT gctINT * SignalID
+	)
+{
+	gcsSIGNAL_PTR signal;
+	gctINT unused, currentID, tableLen;
+	gctPOINTER * table;
+	gctINT i;
+	gceSTATUS status;
+	gctBOOL acquired = gcvFALSE;
+
+	gcmkHEADER_ARG("Os=0x%0x ManualReset=%d", Os, ManualReset);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(SignalID != gcvNULL);
+
+	/* Lock the table. */
+	gcmkONERROR(
+		gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+
+	acquired = gcvTRUE;
+
+	if (Os->signal.unused < 1)
+	{
+		/* Enlarge the table. */
+		table = (gctPOINTER *) kmalloc(
+					sizeof(gctPOINTER) * (Os->signal.tableLen + USER_SIGNAL_TABLE_LEN_INIT),
+					GFP_KERNEL);
+
+		if (table == gcvNULL)
+		{
+			/* Out of memory. */
+			gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+		}
+
+		memset(table + Os->signal.tableLen, 0, sizeof(gctPOINTER) * USER_SIGNAL_TABLE_LEN_INIT);
+		memcpy(table, Os->signal.table, sizeof(gctPOINTER) * Os->signal.tableLen);
+
+		/* Release the old table. */
+		kfree(Os->signal.table);
+
+		/* Update the table. */
+		Os->signal.table = table;
+		Os->signal.currentID = Os->signal.tableLen;
+		Os->signal.tableLen += USER_SIGNAL_TABLE_LEN_INIT;
+		Os->signal.unused += USER_SIGNAL_TABLE_LEN_INIT;
+	}
+
+	table = Os->signal.table;
+	currentID = Os->signal.currentID;
+	tableLen = Os->signal.tableLen;
+	unused = Os->signal.unused;
+
+	/* Create a new signal. */
+	gcmkONERROR(
+		gckOS_CreateSignal(Os, ManualReset, (gctSIGNAL *) &signal));
+
+	/* Save the process ID. */
+	signal->process = (gctHANDLE) current->tgid;
+
+	table[currentID] = signal;
+
+	/* Plus 1 to avoid NULL claims. */
+	*SignalID = currentID + 1;
+
+	/* Update the currentID. */
+	if (--unused > 0)
+	{
+		for (i = 0; i < tableLen; i++)
+		{
+			if (++currentID >= tableLen)
+			{
+				/* Wrap to the begin. */
+				currentID = 0;
+			}
+
+			if (table[currentID] == gcvNULL)
+			{
+				break;
+			}
+		}
+	}
+
+	Os->signal.table = table;
+	Os->signal.currentID = currentID;
+	Os->signal.tableLen = tableLen;
+	Os->signal.unused = unused;
+
+	gcmkONERROR(
+		gckOS_ReleaseMutex(Os, Os->signal.lock));
+
+	gcmkFOOTER_ARG("*SignalID=%d", gcmOPT_VALUE(SignalID));
+	return gcvSTATUS_OK;
+
+OnError:
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the staus. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_DestroyUserSignal
+**
+**	Destroy a signal to be used in the user space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctINT SignalID
+**			The signal's ID.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_DestroyUserSignal(
+	IN gckOS Os,
+	IN gctINT SignalID
+	)
+{
+	gceSTATUS status;
+	gcsSIGNAL_PTR signal;
+	gctBOOL acquired = gcvFALSE;
+
+	gcmkHEADER_ARG("Os=0x%x SignalID=%d", Os, SignalID);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	gcmkONERROR(
+		gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+
+	acquired = gcvTRUE;
+
+	if (SignalID < 1 || SignalID > Os->signal.tableLen)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_DestroyUserSignal: invalid signal->%d.",
+			(gctINT) SignalID
+			);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	SignalID -= 1;
+
+	signal = Os->signal.table[SignalID];
+
+	if (signal == gcvNULL)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_DestroyUserSignal: signal is NULL."
+			);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	/* Check to see if the process is the owner of the signal. */
+	if (signal->process != (gctHANDLE) current->tgid)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_DestroyUserSignal: process id doesn't match. ",
+			"signal->process: %d, current->tgid: %d",
+			signal->process,
+			current->tgid);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	gcmkONERROR(
+		gckOS_DestroySignal(Os, signal));
+
+	/* Update the table. */
+	Os->signal.table[SignalID] = gcvNULL;
+	if (Os->signal.unused++ == 0)
+	{
+		Os->signal.currentID = SignalID;
+	}
+
+	gcmkVERIFY_OK(
+		gckOS_ReleaseMutex(Os, Os->signal.lock));
+
+	/* Success. */
+	gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
+
+OnError:
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_WaitUserSignal
+**
+**	Wait for a signal used in the user mode to become signaled.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctINT SignalID
+**			Signal ID.
+**
+**		gctUINT32 Wait
+**			Number of milliseconds to wait.
+**			Pass the value of gcvINFINITE for an infinite wait.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_WaitUserSignal(
+	IN gckOS Os,
+	IN gctINT SignalID,
+	IN gctUINT32 Wait
+	)
+{
+	gceSTATUS status;
+	gcsSIGNAL_PTR signal;
+	gctBOOL acquired = gcvFALSE;
+
+	gcmkHEADER_ARG("Os=0x%x SignalID=%d Wait=%u", Os, SignalID, Wait);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	gcmkONERROR(gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+	acquired = gcvTRUE;
+
+	if (SignalID < 1 || SignalID > Os->signal.tableLen)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_WaitSignal: invalid signal.",
+			SignalID
+			);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	SignalID -= 1;
+
+	signal = Os->signal.table[SignalID];
+
+	gcmkONERROR(gckOS_ReleaseMutex(Os, Os->signal.lock));
+	acquired = gcvFALSE;
+
+	if (signal == gcvNULL)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_WaitSignal: signal is NULL."
+			);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	if (signal->process != (gctHANDLE) current->tgid)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_WaitUserSignal: process id doesn't match. "
+			"signal->process: %d, current->tgid: %d",
+			signal->process,
+			current->tgid);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+    status = gckOS_WaitSignal(Os, signal, Wait);
+
+	/* Return the status. */
+	gcmkFOOTER();
+	return status;
+
+OnError:
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the staus. */
+	gcmkFOOTER();
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_SignalUserSignal
+**
+**	Set a state of the specified signal to be used in the user space.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to an gckOS object.
+**
+**		gctINT SignalID
+**			SignalID.
+**
+**		gctBOOL State
+**			If gcvTRUE, the signal will be set to signaled state.
+**			If gcvFALSE, the signal will be set to nonsignaled state.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_SignalUserSignal(
+	IN gckOS Os,
+	IN gctINT SignalID,
+	IN gctBOOL State
+	)
+{
+	gceSTATUS status;
+	gcsSIGNAL_PTR signal;
+	gctBOOL acquired = gcvFALSE;
+
+	gcmkHEADER_ARG("Os=0x%x SignalID=%d State=%d", Os, SignalID, State);
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	gcmkONERROR(gckOS_AcquireMutex(Os, Os->signal.lock, gcvINFINITE));
+	acquired = gcvTRUE;
+
+	if ((SignalID < 1)
+	||  (SignalID > Os->signal.tableLen)
+	)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,  gcvZONE_OS,
+					   "gckOS_WaitSignal: invalid signal->%d.", SignalID);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	SignalID -= 1;
+
+	signal = Os->signal.table[SignalID];
+
+	gcmkONERROR(gckOS_ReleaseMutex(Os, Os->signal.lock));
+	acquired = gcvFALSE;
+
+	if (signal == gcvNULL)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_WaitSignal: signal is NULL."
+			);
+
+		gcmkONERROR(gcvSTATUS_INVALID_REQUEST);
+	}
+
+	if (signal->process != (gctHANDLE) current->tgid)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"gckOS_DestroyUserSignal: process id doesn't match. ",
+			"signal->process: %d, current->tgid: %d",
+			signal->process,
+			current->tgid);
+
+		gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+	}
+
+	status = gckOS_Signal(Os, signal, State);
+
+	/* Success. */
+	gcmkFOOTER();
+	return status;
+
+OnError:
+	if (acquired)
+	{
+		/* Release the mutex. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os, Os->signal.lock));
+	}
+
+	/* Return the staus. */
+	gcmkFOOTER();
+	return status;
+}
+
+gceSTATUS
+gckOS_CleanProcessSignal(
+	gckOS Os,
+	gctHANDLE Process
+	)
+{
+	gctINT signal;
+
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	gcmkVERIFY_OK(gckOS_AcquireMutex(Os,
+		Os->signal.lock,
+		gcvINFINITE
+		));
+
+	if (Os->signal.unused == Os->signal.tableLen)
+	{
+		gcmkVERIFY_OK(gckOS_ReleaseMutex(Os,
+			Os->signal.lock
+			));
+
+		return gcvSTATUS_OK;
+	}
+
+	for (signal = 0; signal < Os->signal.tableLen; signal++)
+	{
+		if (Os->signal.table[signal] != gcvNULL &&
+			((gcsSIGNAL_PTR)Os->signal.table[signal])->process == Process)
+		{
+			gckOS_DestroySignal(Os,	Os->signal.table[signal]);
+
+			/* Update the signal table. */
+			Os->signal.table[signal] = gcvNULL;
+			if (Os->signal.unused++ == 0)
+			{
+				Os->signal.currentID = signal;
+			}
+		}
+	}
+
+	gcmkVERIFY_OK(gckOS_ReleaseMutex(Os,
+		Os->signal.lock
+		));
+
+	return gcvSTATUS_OK;
+}
+
+#endif /* USE_NEW_LINUX_SIGNAL */
+
+/*******************************************************************************
+**
+**	gckOS_MapUserMemory
+**
+**	Lock down a user buffer and return an DMA'able address to be used by the
+**	hardware to access it.
+**
+**	INPUT:
+**
+**		gctPOINTER Memory
+**			Pointer to memory to lock down.
+**
+**		gctSIZE_T Size
+**			Size in bytes of the memory to lock down.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Info
+**			Pointer to variable receiving the information record required by
+**			gckOS_UnmapUserMemory.
+**
+**		gctUINT32_PTR Address
+**			Pointer to a variable that will receive the address DMA'able by the
+**			hardware.
+*/
+gceSTATUS
+gckOS_MapUserMemory(
+	IN gckOS Os,
+	IN gctPOINTER Memory,
+	IN gctSIZE_T Size,
+	OUT gctPOINTER * Info,
+	OUT gctUINT32_PTR Address
+	)
+{
+	gceSTATUS status;
+	gctSIZE_T pageCount, i, j;
+	gctUINT32_PTR pageTable;
+	gctUINT32 address;
+	gctUINT32 start, end, memory;
+	gctINT result = 0;
+
+	gcsPageInfo_PTR info = gcvNULL;
+	struct page **pages = gcvNULL;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Size > 0);
+	gcmkVERIFY_ARGUMENT(Info != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Address != gcvNULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_VERBOSE,
+		gcvZONE_OS,
+		"[gckOS_MapUserMemory] enter."
+		);
+
+	do
+	{
+		memory = (gctUINT32) Memory;
+
+		/* Get the number of required pages. */
+		end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+		start = memory >> PAGE_SHIFT;
+		pageCount = end - start;
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+			gcvZONE_OS,
+			"[gckOS_MapUserMemory] pageCount: %d.",
+			pageCount
+			);
+
+		/* Invalid argument. */
+		if (pageCount == 0)
+		{
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		/* Overflow. */
+		if ((memory + Size) < memory)
+		{
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		MEMORY_MAP_LOCK(Os);
+
+		/* Allocate the Info struct. */
+		info = (gcsPageInfo_PTR)kmalloc(sizeof(gcsPageInfo), GFP_KERNEL);
+
+		if (info == gcvNULL)
+		{
+			status = gcvSTATUS_OUT_OF_MEMORY;
+			break;
+		}
+
+		/* Allocate the array of page addresses. */
+		pages = (struct page **)kmalloc(pageCount * sizeof(struct page *), GFP_KERNEL);
+
+		if (pages == gcvNULL)
+		{
+			status = gcvSTATUS_OUT_OF_MEMORY;
+			break;
+		}
+
+		/* Get the user pages. */
+		down_read(&current->mm->mmap_sem);
+		result = get_user_pages(current,
+					current->mm,
+					memory & PAGE_MASK,
+					pageCount,
+					1,
+					0,
+					pages,
+					NULL
+					);
+		up_read(&current->mm->mmap_sem);
+
+		if (result <=0 || result < pageCount)
+		{
+			struct vm_area_struct *vma;
+
+			vma = find_vma(current->mm, memory);
+
+			if (vma && (vma->vm_flags & VM_PFNMAP) )
+			{
+				do
+				{
+					pte_t		* pte;
+					spinlock_t 	* ptl;
+					unsigned long pfn;
+
+				pgd_t * pgd = pgd_offset(current->mm, memory);
+					pud_t * pud = pud_alloc(current->mm, pgd, memory);
+					if (pud)
+					{
+						pmd_t * pmd = pmd_alloc(current->mm, pud, memory);
+						if (pmd)
+						{
+							pte = pte_offset_map_lock(current->mm, pmd, memory, &ptl);
+							if (!pte)
+							{
+								break;
+							}
+						}
+						else
+						{
+							break;
+						}
+					}
+					else
+					{
+						break;
+					}
+
+					pfn 	 = pte_pfn(*pte);
+					*Address = ((pfn << PAGE_SHIFT) | (((unsigned long)Memory) & ~PAGE_MASK))
+								- Os->baseAddress;
+					*Info 	 = gcvNULL;
+
+					pte_unmap_unlock(pte, ptl);
+
+					/* Release page info struct. */
+					if (info != gcvNULL)
+					{
+						/* Free the page info struct. */
+						kfree(info);
+					}
+
+					if (pages != gcvNULL)
+					{
+						/* Free the page table. */
+						kfree(pages);
+					}
+
+					MEMORY_MAP_UNLOCK(Os);
+
+					return gcvSTATUS_OK;
+				}
+				while (gcvFALSE);
+
+				*Address = ~0;
+				*Info = gcvNULL;
+
+				status = gcvSTATUS_OUT_OF_RESOURCES;
+				break;
+			}
+			else
+			{
+				status = gcvSTATUS_OUT_OF_RESOURCES;
+				break;
+			}
+		}
+
+		for (i = 0; i < pageCount; i++)
+		{
+			/* Flush the data cache. */
+#ifdef ANDROID
+			dma_sync_single_for_device(
+						gcvNULL,
+						page_to_phys(pages[i]),
+						PAGE_SIZE,
+						DMA_TO_DEVICE);
+#else
+			flush_dcache_page(pages[i]);
+#endif
+		}
+
+		/* Allocate pages inside the page table. */
+		gcmkERR_BREAK(gckMMU_AllocatePages(Os->device->kernel->mmu,
+										  pageCount * (PAGE_SIZE/4096),
+										  (gctPOINTER *) &pageTable,
+										  &address));
+
+		/* Fill the page table. */
+		for (i = 0; i < pageCount; i++)
+		{
+			/* Get the physical address from page struct. */
+			pageTable[i * (PAGE_SIZE/4096)] = page_to_phys(pages[i]);
+
+			for (j = 1; j < (PAGE_SIZE/4096); j++)
+			{
+				pageTable[i * (PAGE_SIZE/4096) + j] = pageTable[i * (PAGE_SIZE/4096)] + 4096 * j;
+			}
+
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"[gckOS_MapUserMemory] pages[%d]: 0x%x, pageTable[%d]: 0x%x.",
+				i, pages[i],
+				i, pageTable[i]);
+		}
+
+		/* Save pointer to page table. */
+		info->pageTable = pageTable;
+		info->pages = pages;
+
+		*Info = (gctPOINTER) info;
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+			gcvZONE_OS,
+			"[gckOS_MapUserMemory] info->pages: 0x%x, info->pageTable: 0x%x, info: 0x%x.",
+			info->pages,
+			info->pageTable,
+			info
+			);
+
+		/* Return address. */
+		*Address = address + (memory & ~PAGE_MASK);
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+			gcvZONE_OS,
+			"[gckOS_MapUserMemory] Address: 0x%x.",
+			*Address
+			);
+
+		/* Success. */
+		status = gcvSTATUS_OK;
+	}
+	while (gcvFALSE);
+
+	if (gcmIS_ERROR(status))
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+			gcvZONE_OS,
+			"[gckOS_MapUserMemory] error occured: %d.",
+			status
+			);
+
+		/* Release page array. */
+		if (result > 0 && pages != gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"[gckOS_MapUserMemory] error: page table is freed."
+				);
+
+			for (i = 0; i < result; i++)
+			{
+				if (pages[i] == gcvNULL)
+				{
+					break;
+				}
+#ifdef ANDROID
+				dma_sync_single_for_device(
+							gcvNULL,
+							page_to_phys(pages[i]),
+							PAGE_SIZE,
+							DMA_FROM_DEVICE);
+#endif
+				page_cache_release(pages[i]);
+			}
+		}
+
+		if (pages != gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"[gckOS_MapUserMemory] error: pages is freed."
+				);
+
+			/* Free the page table. */
+			kfree(pages);
+			info->pages = gcvNULL;
+		}
+
+		/* Release page info struct. */
+		if (info != gcvNULL)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"[gckOS_MapUserMemory] error: info is freed."
+				);
+
+			/* Free the page info struct. */
+			kfree(info);
+			*Info = gcvNULL;
+		}
+	}
+
+	MEMORY_MAP_UNLOCK(Os);
+
+	gcmkTRACE_ZONE(gcvLEVEL_VERBOSE,
+		gcvZONE_OS,
+		"[gckOS_MapUserMemory] leave."
+		);
+
+	/* Return the status. */
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_UnmapUserMemory
+**
+**	Unlock a user buffer and that was previously locked down by
+**	gckOS_MapUserMemory.
+**
+**	INPUT:
+**
+**		gctPOINTER Memory
+**			Pointer to memory to unlock.
+**
+**		gctSIZE_T Size
+**			Size in bytes of the memory to unlock.
+**
+**		gctPOINTER Info
+**			Information record returned by gckOS_MapUserMemory.
+**
+**		gctUINT32_PTR Address
+**			The address returned by gckOS_MapUserMemory.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gckOS_UnmapUserMemory(
+	IN gckOS Os,
+	IN gctPOINTER Memory,
+	IN gctSIZE_T Size,
+	IN gctPOINTER Info,
+	IN gctUINT32 Address
+	)
+{
+	gceSTATUS status;
+	gctUINT32 memory, start, end;
+	gcsPageInfo_PTR info;
+	gctSIZE_T pageCount, i;
+	struct page **pages;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Size > 0);
+	gcmkVERIFY_ARGUMENT(Info != gcvNULL);
+
+	gcmkTRACE_ZONE(gcvLEVEL_VERBOSE,
+		gcvZONE_OS,
+		"[gckOS_UnmapUserMemory] enter."
+		);
+
+	do
+	{
+		info = (gcsPageInfo_PTR) Info;
+
+		if (info == gcvNULL)
+		{
+			return gcvSTATUS_OK;
+		}
+
+		pages = info->pages;
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+			gcvZONE_OS,
+			"[gckOS_UnmapUserMemory] info: 0x%x, pages: 0x%x.",
+			info,
+			pages
+			);
+
+		/* Invalid page array. */
+		if (pages == gcvNULL)
+		{
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		memory = (gctUINT32) Memory;
+		end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+		start = memory >> PAGE_SHIFT;
+		pageCount = end - start;
+
+		/* Overflow. */
+		if ((memory + Size) < memory)
+		{
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		/* Invalid argument. */
+		if (pageCount == 0)
+		{
+			return gcvSTATUS_INVALID_ARGUMENT;
+		}
+
+		gcmkTRACE_ZONE(gcvLEVEL_INFO,
+			gcvZONE_OS,
+			"[gckOS_UnmapUserMemory] memory: 0x%x, pageCount: %d, pageTable: 0x%x.",
+			memory,
+			pageCount,
+			info->pageTable
+			);
+
+		MEMORY_MAP_LOCK(Os);
+
+		/* Free the pages from the MMU. */
+		gcmkERR_BREAK(gckMMU_FreePages(Os->device->kernel->mmu,
+									  info->pageTable,
+									  pageCount * (PAGE_SIZE/4096)
+									  ));
+
+		/* Release the page cache. */
+		for (i = 0; i < pageCount; i++)
+		{
+			gcmkTRACE_ZONE(gcvLEVEL_INFO,
+				gcvZONE_OS,
+				"[gckOS_UnmapUserMemory] pages[%d]: 0x%x.",
+				i,
+				pages[i]
+				);
+
+			if (!PageReserved(pages[i]))
+			{
+				SetPageDirty(pages[i]);
+			}
+
+#ifdef ANDROID
+			dma_sync_single_for_device(
+						gcvNULL,
+						page_to_phys(pages[i]),
+						PAGE_SIZE,
+						DMA_FROM_DEVICE);
+#endif
+			page_cache_release(pages[i]);
+		}
+
+		/* Success. */
+		status = gcvSTATUS_OK;
+	}
+	while (gcvFALSE);
+
+	if (info != gcvNULL)
+	{
+		/* Free the page array. */
+		if (info->pages != gcvNULL)
+		{
+			kfree(info->pages);
+		}
+
+		kfree(info);
+	}
+
+	MEMORY_MAP_UNLOCK(Os);
+
+	/* Return the status. */
+	return status;
+}
+
+/*******************************************************************************
+**
+**	gckOS_GetBaseAddress
+**
+**	Get the base address for the physical memory.
+**
+**	INPUT:
+**
+**		gckOS Os
+**			Pointer to the gckOS object.
+**
+**	OUTPUT:
+**
+**		gctUINT32_PTR BaseAddress
+**			Pointer to a variable that will receive the base address.
+*/
+gceSTATUS
+gckOS_GetBaseAddress(
+	IN gckOS Os,
+	OUT gctUINT32_PTR BaseAddress
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(BaseAddress != gcvNULL);
+
+	/* Return base address. */
+	*BaseAddress = Os->baseAddress;
+
+	/* Success. */
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_SuspendInterrupt(
+	IN gckOS Os
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	disable_irq(Os->device->irqLine);
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ResumeInterrupt(
+	IN gckOS Os
+	)
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	enable_irq(Os->device->irqLine);
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ClockOff(
+    void
+	)
+{
+    struct clk * clk = NULL;
+
+#ifdef CONFIG_PXA_DVFM
+    gc_pwr(0);
+#endif
+
+    clk = clk_get(NULL, "gpu_clk");
+    CLOCK_VERIFY(clk);
+    clk_disable(clk);
+    clk_unprepare(clk);
+
+#ifdef CONFIG_PXA_DVFM
+	/* decrease AXICLK count in kernel */
+    clk = NULL;
+    clk = clk_get(NULL, "axi_clk");
+    CLOCK_VERIFY(clk);
+    clk_disable(clk);
+    clk_unprepare(clk);
+#endif
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ClockOn(
+	IN gctUINT64 Frequency
+	)
+{
+    struct clk * clk = NULL;
+
+#ifdef CONFIG_PXA_DVFM
+	/* increase AXICLK count in kernel */
+    clk = clk_get(NULL, "axi_clk");
+    CLOCK_VERIFY(clk);
+    clk_prepare(clk);
+    clk_enable(clk);
+    clk = NULL;
+#endif
+
+    clk = clk_get(NULL, "gpu_clk");
+    CLOCK_VERIFY(clk);
+
+    if(Frequency != 0)
+    {
+        /* APMU_GC_156M, APMU_GC_624M, APMU_GC_PLL2, APMU_GC_PLL2_DIV2 currently */
+        printk("\n[galcore] clk input = %dM Hz; running on %dM Hz\n",(int)Frequency, (int)Frequency/2);
+        if (clk_set_rate(clk, Frequency*1000*1000))
+        {
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR, gcvZONE_DRIVER,
+			      "[galcore] Can't set core clock.");
+            return -EAGAIN;
+        }
+    }
+    clk_prepare(clk);
+    clk_enable(clk);
+
+#ifdef CONFIG_PXA_DVFM
+    gc_pwr(1);
+#endif
+
+	return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_Reset(
+	IN gckOS Os
+	)
+{
+    gceSTATUS status;
+    gckHARDWARE hardware = Os->device->kernel->hardware;
+    gckEVENT event = Os->device->kernel->event;
+    gckCOMMAND command = Os->device->kernel->command;
+    gctUINT32 data = 0;
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    if(Os->device->reset)
+	{
+         /*  Stall */
+	{
+            /* Acquire the context switching mutex so nothing else can be
+		** committed. */
+		gcmkONERROR(
+			gckOS_AcquireMutex(Os,
+							   command->mutexContext,
+							   gcvINFINITE));
+
+             /*  mdelay(); */
+	}
+	 /*  Stop */
+	{
+		/* Stop the command parser. */
+		gcmkONERROR(
+			gckCOMMAND_Stop(command));
+
+		/* Grab the command queue mutex so nothing can get access to the
+		** command queue. */
+		gcmkONERROR(
+			gckOS_AcquireMutex(Os,
+							   command->mutexQueue,
+							   gcvINFINITE));
+	}
+
+        gckOS_SuspendInterrupt(Os);
+        gckOS_ClockOff();
+
+		/* Read AQIntrAcknowledge register. */
+		gcmkVERIFY_OK(gckOS_ReadRegister(Os,
+										0x00010,
+									    &data));
+
+        /* trigger any commited event */
+	gcmkVERIFY_OK(gckEVENT_Interrupt(event, data));
+        gcmkVERIFY_OK(gckEVENT_Notify(event, 1));
+
+        gckOS_ClockOn(0);
+        gckOS_ResumeInterrupt(Os);
+
+         /*  Initialize */
+	{
+		/* Initialize hardware. */
+		gcmkONERROR(
+			gckHARDWARE_InitializeHardware(hardware));
+
+		gcmkONERROR(
+			gckHARDWARE_SetFastClear(hardware,
+									 hardware->allowFastClear,
+									 hardware->allowCompression));
+
+		/* Force the command queue to reload the next context. */
+		command->currentContext = 0;
+	}
+
+	/* Sleep for 1ms, to make sure everything is powered on. */
+	gcmkVERIFY_OK(gckOS_Delay(Os, 1));
+
+	 /*  start */
+	{
+            /* Release the command mutex queue. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os,
+							   command->mutexQueue));
+		/* Start the command processor. */
+		gcmkONERROR(
+			gckCOMMAND_Start(command));
+	}
+	 /*  release context mutex */
+	{
+		/* Release the context switching mutex. */
+		gcmkONERROR(
+			gckOS_ReleaseMutex(Os,
+							   command->mutexContext));
+	}
+
+        hardware->chipPowerState = gcvPOWER_ON;
+
+        printk("[galcore] %s : %d \n", __func__, __LINE__);
+
+        return status;
+    }
+
+    return gcvSTATUS_SKIP;
+
+OnError:
+    printk("ERROR: %s has error \n",__func__);
+    return status;
+
+}
+
+gceSTATUS
+gckOS_SetConstraint(
+	IN gckOS Os,
+	IN gctBOOL enableDVFM,
+	IN gctBOOL enableLPM
+        )
+{
+    /* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+#ifdef CONFIG_CPU_MMP2
+    if(enableDVFM)
+    {
+        /* disable LPM and OP1 - OP5 on mmp2 */
+        dvfm_disable(Os->device->dvfm_dev_index);
+    }
+#endif
+
+#ifdef CONFIG_PXA_DVFM
+
+#if 0
+    if(enableDVFM)
+    {
+        /* disable LPM and OP1 - OP5 on PV2 evb */
+        dvfm_disable(Os->device->dvfm_dev_index);
+    }
+#else
+    if(enableLPM)
+    {
+         /* printk("\n Idle = false, disable low power mode\n"); */
+        /* Disable D0CS */
+        dvfm_disable_op_name("D0CS", Os->device->dvfm_dev_index);
+        /* Disable Low power mode */
+        dvfm_disable_op_name("D1", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("D2", Os->device->dvfm_dev_index);
+        /* Disable CG */
+        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
+            dvfm_disable_op_name("CG", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD1)
+    {
+        dvfm_disable_op_name("D1", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD2)
+    {
+        dvfm_disable_op_name("D2", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD0CS)
+    {
+        dvfm_disable_op_name("D0CS", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableCG)
+    {
+        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
+            dvfm_disable_op_name("CG", Os->device->dvfm_dev_index);
+    }
+
+    if(enableDVFM)
+    {
+
+        /* Disable OP1 - OP7  on PV2 evb */
+        dvfm_disable_op_name("156M", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("208M", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("156M_HF", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("208M_HF", Os->device->dvfm_dev_index);
+        dvfm_disable_op_name("416M", Os->device->dvfm_dev_index);
+         /* dvfm_disable_op_name("624M", Os->device->dvfm_dev_index); */
+         /* dvfm_disable_op_name("832M", Os->device->dvfm_dev_index); */
+         /* dvfm_disable(Os->device->dvfm_dev_index); */
+    }
+#endif
+
+#endif
+        return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_UnSetConstraint(
+	IN gckOS Os,
+	IN gctBOOL enableDVFM,
+	IN gctBOOL enableLPM
+	)
+{
+    /* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+#ifdef CONFIG_CPU_MMP2
+    if(enableDVFM)
+    {
+        /* enable LPM and OP1 - OP5 on mmp2 */
+        dvfm_enable(Os->device->dvfm_dev_index);
+    }
+#endif
+
+#ifdef CONFIG_PXA_DVFM
+
+#if 0
+    if(enableDVFM)
+    {
+        /* enable LPM and OP1 - OP5 on PV2 evb  */
+        dvfm_enable(Os->device->dvfm_dev_index);
+    }
+#else
+    if(enableLPM)
+    {
+         /* printk("\n Idle = true, enable low power mode\n"); */
+        /* Enable D0CS */
+        dvfm_enable_op_name("D0CS", Os->device->dvfm_dev_index);
+        /* Enable Low power mode */
+        dvfm_enable_op_name("D1", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("D2", Os->device->dvfm_dev_index);
+        /* Enable CG */
+        if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
+            dvfm_enable_op_name("CG", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD1)
+    {
+        dvfm_enable_op_name("D1", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD2)
+    {
+        dvfm_enable_op_name("D2", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableD0CS)
+    {
+        dvfm_enable_op_name("D0CS", Os->device->dvfm_dev_index);
+    }
+
+    if(Os->device->enableCG)
+    {
+       if(cpu_is_pxa935() || cpu_is_pxa950() || cpu_is_pxa955())
+           dvfm_enable_op_name("CG", Os->device->dvfm_dev_index);
+    }
+
+    if(enableDVFM)
+    {
+
+        /* Enable OP1 - OP7 on PV2 evb */
+        dvfm_enable_op_name("156M", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("208M", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("156M_HF", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("208M_HF", Os->device->dvfm_dev_index);
+        dvfm_enable_op_name("416M", Os->device->dvfm_dev_index);
+         /* dvfm_enable_op_name("624M", Os->device->dvfm_dev_index); */
+         /* dvfm_enable_op_name("832M", Os->device->dvfm_dev_index); */
+         /* dvfm_enable(Os->device->dvfm_dev_index); */
+    }
+#endif
+
+#endif
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_FrequencyScaling(
+	IN gckOS Os,
+	IN gctBOOL Idle
+    )
+{
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+    /* printk("[galcore] %s:\n",Idle?"Idle,freq scale to 1/64":"Running"); */
+    if(Idle)
+    {
+        /* frequence change to 1/64 */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x204));
+        /* Loading the frequency scaler. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os,0x00000,0x004));
+
+        gckOS_UnSetConstraint(Os,
+            Os->device->enableDVFM,
+            Os->device->enableLowPowerMode);
+    }
+    else
+    {
+        /* Write the clock control register. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x300));
+        /* Done loading the frequency scaler. */
+        gcmkVERIFY_OK(gckOS_WriteRegister(Os, 0x00000, 0x100));
+
+        gckOS_SetConstraint(Os,
+            Os->device->enableDVFM,
+            Os->device->enableLowPowerMode);
+    }
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_NotifyIdle(
+	IN gckOS Os,
+	IN gctBOOL Idle
+	)
+{
+
+#if defined CONFIG_CPU_PXA910
+#if POWER_OFF_GC_WHEN_IDLE
+    static int  count = 0;
+    gceSTATUS   status;
+#endif
+#endif
+
+	/* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+
+	Os->device->lastNodeIndex = (Os->device->lastNodeIndex + 1) %100;
+    Os->device->profNode[Os->device->lastNodeIndex].idle = Idle;
+    Os->device->profNode[Os->device->lastNodeIndex].tick = gckOS_GetTicks();
+
+#if defined CONFIG_CPU_PXA910
+#if POWER_OFF_GC_WHEN_IDLE
+    switch (galDevice->currentPMode)
+    {
+    case gcvPM_NORMAL:
+        {
+            gckOS_FrequencyScaling(Os,Idle);
+        }
+        break;
+
+    case gcvPM_EARLY_SUSPEND:
+        {
+            printk(">>>[%s]\t@%d\tN:0x%x\tIDLE:%d\n", __func__, __LINE__, count, Idle);
+            /* return if not idle */
+            if (gcvFALSE == Idle) {
+                printk("<<<<<busy, gcvPM_EARLY_SUSPEND return.\n");
+                break;
+            }
+
+            /* Acquire the mutex. */
+            if (galDevice->printPID) {
+                printk("|-|-|- Acquiring gcdevice mutex...\t%s@%d\n",__FUNCTION__,__LINE__);
+            }
+
+            gcmkONERROR(
+                gckOS_AcquireMutex(galDevice->os, galDevice->mutexGCDevice, gcvINFINITE));
+
+            _power_off_gc(galDevice, gcvFALSE);
+
+            /* Release the mutex. */
+            gcmkVERIFY_OK(
+                gckOS_ReleaseMutex(galDevice->os, galDevice->mutexGCDevice));
+
+            if (galDevice->printPID) {
+                printk("|-|-|- Released gcdevice mutex...\t%s@%d\n",__FUNCTION__,__LINE__);
+            }
+
+
+            printk("<<<[%s]\t@%d\tN:0x%x\n", __func__, __LINE__, count);
+        }
+        break;
+    default:
+        break;
+    }
+    return gcvSTATUS_OK;
+
+OnError:
+    /* Return the status. */
+    printk("---->ERROR:%s @ %d\n", __func__, __LINE__);
+    return status;
+#else
+    /* POWER_OFF_GC_WHEN_IDLE not true, just go to normal path*/
+    gckOS_FrequencyScaling(Os, Idle);
+#endif
+
+#else
+    /* other platform */
+    gckOS_FrequencyScaling(Os, Idle);
+#endif
+
+	return gcvSTATUS_OK;
+}
+
+gctUINT32
+gckOS_GetTicks(
+    void
+    )
+{
+    struct timeval tv;
+    unsigned int tickcount = 0;
+    do_gettimeofday(&tv);
+    tickcount = (tv.tv_sec*1000 + tv.tv_usec/1000);
+    return tickcount;
+}
+
+gceSTATUS
+gckOS_IdleProfile(
+    IN gckOS Os,
+    IN OUT gctUINT32* Timeslice,
+    OUT gctUINT32* IdleTime
+    )
+{
+    int i;
+    gctUINT currentTick;
+    gckProfNode firstNode;
+    gckProfNode lastNode;
+    gckProfNode iterNode; /* first node in the time slice */
+    gckProfNode nextNode; /* the next node of iterNode */
+    gctUINT firstIndex, lastIndex, iterIndex;
+    gctUINT idleTime = 0;
+
+    /* Verify the arguments. */
+	gcmkVERIFY_OBJECT(Os, gcvOBJ_OS);
+	gcmkVERIFY_ARGUMENT(Timeslice != gcvNULL);
+
+    /* Grab the conmmand queue mutex. */
+	gcmkVERIFY_OK(gckOS_AcquireMutex(Os,
+									Os->device->kernel->command->mutexQueue,
+									gcvINFINITE));
+
+
+    currentTick = gckOS_GetTicks();
+    lastIndex = Os->device->lastNodeIndex;
+    iterIndex = lastIndex;
+    firstIndex = (Os->device->lastNodeIndex + 1) % 100;
+    firstNode = &Os->device->profNode[firstIndex];
+    lastNode = &Os->device->profNode[lastIndex];
+
+    /* printk("@@@@@@[first last] [%d, %d]\n",firstIndex,lastIndex); */
+
+    /* no node in the time slice */
+    if(currentTick - lastNode->tick >= *Timeslice)
+    {
+        if(lastNode->idle)
+        {
+            idleTime += *Timeslice;
+            /* printk("line %d, idletime : %d",__LINE__, idleTime); */
+        }
+    }
+    else
+    {
+        /* find first node in the time slice */
+        if(currentTick - firstNode->tick < *Timeslice)
+        {
+            /* */
+            *Timeslice = currentTick - firstNode->tick;
+
+            iterIndex = firstIndex;
+            iterNode = &Os->device->profNode[iterIndex];
+        }
+        else
+        {
+            for(i=0;i<100;i++)
+            {
+                iterIndex = (firstIndex + i)%100;
+                iterNode = &Os->device->profNode[iterIndex];
+                if(currentTick - iterNode->tick < *Timeslice)
+                {
+                    break;
+                }
+            }
+        }
+        /* printk("line %d, iterIndex : %d\n",__LINE__, iterIndex); */
+
+        /* startTick to first node time */
+        if(!iterNode->idle)
+        {
+            idleTime += iterNode->tick - (currentTick - *Timeslice);
+            /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
+        }
+
+        /* last node to currentTick time */
+        if(lastNode->idle)
+        {
+            idleTime += currentTick - lastNode->tick;
+            /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
+        }
+
+        /* first node to last node time */
+        for(i = 0; i < 100; i++ )
+        {
+            if(iterIndex == lastIndex)
+                break;
+
+            if(iterNode->idle)
+            {
+                nextNode = &Os->device->profNode[(iterIndex + 1)%100];
+                idleTime += nextNode->tick - iterNode->tick;
+                /* printk("line %d, idletime : %d\n",__LINE__, idleTime); */
+            }
+            iterIndex = (iterIndex + 1)%100;
+            iterNode = &Os->device->profNode[iterIndex];
+        }
+
+    }
+
+    *IdleTime = idleTime;
+
+    /* Release the command queue mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Os, Os->device->kernel->command->mutexQueue));
+
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_MemCopy(
+        IN gctPOINTER Destination,
+        IN gctCONST_POINTER Source,
+        IN gctSIZE_T Bytes
+        )
+{
+        gcmkVERIFY_ARGUMENT(Destination != NULL);
+        gcmkVERIFY_ARGUMENT(Source != NULL);
+        gcmkVERIFY_ARGUMENT(Bytes > 0);
+
+        memcpy(Destination, Source, Bytes);
+
+        return gcvSTATUS_OK;
+}
+
+gceSTATUS
+gckOS_ZeroMemory(
+	IN gctPOINTER Memory,
+	IN gctSIZE_T Bytes
+	)
+{
+	gcmkHEADER_ARG("Memory=0x%x Bytes=%lu", Memory, Bytes);
+
+	gcmkVERIFY_ARGUMENT(Memory != gcvNULL);
+	gcmkVERIFY_ARGUMENT(Bytes > 0);
+
+	memset(Memory, 0, Bytes);
+
+	gcmkFOOTER_NO();
+	return gcvSTATUS_OK;
+}
+
+#if gcdkUSE_MEMORY_RECORD
+MEMORY_RECORD_PTR
+CreateMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List,
+	gcuVIDMEM_NODE_PTR Node
+	)
+{
+	MEMORY_RECORD_PTR	mr;
+
+	mr = (MEMORY_RECORD_PTR)kmalloc(sizeof(struct MEMORY_RECORD), GFP_ATOMIC);
+	if (mr == gcvNULL) return gcvNULL;
+
+	MEMORY_LOCK(Os);
+
+	mr->node			= Node;
+
+	mr->prev			= List->prev;
+	mr->next			= List;
+	List->prev->next	= mr;
+	List->prev			= mr;
+
+	MEMORY_UNLOCK(Os);
+
+	return mr;
+}
+
+void
+DestoryMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR Mr
+	)
+{
+	MEMORY_LOCK(Os);
+
+	Mr->prev->next		= Mr->next;
+	Mr->next->prev		= Mr->prev;
+
+	MEMORY_UNLOCK(Os);
+
+	kfree(Mr);
+}
+
+MEMORY_RECORD_PTR
+FindMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List,
+	gcuVIDMEM_NODE_PTR Node
+	)
+{
+	MEMORY_RECORD_PTR mr;
+
+	MEMORY_LOCK(Os);
+
+	mr = List->next;
+
+	while (mr != List)
+	{
+		if (mr->node == Node)
+		{
+			MEMORY_UNLOCK(Os);
+
+			return mr;
+		}
+
+		mr = mr->next;
+	}
+
+	MEMORY_UNLOCK(Os);
+
+	return gcvNULL;
+}
+
+void
+FreeAllMemoryRecord(
+	gckOS Os,
+	MEMORY_RECORD_PTR List
+	)
+{
+	MEMORY_RECORD_PTR mr;
+	gctUINT i = 0;
+
+	MEMORY_LOCK(Os);
+
+	while (List->next != List)
+	{
+		mr = List->next;
+
+		mr->prev->next		= mr->next;
+		mr->next->prev		= mr->prev;
+
+		i++;
+
+		MEMORY_UNLOCK(Os);
+
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"Unfreed %s memory: node: %p",
+				(mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)?
+					"video" : (mr->node->Virtual.contiguous)?
+						"contiguous" : "virtual",
+				mr->node);
+
+		while (gcvTRUE)
+		{
+			if (mr->node->VidMem.memory->object.type == gcvOBJ_VIDMEM)
+			{
+				if (mr->node->VidMem.locked == 0) break;
+			}
+			else
+			{
+				if (mr->node->Virtual.locked == 0) break;
+			}
+
+			gckVIDMEM_Unlock(mr->node, gcvSURF_TYPE_UNKNOWN, gcvNULL);
+		}
+
+		gckVIDMEM_Free(mr->node);
+
+		kfree(mr);
+
+		MEMORY_LOCK(Os);
+	}
+
+	MEMORY_UNLOCK(Os);
+
+	if (i > 0)
+	{
+		gcmkTRACE_ZONE(gcvLEVEL_ERROR,
+				gcvZONE_OS,
+				"======== Total %d unfreed video/contiguous/virtual memory ========", i);
+	}
+}
+#endif
+
+/*******************************************************************************
+**  gckOS_CacheFlush
+**
+**  Flush the cache for the specified addresses.  The GPU is going to need the
+**  data.  If the system is allocating memory as non-cachable, this function can
+**  be ignored.
+**
+**  ARGUMENTS:
+**
+**      gckOS Os
+**          Pointer to gckOS object.
+**
+**      gctHANDLE Process
+**          Process handle Logical belongs to or gcvNULL if Logical belongs to
+**          the kernel.
+**
+**      gctPOINTER Logical
+**          Logical address to flush.
+**
+**      gctSIZE_T Bytes
+**          Size of the address range in bytes to flush.
+*/
+gceSTATUS
+gckOS_CacheFlush(
+    IN gckOS Os,
+    IN gctHANDLE Process,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    )
+{
+    return gcvSTATUS_OK;
+}
+
+/*******************************************************************************
+**  gckOS_CacheInvalidate
+**
+**  Flush the cache for the specified addresses and invalidate the lines as
+**  well.  The GPU is going to need and modify the data.  If the system is
+**  allocating memory as non-cachable, this function can be ignored.
+**
+**  ARGUMENTS:
+**
+**      gckOS Os
+**          Pointer to gckOS object.
+**
+**      gctHANDLE Process
+**          Process handle Logical belongs to or gcvNULL if Logical belongs to
+**          the kernel.
+**
+**      gctPOINTER Logical
+**          Logical address to flush.
+**
+**      gctSIZE_T Bytes
+**          Size of the address range in bytes to flush.
+*/
+gceSTATUS
+gckOS_CacheInvalidate(
+    IN gckOS Os,
+    IN gctHANDLE Process,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    )
+{
+    return gcvSTATUS_OK;
+}
+
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.h
index 0e94b7e..dc583b2 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/os/linux/kernel/gc_hal_kernel_os.h
@@ -10,7 +10,7 @@
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-*    GNU General Public Lisence for more details.
+*    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not write to the Free Software
@@ -24,6 +24,19 @@
 #ifndef __gc_hal_kernel_os_h_
 #define __gc_hal_kernel_os_h_
 
+/* 
+* Allocate video memory from low memory back when ALLOC_HIGHMEM set to 0 
+* Allocate video memory from hight memory back when ALLOC_HIGHMEM set to 1
+*
+* When we can not reserve physical continious memory (video memory), please 
+* set ALLOC_HIGHMEM set to 1 and Allocate video memory from hight memory back.
+*/
+#define ALLOC_HIGHMEM 0
+
+#define ALLOC_ALIGN_BYTES   64
+
+#define GC_INVALID_PHYS_ADDR    ~0U
+
 typedef struct _LINUX_MDL_MAP
 {
 	gctINT					pid;
@@ -37,9 +50,12 @@ typedef struct _LINUX_MDL
 {
 	gctINT					pid;
 	char *					addr;
+    char *                  addr_free;    /* Alighment used, really allocated memory pointer, for free use.*/
 
 #ifdef NO_DMA_COHERENT
+#if !ALLOC_HIGHMEM
 	gctPOINTER				kaddr;
+#endif
 #endif /* NO_DMA_COHERENT */
 
 	gctINT					numPages;
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gcProfiler.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gcProfiler.h
index 4bd62ff..ed1d2ef 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gcProfiler.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gcProfiler.h
@@ -13,7 +13,7 @@
 *  
 *****************************************************************************/
 
-
+.
 #ifndef __gl2_profile_h_
 #define __gl2_profile_h_
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user.h
index 181186c..fb7a83c 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user.h
@@ -163,14 +163,6 @@ gcoHARDWARE_LoadStateBuffer(
 	IN gctSIZE_T Bytes
 	);
 
-/* Load a number of load states from external buffer. */
-gceSTATUS
-gcoHARDWARE_LoadStateExternalBuffer(
-	IN gcoHARDWARE Hardware,
-	IN gctPOINTER StateBuffer,
-	IN gctSIZE_T Size
-	);
-
 /* Load a number of load states in fixed-point (3D pipe). */
 gceSTATUS
 gcoHARDWARE_LoadStateX(
@@ -227,6 +219,12 @@ gcoHARDWARE_PreserveCmdSpace(
     IN gctSIZE_T    Size
     );
 
+gceSTATUS
+gcoHARDWARE_SkipContext(
+    IN gcoHARDWARE  Hardware,
+    IN gctBOOL      Value
+    );
+
 /* Commit the current command buffer. */
 gceSTATUS
 gcoHARDWARE_Commit(
@@ -239,6 +237,17 @@ gcoHARDWARE_Stall(
 	IN gcoHARDWARE Hardware
 	);
 
+/* Compute the offset of the specified pixel location. */
+gceSTATUS
+gcoHARDWARE_ComputeOffset(
+    IN gctINT32 X,
+    IN gctINT32 Y,
+    IN gctUINT Stride,
+    IN gctINT BytesPerPixel,
+    IN gceTILING Tiling,
+    OUT gctUINT32_PTR Offset
+    );
+
 /* Resolve. */
 gceSTATUS
 gcoHARDWARE_ResolveRect(
@@ -451,6 +460,17 @@ gcoHARDWARE_ConvertFormat(
 	OUT gctUINT32 * BytesPerTile
 	);
 
+/* Convert face to offset */
+gceSTATUS
+gcoHARDWARE_ConvertFace(
+    IN gcoHARDWARE Hardware,
+    IN gctUINT32 Width,
+    IN gctUINT32 Height,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Face,
+    OUT gctUINT32 * Offset
+    );
+
 /* Align size to tile boundary. */
 gceSTATUS
 gcoHARDWARE_AlignToTile(
@@ -1216,6 +1236,13 @@ gcoHARDWARE_GetClosestTextureFormat(
 	OUT gceSURF_FORMAT* OutFormat
 	);
 
+/* Query the texture mipmap support. */
+gceSTATUS
+gcoHARDWARE_QueryTexture_MipMap(
+	IN gctUINT Width,
+	IN gctUINT Height
+	);
+
 /* Query the texture support. */
 gceSTATUS
 gcoHARDWARE_QueryTexture(
@@ -1941,6 +1968,15 @@ gcoHARDWARE_MonoBlit(
 	IN gctUINT32 BgRop
 	);
 
+/* Get Hw status*/
+gceSTATUS
+gcoHARDWARE_GetHWStatus(
+	IN gcoHARDWARE Hardware,
+	OUT gctBOOL_PTR* Idle,
+	OUT gctINT_PTR Count,
+	OUT gctINT_PTR CurrentCmdIndex
+	);
+
 /******************************************************************************\
 ******************************** gcoBUFFER Object *******************************
 \******************************************************************************/
@@ -2011,6 +2047,15 @@ gcoBUFFER_Commit(
 	IN gcoQUEUE Queue
 	);
 
+/*get the status of command buffer*/
+gceSTATUS
+gcoBUFFER_Status(
+	IN    gcoBUFFER Buffer,
+	OUT gctBOOL_PTR* Idle,
+	OUT gctINT_PTR Count,
+	OUT gctINT_PTR CurrentCmdIndex
+	);
+	
 /******************************************************************************\
 ******************************** gcoCMDBUF Object *******************************
 \******************************************************************************/
@@ -2080,6 +2125,29 @@ gcoCONTEXT_PostCommit(
 #define PENDING_FREED_MEMORY_SIZE_LIMIT		(4 * 1024 * 1024)
 #endif
 
+#if MRVL_PRE_ALLOCATE_CTX_BUFFER
+
+/******************************************************************************\
+******************************** gcoCTXBUF Object *******************************
+\******************************************************************************/
+
+/* Construct a new gcoCTXBUF object. */
+gceSTATUS
+gcoCTXBUF_Construct(
+	IN gcoOS Os,
+	IN gcoHARDWARE Hardware,
+	IN gctSIZE_T Bytes,
+	OUT gcoCTXBUF * Buffer
+	);
+
+/* Destroy an gcoCTXBUF object. */
+gceSTATUS
+gcoCTXBUF_Destroy(
+	IN gcoCTXBUF Buffer
+	);
+
+#endif
+
 /******************************************************************************\
 ********************************* gcoHAL object *********************************
 \******************************************************************************/
@@ -2131,6 +2199,7 @@ struct _gcoHAL
     gctUINT32                   reserveMemorySize[RESERVE_MEMORY_NUM];
     gctUINT32                   streamAlign;
     gctUINT32                   indexAlign;
+    gctBOOL                     DisableReserveMemory;
 #endif
 };
 
@@ -2235,6 +2304,10 @@ typedef struct _gcsSURF_INFO
 
 	/* Hierarchical Z buffer pointer. */
 	gcsSURF_NODE			hzNode;
+
+	/* face for resolve */
+	gctUINT                 face;
+	
 }
 gcsSURF_INFO;
 
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_compiler.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_compiler.h
index c2001f0..87925bc 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_compiler.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_compiler.h
@@ -413,6 +413,9 @@ struct _gcSHADER
 
 	/* Optimization option. */
 	gctUINT						optimizationOption;
+
+    /* has loop ? */
+    gctBOOL                     hasLoop;
 };
 
 /******************************************************************************\
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_context.h b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_context.h
index 4f93a4f..10c0564 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_context.h
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/hal/user/gc_hal_user_context.h
@@ -23,6 +23,27 @@
 extern "C" {
 #endif
 
+struct _gcoCTXBUF
+{
+    /* The object. */
+    gcsOBJECT                   object;
+
+    /* Pointer to gcoOS object. */
+    gcoOS                       os;
+
+    /* Pointer to gcoHARDWARE object. */
+    gcoHARDWARE                 hardware;
+
+    /* Physical address of context buffer. */
+    gctPHYS_ADDR                physical;
+
+    /* Logical address of context buffer. */
+    gctPOINTER                  logical;
+
+    /* Number of bytes in context buffer. */
+    gctSIZE_T                   bytes;
+};
+
 /* gcoCONTEXT structure that hold the current context. */
 struct _gcoCONTEXT
 {
@@ -56,8 +77,18 @@ struct _gcoCONTEXT
     gctSIZE_T                   bufferSize;
 
     /* Context buffer used for commitment. */
+#if MRVL_PRE_ALLOCATE_CTX_BUFFER
+	/* Array of phisical context buffers and their signals. */
+	gcoCTXBUF					ctxbufArray[gcdCTXBUF_SIZE_DEFAULT];
+	gctSIGNAL					ctxbufSignal[gcdCTXBUF_SIZE_DEFAULT];
+	/* Real number of context buffers pre-allocated. */
+	gctINT						ctxbufSize;
+	/* Current context buffer. */
+	gctINT						ctxbufIndex;
+#else
     gctSIZE_T                   bytes;
     gctPHYS_ADDR                physical;
+#endif
     gctPOINTER                  logical;
 
     /* Pointer to final LINK command. */
@@ -83,6 +114,9 @@ struct _gcoCONTEXT
     /* Hint array. */
     gctUINT32_PTR               hintArray;
     gctUINT32_PTR               hintIndex;
+
+    /* Skip flag */
+    gctBOOL                     skipContext;                
 };
 
 struct _gcoCMDBUF
diff --git a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/makefile.linux.def b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/makefile.linux.def
index e903248..503c5a8 100644
--- a/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/makefile.linux.def
+++ b/arch/arm/mach-dove/gc600_driver_dove/galcore_ko_src/makefile.linux.def
@@ -1,16 +1,16 @@
 ##############################################################################
-#  
+#
 #    Copyright (c) 2005 - 2010 by Vivante Corp.  All rights reserved.
-#  
+#
 #    The material in this file is confidential and contains trade secrets
 #    of Vivante Corporation. This is proprietary information owned by
-#    Vivante Corporation. No part of this work may be disclosed, 
-#    reproduced, copied, transmitted, or used in any way for any purpose, 
+#    Vivante Corporation. No part of this work may be disclosed,
+#    reproduced, copied, transmitted, or used in any way for any purpose,
 #    without the express written permission of Vivante Corporation.
-#  
+#
 ##############################################################################
-#  
-#  
+#
+#
 ##############################################################################
 
 
@@ -131,7 +131,7 @@ ifeq ($(ABI), 0)
 else
 	CFLAGS += -mabi=$(ABI)
 endif
-	
+
 ifneq ($(ENDIANNESS),)
    	CFLAGS += $(ENDIANNESS)
 	LFLAGS += $(ENDIANNESS)
@@ -143,7 +143,7 @@ ifeq ($(ANDROID), 1)
     USE_VDK = 0
 
     ifeq ($(ARCH_TYPE), arm)
-	CFLAGS += -I$(ANDROID_HOME)/bionic/libstdc++/include -I$(ANDROID_HOME)/bionic/libc/arch-arm/include -I$(ANDROID_HOME)/bionic/libc/include -I$(ANDROID_HOME)/bionic/libc/kernel/common/ -I$(ANDROID_HOME)/bionic/libc/kernel/arch-arm -I$(ANDROID_HOME)/bionic/libm/include -I$(ANDROID_HOME)/bionic/libm/include/arch/arm -I$(ANDROID_HOME)/bionic/libthread_db/include -I$(ANDROID_HOME)/system/core/include -I$(ANDROID_HOME)/frameworks/base/include 
+	CFLAGS += -I$(ANDROID_HOME)/bionic/libstdc++/include -I$(ANDROID_HOME)/bionic/libc/arch-arm/include -I$(ANDROID_HOME)/bionic/libc/include -I$(ANDROID_HOME)/bionic/libc/kernel/common/ -I$(ANDROID_HOME)/bionic/libc/kernel/arch-arm -I$(ANDROID_HOME)/bionic/libm/include -I$(ANDROID_HOME)/bionic/libm/include/arch/arm -I$(ANDROID_HOME)/bionic/libthread_db/include -I$(ANDROID_HOME)/system/core/include -I$(ANDROID_HOME)/frameworks/base/include
         CFLAGS += -DANDROID -D__ARM_ARCH_5__ -D__ARM_ARCH_5T__ -D__ARM_ARCH_5E__ -D__ARM_ARCH_5TE__ -fno-short-enums
     endif
 
@@ -158,10 +158,14 @@ ifeq ($(ANDROID), 1)
     ifeq ($(ANDROID_VERSION_ECLAIR), 1)
         CFLAGS += -DANDROID_VERSION_ECLAIR
     endif
+
+    ifeq ($(ANDROID_VERSION_GINGERBREAD), 1)
+        CFLAGS +=  -I$(ANDROID_HOME)/frameworks/base/native/include -DANDROID_VERSION_GINGERBREAD
+    endif
 endif
 
 ifeq ($(QNX), 1)
-	CFLAGS += -D__QNXNTO__   
+	CFLAGS += -D__QNXNTO__
 else
 	ifneq ($(USE_ARMCC),1)
 		CFLAGS += -DLINUX
@@ -213,12 +217,6 @@ else
     CFLAGS += -DMRVL_NATIVE_IMAGE_KHR_FOR_CHROME=0
 endif
 
-ifeq ($(MRVL_EGL_SUPPORT_RESIZE_WINDOW),1)
-    CFLAGS += -DMRVL_EGL_SUPPORT_RESIZE_WINDOW=1
-else
-    CFLAGS += -DMRVL_EGL_SUPPORT_RESIZE_WINDOW=0
-endif
-
 ifeq ($(USE_NEW_LINUX_SIGNAL), 1)
 	CFLAGS += -DUSE_NEW_LINUX_SIGNAL=1
 endif
@@ -242,11 +240,18 @@ endif
 
 CFLAGS += -DgcdREGISTER_ACCESS_FROM_USER=1
 
-CFLAGS += -D__KERNEL_SYSCALLS__
 ################################################################################
 # Build with profiler
 ifeq ($(USE_PROFILER),1)
-CFLAGS += -DVIVANTE_PROFILER=1
+    CFLAGS += -DVIVANTE_PROFILER=1
+else
+    CFLAGS += -DVIVANTE_PROFILER=0
+endif
+
+ifeq ($(USE_MRVL_PROFILER),1)
+    CFLAGS += -DMRVL_BENCH=1
+else
+    CFLAGS += -DMRVL_BENCH=0
 endif
 
 
@@ -278,7 +283,7 @@ SC2X_LIB_DIR    := $(GLES2X_DIR)/slc/glslang/MachineIndependent/compiler
 endif
 
 ifeq ($(ANDROID), 1)
-GCU_DIR		:= $(AQROOT)/gcu/proj/eclair
+GCU_DIR		:= $(AQROOT)/gcu/proj/android
 else
 GCU_DIR		:= $(AQROOT)/gcu/proj/linux
 endif
@@ -306,7 +311,7 @@ CONFORM_DIR     := $(AQROOT)/test/es11/conform
 else
 # old es11 conformce test was removed
 # $(AQROOT)/driver/openGL/es11/test/conform
-CONFORM_DIR	    := 
+CONFORM_DIR	    :=
 endif
 
 GLBES11_DIR     := $(AQROOT)/test/es11/GLBenchmark_ES1.1v2
@@ -330,13 +335,16 @@ KANZI_DIR       := $(AQROOT)/test/es20/Kanzi_UI_demo/Kanzi_UI_src
 AB20_DIR        := $(ES2X_TEST_DIR)/Automotive
 JRC_DIR         := $(ES2X_TEST_DIR)/JRC
 GFX_TEST_DIR    := $(AQROOT)/test/gfx
+ES20_GEARS_DIR  := $(AQROOT)/test/es20/gles2-cm-gears
 ES11_UNIT_DIR   := $(AQROOT)/test/es11/common/UnitTest
 ES11_EXTERN_DIR := $(AQROOT)/test/es11/extern
+ES11_EXTENSION_DIR := $(AQROOT)/test/es11/Extension
+ES11_GEARS_DIR	:= $(AQROOT)/test/es11/gles1-cm-gears
 VG11_UNIT_DIR   := $(AQROOT)/test/vg11/UnitTest
 VG11_EXTERN_DIR := $(AQROOT)/test/vg11/extern
 
 # third party resources
-DFB_DIR ?= $(TOOL_DIR)/dfb 
+DFB_DIR ?= $(TOOL_DIR)/dfb
 
 TEXTURE5_DIR    := $(ES2X_TEST_DIR)/texture5
 TEXTURE7_DIR    := $(ES2X_TEST_DIR)/texture7
@@ -346,3 +354,5 @@ VVLAUNCHER_DIR  := $(ES2X_TEST_DIR)/vv_launcher
 
 VIDEOCUBE_DIR	:= $(AQROOT)/test/es11/extern/VideoCube
 
+
+
-- 
1.7.4.1

