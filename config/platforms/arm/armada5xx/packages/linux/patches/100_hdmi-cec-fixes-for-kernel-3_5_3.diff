diff --git a/drivers/video/dovefb/dovefb_base.c b/drivers/video/dovefb/dovefb_base.c
index 5d030eb..1a106a5 100644
--- a/drivers/video/dovefb/dovefb_base.c
+++ b/drivers/video/dovefb/dovefb_base.c
@@ -1119,6 +1119,14 @@ failed:
 	return ret;
 }
 
+static void dovefb_shutdown(struct platform_device *pdev)
+{
+	struct dovefb_info *dfi = platform_get_drvdata(pdev);
+	struct fb_info *fi = dfi->gfx_plane->fb_info;
+	
+	(*dovefb_gfx_ops.fb_blank)(FB_BLANK_POWERDOWN, fi);
+}
+
 #ifdef CONFIG_PM
 static int dovefb_suspend(struct platform_device *pdev, pm_message_t mesg)
 {
@@ -1232,6 +1240,7 @@ static int dovefb_resume(struct platform_device *pdev)
 
 static struct platform_driver dovefb_driver = {
 	.probe		= dovefb_probe,
+	.shutdown	= dovefb_shutdown,
 #ifdef CONFIG_PM
 	.suspend	= dovefb_suspend,
 	.resume		= dovefb_resume,
diff --git a/drivers/video/dovefb/dovefb_gfx.c b/drivers/video/dovefb/dovefb_gfx.c
index 731d28a..30bb811 100644
--- a/drivers/video/dovefb/dovefb_gfx.c
+++ b/drivers/video/dovefb/dovefb_gfx.c
@@ -56,6 +56,12 @@ static int dovefb_fill_edid(struct fb_info *fi,
 static int wait_for_vsync(struct dovefb_layer_info *dfli);
 static void dovefb_set_defaults(struct dovefb_layer_info *dfli);
 
+#ifdef CONFIG_TDA19988
+extern const char *tda19988_get_edid(int *num_of_blocks);
+extern int tda19988_configure_tx_inout(int x, int y, int interlaced, int hz);
+#endif
+
+
 #define AXI_BASE_CLK	(2000000000ll)	/* 2000MHz */
 
 static const u8 edid_header[] = {
@@ -545,9 +551,6 @@ static u8 *make_analog_fake_edid(void)
 
 	return edid_block;
 }
-#ifdef CONFIG_TDA19988
-extern	int configure_tx_inout(int x, int y, int interlaced, int hz);
-#endif
 
 static int dovefb_gfx_set_par(struct fb_info *fi)
 {
@@ -628,7 +631,7 @@ static int dovefb_gfx_set_par(struct fb_info *fi)
 	printk(KERN_INFO "Setting HDMI TX resolution to %dx%d%c @ %d\n",
 		m->xres, m->yres, (m->vmode & FB_VMODE_INTERLACED) ? 'i' : 'p',
 		m->refresh);
-	if (!configure_tx_inout(m->xres, m->yres,
+	if (!tda19988_configure_tx_inout(m->xres, m->yres,
 		(m->vmode & FB_VMODE_INTERLACED) ? 1 : 0, m->refresh))
 		printk(KERN_ERR "Setting HDMI TX mode failed\n");
 #endif
@@ -1175,15 +1178,13 @@ static u8 *pull_edid_from_i2c(int busid, int addr)
 }
 #endif
 
-#ifdef CONFIG_TDA19988
-extern char *tda19988_get_edid(int *num_of_blocks);
-#endif
 static u8 *dove_read_edid(struct fb_info *fi, struct dovefb_mach_info *dmi)
 {
 	char *edid_data = NULL;
 #ifdef CONFIG_TDA19988
 	int num_of_blocks;
-	char *nxp_edid;
+	const char *nxp_edid;
+
 	nxp_edid = tda19988_get_edid(&num_of_blocks);
 	if (nxp_edid == NULL) /* EDID not ready */
 		return NULL;
diff --git a/drivers/video/dovefb/nxp_hdmi/Makefile b/drivers/video/dovefb/nxp_hdmi/Makefile
index c406b23..9d492d3 100755
--- a/drivers/video/dovefb/nxp_hdmi/Makefile
+++ b/drivers/video/dovefb/nxp_hdmi/Makefile
@@ -125,6 +125,9 @@ obj-y += hdmitx.o
 hdmitx-objs := tda998x.o
 hdmicec-objs := tda998x_cec.o
 
+#hdmitx-objs += tda998x_i2c.o
+hdmicec-objs += tda998x_i2c.o
+
 # NXP comps
 ifeq ($(TDA_TX),TDA19989)
 hdmitx-objs += $(TXSRC)/tmdlHdmiTx.o
diff --git a/drivers/video/dovefb/nxp_hdmi/comps/tmbslTDA9989/src/tmbslTDA9989_Misc.c b/drivers/video/dovefb/nxp_hdmi/comps/tmbslTDA9989/src/tmbslTDA9989_Misc.c
index 855069b..1dee229 100755
--- a/drivers/video/dovefb/nxp_hdmi/comps/tmbslTDA9989/src/tmbslTDA9989_Misc.c
+++ b/drivers/video/dovefb/nxp_hdmi/comps/tmbslTDA9989/src/tmbslTDA9989_Misc.c
@@ -893,7 +893,7 @@ tmbslTDA9989HwHandleInterrupt
         /* Has the EDID_blk_rd interrupt occurs */
         if ((regVal & E_MASKREG_P00_INT_FLAGS_2_edid_blk_rd) != 0)
         {
-             fInterruptStatus = fInterruptStatus | (1 << HDMITX_CALLBACK_INT_EDID_BLK_READ);
+           fInterruptStatus = fInterruptStatus | (1 << HDMITX_CALLBACK_INT_EDID_BLK_READ);
         }
     }
 
@@ -962,29 +962,35 @@ tmbslTDA9989HwHandleInterrupt
 
            if (fInterruptStatus & (1 << HDMITX_CALLBACK_INT_EDID_BLK_READ))
            {
-               err = EdidBlockAvailable(txUnit,&sendEdidCallback);
-               RETIF(err != TM_OK, err)
-               if (sendEdidCallback == False)
+               if (pDis->hotPlugStatus == HDMITX_HOTPLUG_ACTIVE)
                {
-                   /* Read EDID not finished clear callback */
-                   fInterruptStatus &= ~(1 << HDMITX_CALLBACK_INT_EDID_BLK_READ);
-               }
-               else {
-                #ifdef TMFL_TDA9989_PIXEL_CLOCK_ON_DDC
-
-                if ( (pDis->vinFmt == HDMITX_VFMT_16_1920x1080p_60Hz) || (pDis->vinFmt == HDMITX_VFMT_31_1920x1080p_50Hz)) {
-
-                err = setHwRegisterField(pDis, 
-                                 E_REG_P02_PLL_SERIAL_3_RW, 
-                                 E_MASKREG_P02_PLL_SERIAL_3_srl_ccir,
-                                 0x00);
-                RETIF_REG_FAIL(err)
+                   err = EdidBlockAvailable(txUnit,&sendEdidCallback);
+                   RETIF(err != TM_OK, err)
+                   if (sendEdidCallback == False)
+                   {
+                       /* Read EDID not finished clear callback */
+                       fInterruptStatus &= ~(1 << HDMITX_CALLBACK_INT_EDID_BLK_READ);
+                   }
+                   else {
+                    #ifdef TMFL_TDA9989_PIXEL_CLOCK_ON_DDC
+    
+                    if ( (pDis->vinFmt == HDMITX_VFMT_16_1920x1080p_60Hz) || (pDis->vinFmt == HDMITX_VFMT_31_1920x1080p_50Hz)) {
+    
+                    err = setHwRegisterField(pDis, 
+                                     E_REG_P02_PLL_SERIAL_3_RW, 
+                                     E_MASKREG_P02_PLL_SERIAL_3_srl_ccir,
+                                     0x00);
+                    RETIF_REG_FAIL(err)
+                    }
+    
+                   #endif /* TMFL_TDA9989_PIXEL_CLOCK_ON_DDC */
+                   }
+                }
+                else
+                {
+                    ClearEdidRequest(txUnit);
+                    fInterruptStatus &= ~(1 << HDMITX_CALLBACK_INT_EDID_BLK_READ);
                 }
-
-               #endif /* TMFL_TDA9989_PIXEL_CLOCK_ON_DDC */
-               }
-
-
            }
       }
 
diff --git a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
index 332e3dd..fea74bc 100755
--- a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
+++ b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
@@ -141,7 +141,7 @@ tmErrorCode_t tmdlHdmiTxIWTaskStart(tmdlHdmiTxIWTaskHandle_t handle);
             - TMDL_ERR_DLHDMIRX_NO_RESOURCES: the resource is not available
 
 ******************************************************************************/
-static tmErrorCode_t tmdlHdmiTxIWWait(UInt16 duration);
+tmErrorCode_t tmdlHdmiTxIWWait(UInt16 duration);
 
 /*============================================================================*/
 
diff --git a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
index 611e6bf..25586eb 100755
--- a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
+++ b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
@@ -1,6 +1,27 @@
+/*****************************************************************************/
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
 /*============================================================================*/
-/*                             INCLUDE FILES                                  */
+/*                       INCLUDE FILES                                        */
 /*============================================================================*/
+/* The following includes are used by I2C access function. If                 */
+/* you need to rewrite these functions for your own SW infrastructure, then   */
+/* it can be removed                                                          */
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/string.h>
@@ -8,413 +29,107 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 
-#include "tmdlHdmiCEC_IW.h"
 #include "tmNxTypes.h"
 #include "tmdlHdmiCEC.h"
 #include "tmdlHdmiCEC_cfg.h"
 
-static struct i2c_client *cecGetThisI2cClient(void);
-static unsigned char  my_i2c_data[255];
+/* low level I2C functions */
+#include "tda998x_i2c.h"
 
 /*============================================================================*/
 /*                          MACROS                                            */
 /*============================================================================*/
 #define RETIF(cond, rslt) if ((cond)){return (rslt);}
-#define I2C_M_WR 0
-
-/*============================================================================*/
-/*                          FUNCTIONS DECLARATIONS                            */
-/*============================================================================*/
-
-
-tmErrorCode_t           I2cReadFunction(tmdlHdmiCecSysArgs_t *pSysArgs);
-tmErrorCode_t           I2cWriteFunction(tmdlHdmiCecSysArgs_t *pSysArgs);
-
 
 /*============================================================================*/
 /*                       CONSTANTS DECLARATIONS                               */
 /*============================================================================*/
-
-
 #define COMMAND_TASK_PRIORITY_0  250
 #define COMMAND_TASK_STACKSIZE_0 128
 #define COMMAND_TASK_QUEUESIZE_0 8
 
 /* I2C adress of the unit */
 #ifdef TMFL_TDA9996
-	#define UNIT_I2C_ADDRESS_0 0x60 /* I2C Address of TDA9950 */
+	#define UNIT_I2C_ADDRESS_0 0x60 /* I2C Address of TDA9996 */
 #else
 	#define UNIT_I2C_ADDRESS_0 0x34 /* I2C Address of TDA9950 */
 #endif
 
 
+/******************************************************************************
+ ******************************************************************************
+ *                 THIS PART CAN BE MODIFIED BY CUSTOMER                      *
+ ******************************************************************************
+ *****************************************************************************/
 
-/*============================================================================*/
-/*                       VARIABLES DECLARATIONS                               */
-/*============================================================================*/
-
-
-tmdlHdmiCecCapabilities_t CeccapabilitiesList = {TMDL_HDMICEC_DEVICE_UNKNOWN, CEC_VERSION_1_3a};
-
-tmdlHdmiCecDriverConfigTable_t CecdriverConfigTable[MAX_UNITS] = {
-    {
-    COMMAND_TASK_PRIORITY_0,
-    COMMAND_TASK_STACKSIZE_0,
-    COMMAND_TASK_QUEUESIZE_0,
-    UNIT_I2C_ADDRESS_0,
-    I2cReadFunction,
-    I2cWriteFunction,
-    &CeccapabilitiesList
-    }
-};
-
-
-int blockwrite_reg(struct i2c_client *client,
-		   u8 reg, u16 alength, u8 *val, u16 *out_len)
-{
-   int err = 0,i,initiator,receiver;
-   struct i2c_msg msg[1];
-    
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-   
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = alength+1;
-   msg->buf = my_i2c_data;
-   
-   msg->buf[0] = reg;   
-   for (i=0; i<alength; i++) {
-      msg->buf[i+1] = val[i];
-/*       printk(KERN_INFO "buf[%d]=%d val[%d]=%d\n",i+1,msg->buf[i+1],i,val[i]); */
-   }
-   
-   err = i2c_transfer(client->adapter, msg, 1);
-   udelay(50);
-
-   if (reg==7) {
-      /* CEC message */
-      extern char *cec_opcode(int op);
-      initiator = (msg->buf[3] >> 4) & 0x0f;
-      receiver = msg->buf[3] & 0x0f;
-/*       printk(KERN_INFO "reg:%d alength:%d \n",reg, alength); */
-      if (alength==3) {
-         printk(KERN_INFO "hdmicec:polling:[%x--->%x] \n", initiator,receiver);
-      }
-      else {
-         printk(KERN_INFO "hdmicec:Tx:[%x--->%x] %s %02x%02x%02x%02x\n", \
-                initiator,receiver,cec_opcode(msg->buf[4]),msg->buf[4],msg->buf[5],msg->buf[6],msg->buf[7]);
-      }
-   }
-/*    dev_dbg(&client->dev, "<%s> i2c Block write at 0x%x, " */
-/*            "*val=%d flags=%d byte[%d] err=%d\n", */
-/*            __func__, data[0], data[1], msg->flags, i, err); */
-   return (err < 0?err:0);
-
-#if 0
-   int err = 0, i;
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 2;
-   msg->buf = data;
-
-   /* high byte goes out first */
-   data[0] = reg >> 8;
-
-   for (i = 0; i < alength - 1; i++) {
-      data[1] = val[i];
-      err = i2c_transfer(client->adapter, msg, 1);
-      udelay(50);
-      dev_dbg(&client->dev, "<%s> i2c Block write at 0x%x, "
-	      "*val=%d flags=%d byte[%d] err=%d\n",
-	      __func__, data[0], data[1], msg->flags, i, err);
-      if (err < 0)
-	 break;
-   }
-   /* set the number of bytes written*/
-   *out_len = i;
-
-   if (err < 0) {
-      dev_err(&client->dev, "<%s> ERROR:  i2c Block Write at 0x%x, "
-	      "*val=%d flags=%d bytes written=%d "
-	      "err=%d\n",
-	      __func__, data[0], data[1], msg->flags, i, err);
-      return err;
-   }
-   return 0;
-#endif
-}
-
-static int blockread_reg(struct i2c_client *client, u16 data_length,
-		  u8 reg, u16 alength, u8 *val, u16 *out_len)
-{
-   int err = 0;
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 1;
-   msg->buf = data;
-   data[0] = reg; /* High byte goes out first */
-   err = i2c_transfer(client->adapter, msg, 1);
-   if (err<0) goto BLOCK_READ_OUPS;
-
-   msg->flags = I2C_M_RD;
-   msg->len = alength; 
-   msg->buf = val;
-   err = i2c_transfer(client->adapter, msg, 1);
-   if (err<0) goto BLOCK_READ_OUPS;
-
-/*    printk(KERN_INFO "DBG blockread_reg addr:%x len:%d buf:%02x%02x%02x%02x\n",msg->addr,msg->len,\ */
-/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3]); */
-
-   return 0;
-   
- BLOCK_READ_OUPS:
-/*    printk(KERN_INFO "DBG blockread_reg addr:%x len:%d ERROR\n",msg->addr,msg->len); */
-   dev_err(&client->dev, "<%s> ERROR:  i2c Read at 0x%x, "
-           "*val=%d flags=%d bytes err=%d\n",
-           __func__, reg, *val, msg->flags, err);
-   return err;
-
-#if 0
-   int err = 0, i;
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 1;
-   msg->buf = data;
-
-   /* High byte goes out first */
-   data[0] = reg;
-
-   for (i = 0; i < alength; i++) {
-      err = i2c_transfer(client->adapter, msg, 1);
-      dev_dbg(&client->dev, "<%s> i2c Block Read1 at 0x%x, "
-	      "*val=%d flags=%d err=%d\n",
-	      __func__, data[0], data[1], msg->flags, err);
-      if (err >= 0) {
-	 mdelay(3);
-	 msg->flags = I2C_M_RD;
-	 msg->len = data_length;
-	 err = i2c_transfer(client->adapter, msg, 1);
-      } else
-	 break;
-      if (err >= 0) {
-	 val[i] = 0;
-	 /* High byte comes first */
-	 if (data_length == 1)
-	    val[i] = data[0];
-	 else if (data_length == 2)
-	    val[i] = data[1] + (data[0] << 8);
-	 dev_dbg(&client->dev, "<%s> i2c Block Read2 at 0x%x, "
-		 "*val=%d flags=%d byte=%d "
-		 "err=%d\n",
-		 __func__, reg, val[i], msg->flags, i, err);
-      } else
-	 break;
-   }
-   *out_len = i;
-   dev_info(&client->dev, "<%s> i2c Block Read at 0x%x, bytes read = %d\n",
-	    __func__, reg, *out_len);
-
-   if (err < 0) {
-      dev_err(&client->dev, "<%s> ERROR:  i2c Read at 0x%x, "
-	      "*val=%d flags=%d bytes read=%d err=%d\n",
-	      __func__, reg, *val, msg->flags, i, err);
-      return err;
-   }
-   return 0;
-#endif
-}
-
-
-static int write_reg(struct i2c_client *client, u8 reg, u8 val)
-{
-   int err = 0;
-   struct i2c_msg msg[1];
-   u8 data[2];
-   int retries = 0;
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
- retry:
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 2;
-   msg->buf = data;
-
-   data[0] = reg;
-   data[1] = val;
-
-   err = i2c_transfer(client->adapter, msg, 1);
-   dev_dbg(&client->dev, "<%s> i2c write at=%x "
-	   "val=%x flags=%d err=%d\n",
-	   __func__, data[0], data[1], msg->flags, err);
-   udelay(50);
-
-/*    printk(KERN_INFO "DBG write_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
-   if (err >= 0)
-      return 0;
-
-   dev_err(&client->dev, "<%s> ERROR: i2c write at=%x "
-	   "val=%x flags=%d err=%d\n",
-	   __func__, data[0], data[1], msg->flags, err);
-   if (retries <= 5) {
-      dev_info(&client->dev, "Retrying I2C... %d\n", retries);
-      retries++;
-      set_current_state(TASK_UNINTERRUPTIBLE);
-      schedule_timeout(msecs_to_jiffies(20));
-      goto retry;
-   }
-
-   return err;
-}
-
-static int read_reg(struct i2c_client *client, u16 data_length, u8 reg, u8 *val)
+/* The following function must be rewritten by the customer to fit its own    */
+/* SW infrastructure. This function allows reading through I2C bus.           */
+static tmErrorCode_t cecI2cReadFunction(tmdlHdmiCecSysArgs_t *pSysArgs)
 {
-   int err = 0;
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 1;
-   msg->buf = data;
+   struct i2c_client *client = cecGetThisI2cClient();
 
-   data[0] = reg;
-   err = i2c_transfer(client->adapter, msg, 1);
-   dev_dbg(&client->dev, "<%s> i2c Read1 reg=%x val=%d "
-	   "flags=%d err=%d\n",
-	   __func__, reg, data[1], msg->flags, err);
+   RETIF(!client || !client->adapter || 
+          client->addr != pSysArgs->slaveAddr, TM_ERR_NULL_DATAINFUNC)
 
-   if (err >= 0) {
-      mdelay(3);
-      msg->flags = I2C_M_RD;
-      msg->len = data_length;
-      err = i2c_transfer(client->adapter, msg, 1);
-   }
+   RETIF(tda998x_i2c_read_regs(
+            client, pSysArgs->lenData, 
+            pSysArgs->firstRegister, pSysArgs->pData) == 0, TM_OK)
 
-   if (err >= 0) {
-      *val = 0;
-      if (data_length == 1)
-	 *val = data[0];
-      else if (data_length == 2)
-	 *val = data[1] + (data[0] << 8);
-      dev_dbg(&client->dev, "<%s> i2c Read2 at 0x%x, *val=%d "
-	      "flags=%d err=%d\n",
-	      __func__, reg, *val, msg->flags, err);
-      return 0;
-   }
-
-   dev_err(&client->dev, "<%s> ERROR: i2c Read at 0x%x, "
-	   "*val=%d flags=%d err=%d\n",
-	   __func__, reg, *val, msg->flags, err);
-   return err;
+   return TMDL_ERR_DLHDMICEC_I2C_WRITE;
 }
 
-
-tmErrorCode_t I2cReadFunction (tmdlHdmiCecSysArgs_t *pSysArgs)
+/* The following function must be rewritten by the customer to fit its own    */
+/* SW infrastructure. This function allows writing through I2C bus.           */
+static tmErrorCode_t cecI2cWriteFunction(tmdlHdmiCecSysArgs_t *pSysArgs)
 {
-   tmErrorCode_t errCode = TM_OK;
-   u16 outLenght=0;
-   struct i2c_client *client=cecGetThisI2cClient();
-   u32 client_main_addr=client->addr;
+   struct i2c_client *client = cecGetThisI2cClient();
 
-   /* DevLib needs address control, so let it be */ 
-   client->addr=pSysArgs->slaveAddr;
+   RETIF(!client || !client->adapter ||
+         client->addr != pSysArgs->slaveAddr, TM_ERR_NULL_DATAOUTFUNC)
 
-   if (pSysArgs->lenData == 1) {
-      /* single byte */
-      errCode = read_reg(cecGetThisI2cClient(),1,pSysArgs->firstRegister,pSysArgs->pData);
-   }
-   else {
-      /* block */
-      errCode = blockread_reg(cecGetThisI2cClient(),1, \
-			      pSysArgs->firstRegister, \
-			      pSysArgs->lenData, \
-			      pSysArgs->pData, &outLenght);
-   }
-   
-   /* restore default client address */
-   client->addr=client_main_addr;
+   RETIF(tda998x_i2c_write_regs(
+            client, pSysArgs->lenData, 
+            pSysArgs->firstRegister, pSysArgs->pData) == 0, TM_OK)
 
-   return errCode;
+   return TMDL_ERR_DLHDMICEC_I2C_READ;
 }
 
+/**
+ * \brief Configuration Tables. This table can be modified by the customer 
+            to choose its prefered configuration
+ */
 
-tmErrorCode_t I2cWriteFunction(tmdlHdmiCecSysArgs_t *pSysArgs)
-{
-
-   tmErrorCode_t errCode = TM_OK;
-   u16 outLenght=0;
-   struct i2c_client *client=cecGetThisI2cClient();
-   u32 client_main_addr=client->addr;
-
-   /* DevLib needs address control, so let it be */ 
-   client->addr=pSysArgs->slaveAddr;
-   
-   if (pSysArgs->lenData == 1) {
-      /* single byte */
-      errCode = write_reg(cecGetThisI2cClient(),pSysArgs->firstRegister,*pSysArgs->pData);
-   }
-   else {
-      /* block */
-      errCode = blockwrite_reg(cecGetThisI2cClient(),  \
-                               pSysArgs->firstRegister, \
-                               pSysArgs->lenData,       \
-                               pSysArgs->pData,&outLenght);
-   }
-   
-   /* restore default client address */
-   client->addr=client_main_addr;
+static tmdlHdmiCecCapabilities_t CeccapabilitiesList = {
+    TMDL_HDMICEC_DEVICE_UNKNOWN, CEC_VERSION_1_3a
+};
 
-   return errCode;
+static tmdlHdmiCecDriverConfigTable_t CecdriverConfigTable[MAX_UNITS] = {
+    {
+    COMMAND_TASK_PRIORITY_0,
+    COMMAND_TASK_STACKSIZE_0,
+    COMMAND_TASK_QUEUESIZE_0,
+    UNIT_I2C_ADDRESS_0,
+    cecI2cReadFunction,
+    cecI2cWriteFunction,
+    &CeccapabilitiesList
+    }
+};
 
-}
 
-static tmErrorCode_t tmdlHdmiTxIWWait
-(
-    UInt16 duration
-)
-{
+/**
+    \brief This function allows to the main driver to retrieve its
+           configuration parameters.
 
-    mdelay((unsigned long)duration);
+    \param pConfig Pointer to the config structure
 
-    return(TM_OK);
-}
+    \return The call result:
+            - TM_OK: the call was successful
+            - TMDL_ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+              the receiver instance is not initialised
+            - TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+              inconsistent
 
+******************************************************************************/
 tmErrorCode_t tmdlHdmiCecCfgGetConfig
 (
     tmUnitSelect_t                 unit,
@@ -430,7 +145,8 @@ tmErrorCode_t tmdlHdmiCecCfgGetConfig
     *pConfig = CecdriverConfigTable[unit];
 
     return(TM_OK);
-};
+}
+
 /*============================================================================*/
 /*                            END OF FILE                                     */
 /*============================================================================*/
diff --git a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
index 859a7a7..629b06c9 100755
--- a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
+++ b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
@@ -229,9 +229,7 @@ tmErrorCode_t tmdlHdmiCecHandleInterrupt
   unsigned char  I2c_ReadBuffer[19] ;   /* I2C Read data buffer */
   tmdlHdmiCecDriverConfigTable_t *pDis; /* Pointer to Device Instance Structure */
   tmdlHdmiCecUnitConfig_t        *pCecObject; /* Pointer to Cec Object */
-  tmdlHdmiCecFrameFormat_t  ReadFrame;
   tmdlHdmiCecSaveMessage_t  LastSendMessage;
-  int i;
 
 
   pDis = &gtmdlHdmiCecDriverConfigTable[instance];
@@ -250,52 +248,35 @@ tmErrorCode_t tmdlHdmiCecHandleInterrupt
 #endif
 
   errCode = getCecHwRegisters(pDis, E_REG_CDR0,I2c_ReadBuffer,19);
-  RETIF(errCode != TM_OK, errCode)
-     
-  /*Fill Frame structure with read data*/
+  RETIF((errCode != TM_OK || I2c_ReadBuffer[0] < 2), errCode)
 
-  /* Case of Receiving CECData.cnf*/
-  /*Inform Success or reason of failure of CEC message sending*/
-  if (I2c_ReadBuffer[1]== 0x01)
+  if (I2c_ReadBuffer[1] == 0x81)
   {
-    /* Get Infos of last message send */ 
-    getCecLastMessage(&LastSendMessage);
-	
-    if (LastSendMessage.MessageTypePolling)
-    {
-     ReadFrame.FrameByteCount = I2c_ReadBuffer[0];
-     ReadFrame.AddressByte = LastSendMessage.AddressByte;
-     ReadFrame.DataBytes[0]= I2c_ReadBuffer[2];
-    }
-    else
-    {
-     ReadFrame.FrameByteCount = I2c_ReadBuffer[0]+1;
-     ReadFrame.AddressByte = LastSendMessage.AddressByte;
-     ReadFrame.DataBytes[0]= I2c_ReadBuffer[2];
-     ReadFrame.DataBytes[1]= LastSendMessage.Opcode;
-    }
-    
-    pCecObject->MessageCallback(TMDL_HDMICEC_CALLBACK_STATUS
-                               , (Void *) &ReadFrame, ReadFrame.FrameByteCount);
-  }
+    /* Case of Receiving CECData.ind*/
+    /*Give receive data from CEC bus*/
 
-  /* Case of Receiving CECData.ind*/
-  /*Give receive data from CEC bus*/
-  if (I2c_ReadBuffer[1]== 0x81)
+    pCecObject->MessageCallback(TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE,
+                                &I2c_ReadBuffer[2], I2c_ReadBuffer[0] - 2);
+  }
+  else if (I2c_ReadBuffer[1]== 0x01)
   {
-    ReadFrame.FrameByteCount = I2c_ReadBuffer[0];
-    ReadFrame.AddressByte = I2c_ReadBuffer[2];
-    for (i=0; i<15; i++)
-    {
-    ReadFrame.DataBytes[i] = I2c_ReadBuffer[i+3];
-    }
+    /* Case of Receiving CECData.cnf*/
+    /*Inform Success or reason of failure of CEC message sending*/
+
+    getCecLastMessage(&LastSendMessage);
+
+    /* Append saved OpCode */
+    if (!LastSendMessage.MessageTypePolling)
+      I2c_ReadBuffer[I2c_ReadBuffer[0]++] = LastSendMessage.Opcode;
 
-    pCecObject->MessageCallback(TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE
-                               , (Void *) &ReadFrame, ReadFrame.FrameByteCount);
+    /* Prepend saved AddressByte */
+    I2c_ReadBuffer[1] = LastSendMessage.AddressByte;
+
+    pCecObject->MessageCallback(TMDL_HDMICEC_CALLBACK_STATUS,
+                                &I2c_ReadBuffer[1], I2c_ReadBuffer[0] - 1);
   }
 
   return(TM_OK);
-
 }
 
 //==========================================================================
@@ -2443,13 +2424,16 @@ tmErrorCode_t tmdlHdmiCecSetTimerProgramTitle
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(ProgramTitleLength > (sizeof(I2c_Buffer) - 4), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
   pDis = &gtmdlHdmiCecDriverConfigTable[Instance];
 
   /* Set Timer Program Title */
-  MessLength = ProgramTitleLength+4;                         /* Calculate Message length*/
+  MessLength = ProgramTitleLength + 4;                       /* Calculate Message length*/
 
   I2c_Buffer[0] = (unsigned char)MessLength;
 
@@ -2462,12 +2446,12 @@ tmErrorCode_t tmdlHdmiCecSetTimerProgramTitle
 
   I2c_Buffer[3] = CEC_OPCODE_SET_TIMER_PROGRAM_TITLE ;      /* Set Timer Program Title*/
 
-  for(loci = 0; loci <= ProgramTitleLength ; loci++)
-    {
-        I2c_Buffer[(loci+4)] = pProgramTitleString[loci];     /* Fill Table with Program Title characters*/
-    }
+  /* Fill Table with Program Title characters*/
+  for (loci = 0; loci < ProgramTitleLength; loci++) {
+      I2c_Buffer[loci + 4] = pProgramTitleString[loci];       
+  }
 
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,(MessLength)); /* CEC Data register */
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -5694,6 +5678,9 @@ tmErrorCode_t tmdlHdmiCecVendorCommand
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(VendorSpecificDataLength > (sizeof(I2c_Buffer) - 4), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
@@ -5714,12 +5701,12 @@ tmErrorCode_t tmdlHdmiCecVendorCommand
 
   I2c_Buffer[3] = CEC_OPCODE_VENDOR_COMMAND ;       /* Vendor Command*/
 
-  for(loci = 0; loci <= VendorSpecificDataLength ; loci++)
-    {
-        I2c_Buffer[(loci+7)] = pVendorSpecificData[loci];    /* Fill Table with vendorSpecific Data characters*/
-    }
+  /* Fill Table with vendorSpecific Data characters*/
+  for (loci = 0; loci < VendorSpecificDataLength; loci++) {
+      I2c_Buffer[loci + 4] = pVendorSpecificData[loci];    
+  }
 
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,MessLength); /* CEC Data register */
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -5778,6 +5765,9 @@ tmErrorCode_t tmdlHdmiCecVendorCommandWithID
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(VendorSpecificDataLength > (sizeof(I2c_Buffer) - 7), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
@@ -5801,12 +5791,12 @@ tmErrorCode_t tmdlHdmiCecVendorCommandWithID
   I2c_Buffer[5] = (unsigned char)(VendorID >> 8);
   I2c_Buffer[6] = (unsigned char)VendorID;          /* LSByte of Vendor ID*/
 
-  for(loci = 0; loci <= VendorSpecificDataLength ; loci++)
-  {
-     I2c_Buffer[(loci+7)] = pVendorSpecificData[loci];    /* Fill Table with vendorSpecific Data characters*/
+  /* Fill Table with vendorSpecific Data characters*/
+  for (loci = 0; loci < VendorSpecificDataLength; loci++) {
+      I2c_Buffer[loci + 7] = pVendorSpecificData[loci];    
   }
 
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,MessLength); /* CEC Data register */
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -5862,6 +5852,9 @@ tmErrorCode_t tmdlHdmiCecVendorRemoteButtonDown
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(VendorSpecificRcCodeLength > (sizeof(I2c_Buffer) - 4), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
@@ -5880,14 +5873,14 @@ tmErrorCode_t tmdlHdmiCecVendorRemoteButtonDown
   I2c_Buffer[2] |= ReceiverLogicalAddress & 0x0F;                                   /* Receiver logical Address*/
 
   I2c_Buffer[3] = CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN ;    /* Vendor Remote Button Down Opcode*/
-  /*Vendor Specific RC code Parameter*/
-  for(loci = 0; loci <= VendorSpecificRcCodeLength ; loci++)
-    {
-        I2c_Buffer[(loci+4)] = pVendorSpecificRcCode[loci];   /* Fill Table with Vendor Specific RC Code data*/
-    }
+
+  /* Fill Table with Vendor Specific RC Code data*/
+  for (loci = 0; loci < VendorSpecificRcCodeLength; loci++) {
+      I2c_Buffer[loci + 4] = pVendorSpecificRcCode[loci];     
+  }
+
   /*Send message Via I2C*/
-  
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,MessLength);
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -6010,6 +6003,9 @@ tmErrorCode_t tmdlHdmiCecSetOsdString
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(OsdStringLength > (sizeof(I2c_Buffer) - 5), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
@@ -6018,9 +6014,9 @@ tmErrorCode_t tmdlHdmiCecSetOsdString
   //======To do : make a prepare message function with parameter
   /* Set OSD String command */
 
-  MessLength = OsdStringLength+5;                   /* Calculate Message length*/
+  MessLength = OsdStringLength + 5;                 /* Calculate Message length*/
 
-  I2c_Buffer[0] = (unsigned char)MessLength;
+  I2c_Buffer[0] = MessLength;
 
   I2c_Buffer[1] = 0x00;     /* Request CEC data */
 
@@ -6031,12 +6027,13 @@ tmErrorCode_t tmdlHdmiCecSetOsdString
 
   I2c_Buffer[3] = CEC_OPCODE_SET_OSD_STRING ;       /* Set Osd String*/
   I2c_Buffer[4] = DisplayControl;                   /*Display Control*/
-   for(loci = 0; loci <= OsdStringLength ; loci++)
-    {
-        I2c_Buffer[(loci+5)] = pOsdString[loci];         /* Fill Table with OSD Name characters*/
-    }
+
+  /* Fill Table with OSD Name characters*/
+  for (loci = 0; loci < OsdStringLength; loci++) {
+      I2c_Buffer[loci + 5] = pOsdString[loci];        
+  }
   
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,(MessLength)); /* CEC Data register */
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -6156,6 +6153,9 @@ tmErrorCode_t tmdlHdmiCecSetOsdName
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[Instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
 
+  /* check if length is valid */
+  RETIF(OsdNameLength > (sizeof(I2c_Buffer) - 4), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
   /* check if instance state is correct */
   //RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, TMDL_ERR_DLHDMICEC_INVALID_STATE)
 
@@ -6164,9 +6164,9 @@ tmErrorCode_t tmdlHdmiCecSetOsdName
   //======To do : make a prepare message function with parameter
   /* Set OSD Name command */
 
-  MessLength = OsdNameLength+4;                         /* Calculate Message length*/
+  MessLength = OsdNameLength + 4;                       /* Calculate Message length*/
 
-  I2c_Buffer[0] = (unsigned char)MessLength;
+  I2c_Buffer[0] = MessLength;
   
   I2c_Buffer[1] = 0x00;     /* Request CEC data */
 
@@ -6176,12 +6176,13 @@ tmErrorCode_t tmdlHdmiCecSetOsdName
   I2c_Buffer[2] |= ReceiverLogicalAddress & 0x0F;                                   /* Receiver logical Address*/
 
   I2c_Buffer[3] = CEC_OPCODE_SET_OSD_NAME ;     /* Set Osd Name*/
-    for(loci = 0; loci <= OsdNameLength ; loci++)
-    {
-        I2c_Buffer[(loci+4)] = pOsdName[loci];       /* Fill Table with OSD Name characters*/
-    }
 
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,(MessLength)); /* CEC Data register */
+  /* Fill Table with OSD Name characters*/
+  for (loci = 0; loci < OsdNameLength; loci++) {
+      I2c_Buffer[loci + 4] = pOsdName[loci];      
+  }
+
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength);
   RETIF(errCode != TM_OK, errCode)
 
   /* Save Datas of the CEC message send */
@@ -7423,13 +7424,12 @@ tmErrorCode_t tmdlHdmiCecSendMessage(
    UInt16       lenData
 )
 {
-
   tmErrorCode_t  errCode = TM_OK;
 
 #ifdef TMFL_TDA9989
 
   unsigned char  I2c_Buffer[19] ;        /* I2C data buffer */
-  unsigned char  Loci;                   /* Local increment variable*/
+  unsigned char  loci;                   /* Local increment variable*/
   unsigned char  MessLength;             /* Local Message length*/
   
   tmdlHdmiCecDriverConfigTable_t *pDis; /* Pointer to Device Instance Structure */
@@ -7440,40 +7440,42 @@ tmErrorCode_t tmdlHdmiCecSendMessage(
   /* check if unit corresponding to instance is opened */
   RETIF(UnitTable[instance].opened == False, TMDL_ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
   
-  /* check if CEC message is not too long */
-  RETIF((lenData > 16), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+  /* check if CEC message length is valid */
+  RETIF((lenData == 0 || lenData > (sizeof(I2c_Buffer) - 2)), TMDL_ERR_DLHDMICEC_INCONSISTENT_PARAMS)
 
   pDis = &gtmdlHdmiCecDriverConfigTable[instance];
 
   /* Calculate Internal Message length*/
-  MessLength = (lenData-1)+3; /* real data is less ReceiverLogical address */
+  MessLength = (unsigned char)(lenData + 2);
   
   I2c_Buffer[0] = MessLength;  /* Param number */
+  I2c_Buffer[1] = 0x00;        /* Request CEC data */
+  I2c_Buffer[3] = 0x00;        /* Initialize (for the case it's a poll) */
 
-  I2c_Buffer[1] = 0x00;     /* Request CEC data */
-
-  /*Build Initiator and Reciever Logical Address Byte*/
-  I2c_Buffer[2] = (unsigned char)(UnitTable[instance].DeviceLogicalAddress) & 0x0F; /*Initiator logical Address*/
-  I2c_Buffer[2] = I2c_Buffer[2] << 4;
-  I2c_Buffer[2] |= pData[0] & 0x0F;
+  /* Copy data */
+  for (loci = 0; loci < lenData; loci++) {
+      I2c_Buffer[loci + 2] = pData[loci]; 
+  }
 
-  for(Loci = 0; Loci <= lenData ; Loci++)
-  {
-     I2c_Buffer[(Loci+3)] = pData[(Loci+1)];     /* Fill Table with Data from middleware, Data begin at position 1*/
+  /* replace initiator logical address *ONLY* in case of 'Broadcast' */
+  /* for libCEC support, we need to be able to use any valid initiator address */
+  if ((I2c_Buffer[2] & 0xf0) == (CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST << 4)) {
+      I2c_Buffer[2] = (I2c_Buffer[2] & 0x0f) |
+          ((unsigned char)(UnitTable[instance].DeviceLogicalAddress) << 4);
   }
-  
-  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer,MessLength); /* CEC Data register */
+
+  /* Write CEC Data registers */
+  errCode = setCecHwRegisters(pDis, E_REG_CDR0, I2c_Buffer, MessLength); 
   RETIF(errCode != TM_OK, errCode)
   
-  /* Save Datas of the CEC message send */
-  gtmdlHdmiCecDriverSaveMessage.AddressByte = pData[2];
-  gtmdlHdmiCecDriverSaveMessage.MessageTypePolling = 0;
-  gtmdlHdmiCecDriverSaveMessage.Opcode = pData[3];
+  /* Save Datas of the CEC message sent */
+  gtmdlHdmiCecDriverSaveMessage.AddressByte = I2c_Buffer[2];
+  gtmdlHdmiCecDriverSaveMessage.MessageTypePolling = (MessLength == 3);
+  gtmdlHdmiCecDriverSaveMessage.Opcode = I2c_Buffer[3];
 
 #endif  /*  TMFL_TDA9989 */
 
   return errCode;
-
 }
 
 
diff --git a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiTx/cfg/TDA9989/tmdlHdmiTx_Linux_cfg.c b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiTx/cfg/TDA9989/tmdlHdmiTx_Linux_cfg.c
index 07f3283..e06b366 100755
--- a/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiTx/cfg/TDA9989/tmdlHdmiTx_Linux_cfg.c
+++ b/drivers/video/dovefb/nxp_hdmi/comps/tmdlHdmiTx/cfg/TDA9989/tmdlHdmiTx_Linux_cfg.c
@@ -37,39 +37,35 @@
 /*============================================================================*/
 /*                       INCLUDE FILES                                        */
 /*============================================================================*/
+/* The following includes are used by I2C access function. If                 */
+/* you need to rewrite these functions for your own SW infrastructure, then   */
+/* it can be removed                                                          */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+/* low level I2C functions */
+#include "tda998x_i2c.h"
+
+/* for CEC error constants */
+#include "tmdlHdmiCEC_Types.h"
 
 /*============================================================================*/
 /*                                MACRO                                       */
 /*============================================================================*/
 /* macro for quick error handling */
 #define RETIF(cond, rslt) if ((cond)){return (rslt);}
-#define I2C_M_WR 0
-
-/*============================================================================*/
-/*                   STATIC FUNCTION DECLARATIONS                             */
-/*============================================================================*/
-tmErrorCode_t TxI2cReadFunction(tmbslHdmiTxSysArgs_t *pSysArgs);
-tmErrorCode_t TxI2cWriteFunction(tmbslHdmiTxSysArgs_t *pSysArgs);
 
 /******************************************************************************
  ******************************************************************************
  *                 THIS PART CAN BE MODIFIED BY CUSTOMER                      *
  ******************************************************************************
  *****************************************************************************/
-static struct i2c_client *GetThisI2cClient(void);
-unsigned char  my_i2c_data[255];
-
-/* The following includes are used by I2C access function. If    */
-/* you need to rewrite these functions for your own SW infrastructure, then   */
-/* it can be removed                                                          */
-#	include <linux/kernel.h>
-#	include <linux/slab.h>
-#	include <linux/semaphore.h>
-#	include <linux/errno.h>
-#	include <linux/string.h>
-#	include <linux/types.h>
-#	include <linux/i2c.h>
-#	include <linux/delay.h>
 
 /* I2C adress of the unit                                                     */
 /* Put there the I2C slave adress of the Tx transmitter IC                    */
@@ -199,252 +195,43 @@ const tmdlHdmiTxCfgVideoSignalCCIR656 videoPortMapping_CCIR656[MAX_UNITS][6] = {
     }
 }; 
 
-/*
- *
- * Linux wrapping starts here...............................
- *
- */ 
-/* 
- *  Write a bloc to a register in Tx device.
- */
-static int blockwrite_reg(struct i2c_client *client, u8 reg, u16 alength, u8 *val)
-{
-   int err = 0;   
-   int i;
-   struct i2c_msg msg[1];
-    
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-   
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = alength+1;
-   msg->buf = my_i2c_data;
-   
-   msg->buf[0] = reg;   
-   for (i=1; i<=alength; i++) msg->buf[i] = (*val++);
-   
-   err = i2c_transfer(client->adapter, msg, 1);
-   udelay(50);
-
-
-/*    printk(KERN_INFO "DBG blockwrite_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
-
-/*    dev_dbg(&client->dev, "<%s> i2c Block write at 0x%x, " */
-/*            "*val=%d flags=%d byte[%d] err=%d\n", */
-/*            __func__, data[0], data[1], msg->flags, i, err); */
-
-   return (err < 0?err:0);
-}
-
-/* 
- *  Read a bloc to a register in Tx device.
- */
-static int blockread_reg(struct i2c_client *client, u8 reg, u16 alength, u8 *val)
-{
-   int err = 0;
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 1;
-   msg->buf = data;
-   data[0] = reg; /* High byte goes out first */
-   err = i2c_transfer(client->adapter, msg, 1);
-/*    printk(KERN_INFO "DBG blockread_reg #1 addr:%x len:%d buf:%02x%02x%02x%02x %s\n",msg->addr,msg->len,\ */
-/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3],(err<0?"ERROR":"")); */
-   if (err<0) goto BLOCK_READ_OUPS;
-
-   msg->flags = I2C_M_RD;
-   msg->len = alength; 
-   msg->buf = val;
-   err = i2c_transfer(client->adapter, msg, 1);
-/*    printk(KERN_INFO "DBG blockread_reg #2 addr:%x len:%d buf:%02x%02x%02x%02x %s\n",msg->addr,msg->len,\ */
-/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3],(err<0?"ERROR":"")); */
-
-   if (err<0) goto BLOCK_READ_OUPS;
-
-   return 0;
-   
- BLOCK_READ_OUPS:
-   dev_err(&client->dev, "<%s> ERROR:  i2c Read at 0x%x, "
-           "*val=%d flags=%d bytes err=%d\n",
-           __func__, reg, *val, msg->flags, err);
-		   
-   return err;
-}
-
-/* 
- *  Write a byte to a register in Tx device.
- */
-int write_reg(struct i2c_client *client, u8 reg, u8 val)
-{
-   int err = 0;
-   struct i2c_msg msg[1];
-   u8 data[2];
-   int retries = 0;   
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
- retry:
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 2;
-   msg->buf = data;
-
-   data[0] = reg;
-   data[1] = val;
-
-   err = i2c_transfer(client->adapter, msg, 1);
-   dev_dbg(&client->dev, "<%s> i2c write at=%x "
-	   "val=%x flags=%d err=%d\n",
-	   __func__, data[0], data[1], msg->flags, err);
-   udelay(50);
-
-/*    printk(KERN_INFO "DBG write_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
-
-   if (err >= 0)
-      return 0;
-
-   dev_err(&client->dev, "<%s> ERROR: i2c write at=%x "
-	   "val=%x flags=%d err=%d\n",
-	   __func__, data[0], data[1], msg->flags, err);
-   if (retries <= 5) {
-      dev_info(&client->dev, "Retrying I2C... %d\n", retries);
-      retries++;
-      set_current_state(TASK_UNINTERRUPTIBLE);
-      schedule_timeout(msecs_to_jiffies(20));
-      goto retry;
-   }
-   
-   return err;
-}
-
-/*
- *  Read a byte from a register in Tx device.
- */
-int read_reg(struct i2c_client *client, u16 data_length, u8 reg, u8 *val)
-{
-   int err = 0;  
-   struct i2c_msg msg[1];
-   u8 data[2];
-
-   if (!client->adapter) {
-      dev_err(&client->dev, "<%s> ERROR: No HDMI Device\n", __func__);
-      return -ENODEV;
-   }
-
-   msg->addr = client->addr;
-   msg->flags = I2C_M_WR;
-   msg->len = 1;
-   msg->buf = data;
-
-   data[0] = reg;
-   err = i2c_transfer(client->adapter, msg, 1);
-   dev_dbg(&client->dev, "<%s> i2c Read1 reg=%x val=%d "
-	   "flags=%d err=%d\n",
-	   __func__, reg, data[1], msg->flags, err);
-
-   if (err >= 0) {
-      mdelay(3);
-      msg->flags = I2C_M_RD;
-      msg->len = data_length;
-      err = i2c_transfer(client->adapter, msg, 1);
-   }
-
-   if (err >= 0) {
-      *val = 0;
-      if (data_length == 1)
-	 *val = data[0];
-      else if (data_length == 2)
-	 *val = data[1] + (data[0] << 8);
-      dev_dbg(&client->dev, "<%s> i2c Read2 at 0x%x, *val=%d "
-	      "flags=%d err=%d\n",
-	      __func__, reg, *val, msg->flags, err);
-      return 0;
-   }
-
-   dev_err(&client->dev, "<%s> ERROR: i2c Read at 0x%x, "
-	   "*val=%d flags=%d err=%d\n",
-	   __func__, reg, *val, msg->flags, err);
-
-   return err;   
-}
-/*
- *
- * Linux wrapping end...............................
- *
- */
 
 /* The following function must be rewritten by the customer to fit its own    */
 /* SW infrastructure. This function allows reading through I2C bus.           */
 /* tmbslHdmiTxSysArgs_t definition is located into tmbslHdmiTx_type.h file.   */
-tmErrorCode_t TxI2cReadFunction(tmbslHdmiTxSysArgs_t *pSysArgs)
+static tmErrorCode_t TxI2cReadFunction(tmbslHdmiTxSysArgs_t *pSysArgs)
 {
-   tmErrorCode_t errCode = TM_OK;
-   struct i2c_client *client=GetThisI2cClient();
-   u32 client_main_addr=client->addr;
+   struct i2c_client *client = (pSysArgs->slaveAddr == UNIT_I2C_ADDRESS_0) ? 
+				txGetThisI2cClient() : cecGetThisI2cClient();
 
-   /* DevLib needs address control, so let it be */ 
-   client->addr=pSysArgs->slaveAddr;
+   RETIF(!client || !client->adapter || 
+         client->addr != pSysArgs->slaveAddr, TM_ERR_NULL_DATAINFUNC)
 
-   if (pSysArgs->lenData == 1) {
-      /* single byte */
-      errCode = read_reg(GetThisI2cClient(),1,pSysArgs->firstRegister,pSysArgs->pData);
-   }
-   else {
-      /* block */
-      errCode = blockread_reg(GetThisI2cClient(), \
-			      pSysArgs->firstRegister, \
-			      pSysArgs->lenData, \
-			      pSysArgs->pData);
-   }
-   
-   /* restore default client address */
-   client->addr=client_main_addr;
+   RETIF(tda998x_i2c_read_regs(
+	    client, pSysArgs->lenData, 
+	    pSysArgs->firstRegister, pSysArgs->pData) == 0, TM_OK)
 
-    return errCode;
+   return (pSysArgs->slaveAddr == UNIT_I2C_ADDRESS_0) ?
+      TMDL_ERR_DLHDMITX_I2C_WRITE : TMDL_ERR_DLHDMICEC_I2C_WRITE;
 }
 
 /* The following function must be rewritten by the customer to fit its own    */
 /* SW infrastructure. This function allows writing through I2C bus.           */
 /* tmbslHdmiTxSysArgs_t definition is located into tmbslHdmiTx_type.h file.   */
-tmErrorCode_t TxI2cWriteFunction(tmbslHdmiTxSysArgs_t *pSysArgs)
+static tmErrorCode_t TxI2cWriteFunction(tmbslHdmiTxSysArgs_t *pSysArgs)
 {
-   tmErrorCode_t  errCode = TM_OK;
-   struct i2c_client *client=GetThisI2cClient();
-   u32 client_main_addr=client->addr;
+   struct i2c_client *client = (pSysArgs->slaveAddr == UNIT_I2C_ADDRESS_0) ? 
+				txGetThisI2cClient() : cecGetThisI2cClient();
 
-   /* DevLib needs address control, so let it be */ 
-   client->addr=pSysArgs->slaveAddr;
-   
-   if (pSysArgs->lenData == 1) {
-      /* single byte */
-      errCode = write_reg(GetThisI2cClient(),pSysArgs->firstRegister,*pSysArgs->pData);
-   }
-   else {
-      /* block */
-      errCode = blockwrite_reg(GetThisI2cClient(),  \
-                               pSysArgs->firstRegister, \
-                               pSysArgs->lenData,       \
-                               pSysArgs->pData);
-   }
-   
-   /* restore default client address */
-   client->addr=client_main_addr;
+   RETIF(!client || !client->adapter ||
+         client->addr != pSysArgs->slaveAddr, TM_ERR_NULL_DATAOUTFUNC)
+
+   RETIF(tda998x_i2c_write_regs(
+            client, pSysArgs->lenData, 
+            pSysArgs->firstRegister, pSysArgs->pData) == 0, TM_OK)
 
-    return errCode;
+   return (pSysArgs->slaveAddr == UNIT_I2C_ADDRESS_0) ?
+      TMDL_ERR_DLHDMITX_I2C_READ : TMDL_ERR_DLHDMICEC_I2C_READ;
 }
 
 
@@ -497,7 +284,6 @@ tmErrorCode_t tmdlHdmiTxIWSemaphoreCreate
        return TMDL_ERR_DLHDMITX_NO_RESOURCES;
     }
     
-//    init_MUTEX(mutex);
     sema_init(mutex,1);
     *pHandle = (tmdlHdmiTxIWSemHandle_t)mutex;
 
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x.c b/drivers/video/dovefb/nxp_hdmi/tda998x.c
index 2e9fd06..eca28c9 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x.c
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x.c
@@ -41,7 +41,9 @@
 /* local */
 #include "tda998x_version.h"
 #include "tda998x.h"
+#include "tda998x_i2c.h"
 #include "tda998x_ioctl.h"
+#include "tda998x_exports.h"
 
 #ifdef I2C_DBG
 #include "tmbslHdmiTx_types.h"
@@ -68,10 +70,12 @@
  *  Global
  */
 
-tda_instance our_instance;
+static tda_instance our_instance;
 static struct cdev our_cdev, *this_cdev=&our_cdev;
 static int initialized = 0;
 static int saved_mode = -1;
+static cec_callback_t cec_callback = NULL;
+
 #ifdef ANDROID_DSS
 static struct omap_video_timings video_640x480at60Hz_panel_timings = {
    .x_res          = 640,
@@ -202,16 +206,15 @@ MODULE_PARM_DESC(major, "The major number of the device mapper");
 /* 
  *  Get main and unique I2C Client driver handle
  */
-struct i2c_client *GetThisI2cClient(void)
+struct i2c_client *txGetThisI2cClient(void)
 {
-   tda_instance *this=&our_instance;
-   return this->driver.i2c_client;
+   return our_instance.driver.i2c_client;
 }
 
 /*
  * error handling
  */
-char *hdmi_tx_err_string(int err)
+static char *hdmi_tx_err_string(int err)
 {
    switch (err & 0x0FFF)
       {
@@ -705,8 +708,8 @@ static int tda_spy(int verbose)
 /*
  * On HDCP
  */
-void hdcp_on(tda_instance *this) {
-
+void hdcp_on(tda_instance *this)
+{
    int err=0;
 
    if (this->tda.hdcp_status != HDCP_IS_NOT_INSTALLED) { /* check HDCP is installed ... */
@@ -728,8 +731,8 @@ void hdcp_on(tda_instance *this) {
 /*
  * Off HDCP
  */
-void hdcp_off(tda_instance *this) {
-
+void hdcp_off(tda_instance *this)
+{
    int err=0;
 
    if (this->tda.hdcp_status != HDCP_IS_NOT_INSTALLED) { /* check HDCP is installed ... */
@@ -745,15 +748,15 @@ void hdcp_off(tda_instance *this) {
 /*
  * Run video
  */
-void show_video(tda_instance *this) {
-
+void show_video(tda_instance *this)
+{
    int err=0;
 
    if (this->tda.rx_device_active) { /* check RxSens */
       if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) { /* should be useless, but legacy... */
          if (this->tda.power == tmPowerOn) { /* check CEC or DSS didn't switch it off */
-            if (this->tda.src_address != 0xFFFF) { /* check EDID has been received */
-				hdcp_off(this);
+            if (this->tda.src_address != NO_PHY_ADDR) { /* check EDID has been received */
+               hdcp_off(this);
                TRY(tmdlHdmiTxSetInputOutput(this->tda.instance,         \
                                             this->tda.setio.video_in,   \
                                             this->tda.setio.video_out,  \
@@ -779,16 +782,21 @@ void show_video(tda_instance *this) {
 static void interrupt_polling(struct work_struct *dummy)
 {
    tda_instance *this=&our_instance;
-   int err=0;
+   tmdlHdmiTxEvent_t prevEvent;
+   int err=0, loopCnt=0;
+
+   do {
+      prevEvent = this->tda.event;
 
-   /* Tx part */
-   TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
+      /* Tx part */
+      TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
 
-   /* CEC part */
-   if (this->driver.cec_callback) this->driver.cec_callback(dummy);
+      /* CEC part */
+      if (this->driver.cec_callback)
+         this->driver.cec_callback(dummy);
 
-   /* FIX : IT anti debounce */
-   TRY(tmdlHdmiTxHandleInterrupt(this->tda.instance));
+   } while (this->tda.event != prevEvent && ++loopCnt < 4 );
+   
 
  TRY_DONE:
 
@@ -830,7 +838,7 @@ static void hdcp_check(struct work_struct *dummy)
       if (this->tda.rx_device_active) { /* check RxSens */
          if (this->tda.hot_plug_detect == TMDL_HDMITX_HOTPLUG_ACTIVE) { /* should be useless, but legacy... */
             if (this->tda.power == tmPowerOn) { /* check CEC didn't switch it off */
-               if (this->tda.src_address != 0xFFFF) { /* check EDID has been received */
+               if (this->tda.src_address != NO_PHY_ADDR) { /* check EDID has been received */
                   hdcp_off(this);
                   hdcp_on(this);				  
                }
@@ -852,7 +860,10 @@ void register_cec_interrupt(cec_callback_t fct)
 {
    tda_instance *this=&our_instance;
 
-   this->driver.cec_callback = fct;
+   if (initialized) 
+	this->driver.cec_callback = fct;
+   else
+	cec_callback = fct;
 }
 EXPORT_SYMBOL(register_cec_interrupt);
 
@@ -860,6 +871,7 @@ void unregister_cec_interrupt(void)
 {
    tda_instance *this=&our_instance;
 
+   cec_callback = NULL;
    this->driver.cec_callback = NULL;
 }
 EXPORT_SYMBOL(unregister_cec_interrupt);
@@ -906,7 +918,7 @@ static void eventCallbackTx(tmdlHdmiTxEvent_t event)
 
    this->tda.event=event;
    if (TMDL_HDMITX_HDCP_INACTIVE != event) {
-      printk(KERN_INFO "hdmi %s\n",tda_spy_event(event));
+      printk(KERN_INFO "hdmitx %s\n",tda_spy_event(event));
    }
 
    switch (event) {
@@ -914,10 +926,13 @@ static void eventCallbackTx(tmdlHdmiTxEvent_t event)
       TRY(tmdlHdmiTxGetEdidSourceAddress(this->tda.instance,        \
                                          &new_addr));
       LOG(KERN_INFO,"phy.@:%x\n",new_addr);
-      /*       if (this->tda.src_address == new_addr) { */
-      /*          break; */
-      /*       } */
+
+      if (new_addr == this->tda.src_address)
+         break;
+
       this->tda.src_address = new_addr;
+      this->tda.src_address_prev = NO_PHY_ADDR;
+
 #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
       tda_spy(this->param.verbose>=1);
 #endif
@@ -950,11 +965,14 @@ static void eventCallbackTx(tmdlHdmiTxEvent_t event)
       break;
    case TMDL_HDMITX_HPD_ACTIVE: /* HDMI is so funny u can get RxSens without being plugged !!! */
       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_ACTIVE;
-      show_video(this);
+      this->tda.src_address = this->tda.src_address_prev;
+      this->tda.src_address_prev = NO_PHY_ADDR;
       break;
    case TMDL_HDMITX_HPD_INACTIVE: /* unplug */
       this->tda.hot_plug_detect = TMDL_HDMITX_HOTPLUG_INACTIVE;
-      this->tda.src_address = 0xFFFF;
+      if (this->tda.rx_device_active)
+         this->tda.src_address_prev = this->tda.src_address;
+      this->tda.src_address = NO_PHY_ADDR;
       break;
 #if defined (TMFL_TDA19989) || defined (TMFL_TDA9984) 
    case TMDL_HDMITX_HDCP_INACTIVE: /* HDCP drops off */
@@ -979,11 +997,9 @@ static void eventCallbackTx(tmdlHdmiTxEvent_t event)
       break;
    }
 
+ TRY_DONE:
    this->driver.poll_done=true;
    wake_up_interruptible(&this->driver.wait);
-   
- TRY_DONE:
-   (void)0;
 }
 
 /*
@@ -1086,6 +1102,7 @@ static int hdmi_tx_init(tda_instance *this)
    this->tda.setio.sink = TMDL_HDMITX_SINK_EDID; /* Don't skip edid reading */
    /*    this->tda.src_address = 0x1000; /\* debug *\/ */
    this->tda.src_address = NO_PHY_ADDR; /* it's unref */
+   this->tda.src_address_prev = NO_PHY_ADDR;
    initialized = 1;
  TRY_DONE:
    return err;
@@ -1405,9 +1422,10 @@ static long this_cdev_ioctl(struct file *pFile, unsigned int cmd, unsigned long
    }
 
    if (_IOC_DIR(cmd) & _IOC_READ) 
-      err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+      err = !arg || !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-      err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+      err = !arg || !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+   
    if (err) {
       printk(KERN_ERR "hdmitx:%s:argument access denied (check address vs value)\n",__func__);
       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
@@ -1899,7 +1917,7 @@ static int this_i2c_probe(struct i2c_client *client, const struct i2c_device_id
 
 /* CuBox specific stuff */
 /* Addions to get EDID stuff out of the transmitter driver */
-char *tda19988_get_edid(int *num_of_blocks)
+const char *tda19988_get_edid(int *num_of_blocks)
 {
 	tda_instance* this = &our_instance;
 	if (!initialized) return NULL;
@@ -1915,14 +1933,13 @@ char *tda19988_get_edid(int *num_of_blocks)
 	return  this->tda.raw_edid;
 }
 
-struct res_to_vmode {
+static struct {
 	int x;
 	int y;
 	int interlaced;
 	int hz;
 	int vmode;
-};
-struct res_to_vmode resolution_to_video_format[] = {
+} resolution_to_video_format[] = {
 {640,	480,	0,	60,	TMDL_HDMITX_VFMT_01_640x480p_60Hz},
 {720,	480,	0,	60,	TMDL_HDMITX_VFMT_02_720x480p_60Hz},
 {720,	480,	0,	60,	TMDL_HDMITX_VFMT_03_720x480p_60Hz},
@@ -1994,45 +2011,40 @@ struct res_to_vmode resolution_to_video_format[] = {
 {1024,	768,	1,	87,	TMDL_HDMITX_VFMT_PC_1024x768i_87Hz},
 };
 
-int configure_tx_inout(int x, int y, int interlaced, int hz)
+int tda19988_configure_tx_inout(int x, int y, int interlaced, int hz)
 {
-	int i, mode = -1, refresh = 0;
 	tda_instance* this = &our_instance;
+	int i, d, mode = -1, rateDiff = 1000;
 
-	for (i = 0 ; i < sizeof(resolution_to_video_format); i++) {
+	for (i = 0; rateDiff && i < sizeof(resolution_to_video_format); i++) {
 		if (	(x == resolution_to_video_format[i].x) &&
 			(y == resolution_to_video_format[i].y) &&
-			(interlaced == resolution_to_video_format[i].interlaced) &&
-			(hz == resolution_to_video_format[i].hz)) {
-			mode = resolution_to_video_format[i].vmode;
-			printk (KERN_INFO "HDMI TX - FOUND exact resolution %d\n",mode);
-			break;
+			(interlaced == resolution_to_video_format[i].interlaced) ) {
+			d = abs(resolution_to_video_format[i].hz - hz);
+			if (d < rateDiff) {
+				rateDiff = d;
+				mode = resolution_to_video_format[i].vmode;
+			}
 		}
 	}
 
 	if (mode < 0) {
-		/* Try finding resolution but with closest refresh rate */
-		for (i = 0 ; i < sizeof(resolution_to_video_format); i++) {
-			if (	(x == resolution_to_video_format[i].x) &&
-				(y == resolution_to_video_format[i].y) &&
-				(interlaced == resolution_to_video_format[i].interlaced)) {
-				if ((resolution_to_video_format[i].hz - refresh) > 
-				    (resolution_to_video_format[i].hz - hz)) {
-					mode = resolution_to_video_format[i].vmode;
-					printk (KERN_INFO "HDMI TX - Found good candidate %d (requested %dhz, found %dhz)\n",mode,hz,resolution_to_video_format[i].hz);
-					refresh = resolution_to_video_format[i].hz;
-				}
-			}
-		}
+		printk (KERN_ERR "HDMI TX - no matching resolution %dx%d%c %dHz\n",x,y,interlaced ? 'i':'p',hz);
+		return 0;
 	}
 
-	if (mode < 0)
-		return 0;
+	if (rateDiff == 0)
+		printk (KERN_INFO "HDMI TX - FOUND exact resolution %d\n",mode);
+	else
+		printk (KERN_INFO "HDMI TX - Found good candidate %d (requested %dhz, found %dhz)\n",
+			mode,hz,resolution_to_video_format[mode].hz);
 
 	if (initialized) {
-		this->tda.setio.video_in.format = mode;
-		this->tda.setio.video_out.format = mode;
-		show_video(this);
+	    if (this->tda.setio.video_in.format != mode) {
+            this->tda.setio.video_in.format = mode;
+            this->tda.setio.video_out.format = mode;
+    		show_video(this);
+    	}
 	} else {
 		saved_mode = mode;
 	}
@@ -2390,7 +2402,6 @@ static int __init tx_init(void)
    /* 
       general device context
    */
-//   init_MUTEX(&this->driver.sem);
    sema_init(&this->driver.sem,1);
    
    /*
@@ -2414,9 +2425,14 @@ static int __init tx_init(void)
 
    /* set video mode */
    if (saved_mode >= 0) {
-	this->tda.setio.video_in.format = saved_mode;
-	this->tda.setio.video_out.format = saved_mode;
-	show_video(this);
+      this->tda.setio.video_in.format = saved_mode;
+	  this->tda.setio.video_out.format = saved_mode;
+	  show_video(this);
+   }
+
+   /* enable cec callback */
+   if (cec_callback) {
+	  this->driver.cec_callback = cec_callback;
    }
 
    return 0;
@@ -2475,3 +2491,4 @@ module_exit(tx_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Andre Lepine <andre.lepine@nxp.com>");
 MODULE_DESCRIPTION(HDMITX_NAME " driver");
+
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x.h b/drivers/video/dovefb/nxp_hdmi/tda998x.h
index 08d742b..839c64b 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x.h
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x.h
@@ -128,6 +128,7 @@ typedef struct {
       tda_edid_latency edid_latency;
 #endif
       unsigned short src_address;
+      unsigned short src_address_prev;
       unsigned char raw_edid[EDID_BLOCK_COUNT*EDID_BLOCK_SIZE];
       tda_capabilities capabilities;
       tda_event event;
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_cec.c b/drivers/video/dovefb/nxp_hdmi/tda998x_cec.c
index dfe1f5f..ff79f31 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x_cec.c
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_cec.c
@@ -30,7 +30,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
-#include <asm/uaccess.h>
+#include <linux/poll.h>
 #include <linux/gpio.h>
 
 /* HDMI DevLib */
@@ -41,7 +41,9 @@
 /* local */
 #include "tda998x_version.h"
 #include "tda998x_cec.h"
+#include "tda998x_i2c.h"
 #include "tda998x_ioctl.h"
+#include "tda998x_exports.h"
 
 /*
  *
@@ -60,8 +62,8 @@ static const struct i2c_device_id this_i2c_id[] = {
    { CEC_NAME, 0 },
    { },
 };
+static struct cdev our_cdev;
 static cec_instance our_instance;
-static struct cdev our_cdev, *this_cdev=&our_cdev;
 
 #ifdef TWL4030_HACK
 /* AL : hack to bypass keypad */
@@ -69,24 +71,12 @@ struct input_dev *gkp_input;
 extern struct input_dev *get_twm4030_input(void);
 #endif
 
-/*
- * Dependancies to HdmiTx module
- */
-
-extern void register_cec_interrupt(cec_callback_t fct); 
-extern void unregister_cec_interrupt(void); 
-extern short edid_phy_addr(void); 
-extern int hdmi_enable(void);
-extern int hdmi_disable(int event_tracking);
-extern cec_power get_hdmi_status(void);
-extern cec_power get_hpd_status(void);
-extern int edid_received(void);
 
 /*
  *  Module params
  */
 
-static int param_verbose=1,param_major=0,param_minor=0,param_device=4,param_addr=0xFFFF;
+static int param_verbose=0,param_major=0,param_minor=0,param_device=4,param_addr=0xFFFF;
 module_param_named(verbose,param_verbose,int,S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(verbose, "Make the driver verbose");
 module_param_named(major, param_major, int, S_IRUGO);
@@ -110,12 +100,11 @@ MODULE_PARM_DESC(addr, "Physical address (until EDID received)");
 
 
 /* 
- *  Get main and unique I2C Client driver handle
+ *  Get main and unique I2C Client driver handle (called from NXP SDK)
  */
 struct i2c_client *cecGetThisI2cClient(void)
 {
-   cec_instance *this=&our_instance;
-   return this->driver.i2c_client;
+   return our_instance.driver.i2c_client;
 }
 
 /*
@@ -152,6 +141,9 @@ static char *hdmi_cec_err_string(int err)
       }
 }
 
+#ifndef CEC_I2C_DEBUG
+static
+#endif
 char *cec_opcode(int op)
 {
    switch (op)
@@ -320,6 +312,12 @@ static char *cec_ioctl(int io)
       case CEC_IOCTL_DISABLE_CALIBRATION_CMD: {return "CEC_IOCTL_DISABLE_CALIBRATION_CMD";break;}
       case CEC_IOCTL_SEND_MSG_CMD: {return "CEC_IOCTL_SEND_MSG_CMD";break;}
       case CEC_IOCTL_SET_REGISTER_CMD: {return "CEC_IOCTL_SET_REGISTER_CMD";break;}
+
+      case CEC_IOCTL_GET_RAW_MODE_CMD: {return "CEC_IOCTL_GET_RAW_MODE_CMD";break;}
+      case CEC_IOCTL_SET_RAW_MODE_CMD: {return "CEC_IOCTL_SET_RAW_MODE_CMD";break;}
+      case CEC_IOCTL_GET_RAW_INFO_CMD: {return "CEC_IOCTL_GET_RAW_INFO_CMD";break;}
+      case CEC_IOCTL_SET_RX_ADDR_MASK_CMD: {return "CEC_IOCTL_SET_RX_ADDR_MASK_CMD";break;}
+
       default : {return "unknown";break;}
       }
 }
@@ -447,12 +445,20 @@ static void cec_on(cec_instance *this)
 
    disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
 
+   /* turn GPIO into calib pulse generator */
+   err = gpio_direction_output(TDA_IRQ_CALIB,0); /* output (1 means try-state or high) */
+   if (err < 0) {
+	LOG(KERN_ERR,"Cannot access GPIO %d, err:%d\n",TDA_IRQ_CALIB,err);
+
+	enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
+	return;
+   }
+
+   __gpio_set_value(TDA_IRQ_CALIB,1);
+
    this->cec.power = tmPowerOn;
    TRY(tmdlHdmiCecSetPowerState(this->cec.inst,this->cec.power));
 
-   /* turn GPIO into calib pulse generator */
-   gpio_direction_output(TDA_IRQ_CALIB,0); /* output (1 means try-state or high) */
-   __gpio_set_value(TDA_IRQ_CALIB,1);
    this->cec.clock = TMDL_HDMICEC_CLOCK_FRO;
    TRY(tmdlHdmiCecEnableCalibration(this->cec.inst,this->cec.clock));
    msleep(10);
@@ -476,14 +482,12 @@ static void cec_on(cec_instance *this)
    this->cec.setup.cecClockSource = this->cec.clock;
    TRY(tmdlHdmiCecInstanceSetup(this->cec.inst,&this->cec.setup));
 
-   /* turn GPIO into IRQ */
-   gpio_direction_input(TDA_IRQ_CALIB);
-   enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
-
    LOG(KERN_INFO,"standby --> on\n");
 
  TRY_DONE:
-   (void)0;
+   /* turn GPIO into IRQ */
+   gpio_direction_input(TDA_IRQ_CALIB);
+   enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
 }
 
 /*
@@ -503,52 +507,120 @@ static void cec_standby(cec_instance *this)
 }
 
 /*
+ * enable listening on a single logical addresses
+ */
+static void cec_listen_single(cec_instance *this, unsigned char rx_addr)
+{
+   int err;
+
+   LOG(KERN_INFO,"logAddr set to 0x%x\n", rx_addr);
+
+   TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst, rx_addr));
+
+   this->cec.rx_addr = rx_addr;
+   this->cec.rx_addr_mask = (1 << rx_addr) & 0x7fff;
+
+ TRY_DONE:
+   (void)0;
+}
+
+/*
+ * enable listening on multiple logical addresses
+ */
+static void cec_listen_multi(cec_instance *this, 
+                             unsigned short onMask, unsigned short offMask)
+{
+   int err;
+   unsigned short newMask, changeMask;
+
+   newMask = (this->cec.rx_addr_mask | onMask) & ~(offMask | 0x8000);
+   changeMask = newMask ^ this->cec.rx_addr_mask; 
+
+   if (changeMask & 0xff00) {
+       TRY(tmdlHdmiCecSetRegister(this->cec.inst, E_REG_ACKH, newMask >> 8));
+       this->cec.rx_addr_mask ^= changeMask & 0xff00;
+   } 
+
+   if (changeMask & 0x80ff) {
+       TRY(tmdlHdmiCecSetRegister(this->cec.inst, E_REG_ACKL, newMask & 0xff));
+       this->cec.rx_addr_mask ^= changeMask & 0x00ff;
+   }
+
+   LOG(KERN_INFO,"logAddrMask is now 0x%04x\n", this->cec.rx_addr_mask);
+
+ TRY_DONE:
+   (void)0;
+}
+
+/*
  *  CEC interrupt polling
  */
 static void cec_interrupt(struct work_struct *dummy)
 {
    cec_instance *this=&our_instance;
-   unsigned short new_phy_addr=edid_phy_addr();
+   cec_power display_active = get_hpd_status();
+   unsigned short new_phy_addr = edid_phy_addr();
    int err=0;
    
-   LOG(KERN_INFO,"%s called\n",__func__);
+   LOG(KERN_INFO,"called\n");
+   
+   /* sync with this_cdev_write */
+   down(&this->driver.sem);
+
 
    /* switch on/off CEC */
-   if (!get_hpd_status() &&                     \
-       (this->cec.power == tmPowerOn)) {
+   if (!display_active && (this->cec.power == tmPowerOn)) {
       this->cec.source_status = CEC_POWER_STATUS_STANDBY;
 /*       TRY(tmdlHdmiCecInactiveSource(this->cec.inst,             \ */
 /*                                        this->cec.initiator,     \ */
 /*                                        this->cec.phy_addr)); */
       cec_standby(this);
    }
-   else if (get_hpd_status() &&                         \
-            (this->cec.power == tmPowerStandby)) {
+   else if (display_active && (this->cec.power == tmPowerStandby)) {
       /* send active msg when hdmi has been abled */
       cec_on(this);
+
+#ifndef GUI_OVER_HDMI
+      this->cec.source_status = CEC_POWER_STATUS_ON;
+#endif
    }
    /* new phy addr means new EDID, mean HPD ! */
-   else if ((this->cec.phy_addr != new_phy_addr) &&        \
-       (this->cec.source_status == CEC_POWER_STATUS_ON)) {
-      LOG(KERN_INFO,"New physical address %02x\n",new_phy_addr);
+   else if ((this->cec.phy_addr != new_phy_addr) &&
+           (this->cec.source_status == CEC_POWER_STATUS_ON)) {
+      LOG(KERN_INFO,"New physical address %04x\n",new_phy_addr);
       this->cec.phy_addr = new_phy_addr;
-      if (this->cec.phy_addr != 0xFFFF) {
-         this->cec.rx_addr = get_next_logical_addr(this->cec.device_type,CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
-         TRY(tmdlHdmiCecPollingMessage(this->cec.inst,this->cec.rx_addr));
-      }
-      else {
-         this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+
+      if( !this->param.passive) {
+         if (!this->driver.raw_mode) {
+            if (this->cec.phy_addr != 0xFFFF) {
+               this->cec.rx_addr = get_next_logical_addr(
+                  this->cec.device_type, CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
+               TRY(tmdlHdmiCecPollingMessage(this->cec.inst, this->cec.rx_addr));
+            }
+            else {
+               this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+            }
+         } 
+         else {
+            // Todo: how to notify libCEC about this ??
+         }
       }
    }
 #ifdef GUI_OVER_HDMI
    else if (edid_received()) { /* Check me */
       if (this->cec.source_status == CEC_POWER_STATUS_STANDBY) {
-         /* only for GFX on HDMI, do not use if only video playback on HDMI */
-         TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
-         TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
-         msleep(200);
-         TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
+         LOG(KERN_INFO,"EDID received in CEC_POWER_STATUS_STANDBY\n");
+
+         if( !this->param.passive) {
+            /* only for GFX on HDMI, do not use if only video playback on HDMI */
+            TRY(tmdlHdmiCecImageViewOn(this->cec.inst,this->cec.initiator));
+            TRY(tmdlHdmiCecHandleInterrupt(this->cec.inst));
+            msleep(200);
+            TRY(tmdlHdmiCecActiveSource(this->cec.inst,this->cec.phy_addr));
+         }
+         
          this->cec.source_status = CEC_POWER_STATUS_ON;
+         goto TRY_DONE;
       }
    }
 #endif
@@ -583,6 +655,9 @@ static void cec_interrupt(struct work_struct *dummy)
     
  TRY_DONE:
 
+   /* sync with this_cdev_write */
+   up(&this->driver.sem);
+
    /* setup next tick */
    if (!this->driver.deinit_req) {
       /* setup next polling */
@@ -613,7 +688,7 @@ void polling_timeout(unsigned long arg)
          printk(KERN_INFO "Fake Rx message\n");
          this->driver.timer.data=0;
 
-         this->cec.frame.count = 4;
+         this->cec.frame.size = 4;
          this->cec.frame.addr = 4; /* 0-->4 (TV-->MediaPlayer1) */
          this->cec.frame.data[0]=0x46; /* opcode: "GiveOsd" */
          this->cec.frame.service = CEC_RX_DONE;
@@ -659,6 +734,7 @@ static void user_control(int key, int press)
 }
 #endif
 
+
 /*
  *  CEC callback
  */
@@ -668,18 +744,81 @@ static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsi
    cec_instance *this=&our_instance;
    int opcode;
    int initiator,receiver;
+   cec_frame *frame;
+   int new_tail;
+
+   if (this->driver.raw_mode) {
+      new_tail = (this->driver.read_queue_tail + 1) %
+                     ARRAY_SIZE(this->driver.read_queue);
+
+      frame = &this->driver.read_queue[this->driver.read_queue_tail];
+      memset(frame, 0, sizeof(frame[0]));
+
+      if (event == TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE) {
+
+         if (new_tail != this->driver.read_queue_head) {
+            frame->size    = length + 2;		/* sizeof(size) + sizeof(service) */
+            frame->service = CEC_RX_PKT;		/* this is an rx packet */
+            frame->addr    = data[0];			/* AddressByte */
+            memcpy(frame->data, &data[1], length - 1);	/* DataBytes[], length - sizeof(addr) */
+
+            initiator = (frame->addr >> 4) & 0x0F;
+            receiver  = frame->addr & 0x0F;
+            opcode    = frame->data[0];
+            LOG(KERN_INFO,"hdmicec:Rx:[%x--->%x] %s length:%d [%02x %02x %02x %02x]\n",
+               initiator,receiver,length > 1 ? cec_opcode(opcode) : "POLL",length, 
+               frame->data[0], frame->data[1], frame->data[2], frame->data[3]);
+
+            this->driver.read_queue_tail = new_tail;
+         }
+
+         wake_up_interruptible(&this->driver.wait_read);
+
+      } else if (event == TMDL_HDMICEC_CALLBACK_STATUS) {
+
+         if (new_tail != this->driver.read_queue_head) {
+            frame->size    = length + 2;		/* sizeof(size) + sizeof(service) */
+            frame->service = CEC_ACK_PKT;		/* this is an ACK/NAK packet */
+            frame->addr    = data[0];			/* AddressByte */
+            memcpy(frame->data, &data[1], length - 1);	/* DataBytes[], length - sizeof(addr) */
+
+            initiator = (frame->addr >> 4) & 0x0F;
+            receiver  = frame->addr & 0x0F;
+            opcode    = frame->data[0];
+            LOG(KERN_INFO,"hdmicec:ACK:[%x--->%x] %s lenght:%d [%02x %02x %02x %02x]\n",
+	      initiator,receiver,cec_rxstatus(opcode),length, 
+              frame->data[0], frame->data[1], frame->data[2], frame->data[3]);
+
+            this->driver.read_queue_tail = new_tail;
+         }
+
+	 this->driver.write_pending = 0;
+         wake_up_interruptible(&this->driver.wait_read);
+         wake_up_interruptible(&this->driver.wait_write);
+
+      } else {
+         LOG(KERN_ERR,"Oups ! Callback got invalid event %d !\n",event);
+      }
+
+      return;
+   }
+
+   if (this->param.passive)
+      return;
+
 
    if (event == TMDL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE) {
 
-      this->cec.frame.count = length;
-      this->cec.frame.addr = data[1]; /* .AddressByte */
+      this->cec.frame.size = length + 2;
+      this->cec.frame.addr = data[0]; /* .AddressByte */
       initiator = (this->cec.frame.addr >> 4) & 0x0F;
       this->cec.initiator = initiator;
       receiver = this->cec.frame.addr & 0x0F;
-      memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr,ack) */
+      memcpy(&this->cec.frame.data,&data[1],length-1); /* .DataBytes[], length - siezof(length,addr,ack) */
       opcode=this->cec.frame.data[0];
-      printk(KERN_INFO "hdmicec:Rx:[%x--->%x] %s length:%d addr:%d %02x%02x%02x%02x\n",initiator,receiver,cec_opcode(opcode), \
-          length,data[1],
+      LOG(KERN_INFO,"hdmicec:Rx:[%x--->%x] %s length:%d addr:%d %02x%02x%02x%02x\n",initiator,receiver,cec_opcode(opcode), \
+          length,
+          this->cec.frame.addr,
           this->cec.frame.data[0],                                      \
           this->cec.frame.data[1],                                      \
           this->cec.frame.data[2],                                      \
@@ -843,11 +982,11 @@ static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsi
    }
    else if (event == TMDL_HDMICEC_CALLBACK_STATUS) {
 
-      this->cec.frame.count = length;
-      this->cec.frame.addr = data[1]; /* .AddressByte */
+      this->cec.frame.size = length + 2;
+      this->cec.frame.addr = data[0]; /* .AddressByte */
       initiator = (this->cec.frame.addr >> 4) & 0x0F;
       receiver = this->cec.frame.addr & 0x0F;
-      memcpy(&this->cec.frame.data,&data[2],length-2); /* .DataBytes[], length - siezof(length,addr)  */
+      memcpy(&this->cec.frame.data,&data[1],length-1); /* .DataBytes[], length - siezof(length,addr)  */
       opcode=this->cec.frame.data[0];
       this->cec.frame.service = CEC_TX_DONE;
 
@@ -876,12 +1015,12 @@ static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsi
             }
          }
          else {
-            printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
+            LOG(KERN_INFO,"ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
          }
       }
       else {
          if (CEC_MSG_SUCCESS != opcode) {
-            printk(KERN_INFO "ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
+            LOG(KERN_INFO,"ACK [%x--->%x] %s\n",initiator,receiver,cec_rxstatus(opcode));
          }
       }
 
@@ -900,7 +1039,7 @@ static void eventCallbackCEC(tmdlHdmiCecEvent_t event, unsigned char *data, unsi
 /*
  *  DevLib CEC opening
  */
-static int hdmi_cec_init(cec_instance *this)
+static int hdmi_cec_init(cec_instance *this, const char *osd_name)
 {
    int err=0;
 
@@ -913,20 +1052,21 @@ static int hdmi_cec_init(cec_instance *this)
 
 /*    this->cec.version = CEC_VERSION_1_4; */
    this->cec.version = CEC_VERSION_1_3a;
-   this->cec.osd_name.data[0]=0x54; /* TDA19989 by default */
-   this->cec.osd_name.data[1]=0x44;
-   this->cec.osd_name.data[2]=0x41;
-   this->cec.osd_name.data[3]=0x31;
-   this->cec.osd_name.data[4]=0x39;
-   this->cec.osd_name.data[5]=0x39;
-   this->cec.osd_name.data[6]=0x38;
-   this->cec.osd_name.data[7]=0x39;
-   this->cec.osd_name.length=8;
-   
+
+   if (!osd_name)
+      osd_name = "TDA19989";	/* TDA19989 by default */
+
+   strncpy(this->cec.osd_name.data, 
+           osd_name, sizeof(this->cec.osd_name.data));
+   this->cec.osd_name.length = 
+      min(strlen(osd_name), sizeof(this->cec.osd_name.data));
+     
+   this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+   this->cec.rx_addr_mask = 0;
+   this->cec.phy_addr = param_addr;			// 0xffff == unconfigured
+   this->cec.device_type = device_type(param_device); // 4 == CEC_DEVICE_TYPE_PLAYBACK_DEVICE 
+
    TRY(tmdlHdmiCecRegisterCallbacks(this->cec.inst,eventCallbackCEC));
-       
-   this->cec.phy_addr = param_addr;
-   this->cec.device_type = device_type(param_device);
 
  TRY_DONE:
    return err;
@@ -951,29 +1091,34 @@ static int hdmi_cec_init(cec_instance *this)
 
 static int this_cdev_open(struct inode *pInode, struct file *pFile)
 {
-   cec_instance *this;
-   int minor=iminor(pInode);
+   cec_instance *this = pFile->private_data;
+   int minor = iminor(pInode);
 
-   if(minor >= MAX_MINOR) {
+   if (minor >= MAX_MINOR) {
       printk(KERN_ERR "hdmicec:%s:only one cec opening please\n",__func__);
       return -EINVAL;
    }
 
-   if ((pFile->private_data != NULL) && (pFile->private_data != &our_instance)) {
-      printk(KERN_ERR "hdmicec:%s:pFile missmatch\n",__func__);
+   if (this && this != &our_instance) {
+      printk(KERN_ERR "hdmicec:%s:pFile mismatch\n",__func__);
+      return -EINVAL;
    }
-   this = pFile->private_data = &our_instance;
+
+   this = &our_instance;
+   pFile->private_data = this;
+
    down(&this->driver.sem);
 
-   LOG(KERN_INFO,"major:%d minor:%d user:%d\n", imajor(pInode), iminor(pInode), this->driver.user_counter);
+   LOG(KERN_INFO,"major:%d minor:%d user:%d\n", 
+       imajor(pInode), iminor(pInode), this->driver.user_counter);
 
    if ((this->driver.user_counter++) && (this->driver.minor == minor)) {
       /* init already done */
       up(&this->driver.sem);
       return 0;
    }
-   this->driver.minor = minor;
 
+   this->driver.minor = minor;
 
    up(&this->driver.sem);
    return 0;
@@ -995,9 +1140,10 @@ static long this_cdev_ioctl(struct file *pFile, unsigned int cmd, unsigned long
    }
 
    if (_IOC_DIR(cmd) & _IOC_READ) 
-      err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+      err = !arg || !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
    else if (_IOC_DIR(cmd) & _IOC_WRITE)
-      err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+      err = !arg || !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+
    if (err) {
       printk(KERN_ERR "hdmicec:%s:argument access denied (check address vs value)\n",__func__);
       printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n",_IOC_DIR(cmd),arg);
@@ -1010,6 +1156,82 @@ static long this_cdev_ioctl(struct file *pFile, unsigned int cmd, unsigned long
 
    switch ( _IOC_NR(cmd) )
       {
+      case CEC_IOCTL_SEND_MSG_CMD:
+         {
+	    cec_frame frame;
+
+            BUG_ON(copy_from_user(&frame, (void *)arg, sizeof(cec_frame)) != 0);
+
+            if (frame.size >= 3 && frame.size < sizeof(cec_frame)) {
+               /* set initiator to "broadcast" */
+               frame.addr |= CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST << 4;
+               TRY(tmdlHdmiCecSendMessage(this->cec.inst, &frame.addr, frame.size - 2));
+            }
+            break;
+         }
+
+      case CEC_IOCTL_GET_RAW_MODE_CMD:
+         {
+            BUG_ON(copy_to_user((void *)arg,&this->driver.raw_mode,sizeof(this->driver.raw_mode)) != 0);
+	    break;
+	 }
+
+      case CEC_IOCTL_SET_RAW_MODE_CMD:
+         {
+            unsigned char raw_mode;
+            BUG_ON(copy_from_user(&raw_mode,(void *)arg,sizeof(raw_mode)) != 0);
+
+            if (raw_mode < 2 && this->driver.raw_mode != raw_mode) {
+
+               this->driver.raw_mode = raw_mode;
+
+	       if (this->driver.raw_mode) {
+                  this->driver.write_pending = 0;
+                  this->driver.read_queue_head = this->driver.read_queue_tail;
+               } 
+               else {
+                  this->driver.write_pending = 1;
+                  this->driver.read_queue_head = this->driver.read_queue_tail;
+                  wake_up_interruptible(&this->driver.wait_read);
+                  wake_up_interruptible(&this->driver.wait_write);
+	       }
+
+               cec_listen_single(this, CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
+            }
+	    break;
+	 }
+
+      case CEC_IOCTL_GET_RAW_INFO_CMD:
+         {
+            int len;
+            cec_raw_info info;
+
+            info.VendorID = this->cec.vendor_id;
+            info.QueueSize = ARRAY_SIZE(this->driver.read_queue);
+            info.LogicalAddress = this->cec.rx_addr;
+            info.PhysicalAddress = this->cec.phy_addr;
+            info.LogicalAddressMask = this->cec.rx_addr_mask;
+
+	    len = min((size_t)this->cec.osd_name.length, sizeof(info.OsdName)-1);
+	    memcpy(info.OsdName, this->cec.osd_name.data, len);
+	    memset(&info.OsdName[len], '\0', sizeof(info.OsdName) - len);
+
+            BUG_ON(copy_to_user((void *)arg,&info,sizeof(info)) != 0);
+	    break;
+	 }
+
+      case CEC_IOCTL_SET_RX_ADDR_MASK_CMD:
+         {
+            cec_rx_mask rx_mask;
+            BUG_ON(copy_from_user(&rx_mask,(void *)arg,sizeof(rx_mask)) != 0);
+
+            if (this->driver.raw_mode) {
+               cec_listen_multi(this, rx_mask.SwitchOn, rx_mask.SwitchOff);
+            }
+            break;
+         }
+
+
       case CEC_VERBOSE_ON_CMD:
          {
             printk(KERN_INFO "verbose on\n");
@@ -1203,9 +1425,11 @@ static long this_cdev_ioctl(struct file *pFile, unsigned int cmd, unsigned long
 
       case CEC_IOCTL_RX_ADDR_CMD:
          {
-            /* 	    BUG_ON(copy_from_user(&this->cec.rx_addr,(unsigned char*)arg,sizeof(unsigned char)) != 0); */
-            this->cec.rx_addr=arg;
-            TRY(tmdlHdmiCecSetLogicalAddress(this->cec.inst,this->cec.rx_addr));
+            unsigned char rx_addr;
+            BUG_ON(copy_from_user(&rx_addr,(void *)arg,sizeof(unsigned char)) != 0);
+            if (rx_addr <= CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST) {
+               cec_listen_single(this, rx_addr);
+            }
             break;
          }
 
@@ -1821,6 +2045,102 @@ static long this_cdev_ioctl(struct file *pFile, unsigned int cmd, unsigned long
 }
 
 /*
+ *  ioctl driver :: read
+ */
+static ssize_t this_cdev_read(struct file *pFile, char *buffer, size_t length, loff_t *offset)
+{
+   cec_instance* this = pFile->private_data;
+   int bytes_returned = 0;
+
+   if (!this->driver.raw_mode || length < sizeof(cec_frame))
+      return -EINVAL; 
+
+   while (length - bytes_returned >= sizeof(cec_frame) &&
+          this->driver.read_queue_head != this->driver.read_queue_tail) {
+      memcpy(buffer + bytes_returned, 
+        &this->driver.read_queue[this->driver.read_queue_head], sizeof(cec_frame));
+
+      this->driver.read_queue_head = 
+        (this->driver.read_queue_head + 1) % ARRAY_SIZE(this->driver.read_queue);
+
+      bytes_returned += sizeof(cec_frame);
+   }
+
+   return bytes_returned;
+}
+
+/*
+ *  ioctl driver :: write
+ */
+static ssize_t this_cdev_write(struct file *pFile, const char *buffer, size_t length, loff_t *offset)
+{
+   cec_instance* this = pFile->private_data;
+   int err = 0, bytes_written = 0;
+   const cec_frame *frame;
+
+   if (!this->driver.raw_mode || length < sizeof(cec_frame))
+      return -EINVAL; 
+
+   frame = (const cec_frame *)buffer;
+   if (frame->size < 3 || frame->size > sizeof(cec_frame))
+      return -EINVAL; 
+   
+   down(&this->driver.sem);
+
+   if (this->driver.write_pending || this->cec.source_status != CEC_POWER_STATUS_ON) {
+      up(&this->driver.sem);
+      return -EAGAIN;
+   }
+
+   if (this->cec.rx_addr == CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST ||
+       (frame->addr & 0xf0) != (CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST << 4)) {
+      TRY(tmdlHdmiCecSendMessage(this->cec.inst, (UInt8 *)&frame->addr, frame->size - 2));
+      this->driver.write_pending = 1;
+      bytes_written += length;
+   }
+   else {
+      LOG(KERN_ERR,"initiator 'Broadcast' is not supported !\n");
+      goto TRY_DONE;
+   }
+
+   up(&this->driver.sem);
+   return bytes_written;
+
+ TRY_DONE:
+   up(&this->driver.sem);
+   return -EINVAL;
+}
+
+/*
+ *  ioctl driver :: poll
+ */
+static unsigned int this_cdev_poll(struct file *pFile, poll_table *poll_data)
+{
+   cec_instance* this = pFile->private_data;
+   unsigned int mask = 0;
+
+   down(&this->driver.sem);
+
+   if (this->driver.raw_mode) {
+      poll_wait(pFile, &this->driver.wait_read, poll_data);
+      poll_wait(pFile, &this->driver.wait_write, poll_data);
+
+      if (this->driver.read_queue_head != this->driver.read_queue_tail)
+         mask |= POLLIN | POLLRDNORM;	/* readable */
+
+      if (!this->driver.write_pending && this->cec.source_status == CEC_POWER_STATUS_ON)
+         mask |= POLLOUT | POLLWRNORM;	/* writable */
+
+   } else {
+      mask |= POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
+   }
+
+   up(&this->driver.sem);
+
+   return mask;
+}
+
+/*
  *  ioctl driver :: releasing
  */
 static int this_cdev_release(struct inode *pInode, struct file *pFile)
@@ -1830,15 +2150,25 @@ static int this_cdev_release(struct inode *pInode, struct file *pFile)
 
    LOG(KERN_INFO,"called\n");
 
-   if(minor >= MAX_MINOR) {
+   if (minor >= MAX_MINOR) {
       return -EINVAL;
    }
 
    BUG_ON(this->driver.minor!=iminor(pInode));
    down(&this->driver.sem);
 
-   this->driver.user_counter--;
-   if(this->driver.user_counter == 0) {
+   if (--this->driver.user_counter == 0) {
+      if (this->driver.raw_mode) {
+         this->driver.raw_mode = 0;
+         this->driver.write_pending = 1;
+         this->driver.read_queue_head = this->driver.read_queue_tail;
+
+         wake_up_interruptible(&this->driver.wait_write);
+         wake_up_interruptible(&this->driver.wait_read);
+
+         cec_listen_single(this, CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
+      }
+
       pFile->private_data = NULL;
    }
    else {
@@ -1868,17 +2198,8 @@ static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_
       return -ENODEV;
    }
 
-   this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
-   if (!this->driver.i2c_client) {
-      return -ENOMEM;
-   }
-   memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
-
-   strncpy(this->driver.i2c_client->name, CEC_NAME, I2C_NAME_SIZE);
-   this->driver.i2c_client->addr = TDA99XCEC_I2C_SLAVEADDRESS;
-   this->driver.i2c_client->adapter = client->adapter;
-
-   i2c_set_clientdata(client, this->driver.i2c_client);
+   this->driver.i2c_client = client;
+   i2c_set_clientdata(client, this);
 
    tmdlHdmiCecGetSWVersion(&this->cec.sw_version);
    LOG(KERN_INFO,"HDMI CEC SW Version:%lu.%lu compatibility:%lu\n", \
@@ -1888,6 +2209,14 @@ static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_
 
    /* I2C ok, then let's startup CEC */
 
+   /* initialize raw mode stuff */
+   this->driver.raw_mode = 0;
+   this->driver.write_pending = 1;
+   this->driver.read_queue_head = 0;
+   this->driver.read_queue_tail = 0;
+   init_waitqueue_head(&this->driver.wait_read);
+   init_waitqueue_head(&this->driver.wait_write);
+
    /* prepare event */
    this->driver.poll_done = true; /* currently idle */
    init_waitqueue_head(&this->driver.wait);
@@ -1905,7 +2234,7 @@ static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_
    /* FRO calibration */
    err=gpio_request(TDA_IRQ_CALIB,"tda19989 calibration");
    if (err < 0) {
-      printk(KERN_ERR "hdmicec:%s:cannot use GPIO 107\n",__func__);
+      printk(KERN_ERR "hdmicec:%s:Cannot use GPIO %d, err:%d\n",__func__,TDA_IRQ_CALIB,err);
       goto i2c_out;
    }
    /* turn GPIO into IRQ */
@@ -1919,9 +2248,8 @@ static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_
    }
 #endif
 
-   err = hdmi_cec_init(this);
+   err = hdmi_cec_init(this, (const char *)client->dev.platform_data);
    if (err) goto i2c_out;
-   this->cec.rx_addr=CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
 
    if (get_hpd_status()) {
       cec_on(this);
@@ -1938,7 +2266,7 @@ static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_
  i2c_out:
    LOG(KERN_INFO,"HDMICEC eject: this->driver.i2c_client removed\n");
    tmdlHdmiCecClose(this->cec.inst);
-   kfree(this->driver.i2c_client);
+
    this->driver.i2c_client = NULL;
 
    return err;
@@ -1961,7 +2289,7 @@ static int this_i2c_remove(struct i2c_client *client)
               __func__);
       return -ENODEV;
    }
-   kfree(this->driver.i2c_client);
+
    this->driver.i2c_client = NULL;
 
    return err;
@@ -1990,6 +2318,9 @@ static struct file_operations this_cdev_fops = {
  open:     this_cdev_open,
  release:  this_cdev_release,
  unlocked_ioctl: this_cdev_ioctl,
+ read:     this_cdev_read,
+ write:    this_cdev_write,
+ poll:     this_cdev_poll
 };
 
 /*
@@ -2008,6 +2339,8 @@ static int __init cec_init(void)
    this->param.verbose = param_verbose;
    this->param.major = param_major;
    this->param.minor = param_minor;
+   this->param.passive = 1;
+   
    /* Hello word */
    printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMICEC_NAME, TDA_NAME, TDA_VERSION_MAJOR,
           TDA_VERSION_MINOR, TDA_VERSION_PATCHLEVEL, __DATE__, __TIME__, TDA_VERSION_EXTRA);
@@ -2051,8 +2384,8 @@ static int __init cec_init(void)
       this->param.major = MAJOR(dev);
    }
 
-   cdev_init(this_cdev, &this_cdev_fops);
-   this_cdev->owner = THIS_MODULE;
+   cdev_init(&our_cdev, &this_cdev_fops);
+   our_cdev.owner = THIS_MODULE;
 
    this->driver.class = class_create(THIS_MODULE, HDMICEC_NAME);
    if (IS_ERR(this->driver.class)) {
@@ -2063,7 +2396,7 @@ static int __init cec_init(void)
    this->driver.dev = device_create(this->driver.class, NULL, dev, NULL, HDMICEC_NAME);
 
    this->driver.devno = dev;
-   err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
+   err = cdev_add(&our_cdev, this->driver.devno, MAX_MINOR);
    if (err){
       printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n",HDMICEC_NAME,this->driver.devno,ERR_TO_STR(err));
       device_destroy(this->driver.class,this->driver.devno);
@@ -2080,7 +2413,6 @@ static int __init cec_init(void)
    /* 
       general device context
    */
-   //init_MUTEX(&this->driver.sem);
    sema_init(&this->driver.sem,1);
    this->driver.deinit_req=0;
    
@@ -2119,7 +2451,7 @@ static void __exit cec_exit(void)
 #endif
 
    /* unregister cdevice */
-   cdev_del(this_cdev);
+   cdev_del(&our_cdev);
    unregister_chrdev_region(this->driver.devno, MAX_MINOR);
 
    /* unregister device */
@@ -2128,7 +2460,6 @@ static void __exit cec_exit(void)
 
    /* unregister i2c */
    i2c_del_driver(&this_i2c_driver);
-
 }
 
 
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_cec.h b/drivers/video/dovefb/nxp_hdmi/tda998x_cec.h
index 2a06e95..abe42f5 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x_cec.h
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_cec.h
@@ -70,6 +70,7 @@ typedef void (*cec_callback_t) (struct work_struct *dummy);
 typedef struct {
    /* module params */
    struct { 
+      int passive;
       int verbose;
       int major;
       int minor;
@@ -87,12 +88,21 @@ typedef struct {
       bool poll_done;
       int deinit_req;
       struct timer_list timer;
+
+      unsigned char raw_mode;
+      unsigned char write_pending;
+      wait_queue_head_t wait_read;
+      wait_queue_head_t wait_write;
+      int read_queue_head;
+      int read_queue_tail;
+      cec_frame read_queue[8];
    } driver;
    /* cec */
    struct {
       int inst;
-      unsigned char rx_addr;
       unsigned short phy_addr;
+      unsigned short rx_addr_mask;
+      unsigned char rx_addr;
       unsigned char initiator;
       cec_version version;
       cec_sw_version sw_version;
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_exports.h b/drivers/video/dovefb/nxp_hdmi/tda998x_exports.h
new file mode 100644
index 0000000..9fcb5ba
--- /dev/null
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_exports.h
@@ -0,0 +1,35 @@
+/*****************************************************************************/
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#ifndef __exports__
+#define __exports__
+
+void register_cec_interrupt(cec_callback_t fct); 
+void unregister_cec_interrupt(void); 
+
+int hdmi_enable(void);
+int hdmi_disable(int event_tracking);
+void reset_hdmi(int hdcp_module);
+
+int edid_received(void);
+short edid_phy_addr(void); 
+tmPowerState_t get_hdmi_status(void);
+tmPowerState_t get_hpd_status(void);
+
+#endif
+
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.c b/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.c
new file mode 100644
index 0000000..3daf9af
--- /dev/null
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.c
@@ -0,0 +1,135 @@
+/*****************************************************************************/
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include "tda998x_i2c.h"
+
+
+/*
+ * Write bytes into consecutive device registers
+ */
+int tda998x_i2c_write_regs(struct i2c_client *client, u8 len, u8 reg, u8 *val)
+{
+   u8 i, data[256];
+   int err, retries;
+   struct i2c_msg msg[1];
+   bool is_cec_data = (reg == 7 && client->addr != 0x70);
+
+   retries = (is_cec_data) ?  1 : 3;
+
+   for (;;) {
+      msg[0].addr  = client->addr;
+      msg[0].flags = 0;
+      msg[0].len   = len + 1;
+      msg[0].buf   = data;
+   
+      data[0] = reg;   
+      for (i = 0; i < len; i++) 
+         data[i+1] = val[i];
+   
+      err = i2c_transfer(client->adapter, msg, 1);
+      udelay(50);
+
+      if (err < 0) {
+         if (len <= 1)
+            dev_err(&client->dev, "<%s> i2c write error at=%x "
+		    "val=%x flags=%d err=%d\n",
+		    __func__, reg, val[0], msg[0].flags, err);
+         else
+            dev_err(&client->dev, "<%s> i2c block write error at=%x "
+		    "*val=%x bytes=%d flags=%d err=%d\n",
+		    __func__, reg, val[0], len, msg[0].flags, err);
+      }
+#ifdef CEC_I2C_DEBUG
+      else if (is_cec_data) {
+         extern char *cec_opcode(int op);
+         unsigned char initiator, receiver;
+
+         for (i = len + 1; i < 8; i++)
+            data[i] = 0xff;
+
+         initiator = data[3] >> 4;
+         receiver  = data[3] & 0x0f;
+         if (len == 3) {
+            printk(KERN_INFO "hdmicec:poll:[%x--->%x] \n", initiator,receiver);
+         }
+         else if (len > 3) {
+            printk(KERN_INFO "hdmicec:Tx:[%x--->%x] %s %02x%02x%02x%02x\n",
+                   initiator,receiver,cec_opcode(data[4]),
+                   data[4],data[5],data[6],data[7]);
+         }
+         else {
+            printk(KERN_INFO "hdmicec:??: invalid data length (%d)\n", len); 
+         }
+      }
+#endif
+
+      if (err >= 0 || --retries == 0)
+         break;
+
+      dev_info(&client->dev, "Retrying I2C... %d\n", retries);
+      set_current_state(TASK_UNINTERRUPTIBLE);
+      schedule_timeout(msecs_to_jiffies(20));
+   }
+
+   return (err < 0) ? err : 0;
+}
+
+/*
+ * Read bytes from consecutive device registers
+ */
+int tda998x_i2c_read_regs(struct i2c_client *client, u8 len, u8 reg, u8 *val)
+{
+   int err;
+   struct i2c_msg msg[2];
+
+   msg[0].addr  = client->addr;
+   msg[0].flags = 0;
+   msg[0].len   = 1;
+   msg[0].buf   = &reg;
+
+   msg[1].addr  = client->addr;
+   msg[1].flags = I2C_M_RD;
+   msg[1].len   = len;
+   msg[1].buf   = val;
+
+   err = i2c_transfer(client->adapter, msg, 2);
+
+   if (err < 0) {
+      if (len <= 1)
+         dev_err(&client->dev, "<%s> i2c read error at 0x%x, "
+	         "*val=%x flags=%d err=%d\n",
+	         __func__, reg, *val, msg[0].flags, err);
+      else
+         dev_err(&client->dev, "<%s> i2c block read error at 0x%x, "
+	         "*val=%x bytes=%d flags=%d err=%d\n",
+	         __func__, reg, *val, len, msg[0].flags, err);
+   }
+
+   return (err < 0) ? err : 0;
+}
+
+
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.h b/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.h
new file mode 100644
index 0000000..2f5adcd
--- /dev/null
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_i2c.h
@@ -0,0 +1,31 @@
+/*****************************************************************************/
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#ifndef __i2c_h__
+#define __i2c_h__
+
+#define CEC_I2C_DEBUG
+
+struct i2c_client *txGetThisI2cClient(void);
+struct i2c_client *cecGetThisI2cClient(void);
+
+int tda998x_i2c_read_regs(struct i2c_client *client, u8 len, u8 reg, u8 *val);
+int tda998x_i2c_write_regs(struct i2c_client *client, u8 len, u8 reg, u8 *val);
+
+#endif
+
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x_ioctl.h b/drivers/video/dovefb/nxp_hdmi/tda998x_ioctl.h
index 192615b..da07a83 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x_ioctl.h
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x_ioctl.h
@@ -772,15 +772,28 @@ typedef struct {
   } cec_send_msg;
 */
 
-typedef struct
-{
-   unsigned char count;
+typedef struct {
+   unsigned char size;
    unsigned char service;
    unsigned char addr;
    unsigned char data[15];
 } cec_frame;
 /* typedef tmdlHdmiCecFrameFormat_t cec_frame; */
 
+typedef struct {
+   unsigned long  VendorID;
+   unsigned char  QueueSize;
+   unsigned char  LogicalAddress;
+   unsigned short PhysicalAddress;
+   unsigned short LogicalAddressMask;
+   char           OsdName[16];
+} cec_raw_info;
+
+typedef struct {
+   unsigned short SwitchOn;
+   unsigned short SwitchOff;
+} cec_rx_mask;
+
 typedef tmSWVersion_t cec_sw_version;
 typedef tmPowerState_t cec_power;
 typedef tmdlHdmiCecInstanceSetup_t cec_setup;
@@ -810,6 +823,9 @@ typedef tmdlHdmiCECDeviceType_t cec_device_type;
 
 /* service */
 enum {
+   CEC_RX_PKT  = 0x01,
+   CEC_ACK_PKT = 0x02,
+
    CEC_WAITING = 0x80,
    CEC_RELEASE,
    CEC_RX_DONE,
@@ -912,7 +928,13 @@ enum {
    CEC_IOCTL_ENABLE_CALIBRATION_CMD,
    CEC_IOCTL_DISABLE_CALIBRATION_CMD,
    CEC_IOCTL_SEND_MSG_CMD,
-   CEC_IOCTL_SET_REGISTER_CMD
+   CEC_IOCTL_SET_REGISTER_CMD,
+
+   /* libCEC support */
+   CEC_IOCTL_GET_RAW_MODE_CMD = 200,
+   CEC_IOCTL_SET_RAW_MODE_CMD,
+   CEC_IOCTL_GET_RAW_INFO_CMD,
+   CEC_IOCTL_SET_RX_ADDR_MASK_CMD
 };
 
 
@@ -1010,7 +1032,15 @@ enum {
 #define CEC_IOCTL_DISABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_EVENT_CMD,cec_event)
 #define CEC_IOCTL_ENABLE_CALIBRATION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_CALIBRATION_CMD,cec_clock)
 #define CEC_IOCTL_DISABLE_CALIBRATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_CALIBRATION_CMD)
-//#define CEC_IOCTL_SEND_MSG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SEND_MSG_CMD,cec_send_msg)
+#define CEC_IOCTL_SEND_MSG      _IOR(CEC_IOCTL_BASE,CEC_IOCTL_SEND_MSG_CMD,cec_frame)
+
+/* libCEC support */
+#define	CEC_IOCTL_GET_RAW_MODE      _IOR(CEC_IOCTL_BASE,CEC_IOCTL_GET_RAW_MODE_CMD,unsigned char)
+#define	CEC_IOCTL_SET_RAW_MODE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_RAW_MODE_CMD,unsigned char)
+#define	CEC_IOCTL_GET_RAW_INFO      _IOR(CEC_IOCTL_BASE,CEC_IOCTL_GET_RAW_INFO_CMD,cec_raw_info)
+#define	CEC_IOCTL_SET_RX_ADDR_MASK  _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_RX_ADDR_MASK_CMD,cec_rx_mask)
+
+
 
 /* --- Full list --- */
 
