diff --git a/drivers/video/dovefb/dovefb_gfx.c b/drivers/video/dovefb/dovefb_gfx.c
index 731d28a..30bb811 100644
--- a/drivers/video/dovefb/dovefb_gfx.c
+++ b/drivers/video/dovefb/dovefb_gfx.c
@@ -56,6 +56,12 @@ static int dovefb_fill_edid(struct fb_info *fi,
 static int wait_for_vsync(struct dovefb_layer_info *dfli);
 static void dovefb_set_defaults(struct dovefb_layer_info *dfli);
 
+#ifdef CONFIG_TDA19988
+extern const char *tda19988_get_edid(int *num_of_blocks);
+extern int tda19988_configure_tx_inout(int x, int y, int interlaced, int hz);
+#endif
+
+
 #define AXI_BASE_CLK	(2000000000ll)	/* 2000MHz */
 
 static const u8 edid_header[] = {
@@ -545,9 +551,6 @@ static u8 *make_analog_fake_edid(void)
 
 	return edid_block;
 }
-#ifdef CONFIG_TDA19988
-extern	int configure_tx_inout(int x, int y, int interlaced, int hz);
-#endif
 
 static int dovefb_gfx_set_par(struct fb_info *fi)
 {
@@ -628,7 +631,7 @@ static int dovefb_gfx_set_par(struct fb_info *fi)
 	printk(KERN_INFO "Setting HDMI TX resolution to %dx%d%c @ %d\n",
 		m->xres, m->yres, (m->vmode & FB_VMODE_INTERLACED) ? 'i' : 'p',
 		m->refresh);
-	if (!configure_tx_inout(m->xres, m->yres,
+	if (!tda19988_configure_tx_inout(m->xres, m->yres,
 		(m->vmode & FB_VMODE_INTERLACED) ? 1 : 0, m->refresh))
 		printk(KERN_ERR "Setting HDMI TX mode failed\n");
 #endif
@@ -1175,15 +1178,13 @@ static u8 *pull_edid_from_i2c(int busid, int addr)
 }
 #endif
 
-#ifdef CONFIG_TDA19988
-extern char *tda19988_get_edid(int *num_of_blocks);
-#endif
 static u8 *dove_read_edid(struct fb_info *fi, struct dovefb_mach_info *dmi)
 {
 	char *edid_data = NULL;
 #ifdef CONFIG_TDA19988
 	int num_of_blocks;
-	char *nxp_edid;
+	const char *nxp_edid;
+
 	nxp_edid = tda19988_get_edid(&num_of_blocks);
 	if (nxp_edid == NULL) /* EDID not ready */
 		return NULL;
diff --git a/drivers/video/dovefb/nxp_hdmi/tda998x.c b/drivers/video/dovefb/nxp_hdmi/tda998x.c
index b8fff8b..a1c694a 100755
--- a/drivers/video/dovefb/nxp_hdmi/tda998x.c
+++ b/drivers/video/dovefb/nxp_hdmi/tda998x.c
@@ -68,11 +68,12 @@
  *  Global
  */
 
-tda_instance our_instance;
+static tda_instance our_instance;
 static struct cdev our_cdev, *this_cdev=&our_cdev;
 static int initialized = 0;
 static int saved_mode = -1;
 static cec_callback_t cec_callback = NULL;
+
 #ifdef ANDROID_DSS
 static struct omap_video_timings video_640x480at60Hz_panel_timings = {
    .x_res          = 640,
@@ -1905,7 +1906,7 @@ static int this_i2c_probe(struct i2c_client *client, const struct i2c_device_id
 
 /* CuBox specific stuff */
 /* Addions to get EDID stuff out of the transmitter driver */
-char *tda19988_get_edid(int *num_of_blocks)
+const char *tda19988_get_edid(int *num_of_blocks)
 {
 	tda_instance* this = &our_instance;
 	if (!initialized) return NULL;
@@ -1921,14 +1922,13 @@ char *tda19988_get_edid(int *num_of_blocks)
 	return  this->tda.raw_edid;
 }
 
-struct res_to_vmode {
+static struct {
 	int x;
 	int y;
 	int interlaced;
 	int hz;
 	int vmode;
-};
-struct res_to_vmode resolution_to_video_format[] = {
+} resolution_to_video_format[] = {
 {640,	480,	0,	60,	TMDL_HDMITX_VFMT_01_640x480p_60Hz},
 {720,	480,	0,	60,	TMDL_HDMITX_VFMT_02_720x480p_60Hz},
 {720,	480,	0,	60,	TMDL_HDMITX_VFMT_03_720x480p_60Hz},
@@ -2000,40 +2000,33 @@ struct res_to_vmode resolution_to_video_format[] = {
 {1024,	768,	1,	87,	TMDL_HDMITX_VFMT_PC_1024x768i_87Hz},
 };
 
-int configure_tx_inout(int x, int y, int interlaced, int hz)
+int tda19988_configure_tx_inout(int x, int y, int interlaced, int hz)
 {
-	int i, mode = -1, refresh = 0;
 	tda_instance* this = &our_instance;
+	int i, d, mode = -1, rateDiff = 1000;
 
-	for (i = 0 ; i < sizeof(resolution_to_video_format); i++) {
+	for (i = 0; rateDiff && i < sizeof(resolution_to_video_format); i++) {
 		if (	(x == resolution_to_video_format[i].x) &&
 			(y == resolution_to_video_format[i].y) &&
-			(interlaced == resolution_to_video_format[i].interlaced) &&
-			(hz == resolution_to_video_format[i].hz)) {
-			mode = resolution_to_video_format[i].vmode;
-			printk (KERN_INFO "HDMI TX - FOUND exact resolution %d\n",mode);
-			break;
+			(interlaced == resolution_to_video_format[i].interlaced) ) {
+			d = abs(resolution_to_video_format[i].hz - hz);
+			if (d < rateDiff) {
+				rateDiff = d;
+				mode = resolution_to_video_format[i].vmode;
+			}
 		}
 	}
 
 	if (mode < 0) {
-		/* Try finding resolution but with closest refresh rate */
-		for (i = 0 ; i < sizeof(resolution_to_video_format); i++) {
-			if (	(x == resolution_to_video_format[i].x) &&
-				(y == resolution_to_video_format[i].y) &&
-				(interlaced == resolution_to_video_format[i].interlaced)) {
-				if ((resolution_to_video_format[i].hz - refresh) > 
-				    (resolution_to_video_format[i].hz - hz)) {
-					mode = resolution_to_video_format[i].vmode;
-					printk (KERN_INFO "HDMI TX - Found good candidate %d (requested %dhz, found %dhz)\n",mode,hz,resolution_to_video_format[i].hz);
-					refresh = resolution_to_video_format[i].hz;
-				}
-			}
-		}
+		printk (KERN_ERR "HDMI TX - no matching resolution %dx%d%c %dHz\n",x,y,interlaced ? 'i':'p',hz);
+		return 0;
 	}
 
-	if (mode < 0)
-		return 0;
+	if (rateDiff == 0)
+		printk (KERN_INFO "HDMI TX - FOUND exact resolution %d\n",mode);
+	else
+		printk (KERN_INFO "HDMI TX - Found good candidate %d (requested %dhz, found %dhz)\n",
+			mode,hz,resolution_to_video_format[mode].hz);
 
 	if (initialized) {
 		this->tda.setio.video_in.format = mode;
@@ -2396,7 +2389,6 @@ static int __init tx_init(void)
    /* 
       general device context
    */
-//   init_MUTEX(&this->driver.sem);
    sema_init(&this->driver.sem,1);
    
    /*

